;
;  MZ-800  Disk Basic  MZ-2Z046

;
;  It is basically a Hu-Basic interpreter engine together with a Sharp Monitor.
;  The comments are useful to decode other eastern computer products (Sharp, Samsung, etc..)
;  Other than being a valid reference for developers.
;

; It can be built with the z88dk's z80asm tool:
;   z80asm -b -m MZ2Z046.asm
;   (z88dk-appmake +mz --org 0 -b MZ2Z046.bin)

; (use: "z88dk-appmake +mz" to look at all the options)
; Add -DCLASSIC_FNK to z80asm for for a different way to map the FN function keys.


; The comments are based on a (not fully correct) hand-edited disassembly
; published in 1985 by Rainer Schäfer (Kirchwald, Germany)


; The sharp MZ 800 was the successor of the MZ 700.
; It was partially compatible with the 700 series and the old MZ 80K series as well.
;
; It was sold under three reference numbers:
;   MZ-811 without tape drive,
;   MZ-821 with built-in 1200-baud tape drive,
;   MZ-831 with tape drive and built-in 4-colour printer-plotter.
;

; The Tape drive could be substituted for a Quick-disk drive unit.
; The Quick-Disc was a small 2.8-inch disk with sequential access.
;
; Like the MZ 700, there was no language in ROM, it had to be loaded
; from tape, quick disk or floppy disk.
; The ROM only contained boot code, OS calls and special code to allow
; the user to use the 64 KB RAM as a virtual disk.



;
        ORG     00000H
;
;
;       The Basic - Interpreter uses routines of the monitor 1Z-013B
;       (or the monitor 9Z-504M)
;
;       The underlined bytes are changed by the Basic Interpreter at runtime
;
;


;
;
;   Control chatacters
;

defc  _PRESS   =      0x7F            ; key press characters
defc  NUL      =      0x00            ; End-of-text/line-end character
defc  __GRPH   =      0x02            ; Switch to graphic mode (printer)
defc  ETX      =      0x03            ; line retraction (printer)
defc  CTRL_D   =      0x04            ; Initialize screen
defc  ___TST   =      0x04            ; Test print pattern call for plotter
defc  _SML     =      0x05            ; Switch to lowercase
defc  _CAP     =      0x06            ; Switch to capital letters
defc  LEADIN   =      0x09            ; Printer initiation code - control characters
defc  LF       =      0x0A            ; newline
defc  CR       =      0x0D            ; carriage return
;;  defc  DEL      =      0x7F            ; control character for DELete (CTL-P)
;; defc  _DEL      =      0x10            ; control character for DELete (CTL-P)
defc  C_DOWN   =      0x11            ; cursor down
defc  C_UP     =      0x12            ; cursor up
defc  C_RIGHT  =      0x13            ; cursor right
defc  C_LEFT   =      0x14            ; cursor left
defc  C_HOME   =      0x15            ; HOME		(CTL-U)
defc  C_CLR    =      0x16            ; CLR
defc  _ALPHA   =      0x19            ; Switch to alpha mode
defc  CTRL_Z   =      0x1A            ; end of file character
defc  ESC      =      0x1B            ; Code of the BREAK key
;
defc  _NOTXT   =      0x80            ; Code 'no error text'
defc  _free    =      0x80            ; Code 'token code not used'

;
;
;   Z-80 commands passed as data
;
defc  _NOP     =      0x00            ; Z-80 instruction  NOP
defc  LD_BC    =      0x01            ; Z-80 instruction  LD BC,nn
defc  LD_B     =      0x06            ; Z-80 instruction  LD B,n
defc  LD_DE    =      0x11            ; Z-80 instruction  LD DE,nn
defc  INC_DE   =      0x13            ; Z-80 instruction  INC DE
defc  DEC_DE   =      0x1B            ; Z-80 instruction  DEC DE
defc  LD_HL    =      0x21            ; Z-80 instruction  LD HL,nn
defc  INC_HL   =      0x23            ; Z-80 instruction  INC HL
defc  ADD_HL   =      0x29            ; Z-80 instruction  ADD HL,HL
defc  DEC_HL   =      0x2B            ; Z-80 instruction  DEC HL
defc  _CPL     =      0x2F            ; Z-80 instruction  CPL
defc  _SCF     =      0x37            ; Z-80 instruction  SCF
defc  LD_A     =      0x3E            ; Z-80 instruction  LD A,n
defc  RES_HL   =      0x86            ; Z-80 instruction  RES x,(HL)
defc  AND_B    =      0xA0            ; Z-80 instruction  AND B
defc  AND_D    =      0xA2            ; Z-80 instruction  AND D
defc  XOR_D    =      0xAA            ; Z-80 instruction  XOR D
defc  XOR_A    =      0xAF            ; Z-80 instruction  XOR A
defc  OR_B     =      0xB0            ; Z-80 instruction  OR B
defc  OR_C     =      0xB1            ; Z-80 instruction  OR C
defc  OR_D     =      0xB2            ; Z-80 instruction  OR D
defc  _JP      =      0xC3            ; Z-80 instruction  JP nn
defc  SET_HL   =      0xC6            ; Z-80 instruction  SET x,(HL)
defc  _RET     =      0xC9            ; Z-80 instruction  RET
defc  _OUT     =      0xD3            ; Z-80 instruction  OUT (n),A
defc  JP_HL    =      0xE9            ; Z-80 instruction  JP (HL)
defc  EX_DE    =      0xEB            ; Z-80 instruction  EX DE,HL
defc  OR_N     =      0xF6            ; Z-80 instruction  OR n
;
defc  DO_CMD   =      0x18            ; Restart to invoke a command

;
;
;   Filetype identifiers
;
defc  _OBJ     =      1               ; Filetype: machine program
defc  _BTX     =      2               ; Filetype: Basic - Program
defc  _BSD     =      3               ; Filetype: sequential file
defc  _BRD     =      4               ; Filetype: RANDOM - file

;
;
;  TOKEN codes used by the BASIC interpeter
;
defc  _LINNO   =      00BH            ; Token code - Line number identifier
defc  _LIN_P   =      00CH            ; Token code - Pointer to line identifier
defc  _HEXNO   =      011H            ; Token code - Hex value identifier
defc  _INTNO   =      012H            ; Token code - Integer value identifier
defc  __REAL   =      015H            ; Token code - Real value identifier
;
__GOTO   =      080H            ; Token code  GOTO
defc  _GOSUB   =      081H            ; Token code  GOSUB
defc  ____GO   =      082H            ; Token code  GO
defc  __LIST   =      087H            ; Token code  LIST
defc  ___RND   =      088H            ; Token code  RND
defc  __PEEK   =      089H            ; Token code  PEEK
defc  __NEXT   =      08EH            ; Token code  NEXT
defc  _PRINT   =      08FH            ; Token code  PRINT  (?)
defc  ____IF   =      093H            ; Token code  IF
defc  __DATA   =      094H            ; Token code  DATA
defc  ___REM   =      097H            ; Token code  REM
defc  __STOP   =      099H            ; Token code  STOP
defc  ____ON   =      09DH            ; Token code  ON
defc  ___CHR   =      0A0H            ; Token code  CHR
defc  ___OFF   =      0A1H            ; Token code  OFF
defc  _RMOVE   =      0A8H            ; Token code  RMOVE
defc  _SPACE   =      0A8H            ; Token code  SPACE
defc  ___KEY   =      0B2H            ; Token code  KEY
defc  ___ERL   =      0B4H            ; Token code  ERL
defc  __WAIT   =      0BEH            ; Token code  WAIT
defc  _ERROR   =      0C1H            ; Token code  ERROR
defc  __ELSE   =      0C2H            ; Token code  ELSE
defc  ____TI   =      0C4H            ; Token code  TI$
defc  ____FN   =      0C7H            ; Token code  FN
defc  _LABEL   =      0CAH            ; Token code  LABEL
defc  __INIT   =      0DCH            ; Token code  INIT
defc  __RMOV   =      0DFH            ; Token code  RMOV
defc  ____TO   =      0E0H            ; Token code  TO
defc  __STEP   =      0E1H            ; Token code  STEP
defc  __THEN   =      0E2H            ; Token code  THEN
defc  _USING   =      0E3H            ; Token code  USING
defc  ____PI   =      0E4H            ; Token code  Pi
defc  ___ALL   =      0E5H            ; Token code  ALL
defc  ___TAB   =      0E6H            ; Token code  TAB
defc  ___SPC   =      0E7H            ; Token code  SPC
defc  ___XOR   =      0EAH            ; Token code  XOR
defc  ____OR   =      0EBH            ; Token code  OR
defc  ___AND   =      0ECH            ; Token code  AND
defc  ___NOT   =      0EDH            ; Token code  NOT
defc  ____LE   =      0F0H            ; Token code  <=
defc  ____GE   =      0F2H            ; Token code  >=
defc  ____EQ   =      0F4H            ; Token code  =
defc  ____GT   =      0F5H            ; Token code  >
defc  ____LT   =      0F6H            ; Token code  <
defc  __PLUS   =      0F7H            ; Token code  +
defc  _MINUS   =      0F8H            ; Token code  -
defc  __IDIV   =      0F9H            ; Token code  DIV  (nicht bekannt)
defc  ___MOD   =      0FAH            ; Token code  MOD
defc  ___DIV   =      0FBH            ; Token code  /
defc  ___POT   =      0FDH            ; Token code  ^

;
;
;   1Z-013B MONITOR routine entries
;
defc  _MELDY   =      030H            ; Restart for 'play melody'
;
defc  TIMIN    =      0038DH          ; Start address time - interrupt - routine
defc  EDGE     =      00601H          ; Search impulse start on tape
defc  RBYTE    =      00624H          ; read a byte from tape
defc  TMARK    =      0065BH          ; Read license plate from tape
defc  MSTOP    =      00700H          ; motor off (cassette)
defc  CKSUM    =      0071AH          ; Count checksum of memory area
defc  WBYTE    =      00767H          ; write a byte to tape
defc  GAP      =      0077AH          ; Write ID tag on tape
defc  DLY12    =      00996H          ; Time loop approx. 7 msec
defc  _SHORT   =      00A01H          ; write a short impulse on tape
defc  LONG     =      00A1AH          ; write a long pulse to tape
defc  DLY3     =      00A4AH          ; Time loop about 330 usec

defc  _ADCN    =      00BB9H          ; Convert ASCII code to display code
defc  _DACN    =      00BCEH          ; Convert display code to ASCII code

defc  KTBL     =      00BEAH          ; Keyboard decode table for Normal mode
defc  KTBLS    =      00C2AH          ; Keyboard decode table for Shift mode
defc  KTBLG    =      00CE9H          ; Keyboard decode table for Shift-Graphic mode
defc  KTBLSG   =      00C6AH          ; Keyboard decode table for graphic mode

;
;
;   Serial port addresses (RS 232 C)
;
defc  SERA_D   =      0B0H            ; data port device RS1
defc  SERA_S   =      0B1H            ; data port device RS1
;
defc  SERB_D   =      0B2H            ; data port device RS2
defc  SERB_S   =      0B3H            ; status port device RS2

;
;
;   CRT controller port addresses
;
defc  CRTCWF   =      0CCH            ; Write - Format - Register   CRT - Controller
defc  CRTCRF   =      0CDH            ; Read - Format - Register    CRT - Controller
defc  CRTCDM   =      0CEH            ; Display - Mode - Register   CRT - Controller
defc  CRTCMP   =      0CFH            ; Scroll - Register - Flag    CRT - Controller

;
;
;   8255 I/O port addresses
;
defc  KEYP_A   =      0D0H            ; Keyboard - Output - Lines
defc  KEYP_B   =      0D1H            ; Keyboard - Input - Lines
defc  KEYP_C   =      0D2H            ; Tape recorder control
defc  KEYP_F   =      0D3H            ; 8255 control word register

;
;
;   8253 counter module addresses
;
defc  CT0_53   =      0D4H            ; 8253 - counter zero
defc  CT1_53   =      0D5H            ; 8253 - counter one
defc  CT2_53   =      0D6H            ; 8253 - counter two
defc  CTC_53   =      0D7H            ; 8253 counter module word register

;
;
;   Floppy-Disk controller port addresses
;
defc  CD_REG   =      0D8H            ; Command - Register
defc  ST_REG   =      0D8H            ; Status - Register
defc  TR_REG   =      0D9H            ; Track - Register
defc  SC_REG   =      0DAH            ; Sector - Register
defc  DA_REG   =      0DBH            ; Data - Register
defc  MO_REG   =      0DCH            ; Motor - Register
defc  PG_REG   =      0DDH            ; Page - Register
defc  DE_REG   =      0DEH            ; Density - Register

;
;
;   Switching addresses for RAM switching
;
defc  _CGVIN   =      0E0H            ; Turn on character set ROM and video ram
defc  _CGVOT   =      0E1H            ; Turn off character set ROM and video ram
;
defc  _00RAM   =      0E0H            ; Switch to RAM from 00000H - 07FFFH
defc  _E0RAM   =      0E1H            ; Switching port for RAM from 0E000H - 0FFFFH
defc  _E0ROM   =      0E3H            ; Monitor ROM switch port from 0E000H - 0FFFFH
defc  _00ROM   =      0E2H            ; Switch port for monitor - ROM
defc  _KMODE   =      0E4H            ; Switching port for MZ-80K mode

;
;
;   Port addresses of the 64K byte add-on RAM card
;
defc  ERAM_D   =      0EAH            ; RAM-card data port
defc  ERAM_A   =      0EBH            ; RAM-card addresses port

;
;
;   Palette - Color - Register
;
defc  PALLET   =      0F0H            ; Palette - Register

;
;
;  Sound Generator - Port Address
;
defc  PSGOUT   =      0F2H            ; PSG sound generator port address

;
;
;   Z-80 PIO system addresses
;
defc  PIOA_C   =      0FCH            ; Control Port - Z80 PIO channel A
defc  PIOB_C   =      0FDH            ; Control Port - Z80 PIO channel B

;
;
;   Printer - System - Addresses
;
defc  LST_ST   =      0FEH            ; Printer - Control Port
defc  LST_DA   =      0FFH            ; Printer - Data Port
;
;
;
;
defc  BITBUF   =      08000H          ; Start address of Graphic - image memory
defc  ZC000    =      0C000H          ; Start address of character generator - RAM in MZ-700 mode
defc  ZD800    =      0D800H          ; Start address of color memory in MZ-700 mode
defc  XF400    =      0F400H          ; Start address of jump table in ROM monitor

defc  XFF00    =      0FF00H          ; Top of memory for BASIC data
defc  ZFF00    =      0FF00H

defc  ZFF12    =      0FF12H

defc  ZFDA0    =      0FDA0H




; ----------------------------------------------------------------------------
;
;       Program start here
;
; ----------------------------------------------------------------------------

;
;
;   RAM - Monitor - jump table
;
        JP      STARTP          ; Monitor / Basic  -  Home entry
;
        JP      GETL            ; Get line from keyboard to memory (DE).
;
        JP      CR1             ; Output newline to screen
;
        JP      CR2             ; Line feed when cursor is not at beginning of line
;
        JP      CRT1S           ; print a space on the screen
;
        JP      PRNTT           ; Move cursor to next tab position
;
        JP      CRT1C           ; Display accu on screen (execution of control characters)
;
        JP      CRTMSG          ; Output text (DE) on screen (execution of control characters)
;
_DOCMD:
        JP      IOSVC           ; Software - execute command (RST _DOCMD)
;
        JP      INKEY0          ; Query whether key is pressed
;
BRKCHK: JP      BRKEY           ; Query whether (Shift) - BREAK is pressed
;
        JP      CMTERR          ; (N/A) File - write identifier on tape (cassette)
;
        JP      CMTERR          ; (N/A) File - write data to tape (cassette)
;
        JP      CMTERR          ; (N/A) Read file identifier from tape (cassette)
;
        JP      CMTERR          ; (N/A) File - read data from tape (cassette)
;
        JP      CMTERR          ; (N/A) File - compare data on tape with storage data
;
        JP      __RET           ; RET (formerly Music - Play Text (DE)), RST6
;
        JP      TIMST           ; set time
;
        DEFS    2               ; dummy
;
        JP      __RET           ; RET (formerly interrupt for clock)
;
        JP      TIMRD           ; read time
;
_BEEP:  JP      CTRLG           ; Treat reference tone according to code in Accu
;
_TEMPO: JP      _TEMP           ; set pace
;
        JP      MLDSP           ; turn off the sound
;
        JP      MLDSP           ; turn off the sound
;
        JP      GETL            ; Get line from keyboard to memory (DE).
;

SYSSTA:
        DEFW   _START
ERRORP:
        DEFS   2
;
        JP     CRTMSG          ;org 51H
;
        DEFS   4
;
        JP     INKEY           ;org 58H


;-----------------------------------------------------------------------------
;
;   CRT driver Table with the start addresses of the routines <> CTRL code
;
;-----------------------------------------------------------------------------
;
;
CONTTB: DEFW    __RET           ; CTRL  @
        DEFW    __RET           ; CTRL  A   (free for switching to ASCII keyboard)
        DEFW    __RET           ; CTRL  B   (free for switching the border color )
        DEFW    CTR_M           ; CTRL  C   (CR ?)
        DEFW    __RET           ; CTRL  D   (free for switching to German keyboard)
        DEFW    CTR_E           ; CTRL  E   (Switch to Shift - Lock - mode)
        DEFW    CTR_F           ; CTRL  F   (Switch to Alpha - mode)
        DEFW    __RET           ; CTRL  G   (free for switching to a different color for plotter )
        DEFW    __RET           ; CTRL  H   (free for background color switching)
        DEFW    C_TAB           ; CTRL  I   (TAB - Taste)
        DEFW    __RET           ; CTRL  J
        DEFW    __RET           ; CTRL  K   (free for 'hardcopy')
        DEFW    __RET           ; CTRL  L
        DEFW    CTR_M           ; CTRL  M   (CR)
        DEFW    SPLSW           ; CTRL  N   (start/stop printing )
        DEFW    __RET           ; CTRL  O
        DEFW    A06BE           ; CTRL  P   (Control character: DELete)
        DEFW    CDOWN           ; CTRL  Q   (Control character: Cursor down)
        DEFW    CUP             ; CTRL  R   (Control character: Cursor up)
        DEFW    CRIGHT          ; CTRL  S   (Control character: Cursor right)
        DEFW    CLEFT           ; CTRL  T   (Control character: Cursor left)
        DEFW    A0992           ; CTRL  U   (Control character: HOME)
        DEFW    HCLSW           ; CTRL  V   (Control character: CLR)
        DEFW    CTR_W           ; CTRL  W   (Control character: Graphic mode)
        DEFW    INST            ; CTRL  X   (Control character: INSerT)
        DEFW    CTR_F           ; CTRL  Y   (Switch to Alpha - mode)
        DEFW    __RET           ; CTRL  Z   (free for switching character color)
        DEFW    CTR_M           ; CTRL  [   (CR ?)
        DEFW    __RET           ; CTRL  ]
        DEFW    __RET           ; CTRL  \
        DEFW    __RET           ; CTRL  ^
        DEFW    __RET           ; CTRL  /
;
;
;   Call control character routine, control character in Accu
;
CTRLJB: ADD     A,A             ; Control characters times two (two bytes per address)
        LD      HL,CONTTB       ; Pointer to table with start addresses of routines
        CALL    ADDHLA          ; Add the value in the Accu to the HL register
        CALL    INDRCT          ; Get address from table (HL) to HL
        JP      (HL)            ; Call control character routine (HL).
;
NOTXT:  DEFB    NUL             ; Default for text without characters
;
A00A7:  JP      (HL)            ; Call program from address (HL).
;
;
;   Disable interrupts     (SVC code:  16)
;
SVC_DI: EI                      ; Enable interrupt
        PUSH    AF              ; Register - save value
        CALL    A44A3           ; wait until all parts of the melody have been played
        CALL    A14F8           ; Printer - Disable interrupt
        POP     AF              ; rescued register - fetch value
        DI                      ; Disable interrupts
__RET:  RET
;
;
;   Enable interrupt      (SVC code:  17)
;
SVC_EI: PUSH    AF              ; Register - save value
        CALL    A14FC           ; Printer - enable interrupt
        POP     AF              ; rescued register - fetch value
        EI                      ; Enable interrupt
        RET
;
;
;   Save registers IX, HL, BC, DE and AF
;
PUSHRA: EX      (SP),IX         ; IX - Store Register / Get Return Address
        PUSH    HL              ; HL - register - save value
        PUSH    BC              ; BC - register - save value
        PUSH    DE              ; DE - register - save value
        PUSH    AF              ; AF - register - save value
        PUSH    HL              ; HL - register - store value again
        LD      HL,POPRA        ; Pointer to routine for repeating register values
        EX      (SP),HL         ; Store address / get value for HL
        JP      (IX)            ; Return to calling program
;
;
;   Save registers IX, HL, BC and DE
;
PUSHR:  EX      (SP),IX         ; IX - Store Register / Get Return Address
        PUSH    HL              ; HL - register - save value
        PUSH    BC              ; BC - register - save value
        PUSH    DE              ; DE - register - save value
        PUSH    HL              ; HL - register - store value again
        LD      HL,POPR         ; Pointer to routine for repeating register values
        EX      (SP),HL         ; Store address / get value for HL
        JP      (IX)            ; Return to calling program
;
;
;   saved registers - reload values
;
POPRA:  POP     AF              ;! saved registers - reload values
POPR:   POP     DE              ;!
        POP     BC              ;!
        POP     HL              ;!
        POP     IX              ;!
        RET
;
;
;   Start BASIC - interpreter after switching on
;
COLDST: DI                      ; Disable interrupts
        LD      SP,0            ; Reset stack pointer
        IM      2               ; Specify interrupt mode
        OUT     (_E0RAM),A      ; Switch to RAM from 0E000H to 0FFFFH
        LD      HL,(SYSSTA)     ; Get current start address (boot start / warm start)
        JP      (HL)            ; Basic - Start interpreter
;
;
;   Abort program without error message; no 'CONT' possible
;
BREAKX: XOR     A               ; Code for 'Abort program; no 'CONT' possible'
        DEFB    LD_HL
;
;
;   Abort the program with 'BREAK'
;
BREAKZ: LD      A,080H          ; Code for 'Abort program with 'BREAK'
        DEFB    LD_HL
;
;
;   Devices - output name and error number in Accu
;
IOERR:  OR      10000000B       ; Code 'Output device name for error number'

;
;
;   Handle error with number in Accu
;
ERRORJ: PUSH    AF              ; Save error number
        CALL    MLDSP           ; turn off the sound
        POP     AF              ; Retrieve saved error number
        LD      HL,(ERRORP)     ; Get start address of error handler
        JP      (HL)            ; Jump to the error handling routine
;
;
;   Count the length of the text (DE); the end of the text is marked by the character NUL
;
;   (SVC code:  23)
;
COUNT:  PUSH    DE              ; Save pointer to beginning of text
        LD      B,0             ; Set counter to zero
A00F9:  LD      A,(DE)          ; get a character text
        OR      A               ; equal to end-of-text character (NUL) ?
        JR      Z,A0102         ; yes --> retrieve saved pointer to start of text
        INC     DE              ; Pointer to text on next character
        INC     B               ; Counter 'Number of characters text' plus one
        JR      NZ,A00F9        ; Counter still OK (< 256) --> continue counting
        DEC     B               ; specify a maximum string length of 255
A0102:  POP     DE              ; retrieve the saved pointer to the beginning of the text
        RET
;
;
;   Output table of values (HL) to ports; B contains number of values in table
;
;   (SVC code:  36)
;
IOOUT:  LD      A,(HL)          ; fetch the value to be output from the table
        INC     HL              ; Skip value in table
        LD      C,(HL)          ; Get port number from table
        INC     HL              ; Skip port number in table
        OUT     (C),A           ; Output value from table to port
        DJNZ    IOOUT           ; output more values
        RET
;
;
;   Convert ASCII value (HL) to hex value in DE, compare to upper limit in B
;
DEVASC: RST     _DOCMD          ; Software - Execute command
        DEFB    19              ; Command 19 convert ASCII value (HL) into hex value in DE
        LD      A,D             ; Get high byte of evaluated value
        OR      A               ; equals zero  ?
        JP      NZ,A1F7F        ; no --> Error 3 Illegal data error
        LD      A,E             ; Get low byte value
        CP      B               ; compare with maximum allowed value
        RET     C               ; value is ok
        JP      A1F7F           ; Error 3 Illegal data error
;
        DEFS    1               ; just so that starting address of the following routine with the
                                ; MZ-700 - Basic - Interpreter MZ-5Z008 matches.
;
;
;   Compare Accu with bytes specified after CALL
;
CHKACC: EX      (SP),HL         ; Get return address
        PUSH    BC              ; Register - save value
        LD      B,(HL)          ; Get number of bytes specified
A011E:  INC     HL              ; Pointer to next character to be compared
        CP      (HL)            ; Character in Accu same character after CALL ?
        JR      Z,A0127         ; yes --> skip the rest of the specified bytes
        DJNZ    A011E           ; compare other characters
        INC     HL              ; skip last compared character
        JR      A012A           ; saved register - get value and return
;
A0127:  INC     HL              ; skip an unmatched character
        DJNZ    A0127           ; skip more uncompared characters
A012A:  POP     BC              ; saved register - retrieve value again
        EX      (SP),HL         ; Store new return address / get HL register value
        RET
;
;
;   Get address from table (HL) to DE; Count up HL
;
LDDEMI: LD      E,(HL)          ; Get low - byte address from table
        INC     HL              ; Skip low - byte address
        LD      D,(HL)          ; Get high byte address from table
        INC     HL              ; Skip high - byte address
        RET
;
;
;   Get address from table (HL) to DE; do not change HL
;
LDDEMD: LD      E,(HL)          ; Get low - byte address from table
        INC     HL              ; Pointer to table on high - byte address
        LD      D,(HL)          ; Get high byte address from table
        DEC     HL              ; Set the pointer to the table back to the low byte
        RET
;
;
;   Delete memory area (HL); B contains number of bytes to delete
;
CLRHL:  XOR     A               ; Accu = zero
;
;
;   Assign memory area (HL) with constant in Accu; B contains number of bytes
;
SETHL:  LD      (HL),A          ; set a byte to a constant value
        INC     HL              ; Pointer to memory area to next byte
        DJNZ    SETHL           ; occupy further bytes with constants
        RET
;
;
;   Delete storage area (DE); B contains number of bytes
;
CLRDE:  XOR     A               ; Accu to zero
SETDE:  LD      (DE),A          ; delete a byte
        INC     DE              ; Pointer to memory area to next byte
        DJNZ    SETDE           ; delete more bytes
        RET
;
;
;   Move storage area from (HL) to (DE); B contains number of bytes
;
LDDEHL: LD      A,(HL)          ; fetch a byte from source area
        LD      (DE),A          ; and drop it in the target area
        INC     HL              ; Pointer to source area to next byte
        INC     DE              ; Pointer to target area to next byte
        DJNZ    LDDEHL          ; move more bytes
        RET
;
;
;   Move storage area from (DE) to (HL); B contains number of bytes
;
LDHLDE: LD      A,(DE)          ; fetch a byte from source area
        LD      (HL),A          ; and drop it in the target area
        INC     HL              ; Pointer to target area to next byte
        INC     DE              ; Pointer to source area to next byte
        DJNZ    LDHLDE          ; move more bytes
        RET
;
;
;   Get address from table (HL) to HL
;
INDRCT: PUSH    AF              ; Save AF
        LD      A,(HL)          ; Get low - byte address from table
        INC     HL              ; Pointer to table on high - byte address
        LD      H,(HL)          ; Get high byte address from table
        LD      L,A             ; Specify low - byte address
        POP     AF              ; Restore AF
        RET
;
;
;   Add the value in the Accu to the HL register
;
ADDHLA: ADD     A,L             ; Add Accu to the low byte value
        LD      L,A             ; and note the result
        RET     NC              ; no carry --> finished
        INC     H               ; Correct high - byte value for carry
        RET
;
;
;   Skip spaces (HL).
;
INCHLF: INC     HL              ; Pointer to text on next character
HLFTCH: LD      A,(HL)          ; get a character text
        CP      ' '             ; equal to space ?
        JR      Z,INCHLF        ; yes --> search for the next relevant text character
        RET
;
;
;   Test whether the next relevant text character (HL) is the same byte after the CALL call
;   if so --> ZERO - flag set and characters skipped
;
TEST1:  CALL    HLFTCH          ; Skip spaces (HL).
        EX      (SP),HL         ; Get return address from stack
        CP      (HL)            ; Accu same byte after CALL call?
        INC     HL              ; Skip comparison characters
        EX      (SP),HL         ; correct return address
        RET     NZ              ; bytes not equal
        INC     HL              ; skip correct text character
        RET
;
;
;   Syntax Check. If next relevant text character (HL) is a valid code, then call
;   Otherwise --> Error 1 Syntax error
;
TESTX:  CALL    HLFTCH          ; Skip spaces (HL).
        EX      (SP),HL         ; Get return address / HL - register - save value
        CP      (HL)            ; Accu same byte after CALL call?
        INC     HL              ; Skip comparison characters
        EX      (SP),HL         ; store new return address / retrieve text pointer
        INC     HL              ; skip compared syntax character
        RET     Z               ; Syntax is OK
        LD      A,1             ; Error 1 Syntax error
        JP      ERRORJ         ; Handle error with number in Accu
;
;
;   Table with the start addresses of the software commands
;
IOSVCT: DEFW    MONOP           ; Code  0  Call Software - Machine - Monitor
        DEFW    CR1             ; Code  1  Output newline to screen
        DEFW    CR2             ; Code  2  Line feed when cursor is not at beginning of line
        DEFW    CRT1C           ; Code  3  Display accu on screen (execution control mark)
        DEFW    CRT1CX          ; Code  4  Display accu on screen (display control characters)
        DEFW    CRTSIMU         ; Code  5  Output text (DE) with upper/lower case
        DEFW    LPTOUT          ; Code  6  Output characters in Accu to printer
        DEFW    LPT1C           ; Code  7  Output characters in the Accu to the printer (and screen).
        DEFW    PR_CR           ; Code  8  Output line feed to screen or printer
        DEFW    PR_1C           ; Code  9  Accu on screen or printer (execution control card)
        DEFW    PR_1CX          ; Code 10  Accu on screen or printer (display control line)
        DEFW    PR_MSG          ; Code 11  Output text (DE) on screen or printer
        DEFW    GETL            ; Code 12  Get line from keyboard to memory (DE).
        DEFW    INKEY           ; Code 13  Keyboard query for status in Accu
        DEFW    BRKEY           ; Code 14  Query whether (Shift) - BREAK is pressed
        DEFW    HALT            ; Code 15  if space pressed --> wait for other key
        DEFW    SVC_DI          ; Code 16  Disable interrupts
        DEFW    SVC_EI          ; Code 17  Enable interrupt
        DEFW    CURMOV          ; Code 18  Place cursor on coordinates in HL
        DEFW    DEASC           ; Code 19  Convert ASCII value (HL) to hex value according to DE
        DEFW    DEHEX           ; Code 20  Convert hexadecimal value (HL) into hex value in DE
        DEFW    CKHEX           ; Code 21  Convert hexadecimal ASCII characters in Accu to hex
        DEFW    ASCHL           ; Code 22  Convert hex value in HL to decimal ASCII to (DE)
        DEFW    COUNT           ; Code 23  Count the length of the text (DE).
        DEFW    ADDP0           ; Code 24  Pointer to I/O work area, basic var., strings corr.
        DEFW    ADDP1           ; Code 25  Fix pointers to basic variables and strings
        DEFW    ADDP2           ; Code 26  Fix pointers to string ranges
        DEFW    ERRX            ; Code 27  Output error text according to error number in Accu
        DEFW    DACN            ; Code 28  Convert display code characters to ASCII code
        DEFW    ADCN            ; Code 29  Convert ASCII characters in Accu to display code
        DEFW    STICK           ; Code 30  Query joystick for direction
        DEFW    STRIG           ; Code 31  Query the joystick's fire button
        DEFW    CTRLG           ; Code 32  Output reference tone
        DEFW    PLAY            ; Code 33  Assign values ??(DE) to the tone generator in the Accu
        DEFW    MSOUND          ; Code 34  Play tone by generator number/frequency or note/length
        DEFW    MCTRL           ; Code 35  Treat music by status in Accu
        DEFW    IOOUT           ; Code 36  Output table of values ??(HL) to ports; B = number
        DEFW    TIMRD           ; Code 37  read time
        DEFW    TIMST           ; Code 38  set time
        DEFW    INP1C0          ; Code 39  provide the next data block of the file
        DEFW    CLRIO           ; Code 40  delete all file data in the computer
        DEFW    SEGADR          ; Code 41  Pointer to record by record number. provide
        DEFW    OPSEG           ; Code 42  provide dynamic cache
        DEFW    DELSEG          ; Code 43  Clear dynamic cache
        DEFW    DEV             ; Code 44  Examine text (DE) for device names
        DEFW    DEV_FN          ; Code 45  Evaluate device names and file numbers
        DEFW    LUCHK           ; Code 46  File management record by file no. provide
        DEFW    LOPEN           ; Code 47  Open (program) file
        DEFW    LOADFL          ; Code 48  Load program according to specified identifier
        DEFW    SAVEFL          ; Code 49  Save program
        DEFW    VRFYFL          ; Code 50  Compare (program) file
        DEFW    RWOPEN          ; Code 51  Open file according to provided data
        DEFW    INPSTRT         ; Code 52  if screen --> get line from keyboard
        DEFW    INPMSG          ; Code 53  provide a line from device/file
        DEFW    INPDT           ; Code 54  Text constant (HL) up to comma or character in C already.
        DEFW    PRTSTR          ; Code 55  Output text (DE) on selected device
        DEFW    CLKL            ; Code 56  Close file or delete file data in the computer
        DEFW    FDIR            ; Code 57  Read or print table of contents
        DEFW    SETDFL          ; Code 58  Pointer to device table/device no. notice
        DEFW    LSALL           ; Code 59  Write or read RAM card contents to quick disk
        DEFW    FINIT           ; Code 60  Initialize device
        DEFW    FDELET          ; Code 61  delete file
        DEFW    FRENAM          ; Code 62  Rename file
        DEFW    FLOCK           ; Code 63  Protect or share file
        DEFW    RECST           ; Code 64  RANDOM - remember block number
        DEFW    INREC           ; Code 65  Read record from RANDOM file
        DEFW    PRREC           ; Code 66  Write record to RANDOM file
        DEFW    ERRCVR          ; Code 67  Delete file data of the output file
        DEFW    FSWAP           ; Code 68  SWAP - Write or load main program
        DEFW    HCLS            ; Code 69  clear entire screen
        DEFW    POSCK           ; Code 70  Check if graphic coordinate in DE',HL' is OK
        DEFW    POSSV           ; Code 71  Set graphic cursor to coordinates in DE',HL'
        DEFW    PSET            ; Code 72  Set or reset point in graphic
        DEFW    WLINE           ; Code 73  Draw a line in Graphic
        DEFW    CHARW           ; Code 74  Graphic - pattern - output text
        DEFW    WBOX            ; Code 75  Draw rectangle
        DEFW    WPAINT          ; Code 76  Paint area (B=number of colors/(HL)=border color values)
        DEFW    WCIRCL          ; Code 77  draw circle
        DEFW    WPOINT          ; Code 78  Query whether point is set in graphic
        DEFW    HCPY            ; Code 79  Output screen content to graphic printer
        DEFW    DSMODE          ; Code 80  Screen - set operating mode
        DEFW    DPALBK          ; Code 81  Memorize pallet block number/output to controller
        DEFW    DPALST          ; Code 82  Match color code in B to pallet code number in Accu
        DEFW    DWIND           ; Code 83  Set values ??for screen - scroll - area
        DEFW    DCOLOR          ; Code 84  Set character color
        DEFW    DGCOL           ; Code 85  Graphic - set palette value
        DEFW    ICRT            ; Code 86  Initialize screen
        DEFW    SYMBOL          ; Code 87  Output text with magnification
;
;
;   RST 3:  Execute software SVC command   (RST 018H - Routine)
;
IOSVC:  EX      (SP),HL         ; Get return address
        PUSH    AF              ; Register - save value
        LD      A,(HL)          ; Get software command number
        INC     HL              ; Command - skip number
        PUSH    HL              ; store new return address
        LD      HL,IOSVCT       ; Pointer to table with start addresses of routines
        ADD     A,A             ; Command number times two (2 bytes per address)
        ADD     A,L             ; and add the start address to the low byte
        JR      NC,A0239        ; no carry
        INC     H               ; Correct carry
A0239:  LD      L,A             ; Remember low byte result
        LD      A,(HL)          ; Get low byte start address from table
        INC     HL              ; Pointer to table on high - byte address
        LD      H,(HL)          ; Get high byte start address from table
        LD      L,A             ; Enter low - byte address
        LD      (IOSVCX+1),HL   ; Enter start address in JP command
        POP     HL              ; fetch saved return address
        POP     AF              ; rescued register - fetch value
        EX      (SP),HL         ; Store return address/HL - register - get value
IOSVCX: JP      0               ; Execute software command (address is entered)
;
;
;   Call routine (IX) with error handling
;
IOCALL: PUSH    HL              ;! Register - save values
        PUSH    DE              ;!
        LD      (IOCALX+1),IX   ; Enter the start address of the routine
        LD      IX,IOERR        ; Address 'Output error with device name'
        OR      A               ; reset carry flag (code 'no error')
IOCALX: CALL    0               ; Call routine (address is entered)
        POP     DE              ;! saved registers - retrieve values
        POP     HL              ;!
        RET     NC              ; no error --> OK
        OR      A               ; end of file ?
        SCF                     ; Set code 'Error Occurred'
        RET     Z               ; End of file --> OK
        JP      IOERR           ; Error with device - output name
;
;
;   Convert hex value in HL to decimal ASCII value to (DE)
;
;   (SVC code:  22)
;
ASCHL:  PUSH    HL              ; save value to be implemented
        PUSH    BC              ; Register - save value
        PUSH    DE              ; Push pointer to text memory on stack
        LD      DE,10000        ; specify priority
        CALL    ASCHL2          ; implement a position
        LD      DE,1000         ; specify priority
        CALL    ASCHL2          ; implement a position
        LD      DE,100          ; specify priority
        CALL    ASCHL2          ; implement a position
        LD      DE,10           ; specify priority
        CALL    ASCHL2          ; implement a position
        LD      A,L             ; Get value of last digit
        POP     DE              ; Get pointer to ASCII - text - memory
        OR      '0'             ; Convert number to ASCII characters
        LD      (DE),A          ; Enter ASCII digits in text memory
        INC     DE              ; skip entered number
        XOR     A               ; Accu to zero (code 'End of text (NUL)')
        LD      (DE),A          ; Enter end of text character after number in memory
        POP     BC              ; rescued register - fetch value
        POP     HL              ; get converted value
        RET
;
;
;   implement a position according to the priority in DE
;
ASCHL2: LD      A,-1            ; Default for counter
A0286:  INC     A               ; counter plus one
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; Subtract the value of the position once
        JR      NC,A0286        ; still OK --> continue to pull off
        ADD     HL,DE           ; Correct remainder value
        OR      A               ; Value of digit equal to zero ?
        JR      NZ,A0293        ; no --> relevant number
        OR      B               ; digit already entered?
        RET     Z               ; no --> suppress leading zero
        XOR     A               ; Accu back to zero
A0293:  LD      B,1             ; Specify code 'digit entered'
        OR      '0'             ; Convert number to ASCII characters
        POP     DE              ; Get return address
        EX      (SP),HL         ; Save register value / get pointer to memory
        LD      (HL),A          ; Enter ASCII characters in text memory
        INC     HL              ; skip entered number
        EX      (SP),HL         ; Save pointer to memory / get residual value
        PUSH    DE              ; Put the return address back on the stack
        RET
;
;
;   Convert decimal or hexadecimal ASCII value (HL) into hex value according to DE
;
;   (SVC code:  19)
;
DEASC:  CALL    TEST1           ; Comparison on byte after CALL call
        DEFM    "$"             ; ID 'hexadecimal - value' ?
        JR      Z,DEHEX         ; yes --> convert hexadecimal value (HL) into hex value in DE
        LD      DE,0            ; Default value result
A02A7:  CALL    HLFTCH          ; Skip spaces (HL).
        SUB     '0'             ; Convert ASCII characters to decimal value
        CP      10              ; digit ?
        RET     NC              ; no --> numerical value implemented
        INC     HL              ; skip converted digit
        PUSH    HL              ; Save pointer to rest of text
        LD      H,D             ;! duplicate old value
        LD      L,E             ;!
        ADD     HL,HL           ; old value times two
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     HL,HL           ;            times four
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     HL,DE           ;            times five
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     HL,HL           ;            times ten
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        LD      E,A             ; value of the new position
        LD      D,0             ; High - byte value to zero
        ADD     HL,DE           ; Add the value of the new digit
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        EX      DE,HL           ; new result after DE
        POP     HL              ; Get pointer to rest of text
        JR      A02A7           ; examine whether additional digits are specified
;
A02C9:  LD      A,2             ; Error 2 Overflow error
        JP      ERRORJ          ; Handle error with number in Accu
;
;
;   Convert hexadecimal ASCII value (HL) to hex value according to DE
;
;   (SVC code:  20)
;
DEHEX:  LD      DE,0            ; Default value result
A02D1:  LD      A,(HL)          ; get a text character
        CALL    CKHEX           ; Convert hexadecimal ASCII characters in Accu to hex value
        RET     C               ; no hex-ASCII character --> done
        INC     HL              ; skip evaluated character
        EX      DE,HL           ; old value to HL / pointer to text to DE
        ADD     HL,HL           ; old value times 2
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     HL,HL           ;             times 4
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     HL,HL           ;             times 8
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     HL,HL           ;             times 16
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     A,L             ; Add the value of the new digit
        LD      L,A             ; note the result
        EX      DE,HL           ; value in DE / pointer to remaining text after HL
        JR      A02D1           ; implement another position
;
;
;   Convert hexadecimal ASCII characters in Accu to hex value after Accu
;
;   (SVC code:  21)
;
CKHEX:  SUB     '0'             ; Convert ASCII characters to decimal - value
        CP      10              ; decimal digit ?
        CCF                     ; Reverse result comparison
        RET     NC              ; is decimal - digit --> done
        SUB     17              ;!  hexadecimal digit ?
        CP      6               ;!
        CCF                     ; Reverse result comparison
        RET     C               ; no hex - ascii - value
        ADD     A,10            ; correct value
        RET
;
;
;   Check whether the space bar is pressed
;   If so -->  wait until another key is pressed
;
;   (SVC code:  15)
;
HALT:   CALL    HALTSB          ; Check whether button or 'BREAK' is pressed
        CP      ' '             ; Space key pressed ?
        RET     NZ              ; no
A02FE:  CALL    HALTSB          ; Check whether button or 'BREAK' is pressed
        OR      A               ; key pressed ?
        JR      Z,A02FE         ; no --> keep waiting
        RET
;
;
;   Check whether button is pressed with BREAK --> Interrupt program
;
HALTSB: RST     _DOCMD          ; Software - Execute command
        DEFB    14              ; Code 14 Query whether (Shift) BREAK is pressed
        JR      Z,HALTBR        ; yes --> interrupt program (BREAK)
        LD      A,-1            ; Code 'keyboard query with debouncing'
        RST     _DOCMD          ; Software - Execute command
        DEFB    13              ; Code 13 Keypad query for status in Accu
        CP      ESC             ; Shift-BREAK pressed?
        RET     NZ              ; no
HALTBR: JP      BREAKZ          ; Shift - BREAK pressed --> interrupt program
;
        RET
;
;
;   Pointer to device table and device number as DEFAULT - remember device
;
;   (SVC code:  58)
;
SETDFL: LD      (DDEV),DE       ; Pointer to device - remember table (DEFAULT).
        LD      (DCHAN),A       ; Devices - remember number
        RET
;
;
;   Fix pointers to file work areas, basic variables and string areas
;
;   (SVC code:  24)
;
ADDP0:  LD      HL,(POOL)       ; Get pointers to file work areas (I/O work area).
        ADD     HL,DE           ; Correct pointer
        LD      (POOL),HL       ; and remember new pointer
;
;
;   Correct pointers to Basic - variable and string ranges
;
;   (SVC code:  25)
;
ADDP1:  LD      HL,(VARST)      ; Get pointer to start of basic variable
        ADD     HL,DE           ; Correct pointer
        LD      (VARST),HL      ; and remember again
;
;
;   Correct pointers to string areas
;
;   (SVC code:  26)
;
ADDP2:  LD      HL,(STRST)      ; Get pointer to beginning of string text area
        ADD     HL,DE           ; Correct pointer
        LD      (STRST),HL      ; and remember again
        LD      HL,(VARED)      ; Get pointer to start of string workspace
        ADD     HL,DE           ; Correct pointer
        LD      (VARED),HL      ; and remember again
        LD      HL,(TMPEND)     ; Get pointer to end of string workspace
        ADD     HL,DE           ; Correct pointer
        LD      (TMPEND),HL     ; and remember again
        RET
;
;
;   Output error text according to error number in Accu
;
;   (SVC code:  27)
;
ERRX:   LD      C,A             ; Remember error number
        RST     _DOCMD          ; Software - Execute command
        DEFB    32              ; Output code 32 reference tone
        RST     _DOCMD          ; Software - Execute command
        DEFB    2               ; Code 2 line feed if cursor not at beginning of line
        BIT     7,C             ; Output device name?
        JR      Z,A0353         ; no
        LD      HL,S11A4        ; Specify pointer to cache
        PUSH    HL              ; Remember pointer to beginning of memory
        CALL    SETDNM          ; Devices - Provide Names by Storage (HL).
        POP     DE              ; Pointers to Recycled Devices - Get Names
        RST     _DOCMD          ; Software - Execute command
        DEFB    5               ; Code 5 Output text (DE) with upper/lower case
A0353:  LD      A,C             ; Get error number
        AND     01111111B       ; mask actual error number
        LD      C,A             ; and remember again
        RST     _DOCMD          ; Software - Execute command
        DEFB    16              ; Code 16 disable interrupt
        OUT     (_E0ROM),A      ; Switch to ROM - monitor from 0E000H to 0FFFFH
        JR      A035F           ; Output error text
;
ERRXU:  LD      C,69            ; Error 69 Unprintable error
A035F:  LD      DE,ZFDA0        ; Pointer to start of error text table in ROM monitor
A0362:  DEC     C               ; Counter minus one
        JR      Z,A036F         ; Pointer is on correct error text --> output
A0365:  LD      A,(DE)          ; Get a character from the error text table
        INC     DE              ; Table pointer to next text character
        OR      A               ; end of text character ?
        JP      P,A0365         ; no --> find end of text
        JR      Z,ERRXU         ; End of table --> Specify error 69 Unprintable error
        JR      A0362           ; test whether pointer is on correct error text
;
A036F:  LD      A,(DE)          ; get first text character
        CP      _NOTXT          ; Code 'no text available' ?
        JR      Z,ERRXU         ; Yes --> Specify error 69 Unprintable error
        EX      DE,HL           ; Pointer to error text after HL
        LD      DE,S11A4        ; Specify pointer to cache
A0378:  LD      A,(HL)          ; one character Get error text from table
        OR      A               ; end of text character ?
        JP      M,A0381         ; yes --> output provided text
        LDI                     ; transfer a text character from table to memory
        JR      A0378           ; transfer more text characters
;
A0381:  AND     01111111B       ; mask actual text character
        LD      (DE),A          ; and remember in memory
        OUT     (_E0RAM),A      ; Switch to RAM from 0E000H to 0FFFFH
        RST     _DOCMD          ; Software - Execute command
        DEFB    17              ; Code 17 enable interrupt
        INC     DE              ; skip last character of text in memory
        LD      HL,M03B6        ; Text " error"
        LD      B,8             ; Specify text length
        CALL    LDDEHL          ; Move text from (HL) to (DE).
        LD      DE,S11A4        ; Pointer to memory with edited error text
        RST     _DOCMD          ; Software - Execute command
        DEFB    5               ; Code 5 Output text (DE) with upper/lower case
        RET
;
;
;   Devices - Provide name of current device after (HL).
;
SETDNM: LD      DE,(ZEQT)       ; Pointers to current devices - get table
        INC     DE              ;! Pointer to next devices - table
        INC     DE              ;! skip
        RST     _DOCMD          ; Software - Execute command
        DEFB    23              ; Code 23 Count length of text (DE).
        CALL    LDHLDE          ; Move memory area from (DE) to (HL).
        LD      A,(ZCH)         ; Get current device number
        ADD     A,'1'           ; convert to ASCII
        LD      (HL),A          ; and after devices - enter the name
        LD      A,(ZFLAG2)      ; Devices - numbers - get flag
        AND     00001111B       ; maximum devices - mask number
        JR      Z,A03B0         ; no device number allowed
        INC     HL              ; entered devices - skip number
A03B0:  LD      (HL),':'        ; Enter a colon after the device name
        INC     HL              ; skip colon
        LD      (HL),NUL        ; Enter the end of the text after the device name
        RET
;
M03B6:  DEFB    ' ', _SML       ; Text  "error"
        DEFM    "ERROR"
		DEFB    NUL
;
;
;   Screen - set operating mode  (SVC code: 80)
;
DSMODE: CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      B,A             ; Screen - remember operating mode
        LD      A,(MEMOP)       ; Get 'additional graphic RAM available' flag (1=yes)
        OR      A               ; Additional graphic RAM available?
        LD      A,B             ; get new screen - operating mode
        JR      NZ,A03D1        ; Graphic RAM available --> all operating modes are permitted
        CP      2               ; Operating mode 2 (320 x 200 pixels / 16 colors) ?
        JR      Z,A0417         ; yes --> not possible without additional graphic --> error
        CP      4               ; Operating mode 4 (640 x 200 pixels / 4 colors) ?
        JR      Z,A0417         ; Yes --> Not possible without additional graphics --> Error
A03D1:  PUSH    AF              ; new screen - remember operating mode
        DEC     A               ; Screen - mode minus one
        LD      D,11111111B     ; Specification for mask 'Number of screen pages'
        LD      HL,B1389        ; Pointer to default color code mode 1
        LD      BC,256*4+0011B  ; maximum palette value / default for color planes
        JR      Z,A03F7         ; Screen - Operating mode 1 --> Note values
        DEC     A               ; Screen - mode minus one
        LD      HL,B138D        ; Pointer to default color code mode 2
        LD      BC,256*16+1111B ; maximum palette value / default for color planes
        JR      Z,A03F7         ; Screen - Operating mode 2 --> Note values
        DEC     A               ; Screen - mode minus one
        LD      HL,B1385        ; Pointer to default color code mode 3
        LD      BC,256*2+0001B  ; maximum palette value / default for color planes
        JR      Z,A03F7         ; Screen - Mode 3 --> Remember values
        LD      HL,B1389        ; Pointer to default for color code mode 4
        LD      BC,256*8+0101B  ; maximum palette value / default for color planes
        LD      D,11111101B     ; Specification for mask 'Number of screen pages'
A03F7:  LD      (CPLANE),BC     ; remember maximum palette value / default for color planes
        LD      A,D             ; Get mask for number of screen pages
        LD      (PMASK),A       ; and remember
        LD      (W137F),HL      ; Pointer to color code - remember default
        CALL    PALOFF          ; Initialize palette registers for basic colors
        POP     AF              ; Screen - Get operating mode
        DEC     A               ; minus one (--> 0 - 3)
        RLCA                    ; and now two
        LD      (DMD),A         ; Note value for display - mode - register
        OUT     (CRTCDM),A      ; Output value to display - mode - register
        AND     00000100B       ; Mask flag '40/80 characters per line'
        CALL    A04EF           ; Change routine to 40 or 80 characters per line
        CALL    A0419           ; Unclip/Initialize Palette
        OR      A               ; reset Carry flag (code 'Function OK')
        RET
;
A0417:  SCF                     ; Set code 'Error Occurred'
        RET
;
;
;   Set scroll area to full screen and initialize palette registers
;
A0419:  LD      HL,256 * 24 + 0 ; Specify Y - Coordinate minimum / maximum
        CALL    DWIND           ; Calculate values ??for scroll area from Y coordinates
        LD      A,(CPLANE)      ; Get default used color planes
        LD      (CMODE),A       ; and remember as currently used color planes
        XOR     A               ; Accu to zero
        CALL    DPALBK          ; Pallet block - remember number and output to controller
        LD      HL,W137F        ; Pointer to Pointer to color code - default
        LD      E,(HL)          ;! Get pointer to default palette register
        INC     HL              ;!
        LD      D,(HL)          ;!
        EX      DE,HL           ; Pointer to default palette register after HL
        LD      DE,S1381        ; Pointer to storage for palette values
        PUSH    DE              ; Remember pointer to beginning of memory
        LD      BC,4            ; Specify number of values
        LDIR                    ; Transfer default pallet value to memory
        POP     HL              ; Pointer to start of memory with palette values
A043A:  LD      B,4             ; four values ??in memory
        LD      C,PALLET        ; Port - number of the palette register
        OTIR                    ; Output values ??to palette registers
        RET
;
;
;   Initialize palette registers for basic colors Black/Blue/Red/Light White
;
PALOFF: PUSH    BC              ; Register - save value
        XOR     A               ; Default initial value (zero)
        LD      B,5             ; output five values
        LD      C,PALLET        ; Specify the port number of the palette register
A0447:  OUT     (C),A           ; Output pallet value
        ADD     A,010H          ; Calculate next pallet value
        DJNZ    A0447           ; output further pallet values
        POP     BC              ; saved register - retrieve value again
        RET
;
;
;   Palette block - Set number (SVC code: 81)
;
DPALBK: CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      (S137E),A       ; current pallet block - remember number
        LD      E,A             ; Pallet block - remember number
        LD      A,(DMD)         ; Get value for Display - Mode - Register
        CP      2               ; Resolution 320 x 200 pixels / 16 colors ?
        JR      NZ,A0470        ; not the finest graphic resolution
        LD      A,E             ; Pallet block - get number
        RLCA                    ;! times two
        RLCA                    ;! times four
        LD      HL,S1381        ; Pointer to storage for palette values
        LD      B,4             ; four values ??in the palette block
        PUSH    HL              ; Remember pointer to beginning of memory
A0466:  LD      (HL),A          ; remember a palette value
        ADD     A,011H          ; Calculate next value in palette block
        INC     HL              ; Pointer to next memory for palette value
        DJNZ    A0466           ; Calculate further initial values ??for pallet block
        POP     HL              ; Get pointer to beginning of memory with palette values
        CALL    A043A           ; output new values ??to palette registers
A0470:  LD      A,E             ; Pallet block - get number
        OR      01000000B       ; plus code 'switch 0/1'
        OUT     (PALLET),A      ; Pallet block - issue number to controller
        RET
;
;
;   Assign the color code in B to the pallet code number in the Accu
;   and output it to the palette register
;
;   (SVC code:  82)
;
DPALST: CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      HL,S1381        ; Pointer to storage for palette values
        LD      D,0             ; High - byte offset to zero
        LD      E,A             ; Specify pallet code number as low byte offset
        ADD     HL,DE           ; Pointer to correct pallet code - calculate value
        OR      A               ; Reset carry flag
        RLCA                    ;! Pallet code - number on pallets - bits
        RLCA                    ;! push
        RLCA                    ;!
        RLCA                    ;!
        OR      B               ; plus color value - number
        LD      (HL),A          ; Remember palette code and color value
        OUT     (PALLET),A      ; and output to pallet registers
        RET
;
;
;   Set current drawing color to palette value in accu
;
;   (SVC code:  84)
;
DCOLOR: PUSH    AF              ; Save pallet value
        CALL    A049C           ; Correct palette value for maximum resolution
        LD      (CMODE),A       ; current character - remember palette value
        POP     AF              ; retrieve saved pallet value
        RET
;
;
;   Set current graphic color to palette value in Accu
;
;   (SVC code:  85)
;
DGCOL:  PUSH    AF              ; Save pallet value
        CALL    A049C           ; Correct palette value for maximum resolution
        LD      (GMODE),A       ; Remember current graphic palette value
        POP     AF              ; recover saved pallet value
        RET
;
;
;   Correct pallet value in Accu for maximum resolution
;
A049C:  PUSH    BC              ; Register - save value
        LD      B,A             ; Remember pallet value
        LD      A,(DMD)         ; Get value for Display - Mode - Register
        CP      6               ; Resolution 640 x 200 pixels / 4 colors ?
        LD      A,B             ; retrieve saved pallet value
        JR      NZ,A04AC        ; not maximum resolution
        CP      2
        JR      C,A04AC         ; Palette value is OK
        ADD     A,2             ; Correct palette value
A04AC:  POP     BC              ; rescued register - fetch value
        RET
;
;
;   Calculate values for screen - scroll - area
;   from start to end coordinates and output to display controller
;
;   (SVC code:  83)
;
DWIND:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      (S136F),HL      ; Y - Remember coordinate minimum / maximum
        LD      A,H             ;! Calculate the number of lines in the scroll area
        SUB     L               ;!
        INC     A               ;!
        LD      (S1371),A       ; Note the number of lines in the scroll area
        LD      B,A             ; Note number of lines
        ADD     A,A             ;! times two
        ADD     A,A             ;!     four
        ADD     A,B             ;!     five
        LD      (S1374),A       ; and note it as the value for 'Scroll - width'
        EX      DE,HL           ; Note the start and end coordinates
        LD      H,0             ; High - byte value to zero
        LD      L,A             ; Number of lines in the scroll area multiplied by five
        ADD     HL,HL           ;! Calculate maximum scroll offset
        ADD     HL,HL           ;!
        ADD     HL,HL           ;!
        LD      (W1377),HL      ; remember maximum scroll offset according to scroll area
        EX      DE,HL           ; Start and end coordinates back to HL
        INC     H               ; End coordinate plus one
        LD      A,H             ; End coordinate scroll - area
        ADD     A,A             ;! times two
        ADD     A,A             ;!     four
        ADD     A,H             ;!     five
        LD      (S1376),A       ; and note it as the value for 'Scroll-End-Address-Register'
        LD      A,L             ; Start coordinate scroll - get area
        ADD     A,A             ;! times two
        ADD     A,A             ;!     four
        ADD     A,L             ;!     five
        LD      (S1375),A       ; and note it as the value for 'Scroll-Start-Address-Register'
        LD      HL,0            ; Default for offset
        LD      (S1372),HL      ; remember as 'scroll offset' for screen controllers
        LD      HL,S1376        ; Pointers to prepared values ??for screen controllers
        LD      BC,256*6+CRTCMP ; Port number Multi-purpose register in the display controller
        OTDR                    ; Output provided values ??to screen controllers
        CALL    HCLS            ; Software command 69 clears the entire screen
        JP      A0992           ; Execute control character 'HOME'
;
;
;   Change screen routines to 40 or 80 characters per line
;   (if Accu is not zero --> 80 characters per line)
;
A04EF:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        OR      A               ; 40 or 80 characters per line?
        LD      A,40            ; 40 characters per line
        LD      DE,256*INC_HL + _NOP
        JR      Z,A04FE         ; change to 40 characters per line
        ADD     A,A             ; Counter to 80 characters per line
        LD      DE,256*_NOP + INC_HL
A04FE:  LD      (W136B),A       ; Note counter '40/80 characters per line'
        LD      H,0             ; High - byte value to zero
        LD      L,A             ; Number of characters per line as low - byte value
        ADD     HL,HL           ;!  times two (eight graphic columns per text character)
        ADD     HL,HL           ;!      four
        ADD     HL,HL           ;!      eight
        LD      (W136D),HL      ; Note the number of pixels per line
        DEC     A               ; Counter to maximum X - coordinate
        LD      (S136A),A       ; note the maximum X coordinate
        LD      A,D             ; Get command for second value
        LD      (D0535),A       ;!  and enter into routines
        LD      (D0536),A       ;!
        LD      (D0547),A       ;!
        LD      A,E             ; Get command for first value
        LD      (D053E),A       ;!  and enter into routines
        LD      (D053F),A       ;!
        LD      (D054B),A       ;!
        LD      BC,256 * 11 + 7 ; 10 two-byte values / 7 one-byte values
        LD      HL,CHTBL        ; Pointer to table with values to be changed
        CALL    A0531           ; Change program according to table (HL).
        CALL    A45D0           ; Change graphic routine to 40 or characters/line
        JP      HCLS            ; Software - command 69 delete complete screen
;
;
;   Change program routines according to table (HL).
;
A0531:  LD      E,(HL)          ;!Get address from table
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL              ; Skip high - byte address
D0535:  INC     HL              ;!  skip the first value (NOP is written here if
D0536:  INC     HL              ;!           the first value is to be entered)
        LD      A,(HL)          ;!  Get the value from the table and enter it at the address in the routine
        INC     HL              ;!      Pointer to table to next byte
        LD      (DE),A          ;!      Enter value in routine
        INC     DE              ;!      Address to next byte
        LD      A,(HL)          ;!      Get value from table
        INC     HL              ;!      Skip value in table
        LD      (DE),A          ;!      Enter value in routine
D053E:  NOP                     ;!  INC HL stands here if the first value from the table
D053F:  NOP                     ;!  was entered
        DJNZ    A0531           ; enter another two byte values from the table
        LD      B,C             ; Specify number of one-byte values for counters
A0543:  LD      E,(HL)          ;!  Get address from table
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL              ; Skip high - byte address
D0547:  INC     HL              ; skip first value (or NOP)
        LD      A,(HL)          ; Get value from table
        INC     HL              ; Skip value in table
        LD      (DE),A          ; Enter value in routine
D054B:  NOP                     ; INC HL stands here if the first value was entered
        DJNZ    A0543           ; enter another one - byte - values
        RET
;
;
;   Table for changing the monitor text routines to 40 or 80 characters per line
;

;
;  word patch
;
CHTBL:  DEFW    A05E5 + 1       ; Address
        DEFW    80              ; Value for 80 characters per line
        DEFW    40              ; Value for 40 characters per line
;
        DEFW    A063D           ; Address
        DEFW    021CBH          ; Value for 80 characters per line   (SLA C)
        DEFW    00000H          ; Value for 40 characters per line   (NOP NOP)
;
        DEFW    A0666 + 1       ; Address
        DEFW    400             ; Value for 80 characters per line
        DEFW    200             ; Value for 40 characters per line
;
        DEFW    A0669 + 1       ; Address
        DEFW    BITBUF + 16000  ; Value for 80 characters per line
        DEFW    BITBUF +  8000  ; Value for 40 characters per line
;
        DEFW    A071F + 1       ; Address
        DEFW    80              ; Value for 80 characters per line
        DEFW    40              ; Value for 40 characters per line
;
        DEFW    A0747 + 1       ; Address
        DEFW    7 * 80          ; Value for 80 characters per line
        DEFW    7 * 40          ; Value for 40 characters per line
;
        DEFW    A07C2 + 1       ; Address
        DEFW    80              ; Value for 80 characters per line
        DEFW    40              ; Value for 40 characters per line
;
        DEFW    A07E8 + 1       ; Address
        DEFW    -80             ; Value for 80 characters per line
        DEFW    -40             ; Value for 40 characters per line
;
        DEFW    A0814 + 1       ; Address
        DEFW    - (7 * 80)      ; Value for 80 characters per line
        DEFW    - (7 * 40)      ; Value for 40 characters per line
;
        DEFW    A0829 + 1       ; Address
        DEFW    80              ; Value for 80 characters per line
        DEFW    40              ; Value for 40 characters per line
;
        DEFW    A08D4 + 1       ; Address
        DEFW    8 * 80 - 1      ; Value for 80 characters per line
        DEFW    8 * 40 - 1      ; Value for 40 characters per line
;
;
;
;byte patch
;
;
        DEFW    A06E4 + 1       ; Address
        DEFB    80 - 1          ; Value for 80 characters per line
        DEFB    40 - 1          ; Value for 40 characters per line
;
        DEFW    A070D + 1       ; Address
        DEFB    80 - 1          ; Value for 80 characters per line
        DEFB    40 - 1          ; Value for 40 characters per line
;
        DEFW    A07B3 + 1       ; Address
        DEFB    80 - 1          ; Value for 80 characters per line
        DEFB    40 - 1          ; Value for 40 characters per line
;
        DEFW    A0824 + 1       ; Address
        DEFB    80 - 1          ; Value for 80 characters per line
        DEFB    40 - 1          ; Value for 40 characters per line
;
        DEFW    A0858 + 1       ; Address
        DEFB    80              ; Value for 80 characters per line
        DEFB    40              ; Value for 40 characters per line
;
        DEFW    A0972           ; Address
        DEFB    ADD_HL          ; Value for 80 characters per line
        DEFB    _NOP            ; Value for 40 characters per line
;
        DEFW    A0989           ; Address
        DEFB    ADD_HL          ; Value for 80 characters per line
        DEFB    _NOP            ; Value for 40 characters per line
;
;
;   Display characters in Accu on screen
;
A05AD:  CALL    PUSHRA          ; Save registers IX, HL, BC, DE and AF
        LD      HL,(POSADR)     ; Get pointer to current location in text memory
        LD      C,A             ; note the character to be output
        CP      ' '             ; Space ?
        JR      NZ,A05B9        ; no
        XOR     A               ; Note space as 000H
A05B9:  LD      (HL),A          ; Enter text characters in pseudo image memory
        LD      HL,(BITADR)     ; Get text cursor position in Graphic screen
        LD      A,C             ; get the character to be output
        CALL    A05CE           ; Enter characters in the Accu in Graphic screen
        XOR     A               ; Code 'Concatenate line if to next line'
        LD      (D09E1 + 1),A   ; Enter jump offset in routine
        CALL    CRIGHT          ; Execute 'Cursor right'
        LD      A,7             ; Code 'move cursor only'
        LD      (D09E1 + 1),A   ; Enter jump offset in routine
        RET
;
;
;   Enter characters in the Accu in Graphic screen
;
A05CE:  RST     _DOCMD          ; Software - Execute command
        DEFB    29              ; Code 29 Convert ASCII characters to display code
        DI                      ; Disable interrupts
        EXX                     ; Save first register record
        PUSH    HL              ; Register - save value
        LD      H,0             ; High - byte value to zero
        LD      L,A             ; Specify display code character as low - byte value
        LD      A,(CMODE)       ; current character - get palette value
        OR      10000000B       ; plus code 'Replace (REPLACE)'
        OUT     (CRTCWF),A      ; to 'Write-Format-Register' of the display controller
        ADD     HL,HL           ;! display code character times two
        ADD     HL,HL           ;!                        four
        ADD     HL,HL           ;!                        eight
        SET     4,H             ; Set offset to address from 01000H (beginning of character ROM)
                                ; (with SET 5,H characters from the second character set are used
                                ;  issued)
        EXX
        LD      B,8             ; eight vertical rows per character
A05E5:  LD      DE,40           ; Distance to the next vertical row (is entered)
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
A05EA:  EXX
        LD      A,(HL)          ; get a byte from character set - ROM
        INC     HL              ; Pointer to character set - ROM to next byte
        EXX
        LD      (HL),A          ; Enter characters in the Graphci image memory
        ADD     HL,DE           ; Pointer to graphic frame buffer to next line
        DJNZ    A05EA           ; enter further lines of the character in graphic image memory
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Enable interrupt
        EXX
        POP     HL              ; rescued register - fetch value
        EXX
        RET
;
;
;   Y - Provide coordinates of beginning of current line and beginning of next line after DE
;
;
A05F9:  CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
A05FC:  LD      A,(HL)          ; Get the row's concatenation flag
        OR      A               ; equals zero  ?
        JR      Z,A0608         ; yes --> Y - coordinate found at beginning of line
        DEC     HL              ; Pointer to concatenation flags minus one
        DEC     E               ; Y - coordinate minus one
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        CP      E               ; compare with Y - coordinate
        JR      C,A05FC         ; still within the scroll area --> search for the beginning of the line
A0608:  LD      D,E             ; Y - Remember the coordinates at the beginning of the line
A0609:  INC     E               ; Y - coordinate plus one
        INC     HL              ; Pointer to concatenation flags plus one
        LD      A,(HL)          ; Get the row's concatenation flag
        OR      A               ; equal to zero (beginning of line) ?
        RET     Z               ; yes --> Found the beginning of the next line
        LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        CP      E               ; compare with current Y - coordinate
        JR      NC,A0609        ; still within the scroll area --> beginning of next line
        RET
;
;
;   Provide pointer to concatenation flag of row in HL
;   On entry, H = Y coordinate
;
A0615:  LD      E,H             ; Y - coordinate of the row as low - byte offset
        LD      D,0             ; High - byte offset to zero
        LD      HL,S13A9        ; Pointer to memory with concatenation flags of text lines
        ADD     HL,DE           ; Set pointer to row concatenation flag
        RET
;
;
;   Cursor - control character CLR (clear screen (section))
;
HCLSW:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        LD      H,A             ; specify as the Y coordinate
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      A,(S1371)       ; Get number of lines in scroll area
        LD      B,A             ;! and remember
        LD      E,A             ;!
        CALL    CLRHL           ; Clear memory area (HL) (concatenation flags)
        LD      C,E             ; Number of lines in the scroll area
        LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        INC     A               ; Y - coordinate of line inter scroll area
        LD      L,0             ; X - coordinate to zero
        LD      H,A             ; Specify Y coordinate
        PUSH    HL              ; Save initial coordinates of line behind scroll area
        CALL    A0963           ; Calculate text memory address from coordinates in HL
        LD      B,0             ; High - byte number of rows to zero
A063D:  NOP                     ;! if 80 characters/line it says SLA C
        NOP                     ;! (Delete duplicate count)
        PUSH    BC              ; Save number of lines
        CALL    A0671           ; Delete storage area from back to front
        POP     HL              ; Get Number of Rows
        ADD     HL,HL           ;! times two (eight bytes per text character in the graphic
        ADD     HL,HL           ;!     four image buffers)
        ADD     HL,HL           ;!     eight
        LD      C,L             ;! Number of rows transferred to BC
        LD      B,H             ;!
        POP     HL              ; Get start coordinate of line after scroll area
        CALL    A097A           ; Calculate graphic image memory coordinate from coordinate in HL
        CALL    A0671           ; Delete storage area from back to front
        JR      A06AC           ; Reset scroll offset
;
;
;   Clear entire screen (SVC code: 69)
;
HCLS:   CALL    PUSHRA          ; Save registers IX, HL, BC, DE and AF
        LD      HL,TEXTBF+2000  ; Pointer to end of pseudo image memory (text memory)
        LD      BC,50           ; 50 half lines of 40 bytes each
        CALL    A0671           ; Delete storage area from back to front
        LD      B,25            ; maximum 25 lines
        LD      HL,S13A9        ; Pointer to memory with concatenation flags of text lines
        CALL    CLRHL           ; Delete memory area (HL).
A0666:  LD      BC,200          ; Number of 40 byte range for erasure (200/400)
A0669:  LD      HL,BITBUF+8000  ; Pointer to end of graphic frame buffer (BITBUF+16000)
        CALL    A0671           ; Delete storage area from back to front
        JR      A06AC           ; Reset scroll offset
;
;
;   Delete storage area from back to front
;   (HL = pointer to end of area / BC = number of 40 - byte - units)
;
A0671:  LD      (D06A2 + 1),SP  ; Save stack pointer at start routine
        LD      (D0683 + 1),HL  ; Enter pointer to end of memory area
        LD      HL,0            ; Default for erasing value
        LD      A,(CPLANE)      ; Get background color value
        OR      10000000B       ; plus code 'Replace (REPLACE)'
        OUT     (CRTCWF),A      ; to 'Write-Format-Register' of the display controller
A0682:  DI                      ; Disable interrupts
D0683:  LD      SP,0            ; Set pointer to end of memory area
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        PUSH    HL              ;!   Delete 2 bytes
        PUSH    HL              ;!   4
        PUSH    HL              ;!   6
        PUSH    HL              ;!   8th
        PUSH    HL              ;!  10
        PUSH    HL              ;!  12
        PUSH    HL              ;!  14
        PUSH    HL              ;!  16
        PUSH    HL              ;!  18
        PUSH    HL              ;!  20
        PUSH    HL              ;!  22
        PUSH    HL              ;!  24
        PUSH    HL              ;!  26
        PUSH    HL              ;!  28
        PUSH    HL              ;!  30
        PUSH    HL              ;!  32
        PUSH    HL              ;!  34
        PUSH    HL              ;!  36
        PUSH    HL              ;!  38
        PUSH    HL              ;!  Delete 40 bytes
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        LD      (D0683 + 1),SP  ; Re-enter pointer to remaining memory area in routine
D06A2:  LD      SP,0            ; Set the stack pointer to the correct value again
        EI                      ; Enable interrupt
        DEC     BC              ; Counter minus one
        LD      A,C             ;!  Counter equal to zero?
        OR      B               ;!
        JR      NZ,A0682        ; no --> delete another 40 byte areas
        RET
;
;
;   Reset screen controller scroll offset
;
A06AC:  LD      HL,0            ; Scroll - offset to zero
        LD      (S1372),HL      ; remember as 'scroll offset' for screen controllers
        LD      B,2             ; High - Byte 'Scroll Offset Register'
        LD      C,CRTCMP        ; Port - number of the multi-purpose register
        OUT     (C),H           ; High - Output byte scroll offset to controller
        DEC     B               ; Address on Low - Byte 'Scroll Offset Register'
        OUT     (C),L           ; Output low - byte offset to screen controller
        JP      A0992           ; Execute control character 'HOME'
;
;
;   Cursor - control character DELete
;
A06BE:  EXX                     ; switch to second register set
        PUSH    HL              ; HL' - register - save value
        PUSH    DE              ; DE' - register - save value
        PUSH    BC              ; BC' - register - save value
        EXX                     ; switch back to the first register set
        CALL    A06CC           ; Delete character at cursor position
        EXX                     ; switch to second register set
        POP     BC              ; fetch saved BC' - register - value
        POP     DE              ; retrieve saved DE' register value
        POP     HL              ; retrieve saved HL' register value
        EXX                     ; switch back to the first register set
        RET
;
;
;   Delete character at cursor position
;
A06CC:  LD      HL,(CURXY)      ; Get current cursor coordinates
        DEC     L               ; X - coordinate minus one
        JP      P,A06E6         ; still in line --> remember new coordinate
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      A,(HL)          ; Get the row's concatenation flag
        LD      H,E             ; current y coordinate
        LD      L,0             ; X - coordinate to zero
        OR      A               ; concatenation flag set ?
        JR      Z,A06E6         ; no
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        CP      H               ; compare with current Y - coordinate
        JR      Z,A06E6         ; is minimal - coordinate
        DEC     H               ; Y - coordinate minus one
A06E4:  LD      L,39            ; X - coordinate at maximum (39/79)
A06E6:  LD      (CURXY),HL      ; new current cursor - remember coordinates
        CALL    LINCAL          ; Cursor at the beginning of the next logical screen line
        CALL    PONTC           ; Text image memory address from current cursor coordinate
        PUSH    BC              ; Number of characters in line/remaining number of characters in cursor line
        LD      D,H             ;! Duplicate text - image storage address to DE
        LD      E,L             ;!
        INC     HL              ; Pointer to character after cursor position
        EXX
        PUSH    HL              ; Place number of characters in line on stack
        EXX
        POP     BC              ; Get number of characters in line
        LDIR                    ; Move line to pseudo - image memory (text memory).
        XOR     A               ; Accu to zero (code 'Space')
        LD      (DE),A          ; enter as the last character of the line
        POP     BC              ; Number of characters in line/remaining number of characters in cursor line
        LD      HL,(CURXY)      ; Get current cursor coordinates
        INC     HL              ; X - coordinate cursor plus one
        CALL    A097A           ; Calculate graphic image memory coordinate from coordinate in HL
A0703:  EXX
        LD      D,8 + 1         ; eight rows of dots make a character
        LD      HL,(MAXCF)      ; get maximum palette value / mask for screen pages
        DEC     D               ; Correct number of point rows
        EXX
        JR      A0723           ; move the rest of the line
;
A070D:  LD      C,39            ; Number of characters to move in line (39/79)
        DEC     B               ; Remaining number of rows minus one
        JR      Z,A0755         ; done --> delete last character in logical line
        INC     DE              ;! Correct pointer to graphic - image memory
        INC     DE              ;!
        LD      H,D             ;! Transfer pointer to HL
        LD      L,E             ;!
        JR      A0703           ; Move characters in graphic image memory
;
A0718:  LD      HL,(MAXCF)      ; get maximum palette value / mask for screen pages
        DEC     D               ; Remaining number of rows minus one
        EXX
        JR      Z,A070D         ; once done --> test whether more lines
A071F:  LD      DE,40           ; Offset to next graphic line (40/80)
        ADD     HL,DE           ; Calculate pointer to next graphic line
A0723:  EXX
        RRC     L               ; one bit maximum palette value after carry
        JR      C,A0718         ; Bit is set --> all palette value levels processed
        LD      A,L             ; Get pallet value
        AND     H               ; link to mask for screen page
        EXX
        JR      Z,A0723         ; Color plane is not used
        DI                      ; Disable interrupts
        PUSH    HL              ; Pointer to Graphic - save image memory
        PUSH    BC              ; Save number of bytes / remaining number of lines
        OUT     (CRTCRF),A      ; Color plane to 'Read-Format-Register' of screen controller
        OUT     (CRTCWF),A      ; Color plane to the 'Write-Format-Register' of the screen controller
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
        LD      D,H             ;! Duplicate pointer to Graphic - Image memory
        LD      E,L             ;!
        DEC     DE              ; Pointer to previous byte
        LD      A,C             ; Get number of characters to move
        OR      A               ; Number equal to zero ?
        JR      Z,A0747         ; yes --> do not move line
        LD      A,B             ; Get counter 'Remaining number of rows'
        LD      B,0             ; High - byte count to zero
        LDIR                    ; move a graphic screen line
        DEC     A               ; Counter 'Remaining number of rows' minus one
        JR      Z,A074D         ; no more lines
A0747:  LD      BC,280          ; Offset for pointer to next graphic - text - line
        ADD     HL,BC           ; Calculate pointer to next graphic text line
        LD      A,(HL)          ; get a byte
        LD      (DE),A          ; and transfer
A074D:  IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Enable interrupt
        POP     BC              ; Get number of bytes / remaining number of lines
        POP     HL              ; Pointer to Graphic - get image memory
        JP      A0723           ; Remaining graphic - move lines
;
A0755:  EX      DE,HL           ; Pointer to graphic memory after HL
        INC     C               ; Correct value to number of characters in line
        LD      E,C             ; Number of characters in the screen line (bytes per graphic line)
        LD      D,B             ; High - byte count to zero
        LD      B,8             ; eight lines of graphic in one line of text
        DI                      ; Disable interrupts
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
        LD      A,(CPLANE)      ; Get background color value
        OR      10000000B       ; plus code 'Replace (REPLACE)'
        OUT     (CRTCWF),A      ; and to the 'Write-Format-Register' of the display controller
A0767:  XOR     A               ; Accu to zero
        LD      (HL),A          ; delete a byte in the graphic screen
        SBC     HL,DE           ; Graphic screen pointer on line above
        DJNZ    A0767           ; delete more bytes in the graphic screen
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Release interrupt again
        LD      HL,(CURXY)      ; Get current cursor coordinates
        JP      CURMOV          ; Set cursor to current coordinates in HL
;
;
;   Cursor - control character INSerT
;
INST:   EXX                     ; switch to second register set
        PUSH    HL              ; HL' - register - save value
        PUSH    DE              ; DE' - register - save value
        PUSH    BC              ; BC' - register - save value
        EXX                     ; switch back to the first register set
        CALL    A0784           ; insert a character at the cursor position
        EXX                     ; switch to second register set
        POP     BC              ; fetch saved BC' - register - value
        POP     DE              ; retrieve saved DE' register value
        POP     HL              ; retrieve saved HL' register value
        EXX                     ; switch back to the first register set
        RET
;
;
;   Insert character (space) at cursor position in line
;
A0784:  LD      HL,(CURXY)      ; Get current cursor coordinates
        CALL    LINCAL          ; Cursor at the beginning of the next logical screen line
        PUSH    HL              ; Remember cursor coordinates of next logical line
        CALL    A0963           ; Calculate text memory address from coordinates in HL
        DEC     HL              ; Set pointer to last character in current line
        LD      A,(HL)          ; Get last character of line from text memory
        OR      A               ; vacancy ?
        JR      NZ,A07AE        ; no --> correct the stack and you're done
        PUSH    BC              ; Save number of screen lines
        LD      D,H             ;! Duplicate pointer to last character in line
        LD      E,L             ;!
        DEC     HL              ; Pointer to next to last character
        EXX
        PUSH    HL              ; Number of characters to move in line
        EXX
        POP     BC              ; bring to BC
        LDDR                    ; Move rest of line in pseudo frame store
        XOR     A               ; Accu to zero (code 'Space')
        LD      (DE),A          ; Enter an empty space in the text memory
        POP     BC              ; Get number of screen rows
        POP     HL              ; Get cursor coordinate of next logical line
        CALL    A097A           ; Calculate graphic image memory coordinate from coordinate in HL
        DEC     HL              ; Pointer to last byte of line in graphic memory
        LD      A,C             ; Get remaining number of characters in cursor line
        LD      (A07BA + 1),A   ; and enter into routine
        DEC     B               ; Number of rows minus one
        JR      Z,A07BC         ; just one line on the screen
        JR      A07B3           ; Move characters in graphic memory
;
A07AE:  POP     HL              ; saved register - get value (fix stack)
        RET
;
A07B0:  DEC     B               ; Remaining number of rows minus one
        JR      Z,A07BA         ; just move the cursor line
A07B3:  LD      C,39            ; Number of bytes to be shifted in one line (39/79)
        CALL    A07DC           ; move a line of text in the Graphic screen
        JR      A07B0           ; examine whether there are more rows to move
;
A07BA:  LD      C,0             ; Remaining number of characters in the cursor line (will be entered)
A07BC:  CALL    A07DC           ; move a line of text in the Graphic screen
        CALL    A0977           ; absolute graphic memory address from cursor coordinate
A07C2:  LD      DE,40           ; Distance to next graphic line (40/80)
        LD      B,8             ; eight graphic lines make up one text line
        DI                      ; Disable interrupts
        LD      A,(CPLANE)      ; Get background color value
        OR      10000000B       ; plus code 'Replace (REPLACE)'
        OUT     (CRTCWF),A      ; and to the 'Write-Format-Register' of the display controller
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
A07D3:  XOR     A               ; Accu to zero (code 'Space')
        LD      (HL),A          ; clear a byte in graphic memory
        ADD     HL,DE           ; Calculate pointer to next graphic line
        DJNZ    A07D3           ; clear more bytes in graphic memory
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Enable interrupt
        RET
;
;
;   Graphic Screen - Shift line with end address in HL
;   by one text character (8 pixels) to the right
;
A07DC:  EXX
        LD      D,8 + 1         ; Number Graphic - Lines for one line of text
A07DF:  LD      HL,(MAXCF)      ; get maximum palette value / mask for screen pages
        DEC     D               ; Remaining number of graphic lines minus one
        EXX
        RET     Z               ; finished
        CALL    A07EF           ; Move the remainder of a graphic line
A07E8:  LD      DE,-40          ; Offset to previous graphic line (-40/-80)
        ADD     HL,DE           ; Calculate pointer to previous graphic line
        EXX
        JR      A07DF           ; test whether there are more rows to move
;
A07EF:  EXX
        RRC     L               ; Shift maximum palette value by one bit
        LD      A,L             ; get current color plane bit to accu
        EXX
        RET     C               ; all color planes processed
        EXX
        AND     H               ; link to mask for screen page
        EXX
        JR      Z,A07EF         ; do not edit this color plane
        PUSH    HL              ; Save pointer to graphic frame buffer
        PUSH    BC              ; Save number of bytes in graphic line
        DI                      ; Disable interrupts
        OUT     (CRTCRF),A      ; Color plane to 'Read-Format-Register' of screen controller
        OUT     (CRTCWF),A      ; Color plane to the 'Write-Format-Register' of the screen controller
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
        LD      D,H             ;! Pointer to end of graphic - duplicate line
        LD      E,L             ;!
        DEC     HL              ; Pointer to penultimate byte (character)
        LD      A,C             ; Get number of bytes in line
        OR      A               ; Number equal to zero ?
        JR      Z,A0814         ; yes --> do not shift bytes in line
        LD      A,B             ; Get remaining rows
        LD      B,0             ; High - Byte Number of characters in line to zero
        LDDR                    ; move a Graphic line
        OR      A               ; Remaining number of lines equal to zero ?
        JR      Z,A081A         ; yes --> saved registers - fetch values
A0814:  LD      BC,-280         ; Offset to previous line of text (Graphic*8) (-280/-560)
        ADD     HL,BC           ; Calculate pointer to previous row
        LD      A,(HL)          ; Graphic - Get pattern from previous line
        LD      (DE),A          ; and enter in a new line
A081A:  IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Enable interrupt
        POP     BC              ; Get number of bytes in graphic line
        POP     HL              ; get saved pointer to graphic memory
        JP      A07EF
;
;
;   Calculate number of connected characters from cursor coordinates in HL to DE
;   Set the cursor coordinate in HL to the beginning of the next logical screen line
;
LINCAL: LD      B,1             ; Default for number of lines
A0824:  LD      A,39            ; Specify maximum X coordinate
        SUB     L               ; Calculate remaining number of characters in cursor line
        LD      C,A             ; and remember
        EXX
A0829:  LD      DE,40           ; Number of characters in physical screen line (40/80)
        LD      H,0             ; High - byte default to zero
        LD      L,A             ; Remaining number of characters in cursor line as low - byte specification
        EXX
A0830:  INC     H               ; Y - coordinate plus one
        LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        CP      H               ; compare with Y - coordinate
        JR      C,A0845         ; End scroll area
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      A,(HL)          ; Get the row's concatenation flag
        OR      A               ; line concatenated ?
        LD      H,E             ; Specify Y coordinate again
        JR      Z,A0845         ; Found the beginning of the next logical line
        INC     B               ; Number of lines plus one
        EXX
        ADD     HL,DE           ; Number of characters plus number in a line
        EXX
        JR      A0830           ; Find end of logical screen line
;
A0845:  LD      L,0             ; X - coordinate to zero
        RET
;
;
;   Scroll screen content
;
A0848:  CALL    PUSHRA          ; Save registers IX, HL, BC, DE and AF
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        LD      H,A             ; as the Y coordinate of the start of the scroll area
        LD      L,0             ; X - coordinate start scroll - area to zero
        CALL    A0963           ; Calculate text memory address from coordinates in HL
        LD      D,H             ;! Duplicate text memory address after DE
        LD      E,L             ;!
        LD      B,0             ; High - byte number of characters to zero
A0858:  LD      C,40            ; Low - byte number of characters per line (40/80)
        ADD     HL,BC           ; Calculate pointer to second line in scroll area
        LD      A,(S1371)       ; Get number of lines in scroll area
        DEC     A               ; correct to number of rows to move
        JR      Z,A0870         ; delete only one line in the scroll area
        PUSH    BC              ; Save number of characters per line
        PUSH    HL              ; Save pointer to second line in scroll area
        LD      HL,0            ; Specification for the number of characters in the scroll area
A0866:  ADD     HL,BC           ;! Calculate number of characters to be moved
        DEC     A               ;!   Remaining number of rows minus one
        JR      NZ,A0866        ;!   Add character for further line
        LD      B,H             ;! Transfer number of characters to be shifted to BC
        LD      C,L             ;!
        POP     HL              ; Get pointer to second row in pseudo image memory
        LDIR                    ; Scroll text in pseudo-image memory
        POP     BC              ; Get number of characters in line
A0870:  LD      B,C             ; Specify the number of characters in the line as a counter
        CALL    CLRDE           ; Delete memory area (DE) (B contains number)
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        LD      H,A             ; and note it as the Y coordinate
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      A,(S1371)       ; Get number of lines in scroll area
        DEC     A               ; correct to number of rows to move
        LD      B,A             ; Remember counter
        LD      (HL),0          ; clear first concatenation flag
        INC     HL              ; Pointer to second concatenation flag
        LD      D,H             ;! Duplicate pointers to concatenation flags
        LD      E,L             ;!
        INC     DE              ; Pointer to next flag
        CALL    NZ,LDHLDE       ; Move memory area from (DE) to (HL).
        LD      (HL),0          ; Clear flag of last line in scroll area
        LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        LD      H,A             ; and note it as the Y coordinate
        LD      L,0             ; X - coordinate to zero (set left margin)
        CALL    A097A           ; Calculate graphic image memory coordinate from coordinate in HL
        LD      (D08CC + 1),HL  ; Enter the end address of the graphic scroll area in the routine
        LD      DE,5 * 8        ; Offset for a line
        LD      HL,(S1372)      ; Get 'scroll offset' for screen controller
        ADD     HL,DE           ; Calculate offset for next line
        PUSH    HL              ; remember new scroll offset
        LD      DE,(W1377)      ; get maximum scroll offset according to scroll area
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; compare new scroll offset to maximum scroll offset
        POP     HL              ; get saved new scroll offset
        JR      NZ,A08AC        ; not yet maximum offset
        LD      HL,0            ; start over again
A08AC:  LD      (S1372),HL      ; 'Scroll offset' for screen - remember controller
A08AF:  IN      A,(CRTCDM)      ; Screen - Controller - Read Status
        AND     01000000B       ; Screen controller active ?
        JR      NZ,A08AF        ; yes --> wait
        DI                      ; Disable interrupts
        LD      C,CRTCMP        ; Port Number Multi Purpose Register
        LD      B,2             ; Address 'high byte scroll offset register'
        OUT     (C),H           ; Output high byte scroll offset to screen controller
        DEC     B               ; Address on 'low byte scroll offset register'
        OUT     (C),L           ; Output low-byte scroll offset to screen controller
        LD      A,(CMODE)       ; current character - get palette value
        OUT     (CRTCRF),A      ; output to the screen controller's 'Read-Format-Register'
        OR      10000000B       ; plus code 'Replace (REPLACE)'
        OUT     (CRTCWF),A      ; to 'Write-Format-Register' of the display controller
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
D08CC:  LD      HL,0            ; End address graphic scroll area
        LD      (HL),0          ; delete first byte in line
        LD      D,H             ;! Duplicate pointer to Graphic frame store to DE
        LD      E,L             ;!
        INC     DE              ; Pointer to second byte in last scroll line
A08D4:  LD      BC,320 - 1      ; Number of bytes -1 for a text line in graphic memory
        LDIR                    ; delete the last line of text in the graphic scroll area
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Enable interrupt
        LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        LD      H,A             ; as the new Y coordinate
        LD      L,0             ; X - coordinate at zero (left edge)
        JP      CURMOV          ; Set cursor to current coordinates in HL
;
;
;   Change character at cursor position for cursor blinking
;
A08E5:  CALL    PUSHRA          ; Save registers IX, HL, BC, DE and AF
        EXX
        PUSH    HL              ; Register - save value
        LD      HL,B1391        ; Pointer to cursor - Bit pattern for alpha mode
        LD      A,(CURMAK)      ; Current keyboard mode (0=Alpha / 1=Small / 2=Graphic)
        OR      A               ; alpha mode ?
        JR      Z,A08FC         ; Yes
        LD      HL,B1399        ; Pointer to cursor bit pattern for lowercase cursor
        DEC     A               ; lowercase mode ?
        JR      Z,A08FC         ; Yes
        LD      HL,B13A1        ; Pointer to cursor bit pattern for graphic cursor
A08FC:  EXX
        DI                      ; Disable interrupts
        LD      A,(CURFLG)      ; Get flag 'original/cursor character' (0=original)
        XOR     00000001B       ; reverse flag
        LD      (CURFLG),A      ; and remember new flag
        LD      HL,(BITADR)     ; Get text cursor position in Graphic screen
        LD      D,0             ; High - byte offset to zero
        LD      A,(W136B)       ; Get counter '40/80 characters per line'
        LD      E,A             ; and specify as low - byte offset
        LD      B,8             ; eight graphic lines make up one text line
        LD      A,(CMODE)       ; current character - get palette value
        OR      00100000B       ; plus code 'XOR'
        OUT     (CRTCWF),A      ; and to the 'Write-Format-Register' of the display controller
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
A091C:  EXX
        LD      A,(HL)          ; get a line of the cursor character
        INC     HL              ; Pointer to cursor bitmap to next byte
        EXX
        LD      (HL),A          ; Enter line of cursor bit pattern in graphic memory
        ADD     HL,DE           ; Pointer to Graphic - store to next line
        DJNZ    A091C           ; print more lines of the cursor pattern
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EXX
        POP     HL              ; rescued register - fetch value
        EXX
        EI                      ; Enable interrupt
        RET
;
;
;   Initialize keyboard and display cursor characters on screen
;
A092B:  CALL    PUSHRA          ; Save registers IX, HL, BC, DE and AF
        XOR     A               ;!  Initialize cursor - blink - encoder
        OUT     (KEYP_A),A      ;!
        CPL                     ;!
        OUT     (KEYP_A),A      ;!
        LD      A,(CURFLG)      ; Get flag 'original/cursor character' (0=original)
        OR      A               ; Original characters in display ?
        RET     NZ              ; no --> cursor character in image memory
        JR      A08E5           ; Enter cursor characters in graphic memory
;
;
;   Enter original character at cursor position
;
A093B:  CALL    PUSHRA          ; Save registers IX, HL, BC, DE and AF
        LD      A,(CURFLG)      ; Get flag 'original/cursor character' (0=original)
        OR      A               ; Original characters in graphic memory ?
        RET     Z               ; yes --> done
        JR      A08E5           ; Enter original character at cursor position
;
;
;   Change cursor character for blinking
;
A0945:  IN      A,(KEYP_C)      ; Cursor - query timer
        RLCA                    ;!  Timer - shift bit after carry
        RLCA                    ;!
        JR      NC,A092B        ; not set --> show cursor characters
        JR      A093B           ; set --> show original characters
;
;
;   Coordinates in HL as current cursor - remember coordinates
;
;   (SVC code:  18)
;
CURMOV: CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      (CURXY),HL      ; current cursor - remember coordinates
        CALL    A0963           ; Calculate text memory address from coordinates in HL
        LD      (POSADR),HL     ; Remember pointer to current position in text memory
        CALL    A0977           ; Calculate graphic memory address from cursor coordinates
        LD      (BITADR),HL     ; Remember text cursor position in Graphic screen
        RET
;
;
;   Calculate text cursor position in pseudo image memory from current cursor coordinate
;
PONTC:  LD      HL,(CURXY)      ; Get current cursor coordinates
;
;
;   Convert text cursor position in pseudo image memory from coordinates in HL
;
A0963:  PUSH    DE              ;!  Register - save values
        PUSH    AF              ;!
        LD      D,TEXTBF/256    ; High - byte starting address of text memory
        LD      E,L             ; Specify X coordinate as low byte
        LD      A,H             ; Y - get coordinate
        ADD     A,A             ;!  times 2
        ADD     A,A             ;!       4
        ADD     A,H             ;!       5
        LD      L,A             ; Y - Remember the coordinate times five
        LD      H,0             ; High - byte to zero
        ADD     HL,HL           ;!  times 10
        ADD     HL,HL           ;!      20
        ADD     HL,HL           ;!      40
A0972:  NOP                     ; or ADD HL,HL for times 80 (80 characters/line)
        ADD     HL,DE           ; Add start address and X - offset
        POP     AF              ;!  saved registers - get values
        POP     DE              ;!
        RET
;
;
;   Graphic - Calculate memory address from current cursor coordinate
;
A0977:  LD      HL,(CURXY)      ; Get current cursor coordinates
;
;
;   Graphic - Calculate memory address from coordinates in HL
;
A097A:  PUSH    DE              ;!Register - save values
        PUSH    AF              ;!
        LD      D,H             ; Y - coordinate
        LD      E,0             ; in DE is now Y - coordinate times 256
        LD      A,L             ; Note X coordinate
        LD      L,H             ; Y - coordinate
        LD      H,E             ; High - byte to zero
        ADD     HL,HL           ;! Y - coordinate times 2
        ADD     HL,HL           ;!                times 4
        ADD     HL,HL           ;!                times 8
        ADD     HL,HL           ;!                times 16
        ADD     HL,HL           ;!                times 32
        ADD     HL,HL           ;!                times 64
        ADD     HL,DE           ;!                times 320
A0989:  NOP                     ; or ADD HL,HL if in 640 x 200 mode
        CALL    ADDHLA          ; Add the value in the Accu to the HL register
        SET     7,H             ; the graphic - image memory starts at 08000H
        POP     AF              ;! saved registers - retrieve values
        POP     DE              ;!
        RET
;
;
;   Set the cursor to the upper left corner of the scroll area
;   (control character 'Cursor HOME')
;
A0992:  LD      L,0             ; X - coordinate at zero (left edge)
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        LD      H,A             ; and specify as the Y coordinate
        JP      A09F6           ; Remember coordinates in HL as current cursor coordinates
;
;
;   Print newline on screen if cursor is not at beginning of line
;
;   (SVC code:  2)
;
CR2:    CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      HL,(CURXY)      ; Get current cursor coordinates
        LD      A,L             ; X - Get cursor coordinate
        OR      A               ; equal to zero (left margin) ?
        JR      NZ,CR1          ; no --> output line feed on screen
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      A,(HL)          ; Get cursor line concatenation flag
        OR      A               ; line concatenated ?
        RET     Z               ; no --> cursor is at the beginning of the line
;
;
;   Output newline to screen (SVC code: 1)
;
CR1:    LD      A,CR            ; Specify newline character
        JP      CRT1C           ; Display accu on screen (execution of control characters)
;
;
;   Perform a carriage return (line feed).
;
CTR_M:  XOR     A               ;! Convert 'uppercase flag' to
        LD      (D0DAA + 1),A   ;! Reset text output routine
        LD      HL,(CURXY)      ; Get current cursor coordinates
        PUSH    HL              ; and remember
        INC     H               ; Y - coordinate cursor plus one
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        LD      D,A             ; and remember
A09C0:  LD      A,(HL)          ; Get concatenation flag
        OR      A               ; line concatenated ?
        JR      Z,A09CA         ; no
        INC     HL              ; Pointer to concatenation flags on next line
        INC     E               ; Y - coordinate plus one
        LD      A,D             ; Y - Get maximum coordinate
        CP      E               ; compare with Y - coordinate
        JR      NC,A09C0        ; still OK --> find the beginning of the next line
A09CA:  DEC     E               ; Y - Coordinate of the end of the logical line
        POP     HL              ; old cursors - get coordinates
        LD      H,E             ; specify a new Y coordinate
        JR      A09DE           ; Y - Coordinate at beginning of line and remember
;
;
;   Cursor - control character cursor down
;
CDOWN:  LD      HL,(CURXY)      ; Get current cursor coordinates
        JR      A09E0           ; Y - coordinate plus one
;
;
;   Cursor - control character cursor right
;
CRIGHT: LD      HL,(CURXY)      ; Get current cursor coordinates
        INC     L               ; X - coordinate plus one
        LD      A,(S136A)       ; Get maximum X coordinate
        CP      L               ; compare with current X - coordinate
        JR      NC,A09F6        ; X - coordinate is OK --> remember new coordinates
A09DE:  LD      L,0             ; Specify minimum X coordinate (left edge)
A09E0:  INC     H               ; Y - coordinate plus one
D09E1:  JR      A09EA           ; check if coordinate is in scroll area
;
;
;   Concatenate screen lines and possibly scroll screen
;
        PUSH    HL              ; save new coordinates
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      (HL),1          ; concatenate row
        POP     HL              ; get saved new coordinates
A09EA:  LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        CP      H               ; compare with new Y - coordinate
        JR      NC,A09F6        ; Y - coordinate is OK --> remember coordinates
        LD      H,A             ; Specify the maximum Y coordinate as the new Y coordinate
        PUSH    HL              ; remember new cursor coordinates
        CALL    A0848           ; scroll screen
        POP     HL              ; new cursor - get coordinates
A09F6:  JP      CURMOV          ; Set cursor to current coordinates in HL
;
;
;   Cursor - Cursor up control character
;
CUP:    LD      HL,(CURXY)      ; Get current cursor coordinates
        JR      A0A09           ; Y - coordinate minus one
;
;
;   Cursor - control character cursor left
;
CLEFT:  LD      HL,(CURXY)      ; Get current cursor coordinates
        LD      A,L             ; Get X coordinate
        OR      A               ; equal to zero (left margin) ?
        JR      NZ,A0A14        ; no --> X - coordinate minus one
        LD      A,(S136A)       ; Get maximum X coordinate
        LD      L,A             ; and specify as the X coordinate
A0A09:  LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        CP      H               ; compare with current Y - coordinate
        JR      C,A0A16         ; still OK --> Y - coordinate minus one
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        LD      H,A             ; and specify as the new Y coordinate
        DEFB    LD_A            ; LD A,n (Z-80 command) --> DEC L is skipped
A0A14:  DEC     L               ; X - coordinate minus one
        DEFB    LD_A            ; LD A,n (Z-80 command) --> DEC H is skipped
A0A16:  DEC     H               ; Y - coordinate minus one
        JR      A09F6           ; Remember coordinates in HL as current cursor coordinates
;
;
;   Switch keyboard to alpha mode
;
CTR_F:  XOR     A               ; Flag for 'Alpha mode'
        DEFB    LD_HL
;
;
;   Switch keyboard to lowercase mode
;
CTR_E:  LD      A,1             ; Flag for 'Lowercase mode'
        DEFB    LD_HL
;
;
;   Switch keyboard to graphics mode
;
CTR_W:  LD      A,2             ; Flag for 'Graphics mode'
        LD      (CURMAK),A      ; Current keyboard mode (0=Alpha / 1=Lowercase / 2=Graphics)
        RET
;
;
;   Move cursor to next tabulator position (TAB key)
;
C_TAB:  LD      B,0             ; counter to zero
        LD      HL,(CURXY)      ; Get current cursor coordinates
        INC     L               ; X - coordinate plus one
        LD      A,L             ; Get X coordinate
A0A2B:  INC     B               ; counter plus one
        SUB     10              ; subtract 10 (10s TAB)
        JR      NC,A0A2B        ; still OK --> continue to pull off
        XOR     A               ; Accu to zero
A0A31:  ADD     A,10            ;! Calculate next tab position
        DJNZ    A0A31           ;!
        LD      L,A             ; remember the new X coordinate
        LD      A,(S136A)       ; Get maximum X coordinate
        CP      L               ; compare with new X - coordinate
        RET     C               ; new X coordinate is greater than maximum --> forgotten
        PUSH    HL              ; remember new cursor coordinates
        LD      A,(INPFLG)      ; Get parallel output flag printer
        OR      A               ; Parallel output set?
        JR      Z,A0A54         ; no --> place cursor on coordinates
        LD      A,(CURX)        ; Get current X - coordinate cursor
        LD      H,A             ; Note the current X coordinate
        LD      A,L             ; Get new X coordinate
        SUB     H               ; Calculate coordinate difference
        JR      Z,A0A54         ; new coordinate equals old coordinate
        LD      B,A             ; Note the difference in coordinates as a counter
A0A4B:  PUSH    BC              ; Save coordinate difference
        LD      A,' '           ; Specify spaces
        CALL    A0EBF           ; Output characters in Accu to printer
        POP     BC              ; Get saved remaining number of spaces
        DJNZ    A0A4B           ; print more spaces
A0A54:  POP     HL              ; Get new cursor coordinate
        JP      CURMOV          ; Set cursor to current coordinates in HL
;
;
;   Move cursor to next tabulator position (emit spaces)
;
PRNTT:  CALL    CRT1S           ; print a space on the screen
        LD      A,(CURX)        ; Get current X - coordinate cursor
A0A5E:  SUB     10              ; subtract 10 (10s TAB)
        JR      NC,A0A5E        ; still OK --> continue to pull off
        ADD     A,10            ; add 10 again
        RET     Z               ; stands on 10s - TAB
        JR      PRNTT           ; Emit spaces and test again
;
;
;   Get line from keyboard and set pointer to actual input
;
A0A67:  PUSH    HL              ; Register - save value
        LD      HL,(CURXY)      ; Get current cursor coordinates
        PUSH    HL              ; and save
        PUSH    DE              ; Pointer to input - save memory
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        POP     DE              ; Pointer to start of input - fetch memory
        LD      (HL),0          ; Set current cursor line as start line
        POP     HL              ; saved cursors - get coordinates
        CALL    GETL            ; Get line from keyboard to memory (DE).
        JR      C,A0A82         ; Break pressed --> no input
        LD      A,L             ; Get old X coordinate cursor
        OR      A               ; equals zero  ?
        JR      Z,A0A82         ; yes --> pointer is on input
        LD      H,0             ; High - byte offset to zero
        ADD     HL,DE           ; Compute pointer to input
        EX      DE,HL           ; Pointer to DE
        OR      A               ; reset carry flag (code 'no error')
A0A82:  POP     HL              ; rescued register - fetch value
        RET
;
;
;   Get line from keyboard to memory (DE) (SVC code: 12)
;
GETL:   PUSH    BC              ;!Register - save values
        PUSH    HL              ;!
        PUSH    DE              ; Pointer to input - save memory
A0A87:  CALL    A0B21           ; fetch a character from keyboard with cursor blinking
        CP      CR              ; Entry complete ?
        JP      Z,A0ABB         ; yes --> provide current text screen line
        CP      ESC             ; BREAK ?
        JR      Z,A0AB4         ; yes --> cancel input
        PUSH    AF              ; remember entered character
        LD      A,(CURMAK)      ; Current keyboard mode (0=Alpha / 1=Small / 2=Graphic)
        CP      2               ; Graphic mode ?
        JR      NZ,A0AAF        ; no --> check for control characters
        POP     AF              ; get entered character
        CP      C_CLR + 1       ; end of cursor control character ?
        JR      NC,A0AB0        ; no cursor control key
        CP      C_DOWN          ; start cursor control character ?
        JR      C,A0AB0         ; no cursor control key
        LD      HL,(S0D30 + 1)  ; Get row value of keyboard column 9
        BIT     6,L             ; CTRL key pressed?
        JR      Z,A0AB0         ; no --> output characters in the Accu
        RST     _DOCMD          ; Software - Execute command
        DEFB    4               ; Output Code 4 Accu on screen (display control characters)
        JR      A0A87           ; Query and edit next key
;
A0AAF:  POP     AF              ; get entered key
A0AB0:  RST     _DOCMD          ; Software - Execute command
        DEFB    3               ; Display Code 3 Accu on screen (execution of control characters)
        JR      A0A87           ; Query and edit next key
;
;
;   Keyboard input aborted with BREAK
;
A0AB4:  SCF                     ; Code 'Input aborted with BREAK'
A0AB5:  RST     _DOCMD          ; Software - Execute command
        DEFB    1               ; Code 1 Output line feed to screen
        POP     DE              ; Get pointer to memory with entered text
        POP     HL              ;! saved registers - get values
        POP     BC              ;!
        RET
;
;
;   Current text - screen line after input - fetch memory
;
A0ABB:  LD      HL,(CURXY)      ; Get current cursor coordinates
        CALL    A05F9           ; Y coordinate start current line/next line.
        LD      A,E             ;! Calculate the number of connected screen lines
        SUB     D               ;!
        LD      E,A             ; Remember number of concatenated lines
        LD      H,D             ; Starting line number as Y - coordinate
        LD      L,0             ; X - coordinate at zero (left edge)
        CALL    A0963           ; Calculate text memory address from coordinates in HL
        LD      A,(W136B)       ; Get counter '40/80 characters per line'
        LD      D,A             ; Note the number of characters per line
        POP     BC              ; Get pointer to memory for row
        PUSH    BC              ; and remember again
        EXX
        PUSH    HL              ; Register - save value
        LD      HL,(S1364)      ; Length input - fetch memory
        EXX
A0AD6:  LD      A,(HL)          ; get a character from text-image memory
        INC     HL              ; Skip characters in text image memory
        LD      (BC),A          ; ASCII - remember characters in memory by line
        INC     BC              ; Pointer to next location in memory
        EXX
        DEC     L               ; Remaining number of characters in input memory minus one
        JR      Z,A0AEA         ; Input - memory full
        EXX
        DEC     D               ; Remaining number of characters in line minus one
        JR      NZ,A0AD6        ; Get more characters from line
        LD      A,(W136B)       ; Get counter '40/80 characters per line'
        LD      D,A             ; Note the number of characters in a line
        DEC     E               ; Remaining number of rows minus one
        JR      NZ,A0AD6        ; provide more lines of text-image memory
        EXX
A0AEA:  POP     HL              ; rescued register - fetch value
        EXX
        XOR     A               ; Code 'End of line' (NUL)
        LD      (BC),A          ; Enter behind provided text
        LD      L,C             ;! Pointer to end of provided text in
        LD      H,B             ;! Input - transfer memory to HL
        POP     DE              ; Pointer to start of input - fetch memory
        PUSH    DE              ; and remember again
        PUSH    HL              ; Pointer to end of text in input - remember memory
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; Calculate number of characters in input memory
        LD      B,L             ; Number of characters after B
        POP     HL              ; Get pointer to end of text in memory
        LD      A,' '           ; Specify spaces
        LD      D,A             ; also spaces
        JP      Z,A0AB5         ; Zero length --> print CR and get saved registers
        DEC     HL              ; Pointer to input - store to previous character
A0AFF:  LD      A,(HL)          ; get a character from input - memory
        OR      A               ; equals zero  ?
        JR      Z,A0B08         ; yes --> examine whether additional characters
        CP      D               ; character equals space ?
        JR      NZ,A0B0D        ; no --> replace NUL in the rest of the text with a space
        LD      (HL),NUL        ; Replace space at end of text
A0B08:  DEC     HL              ; Pointer to text in memory to previous character
        DJNZ    A0AFF           ; exchange more characters
        JR      A0B16           ; Reset carry flag and get saved registers
;
A0B0D:  LD      A,(HL)          ; fetch a character from memory
        OR      A               ; equal to NUL ?
        JR      NZ,A0B13        ; no
        LD      (HL),' '        ; Exchange NUL for Space
A0B13:  DEC     HL              ; Pointer to memory on previous character
        DJNZ    A0B0D           ; exchange more characters
A0B16:  OR      A               ; reset carry flag (code 'no BREAK')
        JP      A0AB5           ; Output CR and retrieve saved register values
;
;
;   Keyboard query for status in Accu
;   (-1 --> keyboard query with debouncing)
;   ( 0 --> Query whether a key is pressed)
;   ( 1 --> get a character from keyboard with blinking cursor)
;
;   Software - Kommando  13)
;
INKEY:  INC     A               ; State equal to -1 ?
        JR      Z,A0B8B         ; yes --> keyboard query with debouncing
        DEC     A               ; Status equal to zero?
        JP      Z,INKEY0        ; yes --> Query whether key is pressed
;
;
;   Fetch a character from keyboard with cursor blinking
;
A0B21:  CALL    A0BAB           ; check whether there are still characters from the function key
        CALL    PUSHR           ; Save registers IX, HL, BC and DE
        CALL    A092B           ; Initiate keyboard and display cursor characters on screen
        EX      AF,AF           ;! Save value of register AF'
        PUSH    AF              ;!
        CALL    A0BC1           ; determine if keyboard status has changed
        LD      A,(S0D44)       ; Get counter for repeat
A0B32:  EX      AF,AF           ; Remember counter
A0B33:  LD      B,16            ; Wait time counter
A0B35:  CALL    A0945           ; Change cursor character for blinking
        CALL    A0BC1           ; determine if keyboard status has changed
        BIT     1,A             ; Button bruised?
        JR      NZ,A0B33        ; yes --> forgot and keep asking
        DJNZ    A0B35           ; keep waiting and asking
        BIT     0,A             ; button pressed at all?
        JR      Z,A0B51         ; yes --> query key
        BIT     2,A             ; Keyboard status changed?
        JR      NZ,A0B62        ; yes --> query key
        EX      AF,AF           ; Remainder Repeat - Get counter
        DEC     A               ; Counter minus one
        JR      NZ,A0B32        ; keep waiting
        LD      A,6             ; Default for repeat speed
        JR      A0B64           ; Memorize counter and query keyboard
;
A0B51:  PUSH    HL              ;! Register - save values
        PUSH    DE              ;!
        PUSH    BC              ;!
        LD      HL,S0D3A        ; Pointer to values ??of last row status
        LD      DE,S0D30        ; Pointers to values ??of current row states
        LD      BC,10           ; 10 columns to query
        LDIR                    ; save current row value
        POP     BC              ;! saved registers - retrieve values
        POP     DE              ;!
        POP     HL              ;!
A0B62:  LD      A,64            ; Default for delay before repeat
A0B64:  LD      (S0D44),A       ; note in the repeat counter
A0B67:  CALL    A0945           ; Change cursor character for blinking
        CALL    A0BF6           ; Query keyboard for pressed key
        OR      A               ; key pressed ?
        JR      Z,A0B7B         ; no --> forget all line statuses and query again
        LD      (S1365),A       ; Remember last key pressed
        LD      C,A             ; remember pressed key
        CALL    A093B           ; Enter original character at cursor position
        POP     AF              ;! retrieve saved AF' register value again
        EX      AF,AF           ;!
        LD      A,C             ; get pressed key
        RET
;
;
;   Forget all pressed keys and query keyboard again (with cursor blinking)
;
A0B7B:  PUSH    HL              ;!Register - save value
        PUSH    BC              ;!
        LD      B,10            ; 10 keyboard columns
        LD      HL,S0D30        ; Pointers to values of current row states
A0B82:  LD      (HL),11111111B  ;!  Clear current line status of all keys
        INC     HL              ;!
        DJNZ    A0B82           ;!
        POP     BC              ;!  saved registers - get values
        POP     HL              ;!
        JR      A0B67           ; Prompt keyboard again
;
;
;   Keyboard query with debouncing (without repeat)
;
A0B8B:  CALL    A0BAB           ; check whether there are still characters from the function key
        PUSH    HL              ; Register - save value
        CALL    A0BF6           ; Query keyboard for pressed key
        LD      HL,S1365        ; Pointer to value of last key pressed
        OR      A               ; key pressed ?
        JR      Z,A0B9E         ; no --> delete last key pressed
        CP      (HL)            ; same as the last key pressed?
        JR      NZ,A0B9E        ; no --> remember new key
        POP     HL              ; rescued register - fetch value
        XOR     A               ; Specify code 'no key pressed'
        RET
;
A0B9E:  LD      (HL),A          ; remember new key as last key pressed
        POP     HL              ; rescued register - fetch value
        RET
;
;
;   Query whether key is pressed; if so --> code of the pressed key in the Accu
;
INKEY0: CALL    A0BAB           ; check whether there are still characters from the function key
        CALL    A0BF6           ; Query keyboard for pressed key
        LD      (S1365),A       ; Remember key as last key pressed
        RET
;
;
;   If text of a function key is still available -->
;   Get characters and forget a CALL level
;
A0BAB:  PUSH    HL              ; Register - save value
        LD      HL,(S1352)      ; L = number of characters fetched H = length of text
        LD      A,L             ;! both counters the same?
        CP      H               ;!
        POP     HL              ; saved register - retrieve value again
        RET     Z               ; no more function key text available
        EX      (SP),HL         ; Save HL register again / discard return address
        INC     A               ; Counter 'number of characters fetched' plus one
        LD      (S1352),A       ; remember new counter
        LD      HL,S1353        ; Pointer to start of memory with function key text
        CALL    ADDHLA          ; Add the value in the Accu to the HL register
        LD      A,(HL)          ; get a character keytext
        POP     HL              ; rescued register - fetch value
        RET
;
;
;   Query whether keyboard status has changed
;
A0BC1:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      DE,S0D3A        ; Pointer to values ??of last row status
        LD      HL,S0D30        ; Pointers to values ??of current row states
        LD      BC,256 * 10 + 0 ; 10 = number of columns 0 = default for flags
        DI                      ; Disable interrupts
A0BCE:  LD      A,B             ; 'Remaining number of columns' counter
        ADD     A,0EFH          ; convert to column value for port A / 8255
        OUT     (KEYP_A),A      ; Output column number to port A / 8255
        CP      0F8H            ; Column with SHIFT/CTRL/BREAK ?
        IN      A,(KEYP_B)      ; Get line value from keyboard
        JR      NZ,A0BDB        ; normal column
        OR      01111111B       ; Forgotten keys except for BREAK
A0BDB:  CP      11111111B       ; key pressed ?
        JR      Z,A0BE1         ; no
        SET     0,C             ; Remember code 'key pressed'
A0BE1:  EX      DE,HL           ; Pointer to last value after HL
        CP      (HL)            ; to compare
        LD      (HL),A          ; remember new status
        EX      DE,HL           ; Pointer to current value after HL
        JR      Z,A0BE9         ; same status --> key not bounced
        SET     1,C             ; Set code 'key bruised'
A0BE9:  CPL                     ;! Key also pressed?
        AND     (HL)            ;!
        JR      Z,A0BEF         ; no
        SET     2,C             ; Set code 'keyboard state changed'
A0BEF:  INC     HL              ; Pointer to current column values ??plus one
        INC     DE              ; Pointer to last column values ??plus one
        DJNZ    A0BCE           ; query further columns
        LD      A,C             ; get status flag
A0BF4:  EI                      ; Enable interrupt
        RET
;
;
;   Query keyboard, return in Accu ASCII code
;   of the pressed key or 000H if no key is pressed
;
A0BF6:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      HL,S0D30        ; Pointers to current column state values
        LD      DE,S0D3A        ; Pointer to values ??of last column status
        PUSH    HL              ;! save pointer
        PUSH    DE              ;!
        LD      BC,10           ; Number of keyboard columns
        LDIR                    ; Save current key values
        POP     HL              ;! retrieve saved hands
        POP     DE              ;!
        LD      BC,256*10+0F9H  ; 10 = number of columns 0F9H = specification for column number
        DI                      ; Disable interrupts
        LD      A,C             ; Get column number
        OUT     (KEYP_A),A      ; and output to keyboard
        NOP                     ; waiting
        IN      A,(KEYP_B)      ; Get line value from keyboard
        LD      (DE),A          ; and remember
A0C13:  LD      A,C             ; Get column number
        OUT     (KEYP_A),A      ; and output to keyboard
        CP      0F8H            ; same column with SHIFT/CTRL/BREAK ?
        IN      A,(KEYP_B)      ; Get line value from keyboard
        LD      (DE),A          ; and remember
        JR      Z,A0C3E         ; cancel debouncing with SHIFT/CTRL/BREAK
        CPL                     ;! Mask keyboard change
        AND     (HL)            ;!
A0C1F:  LD      (HL),A          ; and remember
A0C20:  INC     DE              ; Pointer to current values ??plus one
        INC     HL              ; Pointer to changes plus one
        DEC     C               ; Column number minus one
        DJNZ    A0C13           ; query other columns
        EI                      ; Enable interrupt
        LD      BC,256 * 10 + 0 ; 10 = number of columns 0 = counter
A0C29:  DEC     HL              ; Pointer to change value
        LD      A,(HL)          ; fetch value
        OR      A               ; The change  ?
        JR      NZ,A0C68        ; yes --> button lock
        INC     C               ; counter plus one
        DJNZ    A0C29           ; Query other columns for key changes
        LD      B,10            ; 10 columns
A0C33:  DEC     DE              ; Pointer to row values
        LD      A,(DE)          ; get a row value
        CP      11111111B       ; key pressed ?
        JR      NZ,A0C41        ; yes --> determine which key
A0C39:  DJNZ    A0C33           ; test other column values
A0C3B:  XOR     A               ; Set code 'no key pressed'
        JR      A0BF4           ; Enable interrupt
;
A0C3E:  XOR     A               ; Cancel debouncing (column 9)
        JR      A0C1F           ; Return to routine
;
A0C41:  LD      A,B             ; get counter
        CP      2               ; Column with SHIFT/CRTL/BREAK ?
        JR      NZ,A0C4F        ; no
        LD      A,(DE)          ; get row value
        AND     10000001B       ; Mask SHIFT and BREAK
        JR      NZ,A0C39        ; not SHFIT BREAK --> investigate further
        LD      A,ESC           ; Code 'BREAK'
        JR      A0BF4           ; Enable interrupt
;
A0C4F:  CP      1               ; Column 1 (function keys) ?
        JR      Z,A0C3B         ; yes --> code 'no key pressed' (F-keys not repeat)
        LD      A,(S0D45)       ; Get column number changed value
        CP      B               ; Column numbers the same?
        JR      NZ,A0C39        ; no --> investigate further
        LD      A,(DE)          ; get row value
        PUSH    DE              ; Remember pointer
        LD      D,A             ; Remember row value
        LD      A,(B0D46)       ; Get mask for changed value
        AND     D               ; Mask row value
        POP     DE              ; get rescued pointer
        JR      NZ,A0C39        ; Button just released --> investigate further
        LD      A,(S1365)       ; Get last key pressed
        JR      A0BF4           ; Enable interrupt
;
A0C68:  PUSH    AF              ; Register - save value
        LD      A,B             ; Get column number
        LD      (S0D45),A       ; note changed value as column number
        LD      A,(HL)          ; Get mask for changed value
        LD      (B0D46),A       ; remember as mask for changed value
        POP     AF              ; rescued register - fetch value
        DEC     B               ; Counter minus one
        JR      NZ,A0CAB        ; normal row of keys --> evaluate
;
;
;   Function key pressed
;
        CALL    A0D18           ; Convert the bit set in the Accu to a bit number
        LD      A,(S0D30 + 1)   ; Get row value of keyboard column 9
        BIT     6,A             ; CTRL key pressed?
        JR      Z,A0C3B         ; yes --> specify code 'no key pressed'
        BIT     0,A             ; SHIFT key pressed?
        LD      A,B             ; Get key number
        JR      NZ,A0C86        ; SHIFT key not pressed
        ADD     A,5             ; SHIFT - function keys are from 5 - 9
A0C86:  CP      10              ; function key ?
        JR      NC,A0C3B        ; no --> specify code 'no key pressed'
        LD      L,A             ; button number
        LD      H,0             ; High - byte value to zero
        ADD     HL,HL           ;! Key number times 2 (16 characters per function key)
        ADD     HL,HL           ;!              times 4
        ADD     HL,HL           ;!              times 8
        ADD     HL,HL           ;!              times 16
        LD      BC,B12B2        ; Pointer to start of function key texts
        ADD     HL,BC           ; Calculate pointer to correct function key text
        LD      A,(HL)          ; Get length of function key text
        OR      A               ; zero length?
        JR      Z,A0C3B         ; yes --> specify code 'no key pressed'
        LD      DE,S1352        ; Pointer to memory for current key text
        LD      A,1             ; Code 'first character fetched'
        LD      (DE),A          ; enter
        INC     DE              ; Fix pointer for text
        LD      BC,16           ; maximum length key text
        LDIR                    ; Transfer function key text to clipboard
        LD      A,(S1354)       ; get first text character
        JP      A0BF4           ; Enable interrupt
;
;
;   Provide ASCII code of pressed key from line number and column value
;
A0CAB:  CALL    A0D18           ; Convert the bit set in the Accu to a bit number
        LD      A,C             ; Get column number
        ADD     A,A             ;! Column number times 2 (8 keys per column)
        ADD     A,A             ;!               times 4
        ADD     A,A             ;!               times 8
        ADD     A,B             ; Add line number
        LD      L,A             ; Note the offset on the keyboard matrix (key number).
        LD      H,0             ; Set high - byte offset to zero
        LD      A,(S0D30 + 1)   ; Get row value of keyboard column 9
        BIT     6,A             ; CTRL key pressed?
        LD      BC,W0D47        ; Set pointer to table for normal mode
        JR      Z,A0CEF         ; CTRL plus other key
        PUSH    AF              ; Save row value column 9
        LD      A,(CURMAK)      ; Current keyboard mode (0=Alpha / 1=Small / 2=Graphic)
        CP      1               ; lowercase cursor ?
        JR      NZ,A0CCC        ; no
        POP     AF              ; Get row value of column 9
        XOR     00000001B       ; Invert the state of the SHIFT key
        PUSH    AF              ; and remember again
A0CCC:  POP     AF              ; Get row value of column 9
        BIT     0,A             ; SHIFT key pressed?
        JR      NZ,A0CD4        ; no
        LD      BC,W0D59        ; Pointer to keyboard table for SHIFT mode
A0CD4:  LD      A,(CURMAK)      ; Current keyboard mode (0=Alpha / 1=Small / 2=Graphic)
        CP      2               ; Graphic mode ?
        JR      NZ,A0CE8        ; no
        LD      BC,W0D6B        ; Specify keyboard table for SHIFT graphic mode
        LD      A,(S0D30 + 1)   ; Get row value of keyboard column 9
        BIT     0,A             ; SHIFT key pressed?
        JR      Z,A0CE8         ; Yes
        LD      BC,W0D7D        ; Pointer to keyboard table for graphic mode
A0CE8:  CALL    A3C3E           ; Provide key code by key number and table
        LD      A,C             ; Get code of pressed key
        JP      A0BF4           ; Enable interrupt
;
;
;   Decode pressed CTRL key
;
A0CEF:  CALL    A3C3E           ; Get key code by key number
        LD      A,C             ; Get code of pressed key
        CP      ' '             ; control character ?
        JP      C,A0BF4         ; yes --> enable interrupt
        LD      HL,M0D8F        ; Pointer to table with additional CTRL characters
        LD      B,5             ; 5 characters in table
A0CFD:  CP      (HL)            ; compare a character
        JR      Z,A0D12         ; sign is allowed
        INC     HL              ; Pointer to table to next character
        DJNZ    A0CFD           ; further compare values
        CP      '@'
        JP      C,A0C3B         ; less than letter --> no key pressed
        CP      'Z' + 1
        JP      NC,A0C3B        ; greater than letter --> no key pressed
        SUB     '@'             ; Convert letters to CTRL - value
        JP      A0BF4           ; Enable interrupt
;
A0D12:  LD      A,' '           ;! CTRL - Calculate key code
        SUB     B               ;!
        JP      A0BF4           ; Enable interrupt
;
;
;   Convert the bit set in the Accu to a bit number
;
A0D18:  LD      B,8             ; default for value
A0D1A:  RRCA                    ; shift one bit after carry
        JR      C,A0D20         ; set bit found
        DJNZ    A0D1A           ; keep pushing
        RET
;
A0D20:  DEC     B               ; correct value
        RET
;
;
;   Query whether SHIFT - BREAK is pressed
;   if so --> zero flag set on return.
;   If only BREAK is pressed, the program will be stopped until this button is released.
;
BRKEY:  LD      A,0E8H          ; Number of the column with SHIFT/CTRL/BREAK
        OUT     (KEYP_A),A      ; Output column number to keyboard
        NOP                     ; waiting
        IN      A,(KEYP_B)      ; Get line value from keyboard
        AND     10000001B       ; Mask SHIFT and BREAK
        RET     Z               ; both buttons pressed
        RLCA                    ; BREAK - slide key to carry
        RET     C               ; BREAK not pressed
        JR      BRKEY           ; wait until the button is released
;
;
;   Storage area for keyboard query routine
;
S0D30:  DEFS    10              ; Values of current row status
;
S0D3A:  DEFS    10              ; Values of last row status
;
S0D44:  DEFS    1               ; Counter for repeat
;
S0D45:  DEFS    1               ; Column number changed value
;
B0D46:  DEFB    1               ; Mask for changed value
;
;
;   Keyboard decode table for Normal mode
;
W0D47:  DEFW    KTBL                    ; Pointer to table in ROM monitor 1Z-013B
;
        DEFB    090H,017H,0FCH,019H     ; Column 1 buttons
        DEFB    009H,03BH,03AH,00DH
;
        DEFB    018H,010H,012H,011H     ; Column 8 buttons
        DEFB    013H,014H,03FH,02FH
;
;
;   Keyboard decode table for SHIFT mode
;
W0D59:  DEFW    KTBLS                   ; Pointer to table in ROM monitor 1Z-013 B
;
        DEFB    090H,017H,0FBH,005H     ; Column 1 buttons
        DEFB    009H,02BH,02AH,00DH
;
        DEFB    016H,015H,012H,011H     ; Column 8 buttons
        DEFB    013H,014H,0C6H,05FH
;
;
;   Keyboard decode table for SHIFT - Graphic - mode
;
W0D6B:  DEFW    KTBLG                   ; Pointer to table in ROM monitor 1Z-013 B
;
        DEFB    090H,017H,068H,005H     ; Column 1 buttons
        DEFB    009H,084H,0E9H,00DH
;
        DEFB    016H,015H,012H,011H     ; Column 8 buttons
        DEFB    013H,014H,08FH,08BH
;
;
;   Keyboard decode table for graphics mode
;
W0D7D:  DEFW    KTBLSG                  ; Pointer to table in ROM monitor 1Z-013 B
;
        DEFB    090H,017H,06CH,019H     ; Column 1 buttons
        DEFB    009H,0FEH,089H,00DH
;
        DEFB    016H,015H,012H,011H     ; Column 8 buttons
        DEFB    013H,014H,08AH,07BH
;
;
;   Table for implementing the additionally defined CTRL keys
;
M0D8F:  DEFM    "[\\]^/"
;
;
;   Output text in (DE);
;   Convert uppercase to lowercase according to control characters
;
;   (SVC code:  5)
;
CRTSIMU:
        CALL    PUSHR           ; Save registers IX, HL, BC and DE
A0D97:  LD      A,(DE)          ; Get a character of the text to be output
        INC     DE              ; Pointer to text on next character
        OR      A               ; Text character equal to NUL (end of text) ?
        RET     Z               ; yes --> done
        LD      C,A             ; note the character to be output
        CP      _SML            ; Code 'switch to lowercase' ?
        JR      Z,A0DBE         ; yes --> Switch to lower case
        CP      _CAP            ; Code 'switch to uppercase' ?
        JR      Z,A0DBD         ; yes --> Switch to capital letters
        SUB     'A'             ;!  Character to be output same as capital letter ?
        CP      26              ;!
        JR      NC,A0DB6        ; no --> output characters
D0DAA:  LD      A,0             ; Get flag 'convert uppercase'
        OR      A               ; set  ?
        JR      Z,A0DB6         ; no --> output characters
        LD      HL,B0DC3 + -65  ; Pointer to lowercase table
        LD      B,0             ; High - byte offset to zero
        ADD     HL,BC           ; Calculate pointer to table character
        LD      C,(HL)          ; Get lower case letters from table
A0DB6:  LD      A,C             ; get the character to be output
        RST     _DOCMD          ; Software - Execute command
        DEFB    3               ; Display Code 3 Accu on screen (execution of control characters)
        CP      CR              ; newline character output ?
        JR      NZ,A0D97        ; no --> output more characters
A0DBD:  XOR     A               ; Code 'do not convert uppercase'
A0DBE:  LD      (D0DAA + 1),A   ; Set flag 'convert to upper case'
        JR      A0D97           ; output more characters

;
;
;   Table with lowercase letters in SHARP - Code
;
B0DC3:  DEFB    0A1H            ; a
        DEFB    09AH            ; b
        DEFB    09FH            ; c
        DEFB    09CH            ; d
        DEFB    092H            ; e
        DEFB    0AAH            ; f
        DEFB    097H            ; g
        DEFB    098H            ; h
        DEFB    0A6H            ; i
        DEFB    0AFH            ; j
        DEFB    0A9H            ; k
        DEFB    0B8H            ; l
        DEFB    0B3H            ; m
        DEFB    0B0H            ; n
        DEFB    0B7H            ; o
        DEFB    09EH            ; p
        DEFB    0A0H            ; q
        DEFB    09DH            ; r
        DEFB    0A4H            ; s
        DEFB    096H            ; t
        DEFB    0A5H            ; u
        DEFB    0ABH            ; v
        DEFB    0A3H            ; w
        DEFB    09BH            ; x
        DEFB    0BDH            ; y
        DEFB    0A2H            ; z
;
;
;   Devices - Table for Display (CRT:)
;
W0DDD:  DEFW    W0DF6           ; Pointer to Next Devices - Table (KB:)
        DEFM    "CRT"           ; Device - name
		DEFB    NUL
        DEFB    10001010B       ; Device - Type - Byte
        DEFB    00000000B       ; Devices - numbers - bytes
        DEFB    0
        DEFW    A453A           ; Initialize device
        DEFW    __RET           ; RET (open to read)
        DEFW    __RET           ; RET (open for writing)
        DEFW    __RET           ; RET (test device readiness)
        DEFW    __RET           ; RET
        DEFW    A0E0F           ; get a row from keyboard
        DEFW    A0E17           ; Display characters in Accu on screen
        DEFW    A0E26           ; Provide current X coordinate
;
;
;   Devices - Table for Keyboard (KB:)
;
W0DF6:  DEFW    W1479           ; Pointer to next devices table (LPT:)
        DEFM    "KB"            ; Device - name
		DEFB    NUL,NUL
        DEFB    10000001B       ; Device - Type - Byte
        DEFB    00000000B       ; Devices - numbers - bytes
        DEFB    0
        DEFW    __RET           ; RET (initialize device)
        DEFW    __RET           ; RET (Open Device to Read)
        DEFW    __RET           ; RET (open device for writing)
        DEFW    __RET           ; RET
        DEFW    __RET           ; RET
        DEFW    A0E0F           ; get a row from keyboard
        DEFW    __RET           ; RET
        DEFW    __RET           ; RET
;
;
;   Get line from keyboard and provide line length
;
A0E0F:  RST     _DOCMD          ; Software - Execute command
        DEFB    12              ; Code 12, line from keyboard to memory (DE).
        LD      A,080H          ; Code for 'BREAK'
        RET     C               ; Entry aborted with BREAK
        RST     _DOCMD          ; Software - Execute command
        DEFB    23              ; Code 23, Count length of text (DE).
        RET
;
;
;   Output characters in Accu
;
A0E17:  EX      AF,AF           ; save character to be printed
        LD      HL,CRT1C        ; Output address Accu on screen (execution of control characters)
        LD      A,(DISPX)       ; Get flag 'execute control characters'
        OR      A               ; Execute control characters ?
        JR      Z,A0E24         ; Yes
        LD      HL,CRT1CX       ; Output address Accu on screen (output of control characters)
A0E24:  EX      AF,AF           ; get the character to be output
        JP      (HL)            ; Output characters in Accu
;
;
;   Provide current X coordinate screen
;
A0E26:  LD      A,(CURX)        ; Get current X - coordinate cursor
        RET
;
;
;   Output line feed to screen or printer
;
;   (SVC code:  8)
;
PR_CR:  LD      A,CR            ; Code for 'Line feed'
;
;
;   Output characters in the Accu to the screen or printer (execution of control characters)
;
;   (SVC code:  9)
;
PR_1C:  PUSH    AF              ; save character to be printed
        LD      A,(FILOUT)      ; Monitor - Printer - Get status
        OR      A               ; output on screen?
        JR      NZ,A0E36        ; no --> Output characters to printer
        POP     AF              ; get the character to be printed
        JR      CRT1C           ; Display accu on screen (execution of control characters)
;
A0E36:  POP     AF              ; get the character to be output
        JP      LPT1C           ; Output characters in Accu to printer
;
;
;   Output characters in the Accu to the screen or printer (display control characters)
;
;   (SVC code:  10)
;
PR_1CX: PUSH    AF              ; save character to be printed
        LD      A,(FILOUT)      ; Monitor - Printer - Get status
        OR      A               ; output on screen?
        JR      NZ,A0E44        ; no --> Output characters to printer
        POP     AF              ; get the character to be output
        JR      CRT1CX          ; Display accu on screen (display control characters)
;
A0E44:  POP     AF              ; get the character to be output
        JP      A14E0           ; Output Accu to printer (display control characters)
;
;
;   Output text (DE) on screen or printer
;
;   (SVC code:  11)
;
PR_MSG: CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      HL,PR_1C        ; Address 'Output Accu on screen or printer'
        JR      CRTMS2           ; Output text (DE).
;
;
;   Output text (DE) with execution of control characters on screen
;
CRTMSG: CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      HL,CRT1C        ; Display address 'Accu on screen (execution of control characters)
CRTMS2: LD      A,(DE)          ; get a character text
        OR      A               ; equal to NUL (end of text character) ?
        RET     Z               ; yes --> done
        CALL    A00A7           ; JP (HL) (call output routine (HL))
        INC     DE              ; Pointer to text to be output to next character
        JR      CRTMS2           ; output additional characters of text
;
;
;   print a space on the screen
;
CRT1S:  LD      A,' '           ; Specify space character
;
;
;  Display accu on screen (execution of control characters)
;
;   (SVC code:  3)
;
CRT1C:  CALL    PUSHRA          ; Save registers IX, HL, BC, DE and AF
A0E64:  LD      C,A             ; note the character to be output
        LD      A,(INPFLG)      ; Get parallel output flag printer
        OR      A               ; set  ?
        JR      Z,A0E99         ; no --> no parallel output
        LD      A,C             ; get the character to be output
        CP      ' '             ; control character ?
        JR      NC,A0E96        ; no --> output characters
        LD      DE,(CURXY)      ; Get current cursor coordinates
        LD      HL,(S1369)      ; X - Get minimum/maximum coordinate
        CP      C_LEFT          ; 'cursor left' ?
        JR      Z,A0E83         ; yes --> compare to minimal coordinates
        CP      C_UP            ; 'cursor up' ?
        JR      NZ,A0E88        ; no --> execute characters
        LD      HL,(S136F)      ; Y - Get minimum/maximum coordinate
        LD      E,D             ; current Y coordinate to E
A0E83:  LD      A,L             ; Minimal - get coordinate
        CP      E               ; compare with current coordinate
        JP      NC,_BEEP        ; Characters not allowed --> output reference tone
A0E88:  LD      HL,B0ED9        ; Pointer to conversion table for control characters
        LD      B,0             ; High - byte offset to zero (low byte equals character)
        ADD     HL,BC           ; Calculate pointer to character in table
        LD      A,(HL)          ; Get control characters for printer from table
        INC     A               ; Swallow characters for printer?
        JR      Z,A0E99         ; Yes
        DEC     A               ; Characters not allowed on printer ?
        JP      Z,_BEEP         ; yes --> output reference tone
A0E96:  CALL    A0EBF           ; Output characters in Accu to printer
A0E99:  LD      A,C             ; get the character to be output
        CP      ' '             ; control character ?
        JP      C,CTRLJB        ; yes --> Call control character routine
        JP      A05AD           ; Display characters in Accu on screen
;
;
;   Display accu on screen (display control characters)
;
;   (SVC code:  4)
;
CRT1CX: CALL    PUSHRA          ; Save registers IX, HL, BC, DE and AF
        LD      C,A             ; note the character to be output
        CP      CR              ; Carriage return?
        JR      Z,A0E64         ; yes --> perform line feed
        CALL    A05AD           ; Display characters in Accu on screen
        LD      A,(INPFLG)      ; Get parallel output flag printer
        OR      A               ; Parallel output set?
        RET     Z               ; no --> done
        LD      A,C             ; get output character
        CP      C_DOWN          ; start cursor control character ?
        JR      C,A0ED4         ; no --> Output characters as dots on printer
        CP      C_CLR + 1       ; end cursor control character ?
        JR      C,A0ED6         ; Cursor character --> output to printer
        CP      ' '             ; control character ?
        JR      C,A0ED4         ; yes --> output point to printer
A0EBF:  CP      '`'
        JR      C,A0ED6         ; Output correct character to printer
        CP      070H
        JR      C,A0ED4         ; Output point to printer
        CP      0C1H
        JR      C,A0ED6         ; Output correct character to printer
        CALL    CHKACC          ; Compare Accu with bytes specified after CALL
        DEFB    3               ; compare three characters
        DEFB    0D7H            ;!  characters familiar to printers
        DEFB    0CFH            ;!
        DEFB    0FFH            ;!
        JR      Z,A0ED6         ; known character --> output to printer
A0ED4:  LD      A,'.'           ; Dot for unknown character
A0ED6:  JP      LPTOUT          ; Output characters in Accu to printer

;
;
;   Table for converting control characters for output to printer
;
B0ED9:  DEFB    0               ; CTRL @   (characters not allowed)
        DEFB    0               ; CTRL A   (characters not allowed)
        DEFB    0               ; CTRL B   (characters not allowed)
        DEFB    0               ; CTRL C   (characters not allowed)
        DEFB    -1              ; CTRL D   (do not output characters)
        DEFB    -1              ; CTRL E   (do not output characters)
        DEFB    -1              ; CTRL F   (do not output characters)
        DEFB    01DH            ; CTRL G   Code for 'Switch to next character color'
        DEFB    0               ; CTRL H   (characters not allowed)
        DEFB    -1              ; CTRL I   (do not output characters)
        DEFB    0               ; CTRL J   (characters not allowed)
        DEFB    0               ; CTRL K   (characters not allowed)
        DEFB    0               ; CTRL L   (characters not allowed)
        DEFB    CR              ; CTRL M   Code for 'carriage return '
        DEFB    0               ; CTRL N   (characters not allowed)
        DEFB    0               ; CTRL O   (characters not allowed)
        DEFB    0               ; CTRL P   (characters not allowed)
        DEFB    LF              ; CTRL Q   Code for 'newline'
        DEFB    003H            ; CTRL R   Code for 'new line'
        DEFB    ' '             ; CTRL S   Cursor right as space
        DEFB    00EH            ; CTRL T   Code for 'regression'
        DEFB    0               ; CTRL U   (characters not allowed)
        DEFB    0               ; CTRL V   (characters not allowed)
        DEFB    -1              ; CTRL W   (do not output characters)
        DEFB    0               ; CTRL X   (characters not allowed)
        DEFB    -1              ; CTRL Y   (do not output characters)
        DEFB    -1              ; CTRL Z   (do not output characters)
        DEFB    CR              ; CTRL [   Code for 'carriage return'
        DEFB    -1              ; CTRL \   (do not output characters)
        DEFB    0               ; CTRL ]   (characters not allowed)
        DEFB    0               ; CTRL ^   (characters not allowed)
        DEFB    0               ; CTRL /   (characters not allowed)
;
;
;   Bootstart  Monitor / Basic
;
STARTP:  DI                      ; Disable interrupts
        XOR     A               ; Code for '320 x 200 pixels / 4 colors'
        OUT     (CRTCDM),A      ; to 'Display-Mode-Register' of the screen controllerben
        LD      (INPFLG),A      ; Reset printer parallel output flag
        LD      (FILOUT),A      ; Monitor - Printer - Reset status
        LD      SP,0            ; Set stack pointer to RAM - end
        IM      2               ; Specify interrupt mode
        LD      A,00000100B     ; Code for 'Disable Timer - Interrupt'
        OUT     (KEYP_F),A      ; output to control module 8255
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
        OUT     (_E0RAM),A      ; Switch to RAM from 0E000H to 0FFFFH
        CALL    PALOFF          ; Initialize palette registers for basic colors
        LD      A,IV_LPT/256    ; High - Byte Pointer to Interrupt - Vector
        LD      I,A             ; in the interrupt register
        LD      A,IV_LPT%256    ; Low - Byte Pointer to Interrupt - Vector
        OUT     (PIOB_C),A      ; output to Z-80 PIO channel B
        LD      A,00001111B     ; Code for 'Mode 0 - Select'
        OUT     (PIOB_C),A      ; output to Z-80 PIO channel B
        PUSH    BC              ; Load - save code
        CALL    CRTPWR          ; Query whether graphic extension is installed
        CALL    A44B9           ; Muisc - initialize routines
        CALL    A3F58           ; Determine if RAM card is initialized
        POP     BC              ; retrieve the saved loading code
B0F2A:  DEFB    LD_HL           ; Skip autostart skip sequence
        JR      STRTP9          ; Skip autostart sequence
;
;
;   Loading - use current device
;
        XOR     A               ; Accu auf Null  (Code 'NOP')
        LD      (B0F2A),A       ; Routine imstelle, um Kaltstart zu überspringen
        LD      D,A             ;! Uhrzeit auf 00.00.00
        LD      E,A             ;!
        RST     _DOCMD          ; Software - Execute command
        DEFB    38              ; cmd 38 - set time
        LD      DE,W3AD7        ; Pointer to pseudo table 'CMT:'
        LD      A,B             ; Get loading code
        OR      A               ; no loading code given?
        JR      Z,A0F48         ; yes --> save the cassette as the current device
        DEC     A               ; Basic interpreter loaded from cassette?
        JR      Z,A0F48         ; yes --> note the cassette as the current device
        LD      DE,W37C2        ; Pointer to device table for device 'FD:'
        DEC     A               ; Basic interpreter loaded from disk?
        JR      Z,A0F48         ; yes --> remember diskette as current device
        LD      DE,W3ADA        ; Pointer to pseudo table 'QD:'
A0F48:  LD      A,C             ; Devices - get number
        RST     _DOCMD          ; Software - Execute command
        DEFB    58              ; cmd 58-  Remember pointer to device table/number for DEFAULT
STRTP9: JP      COLDST          ; Cold Start Monitor - Basic
;
;
;   Query whether graphic extension is installed
;
CRTPWR: DI                      ; Disable interrupts
        XOR     A               ; Code for 'small graphic - resolution'
        OUT     (CRTCDM),A      ; to the 'Display-Mode-Register' of the graphic controller
        LD      A,00010100B     ; Code for 'Screen B/Level III'
        OUT     (CRTCRF),A      ; to the 'Read format register' of the graphic controller
        LD      A,10010100B     ; Code for 'Replace/Screen B/Level III'
        OUT     (CRTCWF),A      ; to the 'Write Format Register' of the graphic controller
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
        LD      HL,09FFFH       ; Pointer to last byte in graphic memory
        LD      A,(HL)          ; get old value
        LD      C,A             ; and remember
        CPL                     ; Reverse bit pattern
        LD      (HL),A          ; re-enter as the new value in the graphic memory
        CP      (HL)            ; check if value was saved
        LD      (HL),C          ; enter old value again
        LD      A,0             ; Specify code for 'additional graphic not available'
        JR      NZ,A0F6C        ; Additional - Graphic not available
        INC     A               ; Set code for 'additional graphic available'
A0F6C:  LD      (MEMOP),A       ; Update 'additional graphic RAM available' flag (1=yes)
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Release interrupt again
        LD      A,1             ; Code for '320 x 200 pixels / 4 colors'
        CALL    DSMODE          ; Screen - set operating mode
        XOR     A               ; Accu to zero
        LD      (CURFLG),A      ; Clear flag 'original/cursor character' (0=original)
        LD      (CURMAK),A      ; Current keyboard mode (0=Alpha / 1=Small / 2=Graphic)
        RET
;
;
;   Devices - Table for USR Routine
;
W0F7F:  DEFW    0               ; Pointer to next devices table (non-existent)
        DEFM    "USR"           ; Device - name
		DEFB    NUL
        DEFB    10011111B       ; Device - Type - Byte
        DEFB    00000000B       ; Devices - numbers - bytes
        DEFB    0
        DEFW    __RET           ; RET (initialize device)
        DEFW    A0F98           ; Open file on device for reading
        DEFW    A0F98           ; Open file on devices for writing
        DEFW    __RET           ; RET
        DEFW    __RET           ; RET
        DEFW    A0FA7           ; deploy a line of device
        DEFW    A0FA7           ; Output characters in the Accu to the device
        DEFW    __RET           ; RET
;
;
;   Provide start address of USR routine (open device for reading/writing)
;
A0F98:  LD      HL,S1001        ; Pointer to storage for file names in handle
        RST     _DOCMD          ; Software - Execute command
        DEFB    19              ; Code 19 convert ASCII value (HL) into hex value in DE
        LD      A,D             ;!  Start address zero?
        OR      E               ;!
        JP      Z,A1FAF         ; yes --> Error 60 Illegal filename error
        LD      (S1048),DE      ; Note the start address of the USR routine
        RET
;
;
;   Provide data from device 'USR:' or output to device
;
A0FA7:  LD      HL,(S1048)      ; Get start address of USR routine
        JP      (HL)            ; USR - call routine
;
        DEFS    81
;
;
;   Beginning addresses of the interrupt routines for music and printers
;   (addresses must be on an even address)
;
IV_PSG:  DEFW    PSGINT          ; Start address for music interrupt
;
IV_LPT:  DEFW    LPTINT          ; Start address for printer interrupt

;
;   Storage for file identifier (directory entry)
;
S1000:  DEFS    1               ; File type - Identifier
S1001:  DEFS    17              ; File name
S1012:  DEFS    1               ; Write protect - flag
        DEFS    1
S1014:  DEFS    2               ; File length
S1016:  DEFS    2               ; Starting address
S1018:  DEFS    2               ; Start address
        DEFS    4
S101E:  DEFS    2               ; Sector number of first logical sector
;                               ; End of memory for directory entry
S1020:
        DEFS    24
;
INT_JP: DEFS    3               ; Interrupt jump for time interrupt (ROM monitor)
;
S103B:  DEFS    5
;
S1040:  DEFW    2               ; Pointer to current file record
;
;
;   Storage for current file record management
;
S1042:  DEFS    1               ; (internal): current device number
;
S1043:  DEFS    1               ; File access mode
                                ; Bit 0  =  Open for reading
                                ; Bit 1  =  Open for writing
                                ; Bit 2  =  Random R/W access mode
;
ZEQT:   DEFS    2               ; Pointer to current devices - table
;
ZCH:    DEFS    2               ; Current device number
;
S1048:  DEFS    2               ; Start address of the USR routine
;
;
;   Speicher für aktuelle Geräte - Tabelle
;
S104A:  DEFS    2               ; Zeiger auf nächste Geräte - Tabelle
;
        DEFS    4               ; Geräte - Name
;
S1050:  DEFB    1               ; Geräte - Typ - Byte
                                ; Bit 2  =  Gerät stellt einzelne Zeichen zur Verfügung
                                ; Bit 3  =  Zeichenorientierte Ausgabe (nicht Zeilenorientiert)
                                ; Bit 4  =  auf Dateinamen untersuchen
                                ; Bit 5  =  SWAP möglich   (Gerät gleich Diskette)
                                ; Bit 6  =  mehrere Dateinamen auf Gerät zulässig
                                ; Bit 7  =  nicht im Block - Modus
;
ZFLAG2:  DEFS    1              ; Geräte - Nummern - Byte
                                ; Bit 0-3  =  Geräte - Nummer maximal
                                ; Bit 4    =  End - of - File nicht erlaubt
                                ; Bit 5    =  nur eine Datei zum Schreiben eröffnen
                                ; Bit 6    =  nur eine Datei auf Gerät erlaubt
                                ; Bit 7    =  Dateiname muß nicht angegeben sein
;
S1052:  DEFS    1               ; maximale Anzahl Dateien auf Gerät / Datenträger
;
S1053:  DEFS    2               ; Anfangsadresse  'Gerät initialisieren'
;
S1055:  DEFS    2               ; Anfangsadresse  'für Lesen eröffnen'
                                ; Sektornummer für Sektorverzeichnis
;
S1057:  DEFS    2               ; Anfangsadresse  'für Schreiben eröffnen'
                                ; Physikalische Sektorlänge
;
S1059:  DEFS    2               ; Anfangsadresse  'Datei schliessen'
                                ; Anzahl reservierter Sektoren
;
S105B:  DEFS    2               ; Anfangsadresse  'Dateidaten im Rechner löschen'
                                ; maximale Anzahl Zeichen im Sektor
;
S105D:  DEFS    2               ; Anfangsadresse  'Daten bereitstellen'
;
S105F:  DEFS    2               ; Anfangsadresse  'Daten ausgeben'
;
S1061:  DEFS    2               ; Anfangsadresse  'aktuelle Spaltennummer bereitstellen'
                                ; Anfangsadresse  'Datei löschen'
;
S1063:  DEFS    2               ; Anfangsadresse  'Datei umbenennen'
;
S1065:  DEFS    2               ; Anfangsadresse  'freie Kilobyte bereitstellen'
;
        DEFS    2
;
;
;   Memory for default device data
;
DCHAN:  DEFS    1               ; Default device number 
;
DDEV:   DEFS    2               ; Pointer to default device table 
;
;
;
__CRT:  DEFW    W0DDD           ; Zeiger auf Geräte-Tabelle Bildschirm  (erstes Gerät in Kette)
;
__LPT:  DEFW    W1479           ; Zeiger auf Geräte-Tabelle Drucker
;
;
;   Work area pointers
;
TEXTST: DEFS    2               ; Basic - beginning of program ("Text start")
;
POOL:   DEFS    2               ; File work areas (I/O work area)
;
VARST:  DEFS    2               ; Start of Basic variables area
;
STRST:  DEFS    2               ; Start of string text area
;
VARED:  DEFS    2               ; Var & string end
;
TMPEND: DEFS    2               ; End of string work area
;
INTFAC: DEFS    2               ; Start of arithmetic memory (FAC)
;
MEMLMT: DEFS    2               ; LIMIT - address
;
MEMMAX: DEFW    0FF00H          ; Maximum allowed RAM address  (last available memory)


;
;
;   Memory area for cursor management 
;
CURX:
CURXY:  DEFS    1               ; current X - coordinate text cursor
;
CURY:   DEFS    1               ; current Y - coordinate text cursor
;
POSADR: DEFW    TEXTBF          ; Pointer to current position in text memory
;
BITADR: DEFW    08000H          ; Text cursor position in Graphic screen
;
POINTX: DEFS    2               ; X - Coordinate Graphic - Cursor
;
POINTY: DEFS    2               ; Y - Coordinate Graphic - Cursor
;
CURFLG: DEFS    1               ; Flag 'Original/cursor character' (0=Original)
;
CURMAK: DEFS    1               ; Current keyboard mode (0=Alpha [normal] / 1=Small [sftlock] / 2=Graphics)

;
; CRT/LPT work
;
CMTMSG: DEFS    1               ; Text output flag for cassette routine  (if =0 disp cmt-msg)
;
INPFLG: DEFS    1               ; Printer parallel output flag (0=plot off, 1=plot on)
;
DISPX:  DEFS    1               ; 'Execute control characters' flag  (0=MSG, 1=MSGX)
;
FILOUT: DEFS    1               ; Monitor - Printer - Status (0=CRT, 1=LPT)
;
PSEL:   DEFB    1               ; Printer - type - number (bit of number set)
;
;PCRLF:
        DEFB    CR              ; CR - code - value
;
;LPT_TM:
        DEFB    14              ; Time-out counter printer
;
LPOSB:  DEFS    1               ; Column number printer
;
;PSMAL:
        DEFS    1               ; LPT small/capital
;
PNMODE: DEFB    1               ; Printer - Mode - Flag (1=Text / 2=Graphic)
;
;
;  CRT display mode workspace
;
;
DMD:    DEFS    1               ; Value for Display - Mode - Register  (0: 320p 4col / 2: 320p 16col / 4: 640p 2col / 6: 640p 4col)
;
MEMOP:  DEFS    1               ; Flag 'Additional graphic RAM available' (1=yes)
;
PWMODE: DEFS    1               ; Current gfx override value (graphic operation mode)
;
CMODE:  DEFB    3               ; Current character - palette value
;
CPLANE: DEFB    3               ; Background color value / curent active plane
;
MAXCF:  DEFB    4               ; maximum pallet value
;
PMASK:  DEFB    11111111B       ; Mask for screen page (used Grapic - pages)
;
GMODE:  DEFB    3               ; current graphic palette value
;
        DEFS    80              ; Memory for stack in MZ-80K mode


;
S10F0:  DEFS    128             ; Memory for file - identifier (cassette)
;
        DEFS    34
;
FLSDT:  DEFB    0EFH            ; Cursor Character (Monitor 1Z-013B)
;
        DEFS    2
;
TMCNT:  DEFS    2               ; Memory for number of impulses of the tag
;
SUMDT:  DEFS    2               ; Memory for checksum (cassette routine)
;
CSMDT:  DEFS    2               ; second memory for checksum
;
        DEFS    2
;
SWRK:   DEFB    1               ; 'Beep on keypress' flag (1Z-13 B monitor)
;
        DEFB    4               ; Memory for Tempo (Monitor 1Z-013B)
;
ONTYO:  DEFB    5               ; default tone length (monitor 1Z-013B)
;
OCTV:   DEFS    1               ; Memory for Octave (Monitor 1Z-013B)
;
RATIO:  DEFS    2               ; Division Ratio for Sound (Monitor 1Z-013B)
;
S11A3:  DEFS    1
;
;
;   die folgenden 270 Byte dienen als Zwischenspeicher für alle möglichen Zwecke
;
S11A4:  DEFS    2               ; Anzahl noch zu untersuchende Werte   (PAINT)
S11A6:  DEFS    2               ; Zeiger auf PAINT - werte
S11A8:  DEFS    1               ; Speicher für Stackpointer   (BOX)
S11A9:  DEFS    1
S11AA:  DEFS    1
S11AB:  DEFS    1
S11AC:  DEFS    1
S11AD:  DEFS    1
S11AE:  DEFS    1               ; Octantenflag der Anfangskoordinate   (CIRCLE)
S11AF:  DEFS    1               ; Y - Koordinate PAINT / Octantenflag Endpunkt
S11B0:  DEFS    1               ; X - Offset 3 / 6 Octant   (CIRCLE)
S11B1:  DEFS    1               ; linke X - Koordinate   (PAINT)
S11B2:  DEFS    1               ; X - Offset 4 / 5 Octant   (CIRCLE)
S11B3:  DEFS    1               ; rechte X - Koordinate   (PAINT)
S11B4:  DEFS    1               ; Y - Offset 1 / 4 Octant   (CIRCLE)
S11B5:  DEFS    1
S11B6:  DEFS    1               ; Y - Offset 2 / 3 Octant   (CIRCLE)
S11B7:  DEFS    1
S11B8:  DEFS    1
S11B9:  DEFS    1
S11BA:  DEFS    9               ; Octantenbytes   (CIRCLE)
S11C3:  DEFS    2               ; X - Offset Startpunkt   (CIRCLE)
S11C5:  DEFS    2               ; Y - Offset Startpunkt   (CIRCLE)
S11C7:  DEFS    2               ; X - Offset Endpunkt     (CIRCLE)
S11C9:  DEFS    2               ; Y - Offset Endpunkt     (CIRCLE)
S11CB:  DEFS    2               ; Y - Offset 6 / 7 Octant (CIRCLE)
S11CD:  DEFS    2               ; Y - Offset 5 / 8 Octant (CIRCLE)
S11CF:  DEFS    2               ; X - Offset 1 / 8 Octant (CIRCLE)
S11D1:  DEFS    2               ; Y - Offset 2 / 7 Octant (CIRCLE)
S11D3:  DEFS    1               ; Aspect - Flag           (CIRCLE)
S11D4:  DEFS    1               ; Aspect - Verhältnis     (CIRCLE)
;        DEFS    43
        DEFS    25
S11EE:							; Area used by M/C program loader
        DEFS    18
S1200:  DEFS    8               ; Speicher für gedrehtes Zeichen  (muß auf 1200H stehen)
S1208:  DEFS    1
S1209:  DEFS    5
S120E:  DEFS    2
S1210:  DEFS    2
S1212:  DEFS    1
S1213:  DEFS    1
S1214:  DEFS    2               ; Anzahl Punkte in Y - Zeichenrichtung   (SYMBOL)
S1216:  DEFS    2               ; Anzahl Punkte in X - Zeichenrichtung   (SYMBOL)
S1218:  DEFS    2
S121A:  DEFS    2
S121C:  DEFS    2
S121E:  DEFS    1
S121F:  DEFS    1
S1220:  DEFS    1
S1221:  DEFS    2
;S1223:  DEFS    123
S1223:  DEFS    9


S122C:  DEFS    18              ; (relocated) Error handling routine for loading machine programs

S123E:  DEFS    8

S1246:  DEFS    13              ; (reloc) Initiate peripheral modules for MZ - 700 mode

S1253:  DEFS    34              ; (reloc) Table for initializing the control blocks in MZ-700 mode


S1275:
        DEFS    41




S129E:  DEFS    2
S12A0:  DEFS    2
        DEFS    8               ; Memory for stack at ROM - routines - callf
S12AA:  DEFS    2
S12AC:  DEFS    2               ; Storage for stack pointers
S12AE:  DEFS    2               ; Storage for pointers to ROM - commit - text
        DEFS    2


;
;
;   Memory for function key texts
;
; ---------------------------------------------------------------

B12B2:  DEFB    7               ; text length
        DEFM    "RUN   "        ; Text for F1 key
        DEFB    CR
        DEFS    8               ; Rest of text memory
;
        DEFB    5               ; text length
        DEFM    "LIST "         ; Text for F2 key
        DEFS    10              ; Rest of text memory


IF CLASSIC_FNK
; ---------------------------------------------------------------

        DEFB    5               ; text length
        DEFM    "AUTO "         ; Text for F3 key
        DEFS    10              ; Rest of text memory
;
        DEFB    6               ; text length
        DEFM    "RENUM "        ; Text for F4 key
        DEFS    9               ; Rest of text memory
;
        DEFB    6               ; text length
        DEFM    "COLOR "        ; Text for F5 key
        DEFS    9               ; Rest of text memory
;
        DEFB    5               ; text length
        DEFM    "CHR$("         ; Text for key Sft F1
        DEFS    10              ; Rest of text memory
;
        DEFB    8               ; text length
        DEFM    "DEF KEY("      ; Text for key Sft F2
        DEFS    7               ; Rest of text memory
;
        DEFB    4               ; text length
        DEFM    "CONT"          ; Text for key Sft F3
        DEFS    11              ; Rest of text memory
;
        DEFB    6               ; text length
        DEFM    "SAVE  "        ; Text for key Sft F4
        DEFS    9               ; Rest of text memory
;
        DEFB    6               ; text length
        DEFM    "LOAD  "        ; Text for key Sft F5
        DEFS    9               ; Rest of text memory

; ---------------------------------------------------------------
ELSE
; ---------------------------------------------------------------

        DEFB    5               ; text length
        DEFM    "LOAD "         ; Text for F3 key
        DEFS    10              ; Rest of text memory
;
        DEFB    5               ; text length
        DEFM    "SAVE "         ; Text for F4 key
        DEFS    10              ; Rest of text memory
;
        DEFB    5               ; text length
        DEFM    "DIR "          ; Text for F5 key
		DEFB    CR
        DEFS    10              ; Rest of text memory
;
        DEFB    12              ; text length
        DEFM    "INIT\"CRT:M2"  ; Text for key Sft F1
		DEFB    C_LEFT
        DEFS    3               ; Rest of text memory
;
        DEFB    8               ; text length
        DEFM    "DEF KEY("      ; Text for key Sft F2
        DEFS    7               ; Rest of text memory
;
        DEFB    11              ; text length
        DEFM    "OUT@ $E9,0"    ; Text for key Sft F3
		DEFB    C_LEFT
        DEFS    4               ; Rest of text memory
;
        DEFB    8               ; text length
        DEFM    "DEF.RAM"       ; Text for key Sft F4
		DEFB    CR
        DEFS    7               ; Rest of text memory
;
        DEFB    8               ; text length
        DEFM    "DEF.FD1"       ; Text for key Sft F5
		DEFB    C_LEFT
        DEFS    7               ; Rest of text memory
;
; ---------------------------------------------------------------

ENDIF

;
;
;   Storage for values of the current function key
;
S1352:  DEFS    1               ; Fetched number of characters
;
S1353:  DEFS    1               ; Text length current function key
;
S1354:  DEFS    16              ; Text of the current function key
;
S1364:  DEFB    255             ; length input - memory
;
S1365:  DEFS    1               ; last key pressed
;
        DEFS    2               ; Pointer to memory for time (IPL ROM - monitor)
;
        DEFS    1
;
;
;   Memory for current screen - control values
;
S1369:  DEFS    1               ; minimum X coordinate
;
S136A:  DEFS    1,39            ; maximum X coordinate
;
W136B:  DEFW    40              ; Counter '40/80 characters per line'
;
W136D:  DEFW    320             ; Number of pixels per line
;
S136F:  DEFS    1               ; Y - coordinate minimum (scroll - range)
;
S1370:  DEFB    24              ; Y - coordinate maximum (scroll - range)
;
S1371:  DEFB    25              ; Number of lines in the scroll area
;
;
;   Memory for values via scroll area for screen controller
;
S1372:  DEFS    2               ; 'Scroll offset for screen controllers
;
S1374:  DEFS    1,5 * 25        ; Value for 'Scroll width Register' in the Controller screen
;
S1375:  DEFS    1               ; Value for 'Scroll Start Address Register'
;
S1376:  DEFS    1,5 * 25        ; Value for 'Scroll End Address Register'
;
W1377:  DEFW    25 * 5 * 8      ; maximum scroll offset corresponding to scroll area
;
S1379:  DEFB    0000001B        ; Screen Mode Bit (Mode # bit is set)
;
S137A:  DEFB    1               ; Screen - Mode - Number
;
S137B:  DEFB    3               ; maximum palette value / current drawing color
;
S137C:  DEFS    2               ; End of memory for PAINT
;
S137E:  DEFS    1               ; current pallet block number
;
W137F:  DEFW    B1389           ; Pointer to color code - default
;
S1381:  DEFS    4               ; Storage for palette values
;
;
;   Farbcode - Palettencodevorgabe für Bildschirm - Modus  3
;
B1385:  DEFB    00000000B       ; Palettencode 0  Schwarz
        DEFB    00011111B       ; Palettencode 1  Hellweiß
        DEFB    00101111B       ; Palettencode 2  Hellweiß
        DEFB    00111111B       ; Palettencode 3  Hellweiß
;
;
;   Farbcode - Palettencodevorgabe für Bildschirm - Modus  1 oder 4
;
B1389:  DEFB    00000000B       ; Palettencode 0  Schwarz
        DEFB    00010001B       ; Palettencode 1  Blau
        DEFB    00100010B       ; Palettencode 2  Rot
        DEFB    00111111B       ; Palettencode 3  Hellweiß
;
;
;   Farbcode - Palettencodevorgabe für Bildschirm - Modus  2
;
B138D:  DEFB    00000000B       ; Palettencode 0  Schwarz
        DEFB    00010001B       ; Palettencode 1  Blau
        DEFB    00100010B       ; Palettencode 2  Rot
        DEFB    00110011B       ; Palettencode 3  Magenta
;
;
;   Cursor - Bit pattern for  Alpha - Modus
;
B1391:  DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
;
;
;   Cursor - Bit pattern for  Kleinschreibungscursor
;
B1399:  DEFB    01111110B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    01111110B
;
;
;   Cursor - Bit pattern for  Graphic-Cursor
;
B13A1:  DEFB    00000000B
        DEFB    00000000B
        DEFB    00000000B
        DEFB    00000000B
        DEFB    00000000B
        DEFB    00000000B
        DEFB    00000000B
        DEFB    11111111B
;
;
S13A9:  DEFS    26              ; Speicher mit Verkettungsflags der Textzeilen
;
;
;   Speicherbereich für RAM - Karten - Routine
;
S13C3:  DEFS    1               ; Flag  'RAM - Karte vorhanden'
                                ; (0=nein / 1=Kein Spooler / 2=Spooling / 3=Spller möglich)
S13C4:  DEFS    2
;
S13C6:  DEFS    2               ; Anfangsadresse der neuen RAM - Datei
;
S13C8:  DEFS    2               ; RAM - Kartenadresse für Datenblock
;
;
;   Speicher für ROM - Monitor - Drucker - Routinen
;
        DEFS    1               ; SHARP/Centronics-Übernahme - Flag  (0=Sharp)
;
        DEFS    1               ; SHARP/Centronics-Strobe - Flag     (0=Sharp)
;
        DEFW    03FF0H          ; Länge Drucker - Spooler
;
S13CE:  DEFS    2               ; Anzahl Zeichen im Drucker - Spooler
;
        DEFW    0C000H          ; Spooler - Einschreib - Adresse
;
        DEFW    0C000H          ; Spooler - Auslese - Adresse
;
        DEFW    0C000H          ; Anfangsadresse des Spooler - Speichers
;
        DEFS    1               ; Spooler - Status - Flag
;
        DEFS    1               ; Null - Be - Flag
;
        DEFB    4               ; Maximale Drucker - Typ - Nummer
;
S13D9:  DEFS    1               ; ROM - Fehlerstatus
;
W13DA:  DEFW    B13DC           ; Anfangsadresse der Umsetztabelle für ASCII-Zeichen
;
;
;   Tabelle zum Umsetzen der kleinen Buchstaben und Umlaute von Sharp - Code
;   in ASCII - Code und umgekehrt
;
B13DC:  DEFB    39              ; Anzahl Zeichen in Tabelle
;
        DEFB    '#'             ; Sharp - Code
        DEFB    '#'             ;        ... -> ASCII
        DEFB    '@'             ; Sharp - Code
        DEFB    '@'             ;        ... -> ASCII
        DEFB    '['             ; Sharp - Code     (Eckige Klammer auf)
        DEFB    '['             ;        ... -> ASCII
        DEFB    '\\'            ; Sharp - Code     (Backslash)
        DEFB    '\\'            ;        ... -> ASCII
        DEFB    ']'             ; Sharp - Code     (Eckige Klammer zu)
        DEFB    ']'             ;        ... -> ASCII
        DEFB    08BH            ; Sharp - Code
        DEFB    '^'             ;        ... -> ASCII
        DEFB    090H            ; Sharp - Code
        DEFB    '_'             ;        ... -> ASCII
        DEFB    093H            ; Sharp - Code
        DEFB    '`'             ;        ... -> ASCII
        DEFB    0A1H            ; Sharp - Code
        DEFB    'a'             ;        ... -> ASCII
        DEFB    09AH            ; Sharp - Code
        DEFB    'b'             ;        ... -> ASCII
        DEFB    09FH            ; Sharp - Code
        DEFB    'c'             ;        ... -> ASCII
        DEFB    09CH            ; Sharp - Code
        DEFB    'd'             ;        ... -> ASCII
        DEFB    092H            ; Sharp - Code
        DEFB    'e'             ;        ... -> ASCII
        DEFB    0AAH            ; Sharp - Code
        DEFB    'f'             ;        ... -> ASCII
        DEFB    097H            ; Sharp - Code
        DEFB    'g'             ;        ... -> ASCII
        DEFB    098H            ; Sharp - Code
        DEFB    'h'             ;        ... -> ASCII
        DEFB    0A6H            ; Sharp - Code
        DEFB    'i'             ;        ... -> ASCII
        DEFB    0AFH            ; Sharp - Code
        DEFB    'j'             ;        ... -> ASCII
        DEFB    0A9H            ; Sharp - Code
        DEFB    'k'             ;        ... -> ASCII
        DEFB    0B8H            ; Sharp - Code
        DEFB    'l'             ;        ... -> ASCII
        DEFB    0B3H            ; Sharp - Code
        DEFB    'm'             ;        ... -> ASCII
        DEFB    0B0H            ; Sharp - Code
        DEFB    'n'             ;        ... -> ASCII
        DEFB    0B7H            ; Sharp - Code
        DEFB    'o'             ;        ... -> ASCII
        DEFB    09EH            ; Sharp - Code
        DEFB    'p'             ;        ... -> ASCII
        DEFB    0A0H            ; Sharp - Code
        DEFB    'q'             ;        ... -> ASCII
        DEFB    09DH            ; Sharp - Code
        DEFB    'r'             ;        ... -> ASCII
        DEFB    0A4H            ; Sharp - Code
        DEFB    's'             ;        ... -> ASCII
        DEFB    096H            ; Sharp - Code
        DEFB    't'             ;        ... -> ASCII
        DEFB    0A5H            ; Sharp - Code
        DEFB    'u'             ;        ... -> ASCII
        DEFB    0ABH            ; Sharp - Code
        DEFB    'v'             ;        ... -> ASCII
        DEFB    0A3H            ; Sharp - Code
        DEFB    'w'             ;        ... -> ASCII
        DEFB    09BH            ; Sharp - Code
        DEFB    'x'             ;        ... -> ASCII
        DEFB    0BDH            ; Sharp - Code
        DEFB    'y'             ;        ... -> ASCII
        DEFB    0A2H            ; Sharp - Code
        DEFB    'z'             ;        ... -> ASCII
        DEFB    0BEH            ; Sharp - Code   (geschweifte Klammer auf)
        DEFB    '{'             ;        ... -> ASCII
        DEFB    0C0H            ; Sharp - Code   (senkrechter Strich)
        DEFB    '|'             ;        ... -> ASCII
        DEFB    080H            ; Sharp - Code   (geschweifte Klammer zu)
        DEFB    '}'             ;        ... -> ASCII
        DEFB    094H            ; Sharp - Code
        DEFB    '~'             ;        ... -> ASCII
        DEFB    07FH            ; Sharp - Code
        DEFB    07FH            ;        ... -> ASCII  (DEL)
;
;
;   Zeichen für Ausgabe auf ASCII - Gerät umsetzen
;
A142B:  CP      CR              ; Wagenrücklauf  ?
        JR      Z,A1442         ; ja -->  Zeichen ausgeben und Spaltenzähler zurücksetzen
        CP      LF              ; Zeilenvorschub  ?
        JR      Z,A1442         ; ja -->  Zeichen ausgeben und Spaltenzähler zurücksetzen
        CALL    A1448           ; Zeichen im Accu in ASCII - Code umsetzen
        CP      ' '             ; Steuerzeichen  ?
        JR      NC,A1440        ; nein -->  Zeichen im Accu ausgeben
        BIT     0,E             ; Steuerzeichen ausgeben  ?
        JR      Z,A1440         ; ja -->  Zeichen im Accu ausgeben
        LD      A,' '           ; Leerzeichen  (Space)  für Steuerzeichen vorgeben
A1440:  JP      (IX)            ; Zeichen im Accu auf Gerät ausgeben
;
A1442:  CALL    A1440           ; Zeichen im Accu auf Gerät ausgeben
        LD      (HL),0          ; Spaltenzähler des Gerätes zurücksetzen
        RET
;
;
;   Textzeichen im Accu zur Ausgabe auf ASCII - Gerät umsetzen
;
A1448:  PUSH    BC              ; Keep register value
        LD      C,0             ; Code for 'von Sharp in ASCII - Code umsetzen'
        CALL    A1450           ; Zeichen in Austauschtabelle suchen
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Zeichen im Accu in Austauschtabelle suchen und Ersatzzeichen bereitstellen
;
A1450:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      HL,(W13DA)      ; Anfangsadresse der Umsetztabelle holen
        LD      B,(HL)          ; Anzahl Zeichen in Tabelle holen
        INC     HL              ; Anzahl Zeichen überspringen
        LD      D,H             ;! Zeiger auf Tabelle nach DE duplizieren
        LD      E,L             ;!
        INC     DE              ; Zeiger auf Tabelle auf ASCII - Zeichen
        BIT     0,C             ; von Sharp - Code in ASCII - Code umsetzen
        JR      Z,A1460         ; ja
        EX      DE,HL           ; Zeiger auf Tabellenwerte vertauschen
A1460:  CP      (HL)            ; Zeichen mit Tabellenzeichen vergleichen
        JR      Z,A146A         ; Zeichen gefunden -->  Austauschzeichen holen
        INC     HL              ;! Zeiger auf Suchzeichen auf nächstes Zeichen
        INC     HL              ;!
        INC     DE              ;! Zeiger auf Austauschzeichen auf nächstes Zeichen
        INC     DE              ;!
        DJNZ    A1460           ; weitere Zeichen vergleichen
        RET
;
A146A:  LD      A,(DE)          ; Austauschzeichen aus Tabelle holen
        RET
;
;
;   Routine (IX) aufrufen und bereitgestelltes Zeichen in Sharp - Code umsetzen
;
A146C:  CALL    A1440           ; Routine (IX) aufrufen   (Zeichen bereitstellen)
        RET     C               ; Fehler aufgetreten -->  Abbruch
        PUSH    BC              ; Keep register value
        LD      C,1             ; Code for 'von ASCII in Sharp - Code umsetzen'
        CALL    A1450           ; Zeichen im Accu umsetzen
        POP     BC              ; geretteten Register - Wert wieder holen
        OR      A               ; Carry - Flag zurücksetzen   (Code for 'kein Fehler')
        RET
;
;
;   Geräte - Tabelle für Drucker   (LPT:)
;
W1479:  DEFW    W3AD7           ; Zeiger auf nächste Geräte - Tabelle   (CMT:)
        DEFM    "LPT"
		DEFB    NUL             ; Geräte - Name
        DEFB    10001010B       ; Geräte - Typ - Byte
        DEFB    00000000B       ; Geräte - Nummern - Byte
        DEFB    0
        DEFW    A14EC           ; Gerät initialisieren
        DEFW    A1FAC           ; Fehler 59  Can't execute error  (zum Lesen eröffnen)
        DEFW    __RET           ; RET
        DEFW    __RET           ; RET
        DEFW    __RET           ; RET
        DEFW    0               ; Code for 'Zeichen bereitstellen nicht möglich'
        DEFW    A14B2           ; Accu an Drucker ausgeben
        DEFW    A1492           ; aktuelle X - Koordinate Drucker bereitstellen
;
;
;   aktuelle X - Koordinate Drucker bereitstellen
;
A1492:  LD      A,(INPFLG)      ; Parallelausgabeflag Drucker  holen
        OR      A               ; Parallelausgabe gesetzt  ?
        LD      A,(LPOSB)       ; Spaltennummer Drucker  holen
        RET     Z               ; keine Parallelausgabe -->  Wert Drucker zurückliefern
        LD      A,(CURX)        ; X - Koordinate Textcursor holen
        RET
;
;
;   Uhrzeit auf Sekunden in DE und Flag Vormittag/Nachmittag im Accu setzen
;
;   (SVC code:  38)
;
TIMST:  CALL    A1517           ; IPL - ROM - Routine aufrufen
        DEFB    003H            ; Low - Byte Anfangsadresse  'Uhrzeit setzen'
;
;
;   Uhrzeit lesen     (SVC code:  37)
;
TIMRD:  CALL    A1517           ; IPL - ROM - Routine aufrufen
        DEFB    006H            ; Low - Byte Anfangsadresse  'Uhrzeit lesen'
;
;
;   Joy - Stick nach Richtung abfragen   (Accu gleich Joy-Stick-Nummer)
;
;   (SVC code:  30)
;
STICK:  CALL    A1517           ; IPL - ROM - Routine aufrufen
        DEFB    009H            ; Low - Byte Anfangsadresse  'Joy - Stick abfragen'
;
;
;   Abfrage, ob Feuerknopf des Jopy - Sticks gedrückt ist
;
;   (SVC code:  31)
;
STRIG:  CALL    A1517           ; IPL - ROM - Routine aufrufen
        DEFB    00CH            ; Low - Byte Anfangsadresse  'Feuerknopf abfragen'
;
;
;   Graphic - Bildschirm - Inhalt auf Graphic - Drucker ausgeben
;
;   (SVC code:  79)
;
HCPY:   CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    00FH            ; Low - Byte Anfangsadresse  'Graphic auf Drucker kopieren'
;
;
;   ASCII - Zeichen im Accu an Drucker ausgeben
;
A14B2:  LD      HL,DISPX        ; Zeiger auf Flag  'Steuerzeichen ausführen'
        BIT     0,(HL)          ; Steuerzeichen ausführen  ?
        JR      NZ,A14E0        ; nein -->  Steuerzeichen anzeigen
;
;
;   Zeichen im Accu auf Drucker  (und Bildschirm)  ausgeben
;
;   Software - Kommando  7)
;
LPT1C:  PUSH    IY              ; Keep register value
        EX      AF,AF           ; auszugebendes Zeichen retten
        LD      A,012H          ; Code for 'Zeichen an Drucker ausgeben, wenn nicht Parallelausgabe'
        LD      (B14DF),A       ; in Routine eintragen
        LD      A,3             ; Code 3  Accu auf Bildschirm ausgeben  (Ausführung Steuerzeichen)
A14C3:  LD      (B14D6),A       ; in Routine eintragen
        EX      AF,AF           ; auszugebendes Zeichen holen
        CALL    A14D8           ; Zeichen im Accu an Drucker ausgeben
        POP     IY              ; geretteten Register - Wert wieder holen
        PUSH    BC              ; Keep register value
        LD      B,A             ; auszugebendes Zeichen retten
        LD      A,(INPFLG)      ; Parallelausgabeflag Drucker  holen
        OR      A               ; Parallelausgabe  ?
        LD      A,B             ; auzugebendes Zeichen holen
        POP     BC              ; geretteten Register - Wert holen
        RET     Z               ; keine Parallelausgabe -->  fertig
        RST     _DOCMD          ; Software - Kommando ausführen
B14D6:  DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausführung Steuerzeichen)
        RET
;
A14D8:  LD      IY,A142B        ; Adresse  'Zeichen für Ausgabe auf ASCII-Drucker umsetzen'
        CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
B14DF:  DEFB    012H            ; Low - Byte Anfangsadresse  'Zeichen auf Drucker ausgeben'
;
;
;   Zeichen im Accu auf Bildschirm und Drucker ausgeben   (Steuerzeichen anzeigen)
;
A14E0:  PUSH    IY              ; Keep register value
        EX      AF,AF           ; auszugebendes Zeichen retten
        LD      A,015H          ; Code for 'Steuerzeichen auf Drucker anzeigen'
        LD      (B14DF),A       ; in Routine eintragen
        LD      A,3             ; Code 3  Accu auf Bildschirm ausgeben
        JR      A14C3           ; Zeichen ausgeben
;
;
;   Drucker initialisieren
;
A14EC:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    018H            ; Low - Byte Anfangsadresse  'Drucker initialisieren'
;
;
;   Zeichen im Accu auf Drucker ausgeben     (SVC code:  6)
;
LPTOUT: CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    01BH            ; Low - Byte Anfangsadresse  'Zeichen auf Drucker ausgeben'
;
;
;   Spooler - Daten nach Spooler - Anfangsadresse setzen
;
A14F4:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    01EH            ; Low - Byte Anfangsadresse  der ROM - Routine
;
;
;   Drucker - Interrupt abschalten
;
A14F8:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    021H            ; Low - Byte Anfangsadresse  der ROM - Routine
;
;
;   Drucker - Interrupt freigeben
;
A14FC:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    024H            ; Low - Byte Anfangsadresse  der ROM - Routine
;
;
;   Druckvorgang stoppen / anlaufen lassen
;
SPLSW:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    027H            ; Low - Byte Anfangsadresse  der ROM - Routine
;
;
;   auf 'Drucker READY' abfragen und Spooler abschalten
;
A1504:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    02AH            ; Low - Byte Anfangsadresse  der ROM - Routine
;
;
;   wenn P5-A - Drucker -->  erst Music spielen und dann ROM - Routine aufrufen
;
A1508:  EX      AF,AF           ; Keep register value
        LD      A,(PSEL)        ; Drucker - Nummern - byte holen
        BIT     1,A             ; MZ - 80 A   P5 - Drucker  ?
        JR      Z,A1516         ; nein -->  ROM - Routine direkt aufrufen
        PUSH    BC              ; Keep register value
        LD      B,3             ; Code for 'warten, bis Music - Daten gespielt'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    35              ; Code 35  Music nach Status in B behandeln
        POP     BC              ; geretteten Register - Wert wieder holen
A1516:  EX      AF,AF           ; geretteten Accu - Wert wieder holen
;
;
;   IPL - ROM - Routine aufrufen
;
A1517:  EX      AF,AF           ; Wert im Accu retten
        XOR     A               ; Accu auf Null
        LD      (S12AE),HL      ; Zeiger auf ROM - Übergabe - Text eintragen
        LD      (S13D9),A       ; ROM - Fehlerstatus löschen
        EX      AF,AF           ; geretteten Accu - Wert wieder holen
        DI                      ; Interrupt sperren
        LD      (S12AC),SP      ; Stackpointer retten
        EX      (SP),HL         ; HL - Register retten / Rücksprungadresse holen
        LD      SP,HL           ; Stackpointer mit Rücksprungadresse laden
        POP     HL              ; Low - Byte der Adresse hinter Call - Aufruf holen
        OUT     (_E0ROM),A      ; Umschalten auf ROM - Monitor von 0E000H bis 0FFFFH
        LD      SP,S12AA        ; Stackpointer für ROM - Routine setzen
        CALL    A1543           ; High - Byte Adresse vorgeben und ROM - Routine aufrufen
        OUT     (_E0RAM),A      ; Umschalten auf RAM von 0E000H bis 0FFFFH
        LD      SP,(S12AC)      ; alten Stackpointer wieder holen
        EX      (SP),HL         ; geretteten HL - Register - Wert wieder holen
        INC     SP              ;! Stack - Pointer corrigieren
        INC     SP              ;!
        EI                      ; Interrupt freigeben
        EX      AF,AF           ; Wert im Accu retten
        LD      A,(S13D9)       ; ROM - Fehlerstatus holen
        OR      A               ; Fehler aufgetreten  ?
        JR      NZ,A1546        ; ja -->  Fehler behandeln
        EX      AF,AF           ; geretteten Accu - Wert holen
        RET
;
A1543:  LD      H,0F4H          ; High - Byte ROM - Routinen - Adresse vorgeben
        JP      (HL)            ; ROM - Routine aufrufen
;
;
;   Fehler bei ROM - Routine behandeln
;
A1546:  LD      B,A             ; Fehlerstatus merken
        EX      AF,AF           ; geretteten Accu - Wert holen
        DEC     B               ; Fehlerstatus gleich 1  ?
        JP      Z,BREAKZ        ; ja -->  Programm abbrechen  (BREAK)
        DEC     B               ; Fehlerstatus gleich 2  ?
        JP      NZ,ERRORJ       ; nein -->  Fehler mit Nummer im Accu behandeln
A1550:  LD      HL,(S13CE)      ; Anzahl Zeichen im Drucker - Spooler holen
        LD      A,H             ;! gleich Null  ?
        OR      L               ;!
        JR      Z,A1504         ; ja -->  auf Drucker Ready abfragen und Spooler abschalten
        CALL    A14FC           ; Drucker - Interrupt freigeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    14              ; Code 14   Abfrage, ob (Shift) BREAK gedrückt ist
        JP      Z,BREAKZ        ; ja -->  Programm abbrechen  (BREAK)
        JR      A1550           ; warten, bis Drucker - Spooler leer
;
;
;   PIO - Interrupt für Drucker behandeln
;
LPTINT: DI                      ; Interrupt sperren
        PUSH    AF              ;! Register - Werte retten
        PUSH    HL              ;!
        PUSH    BC              ;!
        LD      (S1585),SP      ; Stackpointer retten
        LD      SP,S1585        ; neuen Stackpointer für ROM - Routine vorgeben
        OUT     (_E0ROM),A      ; Umschalten auf ROM - Monitor von 0E000H bis 0FFFFH
        CALL    XF400           ; Drucker - Interrupt - Routine im ROM aufrufen
        OUT     (_E0RAM),A      ; Umschalten auf RAM von 0E000H bis 0FFFFH
        LD      SP,(S1585)      ; geretteten Stackpointer holen
        POP     BC              ;! gerettete Register - Werte holen
        POP     HL              ;!
        POP     AF              ;!
        EI                      ; Interrupt wieder freigeben
        RETI                    ; Interrupt - Routine abschliessen
;
        DEFS    8               ; Speicher für Stack
;
S1585:  DEFS    2               ; Speicher für Stackpointer
;
;
;   Software - Maschinen - Monitor aufrufen
;
;   (SVC code:  0)
;
MONOP:  PUSH    HL              ; Keep register value
        LD      DE,(ERRORP)     ; Fehlerbehandlungsadresse holen
        PUSH    DE              ; und retten
        LD      DE,T15CE        ; neuen Fehlerbehandlungsadresse
        LD      (ERRORP),DE     ; eintragen
        LD      A,(S1364)       ; Länge Eingabe - Speicher  holen
        PUSH    AF              ; und retten
        LD      A,100           ; Vorgabe für neue Pufferlänge
        LD      (S1364),A       ; als Länge Eingabe - Speicher merken
        LD      (A1644 + 1),SP  ; Stackpointer merken
        XOR     A               ; Accu auf Null
        LD      (FILOUT),A      ; Monitor - Drucker - Status  zurücksetzen
A15A5:  LD      SP,0            ; Stackpointer neu setzen
;
;
;   Anfang  Monitor - Schleife
;
T15A8:  LD      BC,T15A8        ; Rücksprungadresse für Schleife
        PUSH    BC              ; auf Stack ablegen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    2               ; Code 2  Zeilenvorschub, wenn Cursor nicht auf Anfang Zeile
        LD      A,'*'           ; Monitor - Prompt - Symbol
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausführung Steuerzeichen)
A15B2:  CALL    A1651           ; Zeile von Tastatur holen und auswerten
        JR      NC,A15B2        ; Zeile vollständig ausgewertet -->  nächste Zeole holen
        LD      A,(DE)          ; erstes Zeichen der Zeile holen
        CP      '*'             ; Monitor - Prompt - Symbol
        RET     NZ              ; nein -->  erneut von Tastatur abfragen
        INC     DE              ; Prompt - Symbol überspringen
        LD      A,(DE)          ; nächstes Textzeichen holen
        INC     DE              ; Textzeichen überspringen
        EXX
        LD      HL,M15E0        ; Zeiger auf Tabelle mit Monitorbefehlen
        LD      B,10            ; 10 Befehle in Tabelle
A15C4:  CP      (HL)            ; Befehlszeichen vergleichen
        INC     HL              ; Zeiger auf Tabelle auf Adresse
        JR      Z,A15DA         ; Befehl gefunden -->  Adresse aus Tabelle holen
        INC     HL              ;! Anfangsadresse des Befehls überspringen
        INC     HL              ;!
        DJNZ    A15C4           ; weitere Befehle vergleichen
        EXX
        RET
;
;
;   Software - Monitor - Fehlerbehandlung
;
T15CE:  LD      C,A             ; Fehlernummer merken
        AND     01111111B       ; eigentliche Fehlernummer maskieren
        JR      Z,A15A5         ; BREAK -->  Monitor - Schleife
        LD      A,C             ; Fehlernummer holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    27              ; Code 27  Fehlertext nach Fehlernummer in A ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    67              ; Code 67   Datei - Daten der Ausgabe - Datei löschen
        JR      A15A5           ; nächsten Monitor - Befehl holen und abarbeiten
;
;
;   Anfangsadresse der Befehlsroutine aus Tabelle holen und Routine aufrufen
;
A15DA:  LD      E,(HL)          ;! Anfangsadresse der Routine aus Tabelle holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        PUSH    DE              ; Anfangsadresse auf Stack ablegen
        EXX
        RET                     ; Routine aufrufen
;
;
;   Tabelle mit Anfangsadressen der Monitor - Befehle
;
M15E0:  DEFM    "D"             ; D  (Dump)
        DEFW    A16C6           ; Adresse  'Speicher ausgeben'
;
        DEFM    "M"             ; M  (Memory correction)
        DEFW    A1738           ; Adresse  'Speicher ändern'
;
        DEFM    "P"             ; P  (Printer mode)
        DEFW    A15FE           ; Adresse  'Druckerausgabe toggeln'
;
        DEFM    "G"             ; G  (Goto)
        DEFW    A16C1           ; Adresse  'Programm aufrufen'
;
        DEFM    "F"             ; F  (Find)
        DEFW    A175C           ; Adresse  'Daten im Speicher suchen'
;
        DEFM    "R"             ; R  (Return)
        DEFW    A1644           ; Adresse  'Rücksprung zum Basic'
;
        DEFM    "S"             ; S  (Save)
        DEFW    A1607           ; Adresse  'Programm abspeichern'
;
        DEFM    "L"             ; L  (Load)
        DEFW    A161E           ; Adresse  'Programm laden'
;
        DEFM    "V"             ; V  (Verify)
        DEFW    A163B           ; Adresse  'Programm vergleichen'
;
        DEFM    "T"             ; T  (Transfer)
        DEFW    A17AC           ; Adresse  'Programm verschieben'
;
;
;   Monitor - Befehl  P   (Ausgabe Drucker umschalten)
;
A15FE:  LD      A,(FILOUT)      ; Monitor - Drucker - Status  holen
        XOR     00000001B       ; Druckerstatus umkehren
        LD      (FILOUT),A      ; und wieder merken
        RET
;
;
;   Monitor - Befehl  S   (Programm abspeichern)
;
A1607:  CALL    A1795           ; Anfangs-, End- und Startadresse bereitstellen
        RET     C               ; Fehler aufgetreten -->  Monitor - Schleife
        EXX
        CALL    A17C3           ; Geräte- und Dateinamen auswerten und aufbereiten
        EXX
        LD      (S1014),BC      ; Datei - Länge merken
        LD      (S1016),DE      ; Anfangsadresse merken
        LD      (S1018),HL      ; Startadresse merken
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    49              ; Code 49  Programm abspeichern
        RET
;
;
;   Monitor - Befehl  L   (Programm laden)
;
A161E:  CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        PUSH    HL              ; Ladeadresse merken
        PUSH    AF              ; Fehlerflag merken
        CALL    A1630           ; Dateinamen auswerten und Kennung lesen
        POP     AF              ; Fehlerflag holen
        POP     HL              ; Ladeadresse holen
        JR      NC,A162D        ; kein Fehler -->  Ladeadresse angegeben
        LD      HL,(S1016)      ; Anfangsadresse aus Datei - Daten holen
A162D:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    48              ; Code 48  Programm nach Kennungsdaten laden
        RET
;
;
;   Dateinamen auswerten und Kennung lesen
;
A1630:  CALL    A17C3           ; Geräte- und Dateinamen auswerten und aufbereiten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    47              ; Code 47  (Programm-)Datei eröffnen
        CP      _OBJ            ; Maschinenprogramm gefunden  ?
        RET     Z               ; ja -->  OK
        JP      A1FB2           ; Fehler 61, Illegal filemode error
;
;
;   Monitor - Befehl  V   (Programm vergleichen)
;
A163B:  CALL    A1630           ; Dateinamen auswerten und Kennung lesen
        LD      HL,(S1016)      ; Anfangsadresse holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    50              ; Code 50  Programm vergleichen
        RET
;
;
;   Monitor - Befehl  R   (Rücksprung zum Basic - Interpreter)
;
A1644:  LD      SP,0            ; Stackpointer wieder setzen  (wird eingetragen)
        POP     AF              ; gerettete Pufferlänge holen
        LD      (S1364),A       ; und wieder als Länge Eingabe - Speicher eintragen
        POP     HL              ; gerettete Fehlerbehandlungsadresse holen
        LD      (ERRORP),HL     ; Fehlerbehandlungsadresse eintragen
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;   Zeile von Tastatur holen und soweit wie möglich auswerten
;
A1651:  LD      DE,ZFF00        ; Zeiger auf Speicher für Tastatureingabe vorgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    12              ; Code 12   Zeile von Tastatur nach Speicher (DE) holen
        JR      C,A1670         ; Eingabe geBREAKt -->  BREAK merken
        LD      A,(DE)          ; erstes Zeichen der Eingabe holen
        CP      ':'             ; Doppelpunkt  ?
        SCF                     ; Code for 'Zeile nicht editierbar'  setzen
        RET     NZ              ; Zeile nicht editierbar
        INC     DE              ; Doppelpunkt überspringen
        CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        RET     C               ; Fehler aufgetreten
        LD      A,(DE)          ; nächstes Textzeichen holen
        INC     DE              ; Textzeichen überspringen
        XOR     '='             ; gleich =  ?
        RET     NZ              ; nein
A1667:  CALL    A1697           ; 2 ASCII-Hex-Zeichen oder ein ASCII-Zeichen -->  Hex-Wert
        CCF                     ; Fehlerstatus umkehren
        RET     NC              ; Fehler oder Datenende
        LD      (HL),A          ; Wert in Speicher eintragen
        INC     HL              ; Zeiger auf Speicher auf nächstes Byte
        JR      A1667           ; untersuchen, ob weitere Werte angegeben sind
;
A1670:  LD      (DE),A          ; Code for 'BREAK'  merken
        RET
;
;
;   4 ASCII - Hex - Zeichen (DE) umsetzen in Hex - Wert nach HL
;
A1672:  PUSH    HL              ; Keep register value
        CALL    A168C           ; Zeiger in DE auf nächstes relevantes Zeichen setzen
        PUSH    DE              ; Zeiger auf Textanfang merken
        CALL    A169E           ; 2 ASCII-Hex-Zeichen (DE) umsetzen in Hex nach Accu
        JR      C,A1687         ; Fehler aufgetreten -->  Abbruch
        LD      H,A             ; High - Byte Wert merken
        CALL    A169E           ; 2 ASCII-Hex-Zeichen (DE) umsetzen in Hex nach Accu
        JR      C,A1687         ; Fehler aufgetreten -->  Abbruch
        LD      L,A             ; Low - Byte Wert merken
        POP     AF              ; Zeiger auf Textanfang verwerfen
        POP     AF              ; alten HL - Register - Wert verwerfen
        XOR     A               ; Carry-Flag zurücksetzen  (Code for 'Funktion ok')
        RET
;
A1687:  POP     DE              ; Zeiger auf Textanfang wieder holen
        POP     HL              ; alten HL - Register - Wert wieder holen
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
;
;   Zeiger in DE auf nächstes relevantes Zeichen setzen
;
A168B:  INC     DE              ; Zeiger auf Text auf nächstes Zeichen
A168C:  LD      A,(DE)          ; ein Textzeichen holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A168B         ; ja -->  nächstes relevante Zeichen suchen
        RET
;
;
;   ASCII - Zeichen (DE) umsetzen in Hex - Wert nach Accu
;
A1692:  LD      A,(DE)          ; Textzeichen holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    21              ; Code 21  Sedezimal-ASCII-Zeichen im Accu umsetzen in Hex
        INC     DE              ; ausgewertetes Zeichen überspringen
        RET
;
;
;   2 ASCII - Hex - Zeichen oder ein ASCII - Zeichen (DE) umsetzen in
;   entsprechenden Hex - Wert nach Accu
;
A1697:  CALL    A168C           ; Zeiger in DE auf nächstes relevantes Zeichen setzen
        CP      ';'             ; Strichpunkt  ?
        JR      Z,A16BC         ; ja -->  Hex - Wert des nächste ASCII - Zeichens holen
;
;
;   2 ASCII - Hex - Zeichen (DE) umsetzen in HEX - Wert nach Accu
;
A169E:  PUSH    BC              ; Keep register value
        PUSH    DE              ; Zeiger auf Textanfang retten
        CALL    A1692           ; HEX-ASCII-Zeichen (DE) umsetzen in Hex-Wert nach Accu
        JR      C,A16B8         ; kein HEX - Zeichen -->  gerettete Register holen
        LD      C,A             ; High - Nibble - Wert merken
        CALL    A1692           ; HEX-ASCII-Zeichen (DE) umsetzen in Hex-Wert nach Accu
        JR      C,A16B8         ; kein HEX - Zeichen -->  gerettete Register holen
        LD      B,A             ; Low - Nibble merken
        LD      A,C             ; High - Nibble - Wert holen
        RLCA                    ;! auf High - Nibble schieben
        RLCA                    ;!
        RLCA                    ;!
        RLCA                    ;!
        ADD     A,B             ; plus Low - Nibble
        LD      C,A             ; Wert merken
        LD      A,C             ; und wieder holen  (Warum  ?)
        POP     BC              ; Zeiger auf Textanfang verwerfen
        POP     BC              ; geretteten Register - Wert holen
        OR      A               ; Carry - Flag zurücksetzen  (Code for 'kein Fehler')
        RET
;
A16B8:  POP     DE              ; geretteten Zeiger auf Textanfang holen
        POP     BC              ; geretteten Register - Wert holen
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
A16BC:  INC     DE              ; Strichpunkt überspringen
        LD      A,(DE)          ; Textzeichen holen
        INC     DE              ; ausgewertetes Textzeichen überspringen
        OR      A               ; Carry-Flag zurücksetzen   (Code 'kein Fehler')
        RET
;
;
;   Monitor - Befehl  G   (Programmaufruf)
;
A16C1:  CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        RET     C               ; Fehler aufgetreten -->  Monitor - Haupt - Schleife
        JP      (HL)            ; Programm aufrufen
;
;
;   Monitor - Befehl  D   (Speicherbereich ausgeben)
;
A16C6:  CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        JR      C,A16D6         ; keine Adresse angegeben -->  weiter ab letzter Stelle
        PUSH    HL              ; Anfangsadresse merken
        CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        JR      C,A16D5         ; keine Endadresse angegeben --> 128 Bytes ausgeben
        POP     DE              ; Anfangsadresse holen
        EX      DE,HL           ; Adressen vertauschen
        JR      A16DC           ; Speicherbereich ausgeben
;
A16D5:  POP     HL              ; Anfangsadresse holen
A16D6:  EX      DE,HL           ; Adresse nach DE
        LD      HL,128          ; 128 Bytes ausgeben
        ADD     HL,DE           ; Endadresse errechnen
        EX      DE,HL           ; Adressen vertauschen
A16DC:  LD      C,8             ; 8 Byte je Zeile ausgeben
        CALL    A16E9           ; eine Zeile aufbereiten und ausgeben
        RET     C               ; BREAK gedrückt -->  Monitor - Schleife
        PUSH    HL              ; aktuelle Adresse retten
        SBC     HL,DE           ; mit Endadresse vergleichen
        POP     HL              ; aktuelle Adresse holen
        RET     NC              ; fertig
        JR      A16DC           ; weitere Zeilen ausgeben
;
;
;   eine Zeile für Monitor - Befehl D aufbereiten und ausgeben
;
A16E9:  CALL    A1711           ; Doppelpunkt, Anfangsadresse und = ausgeben
        LD      B,C             ; Anzahl Bytes je Zeile als Zähler vorgeben
        PUSH    HL              ; Adresse  'Anfang Zeile'  merken
A16EE:  LD      A,(HL)          ; ein Byte holen
        CALL    A1722           ; Hex-Wert im Accu umsetzen in ASCII-Hex-Wert und ausgeben
        INC     HL              ; Zeiger auf Speicher auf nächstes Byte
        LD      A,' '           ; Leerzeichen  (Space)  als Trennzeichen zwischen Bytes
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker ausgeben
        DJNZ    A16EE           ; weitere Speicherzellen ausgeben
        POP     HL              ; Adresse des Zeilenanfangs holen
        LD      A,'/'           ; Schrägstrich als Trennzeichen zwischen Bytes und Text
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker ausgeben
        LD      B,C             ; Anzahl Bytes je Zeile als Zähler vorgeben
A16FF:  LD      A,(HL)          ; ein Byte holen
        CP      ' '             ; Steuerzeichen  ?
        JR      NC,A1706        ; nein -->  Textzeichen ausgeben
        LD      A,'.'           ; Punkt für Steuerzeichen vorgeben
A1706:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker ausgeben
        INC     HL              ; Zeiger auf Speicher auf nächstes Byte
        DJNZ    A16FF           ; weitere Bytes als Text ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    8               ; Code 8  Zeilenvorschub auf Bildschirm oder Drucker ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    15              ; Code 15  wenn Space gedrückt -->  warten bis andere Taste
        OR      A               ; Carry-Flag zurücksetzen  (Code 'kein Fehler')
        RET
;
;
;   Doppelpunkt, Anfangsadresse und = ausgeben
;
A1711:  LD      A,':'           ; Doppelpunkt
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker ausgeben
        LD      A,H             ; High - Byte Adresse holen
        CALL    A1722           ; Hex-Wert im Accu umsetzen in ASCII-Hex-Wert und ausgeben
        LD      A,L             ; Low - Byte Adresse holen
        CALL    A1722           ; Hex-Wert im Accu umsetzen in ASCII-Hex-Wert und ausgeben
        LD      A,'='           ; Gleichheitszeichen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker ausgeben
        RET
;
;
;   Hex - Wert im Accu umsetzen in ASCII - Hex - Wert und ausgeben
;
A1722:  PUSH    AF              ; auszugebenden Wert retten
        RLCA                    ;! High - Nibble auf Low - Nibble schieben
        RLCA                    ;!
        RLCA                    ;!
        RLCA                    ;!
        CALL    A172B           ; Low - Nibble umsetzen in ASCII und ausgeben
        POP     AF              ; auszugebenden Wert holen
A172B:  AND     00001111B       ; Low - Nibble maskieren
        ADD     A,'0'           ; umsetzen in ASCII
        CP      '9' + 1         ; Dezimalziffer  ?
        JR      C,A1735         ; ja -->  ausgeben
        ADD     A,7             ; ASCII - Zeichen für A - F corrigieren
A1735:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker ausgeben
        RET
;
;
;   Monitor - Befehl  M   (Speicherbereich ändern)
;
A1738:  CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        LD      A,(FILOUT)      ; Monitor - Drucker - Status holen
        PUSH    AF              ; aktuellen Status merken
        XOR     A               ; Code for 'Ausgabe auf Bildschirm'
        LD      (FILOUT),A      ; als Monitor - Drucker - Status  merken
A1743:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    2               ; Code 2  Zeilenvorschub, wenn Cursor nicht auf Anfang Zeile
        CALL    A1711           ; Doppelpunkt, Anfangsadresse und = ausgeben
        LD      A,(HL)          ; ein Byte aus Speicher holen
        CALL    A1722           ; Hex-Wert im Accu umsetzen in ASCII-Hex-Wert und ausgeben
        LD      A,C_LEFT        ; Steuerzeichen  'Cursor links'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausführung Steuerzeichen)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausführung Steuerzeichen)
        CALL    A1651           ; Zeile von Tastatur holen und auswerten
        JR      NC,A1743        ; kein Fehler oder BREAK -->  nächste Zeile
        POP     AF              ; geretteten Drucker - Status holen
        LD      (FILOUT),A      ; alten Monitor - Drucker - Status wieder vorgeben
        RET
;
;
;   Monitor - Befehl  F   (Speicherbereich nach Bytefolge absuchen)
;
A175C:  CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        RET     C               ; Fehler aufgetreten -->  Monitor - Schleife
        PUSH    HL              ; Anfangsadresse retten
        CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        POP     BC              ; gerettete Anfangsadresse holen
        RET     C               ; Fehler aufgetreten -->  Monitor - Schleife
        PUSH    HL              ; Endadresse merken
        PUSH    BC              ; Anfangsadresse merken
        LD      HL,ZFF00        ; Zeiger auf Speicher für Suchbytefolge vorgeben
        CALL    A1667           ; ASCII-Hex-Zeichen oder Textzeichen umsetzen in Hex-Werte
        LD      DE,ZFF00        ; Zeiger auf Anfang Suchbytefolge
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Anzahl Suchbytes errechnen
        LD      C,L             ; und merken
        POP     HL              ; Anfangsadresse holen
        PUSH    HL              ; und merken
        EXX
        POP     HL              ; Anfangsadresse des Suchbereiches
        POP     DE              ; Endadresse des Suchbereiches
        EXX
        RET     Z               ; keine Suchbytes angegeben -->  fertig
A177C:  CALL    A17D6           ; Zeichen (HL) auf Suchbytes überprüfen
        JR      NZ,A1785        ; nicht Suchstring
        CALL    A16E9           ; gefundene Adresse und Bytes ausgeben
        RET     C               ; BREAK gedrückt -->  Monitor - Schleife
A1785:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    14              ; Code 14   Abfrage, ob (Shift) BREAK gedrückt ist
        RET     Z               ; Shift - BREAK gedrückt -->  Monitor - Schleife
        EXX
        INC     HL              ; aktuelle Adresse plus eins
        PUSH    HL              ; aktuelle Adresse retten
        SCF                     ;! überprüfen, ob angegebenen Bereich durchsucht
        SBC     HL,DE           ;!
        POP     HL              ; aktuelle Adresse wieder holen
        RET     NC              ; fertig -->  Monitor - Schleife
        PUSH    HL              ; aktuelle Adresse auf Stack ablegen
        EXX
        POP     HL              ; aktuelle Adresse holen
        JR      A177C           ; weiter untersuchen
;
;
;   Anfangsadresse, Anzahl Bytes und Start-/Neue Adresse bereitstellen
;
A1795:  CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        PUSH    HL              ; Anfangsadresse retten
        CALL    NC,A1672        ; kein Fehler -->  4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        POP     BC              ; Anfangsadresse holen
        RET     C               ; Fehler aufgetreten -->  Abbruch
        SBC     HL,BC           ;! Anzahl Bytes errechnen
        INC     HL              ;!
        PUSH    HL              ; Anzahl Bytes merken
        PUSH    BC              ; Anfangsadresse merken
        CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        PUSH    HL              ; Startadresse / Neue Adresse merken
        EXX
        POP     HL              ; Startadresse / Neue Adresse
        POP     DE              ; Anfangsadresse
        POP     BC              ; Anzahl Bytes
        RET
;
;
;   Monitor - Befehl  T   (Speicherblock verschieben)
;
A17AC:  CALL    A1795           ; Anfangs-, End- und neue Adresse bereitstellen
        RET     C               ; Fehler aufgetreten -->  Monitor - Schleife
        EX      DE,HL           ; Anfangs- und neue Adresse vertauschen
        PUSH    HL              ; Anfangsadresse retten
        SBC     HL,DE           ; Adressen vergleichen
        POP     HL              ; gerettete Anfangadresse holen
        JR      C,A17BA         ; von oben nach unten schieben
        LDIR                    ; Speicherblock verschieben
        RET
;
A17BA:  ADD     HL,BC           ;! Adressen auf Ende der Bereiche umrechnen
        DEC     HL              ;!
        EX      DE,HL           ;!
        ADD     HL,BC           ;!
        DEC     HL              ;!
        EX      DE,HL           ;!
        LDDR                    ; Speicherblock verschieben
        RET
;
;
;   Geräte- und Dateinamen auswerten und aufbereiten
;
A17C3:  LD      A,(DE)          ; ein Textzeichen holen
        OR      A               ; Textendezeichen  ?
        JR      Z,A17CC         ; ja -->  kein Dateiname angegeben
        INC     DE              ; Textzeichen überspringen
        CP      ':'             ; Doppelpunkt  ?
        JR      NZ,A17C3        ; nein -->  weitersuchen
A17CC:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    23              ; Code 23  Länge des Textes (DE) auszählen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    45              ; Code 45   Geräte- und Dateinamen auswerten
        LD      A,_OBJ          ; Datei - Typ  OBJ - Datei   (Maschinensprachendatei)
        LD      (S1000),A       ; in Speicher für Kennung eintragen
        RET
;
;
;   in C angegebene Anzahl Bytes (DE) mit Bytes (HL) vergleichen
;
A17D6:  LD      A,(DE)          ;! erstes Byte vergleichen
        CP      (HL)            ;!
        RET     NZ              ; schon nicht gleich
        PUSH    BC              ; Anzahl Bytes retten
        PUSH    DE              ; Zeiger auf Vorgabe retten
        PUSH    HL              ; Zeiger auf Speicher retten
        LD      B,C             ; Anzahl zu vergleichende Bytes vorgeben
A17DD:  LD      A,(DE)          ;! ein Byte vergleichen
        CP      (HL)            ;!
        JR      NZ,A17E6        ; Bytes nicht gleich
        INC     DE              ;! Zeiger auf Bytes auf nächstes Paar
        INC     HL              ;!
        DJNZ    A17DD           ; weitere Bytes vergleichen
        XOR     A               ; Code for 'Bytes gleich'  setzen  (unnötig)
A17E6:  POP     HL              ; Zeiger auf Speicher holen
        POP     DE              ; Zeiger auf Vorgabe holen
        POP     BC              ; Anzahl Bytes holen
        RET
;
;
        DEFS    22,0
;
;
;   Weiterleitung Sprung auf Kaltstart  BASIC - Interpreter
;
        JP      _START          ; Kaltstart BASIC - Programm
;
;
;   Abfrage, ob aktuelles Gerät gleich Bildschirm ist
;
A1803:  LD      A,(S1042)       ; interne aktuelle Geräte-/Dateinummer holen
        CP      136             ; gleich Bildschirm  (CRT:)  ?
        RET
;
;
;   Speicherbereich für Daten der aktuellen Datei
;
S1809:  DEFS    2               ; Zeiger auf aktuelle Dateikennung
;
S180B:  DEFS    2               ; Zeiger auf Anfang Speicher für Sektor
;
S180D:  DEFS    2               ; Zeiger auf Sektornummer im Sektor
;
;
;   Text (DE) auf angewähltem Gerät oder Datei ausgeben
;
;   (SVC code:  55)
;
PRTSTR: CALL    A181A           ; interne Geräte-Nummer als AUsgabe-Nummer vorgeben
        CALL    A1821           ; Text (DE) auf Datei/Gerät ausgeben
;
;
;   Ausgabe - Geräte - Nummer zurücksetzen
;
A1815:  XOR     A               ; Accu auf Null
        LD      (S1FD9),A       ; Ausgabe - Geräte - Nummer zurücksetzen
        RET
;
;
;   interne Geräte-Nummer als Ausgabe - Nummer vorgeben
;
A181A:  LD      A,(S1042)       ; interne aktuelle Geräte-/Dateinummer holen
        LD      (S1FD9),A       ; als Ausgabe - Geräte - Nummer merken
        RET
;
;
;   Text (DE) auf aktuellem Gerät oder aktueller Datei ausgeben
;
A1821:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      A,(S1050)       ; Geräte - Typ - Byte holen
        BIT     7,A             ; nicht Block - orientiertes Gerät  ?
        LD      HL,T1848        ; Adresse  'Zeichen an Datei ausgeben'
        JR      Z,A183D         ; Text (DE) mit Länge in B über Routine (HL) ausgeben
        BIT     3,A             ; Zeilenorientertes Gerät  ?
        LD      HL,T1835        ; Adresse  'Text über Ausgaberoutine ausgeben'
        JR      NZ,A183D        ; Text (DE) mit Länge in B über Routine (HL) ausgeben
T1835:  LD      IX,(S105F)      ; Adresse  'Daten ausgeben'  aus Geräte - Tabelle holen
        CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        RET
;
;
;   in B angegebene Anzahl Bytes (DE) nach Routine (HL) ausgeben
;
A183D:  LD      A,B             ; Restanzahl Zeichen holen
        OR      A               ; Restanzahl gleich Null  ?
        RET     Z               ; ja -->  fertig
        LD      A,(DE)          ; ein Zeichen holen
        CALL    A00A7           ; JP (HL)   (Routine mit Adresse (HL) aufrufen)
        INC     DE              ; ausgegebenes Textzeichen überspringen
        DEC     B               ; Restanzahl Zeichen minus eins
        JR      A183D           ; testen, ob fertig
;
;
;   Zeichen im Accu an Datei ausgeben
;
T1848:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      E,(IY+64)       ;! relativen Sektorzeiger holen
        LD      D,(IY+65)       ;!
        LD      HL,(S180B)      ; Zeiger auf Anfang Speicher für Sektor holen
        ADD     HL,DE           ; Zeiger auf Stelle für Zeichen errechnen
        LD      (HL),A          ; Textzeichen im Speicher für Sektor merken
        INC     DE              ; relativen Sektorzeiger plus eins
        LD      HL,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Sektor (oder Block) voll  ?
        CALL    Z,A1871         ; ja -->  Sektor wegschreiben
        LD      (IY+64),E       ;! neuen relativen Sektorzeiger merken
        LD      (IY+65),D       ;!
        INC     (IY+20)         ; Low - Byte Dateilänge plus eins
        RET     NZ              ; kein Übertrag -->  fertig
        INC     (IY+21)         ; High - Byte Dateilänge plus eins
        RET     NZ              ; kein Übertrag -->  OK
        JP      A1FA6           ; Fehler 55'  Too long file error
;
;
;   aktuellen Sektor der Datei wegschreiben
;
A1871:  PUSH    BC              ; Keep register value
        LD      B,0010B         ; Code for 'Schreiben / nicht letzter Sektor'
A1874:  CALL    A1D27           ; aktuelles Gerät gleich Diskette  ?
        LD      IX,T1835        ; Adresse  'Sektor über Geräte-Ausgabe-Routine ausgeben'
        JR      Z,A1881         ; nicht Diskette -->  über Geräte-Ausgabe-Routine ausgeben
        LD      IX,A30D7        ; Adresse  'Sektor auf Diskette wegschreiben'   (nur RET)
A1881:  LD      A,B             ; Dateiendecode holen
        CALL    A18B6           ; Daten des aktuellen  (Sektoren-) Blocks laden
        CALL    A1890           ; Routine  (IX)  aufrufen
        INC     (IY+78)
        LD      DE,0            ; Vorgabe  'keine Zeichen im Sektor'
        POP     BC              ; geretteten Register - Wert holen
        RET
;
A1890:  JP      (IX)            ; Routine (IX) aufrufen
;
;
;   Dateiendezeichen in Datei eintragen und letzten Sektor/Block schreiben
;
A1892:  LD      A,CTRL_Z        ; Dateiendezeichen
        LD      E,(IY+64)       ;! relativen Sektorzeiger holen
        LD      D,(IY+65)       ;!
A189A:  LD      HL,(S180B)      ; Zeiger auf Anfang Speicher für Sektor holen
        ADD     HL,DE           ; Zeiger auf aktuelle Stelle im Sektorspeicher errechnen
        LD      (HL),A          ; Dateiendezeichen eintragen
        INC     DE              ; relativen Sektorzeiger plus eins
        LD      HL,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Zeiger auf Ende Sektor  ?
        JR      NZ,A189A        ; nein -->  Rest Speicher mit Dateiendezeichen auffüllen
        PUSH    BC              ; Keep register value
        LD      HL,(S180B)      ; Zeiger auf Anfang Speicher für Sektor holen
        DEC     HL              ; Zeiger auf Stelle für Block - Nummer
        LD      (HL),-1         ;! Code for 'letzter Block'  eintragen
        DEC     HL              ;!
        LD      (HL),-1         ;!
        LD      B,0110B         ; Code for 'Schreiben / letzter Sektor'
        JR      A1874           ; letzten Sektor der Datei wegschreiben
;
;
;   Daten des aktuellen  (Sektoren-) Blocks laden
;
A18B6:  LD      BC,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        INC     BC              ;! für wahre Sektorlänge oder Blocklänge corrigieren
        INC     BC              ;!
        LD      HL,(S180B)      ; Zeiger auf Anfang Speicher für Sektor holen
        DEC     HL              ;! Zeiger auf Stelle für Block - Nummer setzen
        DEC     HL              ;!
        LD      DE,(S1809)      ; Zeiger auf aktuellen Dateikennungseintrag holen
        RET
;
;
;   Gerät in 'Stand By' schalten
;
B18C6:  DEFB    OR_N            ; Code for 'Stand By'
;
;
;   Datei auf Gerät nach Tabellenadresse schliessen
;
A18C7:  XOR     A               ; Code for 'Datei schliessen'
        LD      IX,(S1059)      ; Adresse  'Datei schliessen' aus Geräte-Tabelle holen
        CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        RET
;
;
;   wenn aktuelles Gerät gleich Bildschirm -->  Zeile von Tastatur holen
;
;   (SVC code:  52)
;
INPSTRT:
        CALL    A1803           ; Abfrage, ob aktuelles Gerät gleich Bildschirm ist
        RET     NZ              ; nicht Bildschirm -->  fertig
        PUSH    DE              ; Keep register value
        LD      DE,S11A4        ; Zeiger auf Zwischenspeicher vorgeben
        CALL    A0A67           ; Zeiger von Tastatur holen und Zeiger auf Eingabe stellen
        LD      (A193B + 1),DE  ; Zeiger auf eingegebenen Text in Routine eintragen
        POP     DE              ; geretteten Register - Wert holen
        RET     NC              ; Eingabe nicht geBREAKt
        JP      BREAKZ          ; Programm abbrechen  (BREAK)
;
;
;   einen Datensatz aus Datei oder vom angewähltem Gerät bereitstellen
;   (mit Untersuchung auf 'End of File')
;
;   (SVC code:  53)
;
INPMSG: PUSH    HL              ; Keep register value
        PUSH    DE              ; Zeiger auf Stelle für Datensatz merken
        CALL    A181A           ; interne Geräte-Nummer als Ausgabe-Nummer vorgeben
        LD      HL,(S1040)      ; Zeiger auf aktuellen Daten-Verwaltungssatz holen
        INC     HL              ; Datei - Nummer überspringen
        BIT     7,(HL)          ; EOF - Bit gesetzt   ?
        PUSH    HL              ; Zeiger auf EOF - Bit retten
        LD      B,0             ; Code for 'keine Zeichen bereitgestellt'  vorgeben
        SCF                     ; vorsorglich schon mal EOF - Flag setzen
        CALL    Z,A1913         ; nicht EOF -->  einen Datensatz bereitstellen
        POP     HL              ; Zeiger auf EOF - Bit holen
        CALL    C,A1908         ; End of File -->  merken
        POP     DE              ; Zeiger auf Stelle für Datensatz holen
        PUSH    AF              ; Ergebnisflag retten
        CALL    A1815           ; Ausgabe - Geräte - Nummer zurücksetzen
        LD      L,B             ; bereitgestellte Anzahl Zeichen vorgeben
        LD      H,0             ; High - Byte Offset auf Null
        ADD     HL,DE           ; Zeiger auf Ende der bereitgestellten Daten errechnen
        LD      (HL),NUL        ; Textendezeichen eintragen
        POP     AF              ; gerettetes Ergebnisflag holen
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;   End of File  setzen und eventuell Fehler ausgeben
;
A1908:  SET     7,(HL)          ; Code for 'End of File'  setzen
        LD      HL,ZFLAG2       ; Geräte - Nummer - Flag holen
        BIT     4,(HL)          ; End - of File nicht erlaubt  ?
        RET     Z               ; End of File erlaubt
        JP      A1FB5           ; Fehler 63   Out of file error
;
;
;   einen Datensatz von Gerät/Datei bereitstellen
;
A1913:  CALL    A1803           ; Abfrage, ob aktuelles Gerät gleich Bildschirm ist
        JR      Z,A193B         ; Bildschirm -->  untersuchen, ob noch Text vorhanden ist
        LD      A,(S1050)       ; Geräte - Typ - Byte holen
        BIT     7,A             ; nicht Block - orientiertes Gerät  ?
        LD      HL,T1991        ; Adresse  'ein Zeichen aus Datenblock Datei bereitstellen'
        JR      Z,A1975         ; Block - Orientiertes Gerät
        BIT     2,A             ; 'Gerät stellt nur einzelne Zeichen zur Verfügung'  ?
        LD      HL,A1929        ; Adresse  'Daten bereitstellen aufrufen'  vorgeben
        JR      NZ,A1975        ; ja -->  Datensatz über einzelne Zeichen einlesen
A1929:  LD      IX,(S105D)      ; Anfangsadresse  'Daten bereistellen' aus Geräte-Tabelle holen
        CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        RET
;
;
;   Fragezeichen ausgeben und Zeile von Tastatur holen
;
A1931:  LD      A,'?'           ; ?   (Fragezeichen)  vorgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausführung Steuerzeichen)
        LD      A,' '           ; Leerzeichen  (Space)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausführung Steuerzeichen)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    52              ; Code 52  wenn akt. Gerät=Bildschirm -->  Zeile von Tastatur
A193B:  LD      HL,0            ; Zeiger auf Text holen  (wird eingetragen)
        CALL    HLFTCH          ; Leerzeichen (Spaces)  (HL) überspringen
        OR      A               ; Textendezeichen  (NUL)  ?
        JR      Z,A1931         ; ja -->  erneut Text von Tastatur holen
        LD      C,NUL           ; Textendezeichen als Endezeichen vorgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    54              ; Code 54  Textkonstante (HL) bis Zeichen in C bereitstellen
        LD      (A193B + 1),HL  ; Zeiger auf Resttext wieder in Routine eintragen
        RET
;
;
;   Textkonstante (HL) bis Trennzeichen oder Zeichen in C nach (DE) bereitstellen
;
;   (SVC code:  54)
;
INPDT:  LD      B,0             ; Zähler  'Anzahl übertragene Zeichen '  auf Null
        CALL    TEST1           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFB    '\"'            ; Anführungszeichen  (Kennung Textkonstante)  ?
        JR      NZ,A1967        ; kein Anführungszeichen
A1954:  LD      A,(HL)          ; ein Zeichen Text holen
        OR      A               ; Textendezeichen  (NUL)   ?
        RET     Z               ; ja -->  fertig
        INC     HL              ; Zeiger auf Text auf nächstes Zeichen
        CP      '\"'            ; Anführungszeichen  ?
        JR      Z,A1961         ; ja -->  wenn nächstes Zeichen Komma -->  vergessen
        LD      (DE),A          ; Textzeichen merken
        INC     DE              ; Zeiger auf Speicher für Text auf nächste Stelle
        INC     B               ; Zähler  'Anzahl übertragene Zeichen '  plus eins
        JR      A1954           ; testen, ob weitere Zeichen
;
A1961:  CALL    TEST1           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    ","             ; Komma  ?
        OR      A               ; Carry - Flag zurücksetzen   (Code for 'kein Fehler')
        RET
;
A1967:  LD      A,(HL)          ; ein Zeichen Text holen
        OR      A               ; Textendezeichen  (NUL)   ?
        RET     Z               ; ja -->  fertig
        CP      C               ; gleich vorgegebenem Textendezeichen  ?
        RET     Z               ; ja -->  fertig
        INC     HL              ; Textzeichen überspringen
        CP      ','             ; Komma als Trennzeichen  ?
        RET     Z               ; ja -->  fertig
        LD      (DE),A          ; Textzeichen merken
        INC     DE              ; Zeiger auf Speicher für Text auf nächste Stelle
        INC     B               ; Zähler  'Anzahl übertragene Zeichen'  plus eins
        JR      A1967           ; testen, ob weitere Zeichen
;
;
;   einen Datensatz aus Datei über einzelne Zeichen bereitstellen
;
A1975:  LD      (A197A + 1),HL  ; CALL - Adresse in Routine eintragen
        LD      B,0             ; Zähler  'Anzahl bereitgestellte Zeichen'  auf Null
A197A:  CALL    0               ; ein Zeichen bereitstellen   (Adresse wird eingetragen)
        RET     C               ; Fehler aufgetreten -->  Abbruch
        CP      CR              ; Textendezeichen  ?
        RET     Z               ; ja -->  fertig
        LD      (DE),A          ; bereitgestelltes Zeichen merken
        INC     DE              ; Zeiger auf Speicher für Text auf nächste Stelle
        INC     B               ; Zähler  'Anzahl bereitgestellte Zeichen'  plus eins
        JR      NZ,A197A        ; noch OK -->  weitere Zeichen bereitstellen
        JP      A1F8B           ; Fehler  41   Hardware error
;
;
;   nächsten Datenblock der Datei  (oder ein Zeichen)  bereitstellen
;
;   (SVC code:  39)
;
INP1C0: LD      A,(S1050)       ; Geräte - Typ - Byte holen
        BIT     7,A             ; nicht Block - orientiertes Gerät  ?
        JP      NZ,A1FAC        ; ja -->  Fehler 59'  Can't execute error
T1991:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      E,(IY+64)       ;! relativen Sektorzeiger holen
        LD      D,(IY+65)       ;!
        LD      HL,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; alle Zeichen aus Speicher geholt  ?
        CALL    Z,A19BC         ; ja -->  nächsten Sektor oder Block einlesen
        RET     C               ; Fehler aufgetreten -->  Abbruch
        LD      L,(IY+78)
        LD      H,(IY+79)
        XOR     A               ; Accu auf Null / Carry - Flag zurücksetzen
        SBC     HL,DE
        SCF                     ; Code for 'Fehler aufgetreten' setzen
        RET     Z               ; keine Zeichen mehr vorhanden
        LD      HL,(S180B)      ; Zeiger auf Anfang Speicher für Sektor holen
        ADD     HL,DE           ; Zeiger auf aktuelle Stelle im Sektor errechnen
        LD      A,(HL)          ; Zeichen aus Speicher für Sektor holen
        INC     DE              ; relativen Zeiger auf Sektor auf nächstes Zeichen
        LD      (IY+64),E       ;! neuen relativen Sektorzeiger merken
        LD      (IY+65),D       ;!
        RET
;
;
;   nächsten Sektor aus Datei einlesen
;
A19BC:  CALL    A1D27           ; aktuelles Gerät gleich Diskette  ?
        JP      NZ,A321C        ; ja -->  nächsten Sektor von Diskette lesen
        DEFB    OR_N            ; Code for 'nächsten sektor lesen'
;
;
;   ersten Sektor der Datei einlesen
;
A19C3:  XOR     A               ; Code for 'ersten Sektor lesen'
        CALL    A18B6           ; Daten des aktuellen  (Sektoren-) Blocks laden
        CALL    A1929           ; Datenblock nach Adresse in Geräte-Tabelle bereitstellen
        RET     C               ; Fehler aufgetreten -->  Abbruch
        LD      A,(HL)          ;! Block - Nummer gleich 0FFFFH   (letzter Block)  ?
        INC     HL              ;!
        AND     (HL)            ;!
        LD      (HL),255        ;      255 Zeichen im Block
        INC     A               ;!
        LD      DE,0            ; Offset auf Speicherblock vorgeben
        RET     NZ              ; nicht letzter Block
        PUSH    HL
        LD      HL,(S180D)      ; Zeiger auf Sektornummer im Sektor holen
        LD      BC,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
A19DD:  DEC     HL              ; Zeiger auf vorheriges Zeichen
        DEC     BC              ; Zähler  'Restanzahl Zeichen'  minus eins
        LD      A,(HL)          ; ein Zeichen holen
        OR      A               ; gleich NUL   (Textendezeichen)  ?
        JR      Z,A19DD         ; ja -->  letztes relevantes Zeichen suchen
        POP     HL
        LD      (HL),B          ;! Restanzahl Zeichen im Block eintragen
        DEC     HL              ;!
        LD      (HL),C          ;!
        RET
;
;
;   internen Datei - Verwaltungs - Datensatz nach Datei-/Geräte-Nummer aufbereiten
;
;   (SVC code:  46)
;
LUCHK:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      HL,B1A35        ; Zeiger auf Vorgabe für Gerät Bildschirm  (CRT:)
        CP      136             ; Gerät Bildschirm  ?
        JR      Z,A19FC         ; ja -->  Daten für Bildschirm vorgeben
        LD      HL,B1A3D        ; Zeiger auf Vorgabe für Gerät Drucker  (LPT:)
        CP      137             ; Gerät Drucker  ?
        JR      Z,A19FC         ; ja -->  Daten für Drucker vorgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    41              ; Code 41  Zeiger auf Datensatz nach Datensatznr bereitstellen
        RET     C               ; Datei - Datensatz nicht gefunden -->  Abbruch
A19FC:  LD      (S1040),HL      ; Zeiger auf aktuellen Daten-Verwaltungssatz merken
        LD      DE,S1042        ; Zeiger auf Stelle für aktuellen Geräte-/Dateiverwaltungsdatensatz
        LD      BC,8            ; Zugriffscode / Zeiger / Nummer / USR - Adresse
        LDIR                    ; Daten übertragen
        LD      (S1809),HL      ; Zeiger auf aktuelle Dateikennung merken
        PUSH    HL              ;! Zeiger auf Dateikennung nach IY übertragen
        POP     IY              ;!
        LD      DE,S1000        ; Zeiger auf Speicher für Dateikennung vorgeben
        CALL    A1C66           ; 64 Byte  (Länge Kennungsdaten)  von (HL) nach (DE) übertragen
        PUSH    HL              ; Zeiger auf Ende Kennung retten
        LD      HL,(ZEQT)       ; Zeiger auf aktuelle Geräte - Tabelle holen
        LD      DE,S104A        ; Zeiger auf Speicher für Geräte - Tabelle vorgeben
        LD      BC,29           ; Länge Geräte - Tabelle vorgeben
        LDIR                    ; Geräte - Tabelle in Speicher übertragen
        POP     HL              ; Zeiger auf Ende Kennung holen
        LD      BC,16           ; Offset auf Anfang Sektor
        ADD     HL,BC           ; Zeiger auf Anfang Sektor errechnen
        LD      (S180B),HL      ; Zeiger auf Anfang Speicher für Sektor merken
        LD      BC,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        ADD     HL,BC           ; Zeiger auf Stelle für Sektornummer errechnen
        LD      (S180D),HL      ; Zeiger auf Sektornummer im Sektor merken
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        AND     00001111B       ; eigentlichen Zugriffscode  maskieren
        RET
;
;
;   Vorgabe für Dateidaten für Gerät  Bildschirm
;
B1A35:  DEFB    136             ; interne Geräte - Nummer  Gerät CRT:
        DEFB    00000011B       ; Lesen / Schreiben möglich
        DEFW    W0DDD           ; Zeiger auf Geräte - Tabelle Bildschirm
        DEFW    0
        DEFW    0
;
;
;   Vorgabe für Dateidaten für Gerät  Drucker
;
B1A3D:  DEFB    137             ; interne Geräte - Nummer  Gerät LPT:
        DEFB    00000010B       ; Schreiben  möglich
        DEFW    W1479           ; Zeiger auf Geräte - Tabelle  Drucker
        DEFW    0
        DEFW    0
;
;
;   Text (DE) auf Geräte - Namen auswerten und als aktuelles Gerät bereitstellen
;
;   (SVC code:  44)
;
DEV:    LD      HL,S11A4        ; Zeiger auf Zwischenspeicher für Text vorgeben
        PUSH    HL              ; Zeiger auf Anfang Speicher retten
        LD      A,B             ; Textlänge holen
        OR      A               ; gleich Null  ?
        CALL    NZ,LDHLDE       ; nein -->  Speicherbereicè voî (DE© nacè (HL© verschieben
        LD      (HL),NUL        ; Textende hinter bereitgestelltem Text eintragen
        LD      HL,W0DDD        ; Zeiger auf erstes Gerät in Tabellenkette
        JR      A1A58           ; richtige Geräte - Tabelle suchen
;
A1A55:  LD      HL,0            ; Zeiger auf nächste Geräte-Tabelle  (wird eingetragen)
A1A58:  LD      A,L             ;! Zeiger gleich Null  (Ende Kette)  ?
        OR      H               ;!
        JR      Z,A1A91         ; ja -->  DEFAULT - Gerät vorgeben
        LD      (D1A8B + 1),HL  ; Zeiger auf aktuelle Tabelle in Routine eintragen
        CALL    LDDEMI          ; Adresse aus Tabelle (HL) nach DE holen
        LD      (A1A55 + 1),DE  ; Zeiger auf nächste Tabelle in Routine eintragen
        LD      DE,S11A4        ; Zeiger auf Speicher mit Geräte - Namen
        EX      DE,HL           ; Zeiger vertauschen
A1A6A:  LD      A,(DE)          ; ein Zeichen aus Geräte - Tabelle holen
        OR      A               ; Textendezeichen  (NUL)   ?
        JR      Z,A1A75         ; ja -->  untersuchen, ob Geräte - Nummer
        CP      (HL)            ; Zeichen mit Geräte - Namen vergleichen
        JR      NZ,A1A55        ; nicht gleich -->  nächsten Geräte - Namen testen
        INC     HL              ; Zeiger auf vorgegebenen Namen auf nächstes Zeichen
        INC     DE              ; Zeiger auf Namen in Tabelle auf nächstes Zeichen
        JR      A1A6A           ; nächstes Zeichen Name vergleichen
;
A1A75:  LD      A,(HL)          ; nächstes Zeichen Geräte - Name holen
        INC     HL              ; Zeichen überspringen
        CP      ':'             ; Doppelpunkt   (Namenendezeichen)   ?
        LD      C,0             ; Vorgabe für Geräte - Nummer
        JR      Z,A1A8A         ; keine Geräte - Nummer im Namen
        SUB     '1'             ; Nummer umrechnen in Dezimal-Wert
        CP      9               ; Gerät eins bis acht  ?
        JR      NC,A1A55        ; nein -->  auf nächste Geräte - Tabelle vergleichen
        LD      C,A             ; Geräte - Nummer merken
        LD      A,(HL)          ; nächstes Textzeichen holen
        INC     HL              ; Textzeichen überspringen
        CP      ':'             ; Doppelpunkt  (Namenendezeichen)   ?
        JR      NZ,A1A55        ; nein -->  nächste Geräte - Tabelle vergleichen
A1A8A:  EX      (SP),HL         ; Zeiger verwerfen / Zeiger auf Dateinamen retten
D1A8B:  LD      HL,0            ; Zeiger auf Geräte-Tabelle   (wird eingetragen)
        LD      A,C             ; Geräte - Nummer holen
        JR      A1AA3           ; Geräte - Nummer und Zeiger auf Tabelle merken
;
A1A91:  POP     HL              ; Zeiger auf Geräte - Namen holen
        PUSH    HL              ; und wieder merken
A1A93:  LD      A,(HL)          ; ein Zeichen holen
        INC     HL              ; Zeiger auf Namen auf nächstes Zeichen
        CP      ':'             ; Doppelpunkt   ?
        JP      Z,A1FA9         ; ja -->  Fehler 58  Dev. name error
        OR      A               ; Textendezeichen  (NUL)  ?
        JR      NZ,A1A93        ; nein -->  Rest Name auf Doppelpunkt überprüfen
        LD      HL,(DDEV)       ; Zeiger auf Geräte - Tabelle  (DEFAULT) holen
        LD      A,(DCHAN)       ; Geräte - Nummer  (DEFAULT)  holen
A1AA3:  LD      (ZEQT),HL       ; Zeiger auf aktuelle Geräte - Tabelle merken
        PUSH    HL              ; Zeiger merken
        LD      (ZCH),A         ; aktuelle Geräte - Nummer merken
        LD      DE,S104A        ; Zeiger auf Speicherbereich für Geräte - Tabelle
        LD      BC,29           ; Länge Geräte - Tabelle
        LDIR                    ; Geräte - Tabelle in Speicher übertragen
        LD      B,A             ; Geräte - Nummer merken
        LD      A,(ZFLAG2)      ; Geräte - Nummern - Flag holen
        AND     00000111B       ; maximale Geräte - Nummer maskieren
        CP      B               ; mit angegebener Geräte-Nummer vergleichen
        JP      C,A1FA9         ; Nummer zu groß -->  Fehler 58  Dev. name error
        LD      A,B             ; Geräte - Nummer holen
        POP     DE              ; Zeiger auf aktuelle Geräte - Tabelle holen
        POP     HL              ; Zeiger auf Resttext mit Dateinamen holen
        RET
;
;
;   Text (DE) auf Geräte - Namen und Datei - Namen auswerten
;
;   (Software- Kommando  45)
;
DEV_FN: CALL    PUSHR           ; Save registers IX, HL, BC and DE
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    44              ; Code 44   Text (DE) auf Geräte - Namen auswerten
        EX      DE,HL           ; Zeiger auf Datei - Namen nach DE
        LD      HL,S1001        ; Zeiger auf Speicher für Dateinamen in Kennung
        LD      B,31            ; Restlänge Dateikennung
        CALL    CLRHL           ; Speicherbereich (HL) löschen
        LD      HL,S1000        ; Zeiger auf Speicherbereich für Dateikennung
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    23              ; Code 23  Länge des Textes (DE) auszählen
        CALL    A1EC9           ; Dateinamen aus Text (DE) nach (HL) bereitstellen
        LD      HL,S1050        ; Zeiger auf Geräte - Typ - Byte vorgeben
        BIT     4,(HL)          ; auf Dateinamen untersuchen  ?
        RET     Z               ; nein -->  fertig
        INC     HL              ; Zeiger auf Geräte - Nummern - Byte
        BIT     7,(HL)          ; muß Dateiname angegeben sein  ?
        RET     NZ              ; nein -->  fertig
        LD      A,(S1001)       ; erstes Zeichen des aufbereiteten Dateinamens holen
        CP      CR              ; gleich Namenendezeichen  ?
        JP      Z,A1FAF         ; ja -->  Fehler 60  Illegal filename error
        RET
;
;
;   Datei nach bereitgestellten Daten eröffnen
;
;   (Software- Kommando  51)
;
RWOPEN: CALL    PUSHR           ; Save registers IX, HL, BC and DE
        CALL    A1AF7           ; Speicherplatz für Verwaltung reservieren / Datei eröffnen
        LD      B,00000000B     ; Code for 'Vom Basic verarbeitbare Datei'
        CALL    A1BA9           ; Datei - Kennung überprüfen
        JP      A34CE           ; nicht mehr benötigte Diskettendaten löschen
;
;
;   Speicherbereich für Verwaltungsdatensatz im Rechner reservieren
;   und Datei auf Gerät eröffnen
;
A1AF7:  LD      A,(S1042)       ; interne aktuelle Geräte-/Dateinummer holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    41              ; Code 41  Zeiger auf Datensatz nach Datensatznr bereitstellen
        JP      NC,A1F91        ; Datensatz gefunden -->  Fehler 43`  Already open error
        CALL    A1C6D           ; testen, ob auf gerät nicht schon Datei eröffnet ist
        LD      HL,64 + 29      ; Länge  Datei - Kennung und Geräte - Tabelle
        LD      A,(S1050)       ; Geräte - Typ - Byte holen
        LD      DE,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        INC     DE              ;! auf Sektorlänge corrigieren
        INC     DE              ;!
        BIT     7,A             ; nicht Block - orientiertes Gerät  ?
        JR      NZ,A1B13        ; ja -->  kein Sektorpuffer
        ADD     HL,DE           ; Sektorlänge addieren
A1B13:  LD      A,(S1043)       ; Datei - Zugriffscode holen
        BIT     2,A             ; RANDOM - Datei  ?
        JR      Z,A1B1B         ; nein
        ADD     HL,DE           ; Sektorlänge noch einmal addieren
A1B1B:  EX      DE,HL           ; Speicherlänge für Datei - Datensatz nach DE
        LD      A,(S1042)       ; interne aktuelle Geräte-/Dateinummer holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    42              ; Code 42   dynamischen Zwischenspeicher bereitstellen
        LD      (S1FD9),A       ; Ausgabe - Geräte - Nummer merken
        LD      (S1040),HL      ; Zeiger auf aktuellen Daten-Verwaltungssatz merken
        EX      DE,HL           ; Zeiger auf Speicher für Datei-Datensatz nach DE
        LD      HL,S1042        ; Zeiger auf interne Geräte - Nummer / Dateinummer
        LD      BC,8            ; Datensatzlänge
        LDIR                    ; aktuellen Datensatz in Datei - Daten merken
        LD      (S1809),DE      ; Zeiger auf aktuelle Datei - Kennung merken
        PUSH    DE              ;! Zeiger auf Datei - Kennung nach IY holen
        POP     IY              ;!
        LD      HL,S1000        ; Zeiger auf Speicher mit aufbereiteter Dateikennung
        CALL    A1C66           ; 64 Byte  (Länge Kennungsdaten)  von (HL) nach (DE) übertragen
        LD      HL,16           ; Abstand zum Sektorspeicher
        ADD     HL,DE           ; Zeiger auf Sektorspeicher errechnen
        LD      (S180B),HL      ; Zeiger auf Anfang Speicher für Sektor merken
        LD      DE,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        ADD     HL,DE           ; Zeiger auf Stelle für Sektornummer errechnen
        LD      (S180D),HL      ; Zeiger auf Stelle für Sektornummer im Sektor merken
        CALL    A1D27           ; aktuelles Gerät gleich Diskette  ?
        JP      NZ,A334F        ; ja -->  Datei auf Diskette eröffnen
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        BIT     2,A             ; Schreib - Lesezugriff  (RANDOM-Datei)  ?
        JP      NZ,A1FAC        ; ja -->  Fehler 59'  Can't execute error
        BIT     1,A             ; Datei zum Schreiben eröffnen  ?
        LD      IX,(S1057)      ; Adresse  'Datei zum Schreiben eröffnen'  holen
        JR      NZ,A1B6D        ; Datei zum Schreiben eröffnen
        LD      A,(S1050)       ; Geräte - Typ - Byte holen
        BIT     7,A             ; nicht Block - orientiertes Gerät  ?
        JR      Z,A1B73         ; nein
        LD      IX,(S1055)      ; Adresse  'Datei zum Lesen eröffnen'  holen
A1B6D:  LD      HL,S1000        ; Zeiger auf aufbereitete Datei - Kennung
        JP      IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
;
A1B73:  LD      B,(IY+0)        ; Datei - Typ - Flag aus Datensatz holen
        CALL    A1C4B           ; Datei zum Lesen eröffnen
        LD      A,(S1000)       ; Datei-Typ-Flag aus bereitgestellter Kennung holen
        CP      B               ; mit Datei - Typ - Flag vergleichen
        JP      NZ,A1FB2        ; nicht gleich -->  Fehler 61
        JP      A19C3           ; ersten Sektor der Datei lesen
;
;
;   Datei zum Lesen eröffnen     (SVC code:  47)
;
LOPEN:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      IY,256 * 1 + 0  ; Code for 'Datei zum Lesen eröffnen'
        LD      (S1042),IY      ; als interne aktelle Geräte-Nummer/Zugriffscode merken
        LD      IY,S1000        ; Zeiger auf Speicher für Dateikennung vorgeben
        CALL    A1D27           ; aktuelles Gerät gleich Diskette  ?
        LD      HL,T334A        ; Adresse  'Datei auf Diskette eröffnen'
        JR      NZ,A1B9D        ; ja -->  Datei auf Diskette eröffnen
        LD      HL,A1C4B        ; Adresse  'Datei zum Lesen eröffnen'
A1B9D:  CALL    A00A7           ; JP (HL)   (Routine mit Adresse (HL) aufrufen)
        LD      B,10000000B     ; Code for 'vom Basic nicht bearbeitbare Datei'
        CALL    A1BA9           ; Datei - Kennung überprüfen
        LD      A,(S1000)       ; Datei - Typ - Flag holen
        RET
;
;
;   Datei - Kennung überprüfen
;
A1BA9:  LD      A,(S1000)       ; Datei - Typ - Kennung holen
        CP      _BRD + 1        ; bekannte Datei - Kennung  ?
        RET     C               ; ja -->  OK
        LD      A,(S1012)       ; Schreib - Schutz - Flag holen
        AND     10000000B       ; Bit  'vom Basic bearbeitbar'  maskieren
        CP      B               ; gleich richtigem Status  ?
        RET     Z               ; ja
        JP      A1FB2           ; Fehler 61, Illegal filemode error
;
;
;   Datei schliessen oder Dateidaten im Rechner löschen
;
;   (SVC code:  56)
;
CLKL:   CALL    PUSHR           ; Save registers IX, HL, BC and DE
        OR      A               ; Datei - Nummer angegeben  ?
        JR      Z,A1BFF         ; nein -->  alle Dateien behandeln
        CALL    A1BC5           ; Datei mit Nummer im Accu schliessen oder Dateidaten löschen
        JP      A34CE           ; nicht mehr benötigte Diskettendaten löschen
;
;
;   Datei mit Nummer im Accu schliessen oder Daten der Datei im Rechner löschen
;
A1BC5:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    46              ; Code 46   Datei-Verwaltungssatz nach Nummer bereitstellen
        RET     C               ; keine Datei - Daten im Rechner
        CALL    A181A           ; interne Geräte-Nummer als Ausgabe-Nummer vorgeben
        PUSH    AF              ; interne Geräte - Nummer merken
        CALL    A1D27           ; aktuelles Gerät gleich Diskette  ?
        JR      NZ,A1BF3        ; ja -->  Datei auf Diskette
        BIT     7,A             ; nicht Block - orientiertes Gerät  ?
        LD      A,B             ; FLag  'Schließen/Löschen'  holen
        JR      Z,A1BE6         ; Block - orientiertes Gerät
        OR      A               ; Schließen oder Löschen  ?
        LD      IX,(S105B)      ; Anfangsadresse der KILL - Routine holen
        JR      Z,A1BE1         ; Datei - Daten löschen
        LD      IX,(S1059)      ; Anfangsadresse der CLOSE - Routine holen
A1BE1:  CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        JR      A1BF6           ; dynamisches Segment löschen
;
A1BE6:  OR      A               ; Datei schliessen oder Dateidaten löschen
        JR      Z,A1BF6         ; Datei - Daten im Rechner löschen
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        BIT     1,A             ; Datei zum Schreiben geöffnet  ?
        CALL    NZ,A1892        ; ja -->  Dateiendezeichen eintragen/Sektor wegschreiben
        JR      A1BF6           ; dynamisches Segment löschen
;
;
;   Datei auf Diskette schliessen oder Dateidaten im Rechner löschen
;
A1BF3:  CALL    A33C1           ; Datei, wenn nötig ins Inhaltsverzeichnis eintragen
A1BF6:  POP     AF              ; Interne Datei - Nummer holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    43              ; Code 43   dynamischen Zwischenspeicher löschen
        RET
;
;
;   alle Dateidaten im Rechner löschen     (SVC code:  40)
;
CLRIO:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      B,0             ; Code for 'Dateidaten löschen'
;
;
;   alle offenen Dateien schliessen oder alle Datedaten im Rechner löschen
;
A1BFF:  LD      C,142           ; interne Datei - Nummer vorgeben
A1C01:  LD      A,C             ; Datei - Nummer holen
        PUSH    BC              ; Flag und Datei - Nummer retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    41              ; Code 41  Zeiger auf Datensatz nach Datensatznr bereitstellen
        CALL    NC,A1BC5        ; Datensatz vorhanden -->  Datei schliessen oder Dateidaten löschen
        POP     BC              ; Flag und Datei - Nummer holen
        DEC     C               ; Datei - Nummer minus eins
        JR      NZ,A1C01        ; weitere Dateien schliessen oder Datei - Daten löschen
        JP      ERRCVR          ; Datei-Daten der Ausgabe-Datei  (wenn vorhanden)  löschen
;
;
;   testen, ob  Datei - Name schon auf Gerät / Datenträger vorhanden ist
;
A1C0F:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      A,(S1050)       ; Geräte - Typ - Byte holen
        BIT     6,A             ; mehrere Dateinamen zulässig  ?
        JP      Z,A1FAC         ; nein -->  Fehler 59'  Can't execute error
        CALL    A18C7           ; Datei auf Gerät nach Tabellenadresse schliessen
        LD      A,(S1052)       ; maximale Anzahl Dateien auf Gerät/Dateiträger holen
        LD      B,A             ; Zähler merken
A1C21:  LD      HL,S11A4        ; Zeiger auf Zwischenspeicher vorgeben
        PUSH    BC              ; Zähler retten
        LD      IX,(S1055)      ; Adresse  'Datei zum Lesen eröffnen'  aus Geräte - Tabelle holen
        CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        POP     BC              ; geretteten Zähler holen
        SET     0,A             ; Code for 'Fehler'  setzen
        RET     C               ; Fehler aufgetreten -->  Abbruch
        PUSH    IY              ;! Zeiger auf Kennung der aktuellen Datei nach DE
        POP     DE              ;!
        CALL    A1EB2           ; Dateinamen (HL) mit Dateinamen (DE) vergleichen
        LD      A,(HL)          ; Datei - Typ - Kennung holen
        RET     Z               ; Datei - Namen gleich
        DJNZ    A1C21           ; weitere Dateien testen
        XOR     A               ; Code for 'Dateinamen nicht gefunden'
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
;
;   testen, ob Datei noch nicht vorhanden und noch Platz für neue Datei
;
A1C3D:  CALL    A1C6D           ; testen, ob auf Gerät nicht schon Datei eröffnet ist
        CALL    A1C0F           ; testen, ob Dateiname schon auf Gerät vorhanden ist
        JP      NC,A1F8E        ; Fehler 42'  Already exist error
        OR      A               ; alle möglichen Dateikennungen durchprobiert  ?
        JP      Z,A1F9A         ; ja -->  Fehler 51'  Too many files error
        RET
;
;
;   Datei zum Lesen eröffnet
;
A1C4B:  CALL    A1C6D           ; testen, ob auf Gerät nicht schon Datei eröffnet ist
        CALL    A1C0F           ; testen, ob Dateiname schon auf Gerät vorhanden ist
        JP      C,A1F88         ; nein -->  Fehler 40'  File not found error
        CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      HL,S11A4        ; Zeiger auf Speicher mit Dateikennung vorgeben
        PUSH    IY              ;! Zeiger auf Stelle für Dateikennung nach DE
        POP     DE              ;!
        PUSH    HL              ; Zeiger auf Dateikennung retten
        CALL    A1C66           ; 64 Byte  (Länge Kennungsdaten)  von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf Dateikennung holen
        LD      DE,S1000        ; Zeiger auf Speicher für Dateikennung
        LD      A,(HL)          ; Datei - Typ - Kennung holen
;
;
;   64 Byte  (Länge Kennungsdaten) von (HL) nach (DE) übertragen
;
A1C66:  LD      BC,64           ; Länge Datei - Kennung
        LDIR                    ; Dateikennung von (HL) nach (DE) übertragen
        OR      A               ; Carry - Flag zurücksetzen  (Code for 'Funktion OK')
        RET
;
;
;   testen, ob auf Gerät nicht schon Datei  (zum Schreiben) eröffnet ist
;
A1C6D:  LD      IX,T1CAF        ; Adresse  'testen, ob Datei noch eröffnet werden darf'
;
;
;   alle im Zugriff befindlichen Datei - Datensätze durchspielen
;   wenn aktuelles Gerät gefunden -->  Routine in IX aufrufen
;
A1C71:  LD      (D1CAA + 1),IX  ; Anfangsadresse der Routine eintragen
        CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      A,(S1042)       ; interne aktuelle Geräte-/Dateinummer holen
        LD      C,A             ; und merken
        LD      HL,(POOL)       ; Zeiger auf Datei-Arbeitsbereiche (I/O-Work-Area) holen
        PUSH    HL              ; und merken
A1C80:  POP     HL              ; Zeiger auf Datei-Arbeitsbereich holen
        LD      A,(HL)          ; Dateisatz - Nummer holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  alle Dateisätze abgearbeitet
        LD      B,A             ; Datensatznummer merken
        INC     HL              ; Zeiger auf Länge Speicherbereich
        CALL    LDDEMI          ; Länge Speicherbereich nach DE holen
        PUSH    HL              ; Zeiger auf aktuellen Datensatz retten
        ADD     HL,DE           ; Zeiger auf nächsten Datensatz errechnen
        EX      (SP),HL         ; Zeiger nächster Datensatz retten/akt. Zeiger holen
        CP      08FH            ; nur interner Verwaltungsdatensatz  ?
        JR      NC,A1C80        ; ja -->  nächsten Datensatz testen
        CP      C               ; Datensatznummer gleich aktuellem Datensatz
        JR      Z,A1C80         ; ja -->  nächsten Datensatz testen
        INC     HL              ; Datensatznummer überspringen
        LD      A,(HL)          ; Zugriffscode holen
        EX      AF,AF           ; und retten
        INC     HL              ; Zugriffscode überspringen
        LD      DE,ZEQT         ; Zeiger auf aktuelle Geräte - Tabelle
        PUSH    BC              ; Keep register value
        LD      BC,256 * 3 + 0  ; drei Byte überprüfen / 0 = Vorgabe für Ergebnis
A1C9E:  LD      A,(DE)          ;! ein Byte vergleichen
        SUB     (HL)            ;!
        OR      C               ; plus altes Ergebnis
        LD      C,A             ; neues Ergebnis merken
        INC     DE              ;! Zeiger auf Geräte-Tabellenzeigern auf nächstes Byte
        INC     HL              ;!
        DJNZ    A1C9E           ; weitere Bytes vergleichen
        POP     BC              ; geretteten Register - Wert holen
        JR      NZ,A1C80        ; Gerät nicht gleich -->  nächsten Datensatz vergleichen
        LD      A,B             ; Datensatznummer holen
D1CAA:  CALL    0               ; Routine aufrufen  (Adresse wird eingetragen)
        JR      A1C80           ; nächsten Datensatz testen
;
;
;   testen, ob Datei noch eröffnet werden darf
;
T1CAF:  LD      A,(ZFLAG2)      ; Geräte - Nummern - Flag holen
        BIT     6,A             ; nur eine Datei auf Gerät erlaubt  ?
        JP      NZ,A1F91        ; ja -->  Fehler 43'  Already open error
        BIT     5,A             ; nur eine Datei zum Schreiben eröffnen  ?
        RET     Z               ; nein
        EX      AF,AF           ; Zugriffscode des Datensatzes holen
        LD      B,A             ; und merken
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        AND     B               ;!  beide Dateien zum Schreiben eröffnet  ?
        BIT     1,A             ;!
        RET     Z               ; nein
        JP      A1F91           ; Fehler 43'  Already open error
;
;
;   Programm nach aufbereiteter Kennung laden   (SVC code:  48)
;
LOADFL: CALL    A1D27           ; aktuelles Gerät gleich Diskette  ?
        JP      NZ,A32A2        ; nicht mehr benötigte Diskettendaten löschen
        LD      BC,(S1014)      ; Datei - Länge holen
        PUSH    BC              ; und merken
        XOR     A
        LD      IX,(S105D)      ; Adresse  'Daten vom Gerät bereitstellen' holen
        CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        POP     BC              ; gerettete Programmlänge holen
        RET
;
;
;   (Programm-)  Daten vergleichen     (SVC code:  50)
;
VRFYFL: LD      A,(ZFLAG2)      ; Geräte - Nummern - Flag holen
        BIT     7,A             ; Block - orientiertes Gerät  ?
        JP      Z,A1FAC         ; nein -->  Fehler 59'  Can't execute error
        LD      BC,(S1014)      ; Datei - Länge holen
        ;JP      A388D           ; Dateidaten vergleichen
        JP      A3ADF			; RET (Motor der Quick - Disk - Station abschalten)

;
;
;   Programm abspeichern     (Sofware - Kommando  49)
;
SAVEFL: LD      A,(S1000)       ; Datei - Typ - Kennung holen
        CP      _BRD + 1        ; bekannter Datei - Typ  ?
        JR      C,A1CF6         ; ja
        LD      A,10000000B     ; Code for 'vom Basic abgespeicherte Datei'
        LD      (S1012),A       ; im Schreib - Schutz - Flag merken
A1CF6:  CALL    A1D27           ; aktuelles Gerät gleich Diskette  ?
        JP      NZ,A32B0        ; ja -->  Programm auf Diskette abspeichern
        BIT     7,A             ; nicht Block - orientiertes Gerät  ?
        JP      NZ,A1FAC        ; ja -->  Fehler 59'  Can't execute error
        PUSH    DE              ; Zeiger auf Programm retten
        LD      HL,2 * 256 + 0  ; Code for 'Datei zum Schreiben eröffnen'
        LD      (S1042),HL      ; als interne aktuelle Geräte-Nummer/Zugriffscode merken
        CALL    A1C6D           ; testen, ob auf Gerät nicht schon Datei eröffnet ist
        LD      HL,S1000        ; Zeiger auf Speicher mit Datei - Kennung
        PUSH    HL              ;! nach IY übertragen
        POP     IY              ;!
        LD      IX,(S1057)      ; Adresse  'Datei zum Schreiben eröffnen'
        CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        LD      BC,(S1014)      ; Datei - Länge holen
        POP     HL              ; Zeiger auf Programm holen
        LD      A,0100B
        LD      IX,(S105F)      ; Adresse  'Daten ausgeben'  holen
        CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        RET
;
;
;   Abfrage, ob aktuelles Gerät gleich Diskette ist
;
A1D27:  LD      A,(S1050)       ; Geräte - Typ - Byte holen
        BIT     5,A             ; Gerät gleich Diskette  ?
        RET
;
;
;   Inhaltsverzeichnis einlesen oder ausgeben     (SVC code:  57)
;
FDIR:   CALL    PUSHR           ; Save registers IX, HL, BC and DE
        OR      A               ; Datei- oder Gerätenummer angegeben  ?
        JR      NZ,A1D80        ; ja -->  gelesenes Inhaltsverzeichnis ausgeben
;
;
;   Inhaltsverzeichnis des Gerätes / Datenträgers einlesen
;
        LD      HL,256 * 1 + 0  ; Code for 'Datei zum Lesen eröffnen'
        LD      (S1042),HL      ; als interne aktuelle Geräte-Nummer/Zugriffscode merken
        CALL    A1C6D           ; testen, ob auf Gerät nicht schon Datei eröffnet ist
        LD      HL,S1050        ; Zeiger auf Geräte - Typ - Byte vorgeben
        BIT     7,(HL)          ; nicht Block-orientiertes gerät  ?
        JP      NZ,A1FAC        ; ja -->  Fehler 59'  Can't execute error
        BIT     5,(HL)          ; Gerät gleich Diskette  ?
        JP      NZ,A36FD        ; ja -->  Inhaltsverzeichnis von Diskette lesen
        INC     HL              ; Zeiger auf Geräte - Nummern - Byte
        BIT     7,(HL)          ; Dateiname muß nicht angegeben sein  ?
        JP      NZ,A1FAC        ; ja -->  Fehler 59'  Can't execute error
        CALL    A44A3           ; warten, bis alte Melodien vollständig gespielt sind
        LD      HL,S27D0        ; Zeiger auf Speicher für Inhaltsverzeichnis
        LD      BC,8            ; 8 * 256 Bytes = 2 K - Byte
A1D58:  CALL    CLRHL           ; Speicherbereich (HL) löschen
        DEC     C               ; Restanzahl Blöcke minus eins
        JR      NZ,A1D58        ; weitere Blöcke löschen
        CALL    A18C7           ; Datei auf Gerät nach Tabellenadresse schliessen
        LD      A,(S1052)       ; maximale Anzahl Dateien auf Gerät/Datenträger holen
        LD      B,A             ; und merken
        LD      HL,S27D0        ; Zeiger auf Speicher für Inhaltsverzeichnis
A1D68:  PUSH    BC              ; Zähler retten
        LD      IX,(S1055)      ; Adresse  'Datei zum Lesen eröffnen' aus Gerätetabelle holen
        CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        PUSH    AF              ; Ergebnisflag retten
        LD      BC,32           ; Länge Kennungsdatensatz
        ADD     HL,BC           ; Zeiger auf Ende Datensatz errechnen
        LD      (HL),NUL        ; Endezeichen eintragen
        POP     AF              ; gerettetes Ergebnisflag holen
        POP     BC              ; geretteten Zähler holen
        JR      C,A1D7D         ; keine weiteren Dateinamen
        DJNZ    A1D68           ; weitere Dateien testen   (Dateikennungen einlesen)
A1D7D:  JP      B18C6           ; Gerät in 'Stand by'  schalten
;
;
;   gelesenes Inhaltsverzeichnis aufbereiten und ausgeben
;
A1D80:  LD      (A1E27 + 1),A   ; Ausgabe - Datei - Nummer in Routine eintragen
        XOR     A               ; Accu auf Null
        LD      (DISPX),A       ; Code for 'Steuerzeichen ausführen'  merken
        LD      HL,S11A4        ; Zeiger auf Speicher zur Textaufbereitung
        PUSH    HL              ; Zeiger auf Anfang Speicher merken
        LD      DE,M1E32        ; Text  'DIRECTORY OF'
        LD      B,14            ; Textlänge vorgeben
        CALL    LDHLDE          ; Speicherbereich von (DE) nach (HL) verschieben
        CALL    SETDNM          ; Geräte - Namen nach (HL) bereitstellen
        LD      (HL),' '        ; Leerzeichen  (Space)  eintragen
        INC     HL              ; Leerzeichen überspringen
        LD      (HL),' '        ; Leerzeichen  (Space)  eintragen
        INC     HL              ; Leerzeichen überspringen
        EX      DE,HL           ; Zeiger auf Speicher für Text nach DE
        CALL    A1D27           ; aktuelles Gerät gleich Diskette  ?
        LD      IX,(S1065)      ; Adresse  'freie Kilobyte bereitstellen'  aus Geräte-Tabelle holen
        JR      Z,A1DAA         ; nicht Diskette
        LD      IX,T3716        ; Adresse  'freie Kilobyte bereitstellen (Diskette)'
A1DAA:  CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        JR      C,A1DBD         ; Gerät kann keine freie Speicherkapazität bereitstellen
        LD      H,B             ;! Anzahl freie Kilobyte nach HL
        LD      L,C             ;!
        LD      B,0             ; Code for 'Vornullen unterdrücken'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    22              ; Code 22   Hex-Wert in HL umsetzen in Dezimal-ASCII (DE)
        LD      HL,M1E40        ; Text  'KB FREE'
        LD      B,9             ; Textlänge vorgeben
        CALL    LDDEHL          ; Text von (HL) nach (DE) verschieben
A1DBD:  EX      DE,HL           ; Zeiger auf Ende Text nach HL
        LD      (HL),CR         ; Carriage Return  (Wagenrücklauf)  eintragen
        INC     HL              ; Zeichen überspringen
        LD      (HL),NUL        ; Textendezeichen eintragen
        POP     DE              ; Zeiger auf Anfang aufbereitete Zeile holen
        CALL    A1E27           ; Text (DE) ausgeben
        LD      B,64            ; maximal 64 Datei - Einträge
        LD      HL,S27D0        ; Zeiger auf Speicher mit Inhaltsverzeichnis
A1DCC:  CALL    A1DD8           ; eine Zeile Inhaltsverzeichnis aufbereiten und ausgeben
        LD      DE,32           ; Länge Inhaltsverzeichnis - Eintrag
        ADD     HL,DE           ; Zeiger auf nächsten Inhaltsverzeichnis - Eintrag
        DJNZ    A1DCC           ; weitere Zeilen Inhaltsverzeichnis aufbereiten und ausgeben
        JP      A34CE           ; nicht mehr benötigte Diskettendaten löschen
;
;
;   eine Zeile Inhaltsverzeichnis aufbereiten und ausgeben
;
A1DD8:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      A,(HL)          ; Datei - Typ - Kennung holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  Datei - Eintrag nicht belegt
        RET     M               ; SWAP - Eintrag -->  nicht ausgeben
        LD      DE,S11A4        ; Zeiger auf Speicher für Text vorgeben
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        LD      A,' '           ; Leerzeichen  (Space)  vorgeben
        LD      B,38            ; 38 Zeichen
        CALL    SETDE           ; Speicherbereich (DE) mit Konstante in A laden  (B = Anzahl)
        LD      A,(HL)          ; Datei - Typ - Flag holen
        CP      12              ; bekannter Datei - Typ  ?
        JR      C,A1DF1         ; ja -->  ausgeben
        LD      A,12            ; Code für unbekannten Datei - Typ
A1DF1:  PUSH    HL              ;! Zeiger auf Datei - Kennung im Zwischenspeicher
        POP     IY              ;! nach IY übertragen
        POP     DE              ; Zeiger auf Speicher für Zeile holen
        PUSH    DE              ; und wieder merken
        INC     DE              ; Zeiger auf Stelle für Datei - Typ
        LD      HL,M1E49 + -3   ; Zeiger auf Texte für Datei - Typen
        LD      BC,3            ; Textlänge je Datei - Typ
A1DFD:  ADD     HL,BC           ;! Zeiger auf richtigen Text stellen
        DEC     A               ;!
        JR      NZ,A1DFD        ;!
        LDIR                    ; Datei-Typ - Text in Textspeicher übertragen
        EX      DE,HL           ; Zeiger auf Textspeicher nach HL
        BIT     0,(IY+18)       ; Datei Schreibgeschützt  ?
        JR      Z,A1E0C         ; nein
        LD      (HL),'*'        ; Code for 'LOCK'  eintragen
A1E0C:  INC     HL              ;! Zeiger auf Stelle für Dateinamen setzen
        INC     HL              ;!
        LD      (HL),'\"'       ; Anführungszeichen für Anfang Datei-Name
        INC     HL              ; Anführungszeichen überspringen
A1E11:  LD      A,(IY+1)        ; ein Zeichen Datei - Name holen
        CP      CR              ; Ende Datei - Name  ?
        JR      Z,A1E1E         ; ja -->  Anführungszeichen eintragen
        LD      (HL),A          ; ein Zeichen Name merken
        INC     IY              ; Zeiger auf Inhaltsverzeichnis - Speicher
        INC     HL              ; Zeiger auf Speicher für Text
        JR      A1E11           ; weitere Zeichen Name übertragen
;
A1E1E:  LD      (HL),'\"'       ; Anführungszeichen für Namenende eintragen
        INC     HL              ; Anführungszeichen überspringen
        LD      (HL),CR         ; Carriage Return  (Wagenrücklauf)  eintragen
        INC     HL              ; Zeilenvorschubzeichen überspringen
        LD      (HL),NUL        ; Textendezeichen eintragen
        POP     DE              ; Zeiger auf Anfang aufbereiteten Text holen
;
;
;   aufbereitete Inhaltsverzeichniszeile auf Gerät / Datei ausgeben
;
A1E27:  LD      A,0             ; Ausgabe - Datei - Nummer   (wird eingetragen)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    46              ; Code 46   Datei-Verwaltungssatz nach Nummer bereitstellen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    23              ; Code 23  Länge des Textes (DE) auszählen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    55              ; Code 55  Text auf angewähltem Gerät/Datei ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    15              ; Code 15  wenn Space gedrückt -->  warten bis andere Taste
        RET
;
;
;   Texte für Ausgabe Inhaltsverzeichnis   (DIR)
;
M1E32:  DEFB    CR              ; Text  'DIRECTORY OF '
        DEFM    "DIRECTORY OF "
;
M1E40:  DEFM    " KB FREE."     ; Text  ' KB FREE.'
;
;
;   Vorgabe für Texte für Datei - Typ - Kennungen
;
M1E49:  DEFM    "OBJ"           ; Datei - Typ  1
        DEFM    "BTX"           ; Datei - Typ  2
        DEFM    "BSD"           ; Datei - Typ  3
        DEFM    "BRD"           ; Datei - Typ  4
        DEFM    "RB "           ; Datei - Typ  5
        DEFM    " ? "           ; Datei - Typ  6     (frei für  ASC)
        DEFM    "LIB"           ; Datei - Typ  7
        DEFM    " ? "           ; Datei - Typ  8     (frei für  PTX)
        DEFM    " ? "           ; Datei - Typ  9     (frei für  PSD)
        DEFM    "SYS"           ; Datei - Typ 10
        DEFM    "GR "           ; Datei - Typ 11          ! (Datei - Typ  12 = LOG)
        DEFM    " ? "           ; Datei - Typ 12          ! (Datei - Typ  13 = PIC)
;
;
;   Gerät initialisieren     (SVC code:  60)
;
FINIT:  PUSH    HL              ; Zeiger auf Übergabetext retten
A1E6E:  XOR     A               ; Accu auf Null
        LD      (S1042),A       ; interne aktuelle Geräte-/Dateinummer löschen
        LD      IX,D1E86        ; Adresse  'Dateidaten im Rechner löschen'
        LD      (D1E86 + 1),SP  ; Stackpointer merken
        CALL    A1C71           ; wenn Datei auf Gerät eröffnet -->  Routine (IX) aufrufen
        POP     HL              ; geretteten Zeiger auf Übergabetext holen
        LD      IX,(S1053)      ; Adresse  'Gerät initialisieren'  aus Geräte-Tabelle holen
        CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        RET
;
;
;   Datei mit Nummer im Accu löschen und erneut probieren, ob Gerät noch im Zugriff ist
;
D1E86:  LD      SP,0            ; Stackpointer neu setzen   (Wert wird eingetragen)
        LD      B,0             ; Code for 'Dateidaten im Rechner löschen'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    56              ; Code 56   Datei-Daten im Rechner löschen
        JR      A1E6E           ; erneut testen, ob Gerät noch im Zugriff ist
;
;
;   Abfrage, ob wirklich initialisiert werden soll
;
A1E8F:  CALL    TEST1           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    "Y"             ; Y  (Yes)  ?
        RET     Z               ; Y angegeben -->  initialisieren
        LD      DE,M1EA3        ; Text  'OK ?  (Y/N)'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    5               ; Code 5  Text (DE) mit Groß/Kleinschreibung ausgeben
        LD      A,1             ; Code for 'ein Zeichen von Tastatur mit Cursorblinken'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    13              ; Code 13  Tastaturabfrage nach Status im Accu
        CP      'Y'             ; Y  (Yes)  ?
        RET     Z               ; ja -->  initialisieren
        JP      BREAKZ          ; Programm abbrechen  (BREAK)
;
;
;   Text to ask whether you really want to initialize
;
M1EA3:  DEFM    "OK ? [Y/N]"    ; Text  'OK ? [Y/N]'
        DEFB    _ALPHA,NUL

;
;
;   Compare file name with given file name (HL)
;
A1EAF:
        LD      DE,S1000        ; Pointer to storage for file handle
;
;
;   Compare file name in (HL) with file name in (DE).
;
A1EB2:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        INC     HL              ; File - Skip type in comparison name
        INC     DE              ; File - skip type in given name
        LD      A,(DE)          ; Get first character of given file name
        CP      CR              ; Carriage Return (End of Name Character) ?
        RET     Z               ; yes --> no name specified --> name is OK
        LD      B,17            ; specify the maximum number of characters for the file name
A1EBD:  LD      A,(DE)          ; Get a character given file name
        CP      (HL)            ; compare with a character comparison-name
        RET     NZ              ; File names not the same --> Abort
        CP      CR              ; end file name ?
        RET     Z               ; yes --> file names same
        INC     HL              ; Pointer to comparison name to next character
        INC     DE              ; Pointer to given name to next character
        DJNZ    A1EBD           ; more characters compare file name
        OR      A               ; Reset carry flag
        RET
;
;
;   Provide file names from text (DE) to (HL).
;
A1EC9:  INC     HL              ; Skip location for file - type - identifier
        LD      C,16            ; maximum length file - specify name
A1ECC:  LD      A,B             ; Get remaining length of file name specification
        OR      A               ; equals zero  ?
        JR      Z,A1EE4         ; yes --> enter the end of name character
        LD      A,(DE)          ; get a character filename
        INC     DE              ; skip characters
        DEC     B               ; Remaining number of characters default minus one
        OR      A               ; end of text character ?
        JR      Z,A1EE4         ; yes --> enter the end of name character
        CP      '\"'            ; quotation marks ?
        JR      Z,A1ECC         ; yes --> forgotten characters
        CP      ':'             ; colon ?
        JP      Z,A1FAF         ; yes --> Error 40 Illegal filename error
        LD      (HL),A          ; Remember characters for file names
        INC     HL              ; skip noted character
        DEC     C               ; Remaining number of allowed characters minus one
        JR      NZ,A1ECC        ; provide more characters
A1EE4:  LD      (HL),CR         ; Enter name end character
        INC     HL              ; Skip name ending characters
A1EE7:  LD      A,C             ; Get counter 'Remaining number of allowed characters'
        OR      A               ; equals zero  ?
        RET     Z               ; yes --> done
        LD      (HL),' '        ; enter a space
        INC     HL              ; Skip spaces
        DEC     C               ; Remaining number of characters minus one
        JR      A1EE7           ; write more spaces
;
;
;   Zeiger auf dynamisches Segment nach Satz-Nummer im Accu nach HL bereitstellen
;
;   (SVC code:  41)
;
SEGADR: LD      HL,(POOL)       ; Zeiger auf Datei-Arbeitsbereiche (I/O-Work-Area) holen
A1EF3:  INC     (HL)            ;! Ende Tabelle  ?
        DEC     (HL)            ;!
        SCF                     ; Code for 'Speicher nicht gefunden'  setzen
        RET     Z               ; Speicher nicht gefunden -->  Abbruch
        CP      (HL)            ; Satz - Nummer stimmt  ?
        INC     HL              ; Satz - Nummer überspringen
        JR      Z,A1F03         ; Datensatz gefunden -->  Zeiger auf Bytes stellen
        PUSH    DE              ; Keep register value
        CALL    LDDEMI          ; Länge Bereich aus Datensatz holen
        ADD     HL,DE           ; Zeiger auf nächsten Datensatz errechnen
        POP     DE              ; geretteten Register - Wert holen
        JR      A1EF3           ; nächsten Datensatz testen
;
A1F03:  INC     HL              ;! Bereichslänge überspringen
        INC     HL              ;!
        RET
;
;
;   dynamischen Zwischenspeicher löschen     (SVC code:  43)
;
DELSEG: CALL    PUSHR           ; Save registers IX, HL, BC and DE
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    41              ; Code 41  Zeiger auf Datensatz nach Datensatznr bereitstellen
        RET     C               ; Speicher nicht eröffnet -->  fertig
        DEC     HL
        LD      B,(HL)          ;! Länge des Speicherbereichs holen
        DEC     HL              ;!
        LD      C,(HL)          ;!
        DEC     HL              ; Zeiger auf Anfang Speicherbereich
        LD      D,H             ;! Zeiger nach DE übertragen
        LD      E,L             ;!
        INC     BC              ;! Länge für Verwaltungsbytes corrigieren
        INC     BC              ;!
        INC     BC              ;!
        PUSH    BC              ; Länge merken
        ADD     HL,BC           ; Zeiger auf Ende Bereich errechnen
        PUSH    HL              ; und merken
        LD      B,H             ;! Zeiger auf Ende des dynamischen Speicherbereichs
        LD      C,L             ;! nach BC
        LD      HL,(TMPEND)     ; Zeiger auf Ende Stringarbeitsbereich holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; Anzahl zu verschiebende Bytes errechnen
        LD      B,H             ;! Anzahl zu verschiebende Bytes nach BC
        LD      C,L             ;!
        POP     HL              ; Zeiger auf Ende dynamisches Segment holen
        LDIR                    ; Bytes hinter Segment verschieben  (Segment löschen)
        POP     DE              ; Länge des gelöschten Speichers holen
        LD      HL,0            ;! 2er Complement errechnen
        OR      A               ;!         Carry  - Flag zurücksetzen
        SBC     HL,DE           ;!
        EX      DE,HL           ; negative Segment - Länge nach DE
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    25              ; Code 25   Zeiger auf Basic-Variable und Strings corrigieren
        OR      A               ; Carry - Flag zurücksetzen   (Code for 'kein Fehler')
        RET
;
;
;   dynamischen Zwischenspeicher eröffnen     (SVC code:  42)
;
OPSEG:  PUSH    AF              ; Nummer des Zwischenspeichers retten
        PUSH    BC              ; Keep register value
        PUSH    DE              ;! Länge des zu eröffnenden Zwischenspeichers
        PUSH    DE              ;!
        INC     DE              ;! Länge für Speichernummer und Länge corrigieren
        INC     DE              ;!
        INC     DE              ;!
        LD      HL,(TMPEND)     ; Zeiger auf Ende Stringarbeitsbereich holen
        EX      DE,HL           ; HL - Keep register value
        ADD     HL,DE           ; neues Ende Stringarbeitsbereich errechnen
        EX      DE,HL           ; gerettetes altes Ende wieder nach HL
        JP      C,A1F82         ; Überlauf -->  Fehler 6  Memory capacity error
        PUSH    HL              ; altes Ende Stringarbeitsbereich merken
        LD      HL,-512         ;! kleinstmögliche RAM - Adresse errechnen
        ADD     HL,SP           ;!
        SBC     HL,DE           ; testen, ob sich Adressen überschneiden
        JR      C,A1F82         ; Überlauf -->  Fehler 6  Memory capacity error
        LD      HL,(MEMLMT)     ; LIMIT - Adresse holen
        DEC     H               ;! Vorgabe für freien Arbeitsspeicher  (512 Bytes)
        DEC     H               ;!
        SBC     HL,DE           ; Adressen überprüfen
        JR      C,A1F82         ; Fehler 6  Memory capacity error
        POP     HL              ; altes Ende Stringarbeitsbereich holen
        PUSH    HL              ; und wieder merken
        LD      BC,(VARST)      ; Zeiger auf Anfang Basic-Variable holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; Anzahl zu verschiebende Bytes errechnen
        LD      B,H             ;! und nach BC übertragen
        LD      C,L             ;!
        POP     HL              ; Zeiger auf altes Ende Stringarbeitsbereich holen
        INC     BC              ; Länge corrigieren
        LDDR                    ; BASIC - Variable und Strings verschieben
        POP     DE              ; Länge des Zwischenspeichers holen
        LD      (HL),A          ; Speichernummer eintragen
        INC     HL              ; Speichernummer überspringen
        LD      (HL),E          ;! Speicherlänge eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL
        PUSH    HL              ; Zeiger auf Anfang Speicher merken
        INC     DE
        PUSH    DE              ; Länge merken
A1F6D:  LD      (HL),0          ;! Zwischenspeicher löschen
        INC     HL              ;!     Zeiger auf Speicher auf nächstes Byte
        DEC     DE              ;!     Restanzahl Bytes minus eins
        LD      A,D             ;!     !  Restanzahl Bytes gleich Null  ?
        OR      E               ;!     !
        JR      NZ,A1F6D        ;!     nein -->  weitere Bytes löschen
        POP     DE              ; Speicherlänge holen
        INC     DE              ;! für Verwaltungslänge corrigieren
        INC     DE              ;!
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    25              ; Code 25   Zeiger auf Basic-Variable und Strings corrigieren
        POP     HL              ; Zeiger auf Speicher holen
        POP     DE              ; Speicherlänge holen
        POP     BC              ; geretteten Register - Wert holen
        POP     AF              ; Speicher - Nummer holen
        RET
;
;
;   Tabelle mit Fehlereinsprüngen
;
;   (ist Bit 7 der Fehlernummer gesetzt wird auch der Geräte - Name ausgegeben)
;
A1F7F:  LD      A,3             ; Fehler  3   Illegal data error
        DEFB    LD_HL
;
A1F82:  LD      A,6             ; Fehler  6   Memory capacity error
        DEFB    LD_HL
;
A1F85:  LD      A,28 + 128      ; Fehler 28   System id error
        DEFB    LD_HL
;
A1F88:  LD      A,40 + 128      ; Fehler 40   File not found error
        DEFB    LD_HL
;
A1F8B:  LD      A,41 + 128      ; Fehler 41   Hardware error
        DEFB    LD_HL
;
A1F8E:  LD      A,42 + 128      ; Fehler 42   Already exist error
        DEFB    LD_HL
;
A1F91:  LD      A,43 + 128      ; Fehler 43   Already open error
        DEFB    LD_HL
;
A1F94:  LD      A,46 + 128      ; Fehler 46   Write protect error
        DEFB    LD_HL
;
A1F97:  LD      A,50 + 128      ; Fehler 50   Not ready error
        DEFB    LD_HL
;
A1F9A:  LD      A,51 + 128      ; Fehler 51   Too many files error
        DEFB    LD_HL
;
A1F9D:  LD      A,52 + 128      ; Fehler 52   Disk mismatch error
        DEFB    LD_HL
;
A1FA0:  LD      A,53 + 128      ; Fehler 53   No file space error
        DEFB    LD_HL
;
        LD      A,54 + 128      ; Fehler 54   Unformat error
        DEFB    LD_HL
;
A1FA6:  LD      A,55 + 128      ; Fehler 55   Too many files error
        DEFB    LD_HL
;
A1FA9:  LD      A,58            ; Fehler 58   Dev. name error
        DEFB    LD_HL
;
A1FAC:  LD      A,59 + 128      ; Fehler 59   Can't execute error
        DEFB    LD_HL
;
A1FAF:  LD      A,60 + 128      ; Fehler 60   Illegal filename error
        DEFB    LD_HL
;
A1FB2:  LD      A,61 + 128      ; Fehler 61   Illegal filemode error
        DEFB    LD_HL
;
A1FB5:  LD      A,63 + 128      ; Fehler 63   Out of file error
        DEFB    LD_HL
;
        LD      A,64            ; Fehler 64   Logical number error
        DEFB    LD_HL
;
A1FBB:  LD      A,68 + 128      ; Fehler 68   Dev. mode error
        JP      ERRORJ          ; Fehler mit Nummer im Accu behandeln
;
;
;   Datei - Daten der Ausgabe - Datei  (wenn vorhanden)  löschen
;   Diskettenroutinen initialisieren und Motor abschalten
;
;   (SVC code:  67)
;
ERRCVR: LD      A,(S1FD9)       ; Ausgabe - Geräte-/Dateinummer holen
        OR      A               ; gleich Null  (kein Gerät angewählt)  ?
        LD      B,0             ; Code for 'Dateidaten löschen'
        CALL    NZ,CLKL         ; Dateinummer -->  Dateidaten im Rechner löschen
        CALL    A38C2           ; Gerät 'FD:' initialisieren
        CALL    A3ADF           ; Motor der Quick - Disk - Station abschalten
        XOR     A               ; Accu auf Null
        LD      (S1FD9),A       ; Ausgabe - Geräte-/Dateinummer zurücksetzen
        JP      A34CE           ; nicht mehr benötigte Disketten-Daten löschen
;
        DEFS    3
;
S1FD9:  DEFS    1               ; Ausgabe - Geräte-/Datei - Nummer
;
        DEFS    38,0

;
;
;
; Memory to simulate screen - text - memory
;
; Since the original image memory only contains point patterns, the
; following memory area provides an image of the text screen.
; The 'screen editing' is possible only in this way.
;
; A hardcopy of the displayed text can be easily done PEEKing here
; and sending the output of the read characters to the printer.
; 
;
TEXTBF: DEFS    2000            ; Pseudo - video text memory


;
;
;
S27D0:  DEFS    1792            ; Speicher für Inhaltsverzeichnis
                                ; der folgende Speicherbreich gehört auch
                                ; noch dazu  (insgesamt 2 K - Byte)
S2ED0:  DEFS    256             ; hier werden Werte der noch zu spielenden
                                ; Melodie gespeichert
;
;
S2FD0:  DEFS    256             ; Speicher für Sektorverzeichnis  (Diskette)
;
;    RANDOM - Datensatz merken     (SVC code: 64)
;
RECST:  LD      (S30D5),DE      ; RANDOM - Satznummer merken
        RET
;
;
S30D5:  DEFS    2               ; Speicher für RANDOM - Satznummer
;
;
;    einen Sektor der sequentiellen Datei auf Diskette wegschreiben
;
A30D7:  LD      BC,0            ; Code 'letzter Sektor'
        LD      DE,1            ; ein Sektor
        BIT     2,A             ; Datei - Ende - Bit abfragen
        CALL    Z,A3696         ; nicht gesetzt -->  Sektoren bereitstellen und reservieren
        LD      HL,(S180D)      ; Zeiger auf Sektornummer im Sektor holen
        LD      A,(HL)          ; Low - Byte Sektornummer holen
        LD      (HL),C          ; und Low - Byte neue Sektornummer eintragen
        LD      C,A             ; Low - Byte Sektornummer des jetzigen Sektors
        INC     HL              ; Zeiger auf High - Byte
        LD      A,(HL)          ; High - Byte Sektornummer holen
        LD      (HL),B          ; und High - Byte neue Sektornummer eintragen
        LD      B,A             ; High - Byte Sektornummer des jetzigen Sektors
        LD      HL,(S180B)      ; Zeiger auf Speicher fuer Sektor holen
        LD      DE,256          ; Sektorlänge vorgeben
        JP      B379A           ; Sektor auf Diskette wegschreiben
;
;
;    Datensatz in RANDOM - Datei wegschreiben     (SVC code:  66)
;
PRREC:  CALL    PUSHR           ; Register IX, HL, BC, DE retten
        CALL    A181A           ; interne Geräte-Nummer als Ausgabe-Geräte-Nr. vorgeben
        LD      HL,S11A4        ; Zeiger auf Zwischenspeicher
        PUSH    HL              ; Zeiger auf Anfang Speicher merken
        LD      A,B             ; Anzahl Zeichen holen
        OR      A               ; gleich Null  ?
        CALL    NZ,LDHLDE       ; nein --> Speicherbereich von (DE) nach (HL) verschieben
        LD      B,32            ; 32 Speicherzellen
        LD      A,' '           ; Vorgabe für Löschzeichen
        CALL    SETHL           ; Speicherbereich (HL) mit Zeichen im Accu initiieren
        LD      A,(IY+18)       ; Schreib-Schutz-Flag holen
        OR      A               ; gesetzt  ?
        JP      NZ,A1F94        ; ja --> Fehler 46  Write protect error
        CALL    A31AF           ; überprüfen, ob Satznummer kleiner als bisher größte
        JR      NC,A3134        ; Satznummer ist kleiner als bisher größte Satznummer
        LD      (IY+20),E       ;! neue größte Satznummer merken
        LD      (IY+21),D       ;!
        LD      (IY+70),1       ; Flag 'Blocknummernsektor wegschreiben' eintragen
        JR      Z,A3134         ; Satznummer liegt im schon reservierten Sektorenblock
        CALL    A3192           ; RANDOM-Sektor, wenn geändert, wegschreiben
        CALL    A31D8           ; überprüfen, ob Sektoren für RANDOM-Satznummer schon reserviert
        CALL    A314C           ; Sektornummer und Zeiger auf Stelle für Datensatz errechnen
        LD      (IY+64),L       ;! Sektornummer eintragen
        LD      (IY+65),H       ;!
        JR      A313A           ; neuen Datensatz eintragen
;
A3134:  CALL    A314C           ; Sektornummer und Zeiger auf Stelle für Datensatz errechnen
        CALL    A317B           ; richtigen Sektor der RANDOM - Datei bereitstellen
A313A:  POP     HL              ; Zeiger auf neuen Datensatz holen
        CALL    A35EA           ; 32 Byte (1 Datensatz) von (HL) nach (DE) übertragen
        LD      (IY+68),1       ; Code 'neue Daten im Speicher' merken
;
;
;    RANDOM - Satznummer plus eins
;
A3142:  LD      HL,(S30D5)      ; RANDOM - Satznummer holen
        INC     HL              ; plus eins
        LD      (S30D5),HL      ; und wieder merken
        JP      A1815           ; Ausgabe-Geräte-Nummer zurücksetzen
;
;
;    Sektornummer und Zeiger auf Stelle für Datensatz aus RANDOM - Satznummer errechnen
;
A314C:  LD      HL,(S30D5)      ; RANDOM - Satznummer
        DEC     HL              ; corrigieren
        PUSH    HL              ; und merken
        ADD     HL,HL           ; mal zwei
        LD      E,H             ; High - Byte als Offset merken
        LD      D,0             ; High - Byte Offset auf Null
        LD      HL,(S180B)      ; Zeiger auf Speicher für Sektor
        ADD     HL,DE           ;! Zeiger auf Block-Nummer errechnen
        ADD     HL,DE           ;!
        LD      E,(HL)          ;!  Sektor - Block - Nummer holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        POP     HL              ; RANDOM - Satznummer holen
        LD      A,L             ; Low - Byte Satznummer holen
        PUSH    AF              ; merken
        RRA                     ;! Offset im Sektorblock errechnen
        RRA                     ;!
        RRA                     ;!
        AND     00001111B       ;!
        LD      L,A             ; Low - Byte Offset im Sektorblock
        LD      H,0             ; High - Byte Offset auf Null
        ADD     HL,DE           ; Sektor - Nummer errechnen
        POP     AF              ; Low - Byte RANDOM - Satznummer holen
        AND     00000111B       ; Bits für Offset im Sektor maskieren
        ADD     A,A             ; mal zwei
        ADD     A,A             ; mal vier
        ADD     A,A             ; mal acht
        ADD     A,A             ; mal sechzehn
        ADD     A,A             ; mal zweiunddreißig
        LD      DE,(S180B)      ; Zeiger auf Speicher für Sektor
        INC     D               ; Blocknummernsektor überspringen
        ADD     A,E             ; Low - Byte Offset im Sektor addieren
        LD      E,A             ; Ergebnis merken
        RET     NC              ; kein Übertrag
        INC     D               ; High - Byte Zeiger auf Speicher für Sektor
        RET
;
;
;    richtigen Sektor der RANDOM - Datei bereitstellen
;
A317B:  LD      A,(IY+64)       ; Low - Byte alte Sektornummer holen
        CP      L               ; mit Low - Byte neue Sektornummer vergleichen
        JR      NZ,A3186        ; nicht gleich
        LD      A,(IY+65)       ; High - Byte alte Sektornummer holen
        CP      H               ; mit High - Byte neue Sektornummer vergleichen
        RET     Z               ; richtigen Sektor im Speicher
A3186:  CALL    A3192           ; RANDOM - Sektor, wenn geändert, wegschreiben
        LD      (IY+64),L       ;! neue Sektornummer merken
        LD      (IY+65),H       ;!
        XOR     A               ; Code 'Lesen'
        JR      A319C           ; RANDOM - Sektor lesen
;
;
;    Überprüfen, ob Sektor der RANDOM - Datei weggeschrieben werden muß
;
A3192:  XOR     A               ; Accu auf Null
        CP      (IY+68)         ; mit Flag 'neue Daten im Speicher' vergleichen
        RET     Z               ; keine neuen Daten im Sektorspeicher
        LD      (IY+68),A       ; Flag 'neue Daten im Speicher' eintragen
        LD      A,3             ; Code 'Schreiben'
;
;
;    Sektor der RANDOM - Datei lesen oder schreiben
;
A319C:  CALL    PUSHR           ; Register IX, HL, BC, DE retten
        LD      C,(IY+64)       ;! absolute Sektornummer holen
        LD      B,(IY+65)       ;!
        LD      DE,256          ; 256 Bytes je Sektor
        LD      HL,(S180B)      ; Zeiger auf Speicher für Blocknummernsektor
        INC     H               ; Zeiger auf Speicher für Sektor
        JP      A379C           ; Sektor schreiben oder lesen
;
;
;    überprüfen, ob Satznummer kleiner als bisher größte geschriebene Satznummer ist
;
A31AF:  LD      L,(IY+20)       ;! bisher größte geschriebene RANDOM - Satz -
        LD      H,(IY+21)       ;! Nummer holen
        LD      DE,(S30D5)      ; aktuelle RANDOM - Satznummer holen  ?
        LD      A,H             ;! bisher größte Satznummer gleich Null  ?
        OR      L               ;!
        JR      NZ,A31C1        ; nein --> schon Sektoren reserviert
        OR      11111111B       ; Zero - Flag zurücksetzen
        SCF                     ; Code 'neue Satznummer ist größer' setzen
        RET
;
A31C1:  CALL    A3794           ; HL - und DE - Register vergleichen
        RET     NC              ; neue Satznummer ist kleiner als bisher größte
        CALL    PUSHR           ; Register IX, HL, BC, DE retten
        DEC     HL              ;! Satznummern corrigieren
        DEC     DE              ;!
        LD      A,L             ;! Blocknummern - Anteil der bisher größten
        AND     10000000B       ;! Satznummer maskieren
        LD      L,A             ;!
        LD      A,E             ;! Blocknummern - Anteil der neuen Satznummer
        AND     10000000B       ;! maskieren
        LD      E,A             ;!
        CALL    A3794           ; HL - und DE - Register vergleichen
        RET     C               ; neuer Satz liegt auch im anderen Block
        SCF                     ; Code 'neue Satznummer ist größer' setzen
        RET
;
;
;    überprüfen, ob Sektoren für RANDOM-Satznummer schon reserviert
;
A31D8:  CALL    PUSHR           ; Register IX, HL, BC, DE retten
        LD      HL,(S30D5)      ; RANDOM - Satznummer
        DEC     HL              ; corrigieren
        ADD     HL,HL           ; mal zwei
        LD      B,H             ; Sektorblocknummer merken
        INC     B               ; für Schleife corrigieren
        LD      HL,(S180B)      ; Zeiger auf Speicher für Sektor mit Block-Nummern
A31E5:  LD      A,(HL)          ;! Sektorblocknummer gleich Null  ?
        INC     HL              ;!
        OR      (HL)            ;!
        CALL    Z,A31F3         ; ja --> Sektorblock bereitstellen
        INC     HL              ; Zeiger auf nächste Block - Nummer
        DJNZ    A31E5           ; weitere Block - Nummern überprüfen
        LD      (IY+70),1       ; Flag 'Blocknummernsektor wegschreiben' eintragen
        RET
;
;
;    Sektorblock für RANDOM - Datei bereitstellen und initialisieren
;
A31F3:  CALL    PUSHR           ; Register IX, HL, BC, DE retten
        PUSH    HL              ; Zeiger auf Stelle für Block-Nummer
        LD      DE,16           ; 16 freie Sektoren bereitstellen
        CALL    A3696           ; Sektoren bereitstellen und reservieren
        POP     HL              ; Zeiger auf Stelle für Block - Nummer
        LD      (HL),B          ;! absolute Sektornummer des Sektorblocks
        DEC     HL              ;! eintragen
        LD      (HL),C          ;!
        LD      HL,(S180B)      ; Zeiger auf Speicher für Sektor mit Block-Nummern
        INC     H               ; Zeiger auf Speicher für Sektor
        XOR     A               ; 256 Bytes je Sektor
A3206:  LD      (HL),' '        ;! Speicher für Sektor mit Space vorinitiieren
        INC     HL              ;!
        DEC     A               ;!    Zähler minus eins
        JR      NZ,A3206        ;!    weitere Bytes initiieren
        DEC     H               ; Zeiger wieder auf Anfang Sektor
        LD      DE,256          ; 256 Bytes je Sektor
        LD      A,16            ; 16 Sektoren blocken
A3212:  PUSH    AF              ; Restanzahl Sektoren retten
        CALL    B379A           ; Sektor auf Diskette wegschreiben
        POP     AF              ; Zähler Restanzahl Sektoren wieder holen
        INC     BC              ; Sektor - Nummer plus eins
        DEC     A               ; Zähler minus eins
        JR      NZ,A3212        ; weitere Sektoren initiieren
        RET
;
;
;    nächsten Sektor der sequentiellen Datei für Lesen bereitstellen
;
A321C:  LD      L,(IY+20)       ;! Restdateilänge holen
        LD      H,(IY+21)       ;!
        LD      A,H             ;! gleich Null  ?
        OR      L               ;!
        SCF                     ; Code 'Dateiende' setzen
        RET     Z               ; Restdateilänge gleich null
        LD      DE,-254         ; Anzahl Bytes je Sektor
        PUSH    HL              ; alte Restdateilänge merken
        ADD     HL,DE           ; neue Restdateilänge errechnen
        JR      C,A3230         ; Restdateilänge stimmt
        LD      HL,0            ; neue Restdateilänge ist null
A3230:  LD      (IY+20),L       ;! neue Restdateilänge merken
        LD      (IY+21),H       ;!
        POP     DE              ; alte Restdateilänge holen
        LD      HL,(S180B)      ; Zeiger auf Speicher für Sektor holen
        DEC     HL
        LD      (HL),D          ;! alte Restdateilänge eintragen
        DEC     HL              ;!
        LD      (HL),E          ;!
        CALL    A3258           ; nächsten Sektor von Diskette lesen
        OR      A               ; Carry - Flag zurücksetzen
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        BIT     2,A             ; XOPEN - Bit abfragen
        RET     NZ              ; nicht XOPEN
        LD      HL,(S180D)      ; Zeiger auf Sektornummer im Sektor
        LD      A,(HL)          ; Low - Byte Sektornummer holen
        LD      (IY+30),A       ; und als Low - Byte für nächsten Sektor merken
        INC     HL              ; Zeiger auf High - Byte Sektornummer
        LD      A,(HL)          ; High - Byte Sektornummer holen
        LD      (IY+31),A       ; als High - Byte für nächsten Sektor merken
        LD      DE,0
        RET
;
;
;    Sektornummer des nächsten Sektors holen und nächsten Sektor der sequentiellen Datei
;    lesen oder Blocknummernsektor der RANDOM - Datei lesen
;
A3258:  LD      C,(IY+30)       ;! Sektornummer des nächsten (ersten) Sektors
        LD      B,(IY+31)       ;! aus Inhaltsverzeichnis-Eintrag holen
        LD      A,B             ;! Sektornummer gleich Null  ?
        OR      C               ;!
        JP      Z,A1F8B         ; ja --> Fehler 41  Hardware error
        LD      DE,256          ; 256 Bytes je Sektor
        LD      HL,(S180B)      ; Zeiger auf Speicher für Sektor
        JP      A379B           ; Sektor von Diskette lesen
;
        RET
;
;
;    Datensatz aus RANDOM - Datei lesen   (Software Kommando  65)
;
INREC:  XOR     A               ; Code 'Textende'
        LD      (DE),A          ; erst einmal vorgeben
        PUSH    HL              ; Keep register value
        PUSH    DE              ;! Zeiger auf Stelle für RANDOM - Satz
        PUSH    DE              ;! retten
        CALL    A31AF           ; überprüfen, ob Satznummer kleiner als bisher größte
        POP     DE              ; Zeiger auf Stelle für RANDOM - Satz holen
        JR      C,A3297         ; Satznummer ist größer --> Dateiende
        CALL    A181A           ; interne Gerätenummer als Ausgabe-Geräte-Nummer vorgeben
        PUSH    DE              ; Zeiger auf Stelle für RANDOM-Satz retten
        CALL    A314C           ; Sektornummer und Zeiger auf Stelle für Datensatz errechnen
        CALL    A317B           ; richtigen Sektor der RANDOM - Datei bereitstellen
        EX      DE,HL           ; Zeiger auf Stelle im Sektor nach HL
        POP     DE              ; Zeiger auf Stelle für RANDOM - Satz holen
        CALL    A35EA           ; 32 Byte von (HL) nach (DE) übertragen
        XOR     A               ; Code 'Textende'
        LD      (DE),A          ; hinter RANDOM-Datensatz eintragen
        CALL    A3142           ; RANDOM - Satznummer plus eins
        LD      B,32            ; 32 Byte bereitgestellt
        XOR     A               ; Code 'Funktion OK'
        LD      HL,(S1040)      ; Zeiger auf aktuellen Datei-Verwaltungssatz
        INC     HL              ; Datei-Nummer überspringen
        RES     7,(HL)          ; Code 'nicht Dateiende' setzen
        JR      A329F           ; gerettete Register holen
;
;
;    versucht, Datensatz hinter Dateiende zu lesen --> EOF
;
A3297:  XOR     A               ; Code 'Funktion OK'
        LD      B,A             ; Null Byte bereitgestellt
        LD      HL,(S1040)      ; Zeiger auf aktuellen Datei-Verwaltungssatz
        INC     HL              ; Datei - Nummer überspringen
        SET     7,(HL)          ; Code 'Dateiende' setzen
A329F:  POP     DE              ; Zeiger auf bereitgestellten Datensatz
        POP     HL              ; geretteten Register-Wert holen
        RET
;
;
;    Programmblock von Diskette lesen
;
A32A2:  LD      DE,(S1014)      ; Datei-Länge holen
        LD      BC,(S101E)      ; Sektornummer erster Sektor holen
        CALL    A379B           ; Sektor(en) von Diskette lesen
        JP      A34CE           ; nicht mehr benötigte Diskettendaten im Rechner löschen
;
;
;    Sektoren für Programm bereitstellen, Programm auf Diskette schreiben
;
A32B0:  CALL    A32BA           ; Anzahl Sektoren errechnen/Programm-Daten wegschreiben
        LD      IY,S1000        ; Zeiger auf Speicher für Datei - Kennung
        JP      A33DC           ; Programm ins Inhaltsverzeichnis eintragen
;
;
;    Anzahl Sektoren für Programm errechnen und Programm auf Diskette wegschreiben
;
A32BA:  PUSH    DE              ; Zeiger auf Speicherbereich merken
        CALL    A3596           ; Anzahl Sektoren der Datei errechnen
        CALL    A3696           ; Sektoren bereitstellen und reservieren
        LD      (S101E),BC      ; Sektornummer erster Sektor merken
        LD      D,E             ; Anzahl Sektoren
        LD      E,0             ; DE enthält Anzahl Sektoren
        POP     HL              ; Zeiger auf Speicherbereich
        JP      B379A           ; Sektor(en) auf Diskette wegschreiben
;
;
;    SWAP - Hauptprogramm wegschreiben oder lesen    (SVC code:  68)
;
FSWAP:  OR      A               ; Flag 'Lesen/Schreiben'
        JR      NZ,A3304        ; SWAP - Hauptprogramm lesen
;
;
;    SWAP - Hauptprogramm auf Diskette wegschreiben
;
        PUSH    DE              ; Zeiger auf Speicherbereich mit SWAP - Hauptprogramm
        CALL    A333A           ; untersuchen, ob SWAP - Hauptprogramm vorhanden
        LD      A,0             ; Code 'Sektoren freigeben'
        CALL    Z,A3321         ; ja --> altes SWAP - Hauptprogramm löschen
        POP     DE              ; Zeiger auf Speicherbereich mit SWAP - Hauptprogramm
        CALL    A32BA           ; Programm-Daten auf Diskette bereitstellen
        LD      HL,S1000        ; Zeiger auf Speicher für Datei-Kennung
        OR      11111111B       ; Code 'Sektoren sperren'
        CALL    A3321           ; Sektoren für SWAP - Hauptprogramm sperren
        CALL    A35F0           ; Sektorverzeichnis auf Diskette schreiben
        LD      HL,S27D0        ; Zeiger auf Speicher für Inhaltsverzeichnis
        LD      (HL),081H       ; Code 'SWAP - Hauptprogramm'
        PUSH    HL              ;! Zeiger auf Stelle für Sektorenverzeichnis
        POP     IY              ;! nach IY
        LD      HL,(S1014)      ; Datei-Länge holen
        LD      (IY+20),L       ;! und als Datei-Länge in Inhaltsverzeichnis-
        LD      (IY+21),H       ;! Eintrag eintragen
        LD      HL,(S101E)      ; Sektornummer erster Sektor holen
        LD      (IY+30),L       ;! Sektornummer des ersten Sektors in
        LD      (IY+31),H       ;! Inhaltsverzeichnis-Eintrag eintragen
        JP      A3702           ; Inhaltsverzeichnis auf Diskette schreiben
;
;
;    SWAP - Hauptprogramm von Diskette lesen
;
A3304:  PUSH    HL              ; Keep register value
        CALL    A333A           ; untersuchen, ob SWAP - Hauptprogramm vorhanden
        JP      NZ,A1F9D        ; nein -->  Fehler 52  Disk mismatch error
        DEC     (HL)            ; Datei-Typ-Code wieder auf 'kein SWAP-Programm
        LD      DE,S1000        ; Zeiger auf Speicher für Datei - Kennung
        CALL    A35EA           ; 32 Byte von (HL) nach (DE) übertragen
        CALL    A3702           ; Inhaltsverzeichnis auf Diskette schreiben
        XOR     A               ; Code 'Sektoren freigeben'
        LD      HL,S27D0        ; Zeiger auf Speicher für Inhaltsverzeichnis
        CALL    A3321           ; Sektoren des SWAP - Hauptprogrammes freigeben
        CALL    A35F0           ; Sektorverzeichnis auf Diskette schreiben
        POP     HL              ; geretteten Register-Wert holen
        RET
;
;
;    Sektoren der Datei mit Inhaltsverzeichnis-Eintrag (HL) sperren oder freigeben
;
A3321:  CALL    PUSHR           ; Register IX, HL, BC, DE retten
        PUSH    AF              ; Flag 'Sektoren sperren/freigeben' retten
        LD      DE,20           ; Offset auf Dateilänge
        ADD     HL,DE           ; Zeiger auf Dateilänge errechnen
        CALL    LDDEMI          ; Dateilänge aus Inhaltsverzeichnis holen
        LD      BC,8            ; Offset auf erste Sektornummer
        ADD     HL,BC           ; Zeiger auf erste Sektornummer
        LD      C,(HL)          ;! Sektornummer des ersten Sektors aus
        INC     HL              ;! Inhaltsverzeichnis - Eintrag holen
        LD      B,(HL)          ;!
        CALL    A359E           ; Anzahl Sektoren der Datei errechnen
        POP     AF              ; Flag 'Sektoren sperren/freigeben'
        JP      A363D           ; Sektoren sperren oder freigeben
;
;
;    Investigate whether SWAP - main program is present
;
A333A:  CALL    A1D27           ; deletable table of contents on device ?
        JP      Z,A1FAC         ; no --> Error 57: Can't execute error
        CALL    A35FC           ; Read sector directory/compare with computer directory
        CALL    A36FD           ; Read table of contents from diskette
        LD      A,(HL)          ; Get file type mode of first entry
        CP      081H            ; SWAP main program saved?
        RET
;
;
;
;
T334A:  LD      A,00001001b     ; 'Open file for reading' code
        LD      (S1043),A       ; remember file access mode
;
;
;    Datei auf Diskette eröffnen
;
A334F:  CALL    A3739           ; alle Inhaltsverzeichnis-Einträge bereitstellen
        DEFW    A3378           ; Adresse für 'Eintrag vorhanden'
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        BIT     0,A             ; Datei zum Lesen eröffnen  ?
        JP      NZ,A1F88        ; ja --> Fehler 40  File not found error
        PUSH    AF              ; Datei - Zugriffscode retten
        LD      DE,1            ; einen Sektor bereitstellen
        CALL    A3696           ; Sektor bereitstellen und reservieren
        LD      (IY+30),C       ;! Sektornummer des ersten Sektors in
        LD      (IY+31),B       ;! Inhaltsverzeichnis-Eintrag eintragen
        LD      (IY+70),1       ; Flag 'Blocknummernsektor wegschreiben'
        POP     AF              ; Datei - Zugriffscode holen
        BIT     1,A             ; Datei zum Schreiben eröffnen  ?
        RET     Z               ; nein
        LD      HL,(S180D)      ; Zeiger auf Sektornummer im Sektor
        LD      (HL),C          ;! Sektornummer des ersten Sektors eintragen
        INC     HL              ;!
        LD      (HL),B          ;!
        RET
;
A3378:  RET     M               ; SWAP - Eintrag
        RET     Z               ; Eintrag nicht belegt
        CALL    A1EAF           ; Dateinamen (HL) mit vorgegebenem Dateinamen vergleichen
        RET     NZ              ; Dateinamen nicht gleich
        POP     AF              ; Rücksprungadresse verwerfen
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        BIT     1,A             ; Datei zum Schreiben eröffnen  ?
        JP      NZ,A1F8E        ; ja --> Fehler 42  Already exist error
        LD      (S33BF),HL      ; Zeiger auf letzten behandelten Inhaltsverzeichnis-Eintrag
        PUSH    HL              ; Zeiger auf Datei-Eintrag retten
        CALL    A35EA           ; 32 Byte von (HL) nach (DE) übertragen
        LD      B,32            ; Länge Inhaltsverzeichniseintrag
        CALL    CLRDE           ; Speicherbereich (DE) löschen
        POP     HL              ; Zeiger auf Datei-Eintrag holen
        LD      A,(HL)          ; Datei-Typ-Modus holen
        PUSH    IY              ;! Zeiger auf Datei-Kennung
        POP     DE              ;! Dateidatensatz nach DE
        CALL    A35EA           ; 32 Byte von (HL) nach (DE) übertragen
        LD      HL,S1043        ; Datei-Zugriffscode holen
        BIT     3,(HL)
        RET     NZ
        BIT     0,(HL)          ; Datei zum Lesen eröffnen  ?
        JP      NZ,A321C        ; nächsten Sektor der sequentiellen Datei für Lesen bereitstellen
        CALL    A3624           ; Sektorverzeichnis des Laufwerks bereitstellen
        CALL    A3258           ; Blocknummernsektor der RANDOM-Datei lesen
        LD      D,H             ;! Zeiger auf Speicher mit Blocknummern-
        LD      E,L             ;! sektor nach DE
A33AE:  LD      A,(HL)          ;! Blocknummer vorhanden  ?
        INC     HL              ;!
        OR      (HL)            ;!
        INC     HL
        JR      NZ,A33AE        ; ja --> Ende der Blocknummern suchen
        DEC     HL              ;! Zeiger wieder auf letzte Blocknummer
        DEC     HL              ;!
        SBC     HL,DE           ; Offset auf letzte Blocknummer errechnen
        LD      (IY+66),L       ;! und merken
        LD      (IY+67),H       ;!
        RET
;
S33BF:  DEFS    2               ; Zeiger auf letzten behandelten Inhaltsverzeichnis-Eintrag
;
;
;    Datei auf Diskette schließen oder Dateidaten im Rechner löschen
;
A33C1:  LD      A,B             ; Flag 'Schließen/Löschen' holen
        OR      A               ; Dateidaten löschen  ?
        RET     Z               ; ja --> fertig
        LD      A,(S1043)       ; Datei-Zugriffscode holen
        BIT     0,A             ; Datei zum Lesen eröffnen  ?
        RET     NZ              ; ja
        BIT     2,A             ; Datei für Schreiben/Lesen eröffnen  ?
        JR      NZ,A33F5        ; ja --> RANDOM - Datei
        LD      A,00000110B     ; Code 'letzten Sektor schreiben'
        CALL    A30D7           ; letzten Sektor auf Diskette schreiben
        PUSH    IY              ;! Zeiger auf Datei-Kennung im Dateiverwaltungs-
        POP     HL              ;! Datensatz nach HL
        LD      DE,S1000        ; Zeiger auf Speicher für Datei-Kennnung
        CALL    A35EA           ; 32 Byte von (HL) nach (DE) übertragen
A33DC:  CALL    A3739           ; alle Inhaltsverzeichnis-Einträge bereitstellen
        DEFW    A33EC           ; Adresse für 'Eintrag vorhanden'
        JP      Z,A1F9A         ; Fehler 51  Too many files error
A33E4:  LD      A,1             ; Code 'Datei im Inhaltsverzeichnis eintragen'
        LD      B,(IY+0)        ; Datei - Typ - Modus holen
        JP      A3530           ; Datei im Inhaltsverzeichnis der Diskette eintragen
;
;
;   untersuchen, ob Dateiname (HL) ungleich vorgegebenem Dateinamen ist
;
A33EC:  RET     M               ; SWAP - Eintrag
        RET     Z               ; Datei - Eintrag nicht belegt
        CALL    A1EAF           ; Dateinamen (HL) mit vorgegebenem Dateinamen vergleichen
        RET     NZ              ; Dateinamen nicht gleich
        JP      A1F8E           ; Fehler 42  Already exist error
;
;
;    RANDOM - Datei schließen
;
A33F5:  CALL    A3192           ; RANDOM - Sektor, wenn geändert, wegschreiben
        LD      A,(IY+70)       ; Flag 'Blocknummernsektor wegschreiben'
        OR      A               ; nicht gesetzt  ?
        RET     Z               ; ja --> fertig
        CALL    A3739           ; alle Inhaltsverzeichnis-Einträge bereitstellen
        DEFW    A3407           ; Adresse für 'Eintrag vorhanden'
        JP      Z,A1F9A         ; Fehler 51  Too many files error
        JR      A33E4           ; Datei ins Inhaltsverzeichnis der Diskette eintragen
;
A3407:  RET     M               ; SWAP - Eintrag
        RET     Z               ; Eintrag nicht belegt
        CALL    A1EAF           ; Dateinamen (HL) mit vorgegebenem Dateinamen vergleichen
        RET     NZ              ; Dateinamen nicht gleich
        POP     AF              ; Rücksprungadresse verwerfen
        LD      (IY+69),1       ; Flag 'Sektor mit Sektorblocknummern behandeln' eintragen
        LD      A,(HL)          ; Datei-Typ-Modus aus Inhaltsverzeichnis
        CP      (IY+0)          ; mit Datei-Typ der Datei vergleichen
        JP      NZ,A1FB2        ; Fehler 61, Illegal filemode error
        JR      A33E4           ; Daten ins Inhaltsverzeichnis der Diskette eintragen
;
;
;    Datei schützen oder freigeben    (SVC code:  63)
;
FLOCK:  CALL    PUSHR           ; Register IX, HL, BC, DE retten
        LD      (D3434+1),A     ; Flag 'Sperren/Freigeben' eintragen
        CALL    A3739           ; alle Inhaltsverzeichnis-Einträge bereitstellen
        DEFW    A3429           ; Adresse für 'Eintrag vorhanden'
        JP      A1F88           ; Fehler 40  File not found error
;
A3429:  RET     Z               ; Eintrag nicht belegt
        RET     M               ; SWAP - Eintrag
        CALL    A1EAF           ; Dateinamen (HL) mit vorgegebenem Dateinamen vergleichen
        RET     NZ              ; Dateinamen nicht gleich
        POP     AF              ; Rücksprungadresse verwerfen
        LD      BC,18           ; Offset auf Datei-Schutz-Flag
        ADD     HL,BC           ; Zeiger auf Datei-Schutz-Flag errechnen
D3434:
        LD      (HL),-1         ; Flag 'Sperren/Freigeben' eintragen
A3436:  CALL    A3702           ; Inhaltsverzeichnis auf Diskette schreiben
        JP      A34CE           ; nicht mehr benötigte Diskettendaten im Rechner löschen
;
;
;    Datei löschen     (SVC code: 61)
;
FDELET: CALL    PUSHR           ; Register IX, HL, BC, DE retten
        CALL    A1D27           ; aktuelles Gerät gleich Diskette  ?
        JR      NZ,A3458        ; ja -->  Datei auf Diskette löschen
        LD      HL,(S1061)      ; Anfangsadresse  'Datei löschen'  holen
        LD      A,L             ;! Adresse vorhanden  ?
        OR      H               ;!
        JR      Z,A3488         ; nein -->  Fehler 58'  Can't execute error
        PUSH    HL              ; Anfangsadresse der Geräte - Routine retten
        RST     DO_CMD          ; Software - Kommando aufrufen
        DEFB    47              ; Kommando  47  (Programm-) Datei eröffnen
        LD      A,00000010B     ; Code for 'Datei zum Schreiben eröffnen'
        LD      (S1043),A       ; als Datei - Zugriffscode merken
        CALL    A1C6D           ; testen, ob auf Gerät nicht schon Datei zum Schreiben eröffnet
        JR      A349D           ; Datei löschen
;
;
;   Datei auf Diskette löschen
;
A3458:  RST     DO_CMD          ; Software - Kommando ausführen
        DEFB    47              ; Kommando  47   (Programm-)  Datei eröffnen
        LD      HL,(S33BF)      ; Zeiger auf letzten behandelten Inhaltsverzeichnis-Eintrag
        CALL    A34C1           ; Abfrage, ob Datei schreibgeschützt ist
        PUSH    HL              ; Zeiger auf Inhaltsverzeichniseintrag retten
        LD      IX,T3471        ; Adresse 'Dateinamen vergleichen'
        CALL    A1C71           ; alle vorhandenen Datei - Datensätze überprüfen
        POP     HL              ; Zeiger auf Inhaltsverzeichnis - Eintrag holen
        LD      B,(HL)          ; Datei - Typ - Modus holen
        XOR     A               ; Code for 'Datei gelöscht'
        LD      (IY+0),A        ; eintragen
        JP      A3530           ; Datei löschen und geänderte Daten im Inhaltsverzeichnis eintragen
;
T3471:  INC     HL              ;! Zeiger auf Datei-Datensatz auf Dateinamen
        INC     HL              ;! stellen
        INC     HL              ;!
        CALL    A1EAF           ; Dateinamen (HL) mit vorgegebenem Dateinamen vergleichen
        JP      Z,A1F91         ; Fehler 43  Already open error
        RET
;
;
;   Datei umbenennen     (SVC code:  62)
;
FRENAM: CALL    PUSHR           ; Register IX, HL, BC, DE retten
        CALL    A1D27           ; aktuelles Gerät gleich Diskette  ?
        JR      NZ,A34A2        ; ja -->  Datei auf Diskette umbenennen
        LD      HL,(S1063)      ; Anfangsadresse  'Datei umbenennen'  holen
        LD      A,L             ;! Adresse vorhanden  ?
        OR      H               ;!
A3488:  JP      Z,A1FAC         ; nein -->  Fehler 58'  Can't execute error
        PUSH    HL              ; Anfangsadresse der Geräte - Routine retten
        RST     DO_CMD          ; Software - Kommando ausführen
        DEFB    47              ; Kommando  47   (Programm-)  Datei eröffnen
        LD      HL,S1000        ; Zeiger auf Speicher für Datei - Kennung
        CALL    A1EC9           ; Dateinamen aus Text (HL) nach (DE) bereitstellen
        LD      HL,256 * 2 + 0  ; Code for 'zum Schreiben eröffnen'
        LD      (S1042),HL      ; als Datei - Zugriffscode merken
        CALL    A1C3D           ; prüfen, daß nur eine Datei eröffnet/Name noch nicht vorhanden
A349D:  POP     IX              ; Anfangsadresse der Routine nach IX
        JP      IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
;
;
;   Datei auf Diskette umbenennen
;
A34A2:  RST     DO_CMD          ; Software - Kommando ausführen
        DEFB    47              ; Kommando  47   (Programm-)  Datei eröffnen
        LD      HL,S1000        ; Zeiger auf Speicher für Dateinamen
        CALL    A1EC9           ; Dateinamen aus Text (HL) nach (DE) bereitstellen
        CALL    A3739           ; alle Inhaltsverzeichnis-Einträge bereitstellen
        DEFW    A33EC           ; Adresse  'Untersuchen, daß Dateinamen ungleich vorgegeb. ist'
        LD      HL,(S33BF)      ; Zeiger auf letzten behandelten Inhaltsverzeichnis-Eintrag
        CALL    A34C1           ; Abfrage, ob Datei schreibgeschützt ist
        LD      DE,S1001        ; Zeiger auf neuen Dateinamen
        INC     HL              ; Datei - Typ - Flag im Inhaltsverzeichnis überspringen
        LD      B,17            ; maximale Länge Dateiname
        CALL    LDHLDE          ; Speicherbereich von (DE) nach (HL) übertragen
        JP      A3436           ; Inhaltsverzeichnis auf Diskette schreiben
;
;
;    Abfrage, ob Datei schreibgeschützt ist
;
A34C1:  CALL    PUSHR           ; Register IX, HL, BC, DE retten
        LD      DE,18           ; Abstand zum Schreib-Schutz-Flag
        ADD     HL,DE           ; Zeiger auf Schreib-Schutz-Flag errechnen
        LD      A,(HL)          ; Schreib-Schutz-Flag holen
        OR      A               ; Schreib-Schutz gesetzt  ?
        RET     Z               ; nein -->  OK
        JP      A1F94           ; Fehler 46  Write protect error
;
;
;    nicht mehr benötigte Diskettendaten im Rechner löschen
;
A34CE:  CALL    PUSHRA          ; Register IX, HL, BC, DE retten
        XOR     A               ; Accu auf Null
        LD      (S1FD9),A       ; Ausgabe - Dateinummer löschen
        LD      A,224           ; interne Dateinummer für verschiedene Speicher vorgeben
A34D7:  PUSH    AF              ; Dateinummer retten
        RST     DO_CMD          ; Software-Kommando ausführen
        DEFB    43              ; Code 43  Dynamischen Speicherbereich löschen
        POP     AF              ; gerettete Dateinummer holen
        INC     A               ; plus eins
        JR      NZ,A34D7        ; weitere dynamischen Speicherbereich löschen
        LD      HL,(ZEQT)       ; Zeiger auf aktuelle Geräte - Tabelle
        LD      DE,W37C2        ; Zeiger auf Geräte - Treiber FDx:
        CALL    A3794           ; HL -  und DE - Register vergleichen
        RET     NZ              ; nicht Diskettenstation
        LD      A,(ZCH)         ; Geräte - Nummer holen
        EXX
        LD      H,A             ; Geräte - Nummer merken
        LD      D,0             ; Code 'Keine Diskettenstation mehr im Zugriff'
        LD      B,3             ; vier Diskettenlaufwerke überprüfen
        EXX
        XOR     A               ; Accu auf Null
        LD      (S1042),A       ; als interne Geräte - Nummer merken
A34F6:  EXX
        LD      A,B             ; Geräte - Nummer holen
        LD      (ZCH),A         ; Geräte - Nummer eintragen
        ADD     A,144           ; umrechnen in Datensatznummer für Sektorverzeichnis
        LD      L,A             ; Datensatznummer für Sektorverzeichnis merken
        LD      E,0             ; Code 'keine Datei mehr auf Laufwerk eröffnet'
        EXX
        LD      IX,T3522        ; Adresse 'merken, daß Laufwerk im Zugriff ist'
        CALL    A1C71           ; alle vorhandenen Datei - Datensätze durchspielen
        EXX
        BIT     7,E             ; Datei auf Laufwerk offen
        LD      A,L             ; Speichernummer des Sektorverzeichnisses holen
        EXX
        CALL    Z,DELSEG        ; Laufwerk nicht mehr im Zugriff --> Dynamischen Spei-
        EXX                     ;        cher löschen
        DEC     B               ; Laufwerk - Nummer minus eins
        EXX
        JP      P,A34F6         ; weitere Laufwerke überprüfen
        EXX
        LD      A,H             ; gemerkte Geräte - Nummer holen
        LD      (ZCH),A         ; und als Geräte - Nummer eintragen
        BIT     7,D             ; überhaupt noch Datei auf Diskette offen  ?
        EXX
        CALL    Z,A38C2         ; nein --> Disketten - Routinen initialisieren und Motoren
        RET                     ;             ausschalten
;
T3522:  EXX
        LD      DE,-1           ; Code 'Laufwerk im Zugriff' merken
        EXX
        RET
;
;
;    Zeiger auf Speicher für Sektorverzeichnis des aktuellen
;    Laufwerks bereitstellen
;
A3528:  LD      A,(ZCH)         ; Geräte - Nummer holen
        ADD     A,144           ; umrechnen in Datensatz für Sektorverzeichnis
        RST     DO_CMD          ; Software - Kommando ausführen
        DEFB    41              ; Code 41  Zeiger auf Datensatz nach Nummer im Accu
        RET                     ;   bereitstellen
;
;
;    Datei löschen oder Datei im Inhaltsverzeichnis eintragen
;
A3530:  LD      (S3595),A       ; Flag 'Sektor sperren / freigeben' merken
        LD      A,B             ; Datei - Typ der Datei holen
        PUSH    AF              ; und merken
        EX      DE,HL           ; Zeiger auf Dateinamen nach DE
        LD      HL,S1000        ; Zeiger auf Speicher für Datei - Kennung
        CALL    A35EA           ; 32 Byte von (HL) nach (DE) übertragen
        CALL    A35FC           ; Sektorverzeichnis lesen/mit Rechnerverzeichnis vergleichen
        POP     AF              ; geretteten Datei - Typ holen
        CP      _BRD + 1        ; bekannter Datei - Typ  ?
        JR      C,A354E         ; ja
        LD      A,(S1012)       ; Schreib - Schutz - Byte holen
        RLA
        LD      A,_BSD          ; Vorgabe 'Datei in Datenblocks'
        JR      NC,A354E
        LD      A,_OBJ          ; Vorgabe 'Datei als Programmblock'
A354E:  LD      HL,W3564 + -2   ; Anfangsadressen der DELETE - Routinen
        ADD     A,A             ; Datei - Typ mal zwei
        CALL    ADDHLA          ; Wert im Accu zu HL-Register addieren
        CALL    INDRCT          ; Wert aus Tabelle (HL) nach HL holen
        CALL    A00A7           ; Programm (HL) als Unterprogramm aufrufen
        CALL    A3702           ; Inhaltsverzeichnis auf Diskette schreiben
        CALL    A35F0           ; Sektorverzeichnis auf Diskette schreiben
        JP      A34CE           ; nicht  mehr benötigte Diskettendaten im Rechner löschen
;
;
;    Tabelle mit Anfangsadressen der DELETE - Routinen der Datei - Typen
;
W3564:  DEFW    A358C           ; Adresse  DELETE OBJ - Datei
        DEFW    A358C           ; Adresse  DELETE BTX - Datei
        DEFW    A356C           ; Adresse  DELETE BSD - Datei
        DEFW    A35A8           ; Adresse  DELETE BRD - Datei
;
;
;    Sequentielle Datei (BSD) auf Diskette löschen
;    Sektoren für sequentielle Datei auf Diskette sperren
;
A356C:  LD      HL,S1020        ; Zeiger auf Ende Speicher für Directory-Eintrag
A356F:  DEC     HL              ; Zeiger auf Sektornummer
        LD      B,(HL)          ;! Sektornummer des nächsten Sektors
        DEC     HL              ;! holen
        LD      C,(HL)          ;!
        LD      A,B             ;! gleich null  ?
        OR      C               ;!
        RET     Z               ; ja -->  fertig
        LD      DE,256          ; Länge ein Sektor auf Diskette
        LD      HL,S11A4        ; Zeiger auf Zwischenspeicher für Sektor
        PUSH    HL              ; Zeiger auf Speicher für Sektor merken
        PUSH    DE              ; Länge des Sektors merken
        CALL    A379B           ; Sektor von Diskette lesen
        LD      DE,1            ; Anzahl Sektoren vorgeben
        CALL    A358F           ; Sektor sperren oder freigeben
        POP     DE              ; Sektorlänge holen
        POP     HL              ; Zeiger auf Anfang Sektor holen
        ADD     HL,DE           ; Zeiger auf Ende Sektor errechnen
        JR      A356F           ; weitere Sektoren freigeben
;
;
;    Maschinensprachendatei (OBJ) oder Basic-Daten (BTX) löschen
;    oder Sektoren für Datei auf Diskette sperren
;
A358C:  CALL    A3596           ; Anzahl Sektoren der Datei errechnen
A358F:  LD      A,(S3595)       ; Flag 'Sektoren sperren/freigeben' holen
        JP      A363D           ; Sektoren sperren oder freigeben
;
;
S3595:  DEFS    1               ; Flag 'Sektor sperren / freigeben' holen
;
;
;    Anzahl der Sektoren der Datei errechnen
;
A3596:  LD      DE,(S1014)      ; Datei - Länge holen
        LD      BC,(S101E)      ; Sektornummer erster Sektor holen
A359E:  LD      A,E             ;! Dateilänge gleich null  ?
        OR      D               ;!
        JR      Z,A35A3         ; ja
        DEC     DE              ; Dateilänge corrigieren
A35A3:  INC     D               ; Anzahl Sektoren corrigieren
        LD      E,D             ; Anzahl Sektoren der Datei
        LD      D,0             ; DE enthält Anzahl Sektoren
        RET
;
;
;    RANDOM - Datei (BRD) auf Diskette löschen oder
;    Sektoren der Datei auf Diskette sperren
;
A35A8:  LD      DE,256          ; Sektorlänge
        LD      BC,(S101E)      ; Sektornummer erster Sektor holen
        LD      A,(S3595)       ; Flag 'Sektor sperren / freigeben' holen
        OR      A               ; Datei löschen  ?
        LD      HL,S11A4        ; Zeiger auf Zwischenspeicher
        JR      Z,A35BB         ; Code 'Sektoren freigeben'
        LD      HL,(S180B)      ; Zeiger auf Speicher mit Blocknummern
A35BB:  PUSH    HL              ; Zeiger auf Blocknummernsektor
        PUSH    AF              ; Flag 'Lesen / Schreiben' merken
        CALL    A379C           ; Blocknummernsektor schreiben oder Lesen
        POP     AF              ; Flag 'Lesen / Schreiben' holen
        PUSH    AF              ; und wieder merken
        JR      Z,A35C8         ; Datei löschen
        LD      A,(IY+69)       ; Flag 'Sektor mit Sektorblocknummern behandeln'
        OR      A               ; gesetzt  ?
A35C8:  LD      DE,1            ; ein Sektor  (Blocknummernsektor)
        CALL    Z,A358F         ; ja --> Sektor freigeben oder sperren
        POP     AF              ; Flag 'Lesen / Schreiben' holen
        POP     HL              ; Zeiger auf Blocknummernsektor holen
        JR      Z,A35D9         ; Datei löschen
        LD      E,(IY+66)       ;! Offset auf letzte geschriebene Block-
        LD      D,(IY+67)       ;! nummer holen
        ADD     HL,DE           ; Zeiger auf zu behandelnde Blocknummer errechnen
A35D9:  LD      C,(HL)          ;! Sektornummer Blockanfang holen
        INC     HL              ;!
        LD      B,(HL)          ;!
        INC     HL
        LD      A,B             ;! Sektornummer gleich Null  ?
        OR      C               ;!
        RET     Z               ; ja -->  fertig
        PUSH    HL              ; Zeiger auf Sektornummer retten
        LD      DE,16           ; 16 Sektoren je Block
        CALL    A358F           ; Sektoren sperren oder freigeben
        POP     HL              ; Zeiger auf Sektorblocknummern
        JR      A35D9           ; nächsten Block sperren oder freigeben
;
;
;    32 Byte von (HL) nach (DE) übertragen
;
A35EA:  LD      BC,32           ; Länge Directory-Eintrag/Random-Datensatz
        LDIR                    ; Directory - Eintrag übertragen
        RET
;
;
;    Sektorverzeichnis auf Diskette schreiben
;
A35F0:  LD      HL,S2FD0        ; Zeiger auf Speicher für Sektorenverzeichnis
        LD      DE,256          ; 256 Bytes je Sektor
        LD      BC,15           ; Sektornummmer für Sektorverzeichnis
        JP      B379A           ; Sektor auf Diskette wegschreiben
;
;
;    Sektorverzeichnis lesen und mit Sektorverzeichnis im Rechner vergleichen
;
A35FC:  LD      HL,S2FD0        ; Zeiger auf Speicher für Sektorverzeichnis
        CALL    A362D           ; Sektor mit Sektorverzeichnis lesen
        PUSH    HL              ; Zeiger auf Speicher für Sektorverzeichnis
        CALL    A3528           ; Zeiger auf Sektorverzeichnis aktuelles Laufwerk
        EX      DE,HL           ; Zeiger nach DE
        POP     HL              ; Zeiger auf Speicher für Sektorverzeichnis
        RET     C               ; kein aktuelles Sektorverzeichnis im Rechner
        PUSH    HL              ; Zeiger auf Speicher für Sektorverzeichnis
        LD      A,(DE)          ;! Volume - Nummern vergleichen
        CP      (HL)            ;!
        JP      NZ,A1F9D        ; nicht gleich -->  Fehler 52  Disk mismatch error
        LD      BC,6            ; Offset auf Sektorbit-Tabelle
        ADD     HL,BC           ; Zeiger auf Sektorbit-Tabelle errechnen
        EX      DE,HL
        ADD     HL,BC           ; Zeiger auf Sektorbit-Tabelle errechnen
        EX      DE,HL
        LD      B,250           ; 250 Bytes vergleichen
A3618:  LD      A,(DE)          ;! untersuchen, ob im Rechner nicht weniger
        CPL                     ;! Bits gesetzt sind
        AND     (HL)            ;!
        JP      NZ,A1F9D        ; Fehler -->  Fehler 52  Disk mismatch error
        INC     HL              ;! Zeiger auf nächstes Byte
        INC     DE              ;!
        DJNZ    A3618           ; weitere Bytes untersuchen
        POP     HL              ; Zeiger auf Speicher für Sektorverzeichnis holen
        RET
;
;
;    Sektorverzeichnis des aktuellen Laufwerks, wenn noch nicht vorhanden, einlesen
;
A3624:  CALL    A3528           ; Zeiger auf Sektorverzeichnis aktuelles Laufwerk
        RET     NC              ; Sektorverzeichnis schon vorhanden
        LD      DE,256          ; 256 Bytes Länge
        RST     DO_CMD          ; Software - Kommando ausführen
        DEFB    42              ; Code 42  Zwischenspeicher bereitstellen
;
;
;    Sektor mit Sektorverzeichnis des aktuellen Laufwerks lesen
;
A362D:  LD      BC,15           ; Sektor 15  (Sektor mit Sektorverzeichnis)
        LD      DE,256          ; 256 Bytes je Sektor
        XOR     A               ; Code 'Sektor lesen'
        CALL    A379F           ; Sektor mit Sektorverzeichnis lesen
        LD      A,(HL)          ; erstes Byte des Sektors holen
        OR      A               ; größer 128  ?
        JP      M,A1F85         ; ja --> Fehler 128  System ID error
        RET
;
;
;    in DE angegebene Anzahl Sektoren sperren oder freigeben
;
;    im aktuellen Sektorverzeichnis und im Sektorverzeichnis
;    des Laufwerks freigeben
;
A363D:  LD      HL,S2FD0        ; Zeiger auf Speicher für Sektorverzeichnis
        CALL    A364A           ; Sektoren im aktuellen Verzeichnis behandeln
        OR      A               ; Flag 'Sperren / Freigeben'
        RET     NZ              ; Sektoren sperren -->  fertig
        CALL    A3528           ; Zeiger auf Sektorverzeichnis aktuelles Laufwerk
        RET     C               ; kein Sektorverzeichnis im Rechner
        XOR     A               ; Code 'Sektoren freigeben'
;
;
;    Sektoren im Sektorverzeichnis (HL) sperren oder freigeben
;
A364A:  CALL    PUSHRA          ; Register IX, HL, BC, DE, AF retten
        OR      A               ; Flag 'Sperren / Freigeben'
        PUSH    HL              ; Zeiger auf Sektorverzeichnis retten
        LD      HL,0B600H       ; OR (HL)  NOP    (Z-80 - Befehle)
        LD      A,INC_DE        ; Z-80 - Befehl INC DE  (Anzahl Sektoren plus eins)
        JR      NZ,A365B        ; Sektoren sperren
        LD      HL,0A62FH       ; AND (HL)  CPL   (Z-80 - Befehle)
        LD      A,DEC_DE        ; Z-80 - Befehl DEC DE  (Anzahl Sektoren minus eins)
A365B:  LD      (D3678),A       ; INC DE/DEC DE eintragen
        LD      (D368E),HL      ; Befehle für sperren oder freigeben eintragen
        POP     HL              ; Zeiger auf Sektorverzeichnis holen
A3662:  CALL    A366A           ; einen Sektor sperren oder freigeben
        INC     BC              ; Sektornummer plus eins
        DEC     E               ; Restanzahl Sektoren minus eins
        JR      NZ,A3662        ; weitere Sektoren behandeln
        RET
;
;
;    einen Sektor sperren oder freigeben
;
A366A:  CALL    PUSHR           ; Register IX, HL, BC, DE retten
        INC     HL              ; Volume - Nummer überspringen
        LD      A,C             ;! absolute Sektornummer umrechnen in
        SUB     (HL)            ;! Sektoroffset
        LD      C,A             ;!   Low - Byte Offset merken
        JR      NC,A3674        ;!   kein Unterlauf
        DEC     B               ;!   High - Byte Offset corrigieren
A3674:  INC     HL
        LD      E,(HL)          ;! Anzahl belegte Sektoren holen
        INC     HL              ;!
        LD      D,(HL)          ;!
D3678:  NOP                     ; INC DE/DEC DE  (wird eingetragen)
        DEC     HL
        LD      (HL),E          ;! neue Anzahl belegte Sektoren
        INC     HL              ;! wieder eintragen
        LD      (HL),D          ;!
        INC     HL
        INC     HL              ;! größte mögliche Sektornummer
        INC     HL              ;! überspringen
        LD      A,C             ; Low - Byte Sektornummer merken
        LD      E,3             ;! Sektornummer durch 8  (Offset auf Byte errechnen)
A3683:  SRL     B               ;!
        RR      C               ;!
        DEC     E               ;! Zähler minus eins
        JR      NZ,A3683        ;! weiter schieben
        ADD     HL,BC           ; Zeiger auf richtiges Byte errechnen
        CALL    A36F1           ; Bitmaske aus Bitnummer errechnen
D368E:  NOP                     ;! Sektorbit setzen oder zurücksetzen
        NOP                     ;! (Befehle werden eingetragen)
        CP      (HL)            ; neuen Wert mit altem Wert vergleichen
        LD      (HL),A          ; neuen Wert merken
        RET     NZ              ; neuer Wert ist anders als alter Wert
        JP      A1F9D           ; Fehler 52  Disk mismatch error
;
;
;    Sektoren bereitstellen und reservieren
;
A3696:  PUSH    DE              ; Anzahl Sektoren retten
        CALL    A3624           ; Sektorverzeichnis des Laufwerks bereitstellen
        POP     DE              ; gerettete Anzahl Sektoren holen
        PUSH    HL              ; Zeiger auf sektorverzeichnis retten
        CALL    A36A4           ; zusammenhängenden Block freier Sektoren suchen
        POP     HL              ; Zeiger auf sektorverzeichnis holen
        LD      A,1             ; Code 'Sektoren belegen'
        JR      A364A           ; Sektoren im Sektorverzeichnisperren
;
;
;    Zusammenhängenden Block freier Sektoren suchen
;
A36A4:  LD      A,E             ; Anzahl Sektoren holen
        EXX
        LD      E,A             ;! Anzahl zu suchender freier Sektoren
        LD      D,A             ;! merken
        LD      B,00000001B     ; Vorgabe für Bitmaske
        EXX
        INC     HL              ; Volume - Nummer überspringen
        LD      E,(HL)          ; Low - Byte Offset holen
        LD      D,0             ; High - Byte Vorgabe für Sektornummer
        INC     HL              ; Offset überspringen
        INC     HL              ;! Anzahl belegte Sektoren überspringen
        INC     HL              ;!
        LD      C,(HL)          ;! Anzahl Sektoren auf Diskette holen
        INC     HL              ;!
        LD      B,(HL)          ;!
        DEC     BC              ; für größte mögliche Sektornummer corrigieren
        LD      (A36C1+1),BC    ; größte mögliche Sektornummer in Routine eintragen
        INC     HL
        PUSH    HL              ; Zeiger auf Sektorbit - Tabelle auf Stack ablegen
        EXX
        POP     HL              ; Zeiger auf Sektorbit - Tabelle holen
        EXX
        LD      B,D             ;! Sektornummer vorgeben
        LD      C,E             ;!
A36C1:  LD      HL,0            ; größte mögliche Sektornummer holen (wird eingetragen)
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; mit aktueller Sektornummer vergleichen
        JP      C,A1FA0         ; zu groß -->  Fehler 53  No file space error
        EXX
        LD      A,B             ; aktuelle Bitmaske holen
        AND     (HL)            ; Bit in Sektortabelle maskieren
        EXX
        CALL    A36DB           ; untersuchen, ob Sektor noch frei
        INC     DE              ; aktuelle Sektornummer plus eins
        EXX
        RLC     B               ; aktuelle Bitmaske um ein Bit schieben
        JR      NC,A36D8        ; nicht von Bit 7 auf Bit 0 geschoben
        INC     HL              ; Zeiger auf Bittabelle auf nächstes Byte
A36D8:  EXX
        JR      A36C1           ; untersuchen, ob Sektornummer nicht schon zu groß
;
A36DB:  JR      NZ,A36EA        ; Sektor nicht frei --> wieder von vorne anfangen
        EXX
        DEC     E               ; Restanzahl Sektoren minus eins
        EXX
        RET     NZ              ; noch nicht genug freie Sektoren
        POP     AF              ; Rücksprungadresse verwerfen
        EXX
        LD      A,D             ; Anzahl bereitgestellte Sektoren holen
        EXX
        LD      E,A             ; Anzahl bereitgestellte Sektoren
        LD      D,0             ; High - Byte Anzahl auf Null
        OR      A               ; Carry - Flag zurücksetzen  (Code 'Funktion OK')
        RET
;
A36EA:  EXX
        LD      E,D             ; bereitzustellende Anzahl wieder vorgeben
        EXX
        LD      B,D             ;! erste Sektornummer des Blocks wieder vorgeben
        LD      C,E             ;!
        INC     BC              ; Sektornummer plus eins
        RET
;
;
;    Bitmaske aus Bit - Nummer errechnen
;
A36F1:  PUSH    BC              ; Keep register value
        AND     00000111B       ; Bits für Bit-Nummer errechnen
        INC     A               ; Zähler corrigieren
        LD      B,A             ; Zähler merken
        XOR     A               ; Accu auf Null
        SCF                     ; Carry - Flag setzen
A36F8:  ADC     A,A             ; Bit um ein Bit schieben
        DJNZ    A36F8           ; Bit auf richtiges Bit schieben
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;    Inhaltsverzeichnis von Diskette lesen
;
A36FD:  CALL    A44A3           ; warten, bis alle Melodien vollständig gespielt sind
        XOR     A               ; Code 'Lesen'
        DEFB    LD_HL

;
;
;   Inhaltsverzeichnis auf Diskette schreiben
;
A3702:  OR      0FFH            ; Code for 'Schreiben'
        LD      HL,S27D0        ; Zeiger auf Speicher für Inhaltsverzeichnis
        LD      DE,2048         ; Länge Inhaltsverzeichnis
        LD      BC,16           ; Sektornummer des Inhaltsverzeichnisses
        CALL    A379C           ; Inhaltsverzeichnis schreiben oder lesen
        LD      A,(HL)          ; Kennung des SWAP - Programms holen
        OR      A               ; Wert größer 128  ?
        JP      P,A1F85         ; nein -->  Fehler 28  System ID error
        RET
;
;
;    freie Anzahl Kilobyte der Diskette errechnen
;
T3716:  PUSH    HL              ;! Register retten
        PUSH    DE              ;!
        CALL    A35FC           ; Sektorverzeichnis lesen/mit Rechnerverzeichnis vergleichen
        INC     HL              ; Volume - Nummer überspringen
        INC     HL              ; Offset überspringen
        CALL    LDDEMI          ; Anzahl belegte Sektoren holen
        CALL    INDRCT          ; Gesamtzahl Sektoren holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Anzahl freie Sektoren errechnen
        JP      C,A1F85         ; Fehler 28  System ID error
        SRL     H               ;! umrechnen in Kilobyte
        RR      L               ;!
        SRL     H               ;!
        RR      L               ;!
        LD      B,H             ;! Anzahl freie Kilobytes nach BC
        LD      C,L             ;!
        POP     DE              ;! gerettete  Register holen
        POP     HL              ;!
        OR      A               ; Carry - Flag zurücksetzen  (Code 'kein Fehler')
        JP      A38C2           ; Disketten-Routinen initialisieren und Motor ausschalten
;
;
;    Alle Inhaltsverzeichnis-Einträge bereitstellen
;
A3739:  CALL    A1D27           ; löschbares Inhaltsverzeichnis auf Gerät  ?
        JP      Z,A1FAC         ; nein -->  Fehler 57  Can't execute error
        POP     HL              ; Rücksprungadresse vom Stack holen
        CALL    LDDEMI          ; Adresse bei 'Eintrag vorhanden' holen
        LD      (D377B + 1),HL  ; Rücksprung für 'kein Eintrag' eintragen
        LD      (D3761 + 1),DE  ; Rücksprung für 'Eintrag vorhanden' eintragen
        XOR     A               ; Code 'keinen freien Eintrag gefunden'
        LD      (S378E),A       ; im Flag 'freien Eintrag gefunden' merken
        CALL    A36FD           ; Inhaltsverzeichnis von Diskette lesen
        LD      (S3792),HL      ; Zeiger auf aktuellen Eintrag merken
        LD      A,64            ; 64 Inhaltsverzeichniseinträge
        LD      (S3791),A       ; im Zähler 'Restanzahl Inhaltsverzeichnis-Einträge' merken
A3759:  LD      HL,(S3792)      ; Zeiger auf aktuellen Eintrag
        LD      A,(HL)          ; Datei - Typ - Modus holen
        OR      A               ; Inhaltsverzeichnis - Eintrag frei  ?
        CALL    Z,A377E         ; ja --> Zeiger auf freien Eintrag merken
D3761:  CALL    -1              ; Rücksprung für 'Eintrag vorhanden'
        LD      HL,(S3792)      ; Zeiger auf aktuellen Eintrag
        LD      BC,32           ; Länge Inhaltsverzeichnis-Eintrag vorgeben
        ADD     HL,BC           ; Zeiger auf nächsten Eintrag errechnen
        LD      (S3792),HL      ; als Zeiger auf aktuellen Eintrag merken
        LD      HL,S3791        ; Zähler 'Restanzahl Inhaltsverzeichnis-Einträge'
        DEC     (HL)            ; Zähler minus eins
        JR      NZ,A3759        ; weitere Einträge --> abarbeiten
        LD      A,(S378E)       ; Flag 'freier Eintrag gefunden'
        LD      HL,(S378F)      ; Zeiger auf freien Eintrag holen
        OR      A               ; freier Eintrag  ?
D377B:  JP      -1              ; Rücksprung für 'kein Eintrag mehr'
;
;
;    Zeiger auf freien Eintrag merken
;
A377E:  PUSH    AF              ; Datei - Typ - Modus merken
        LD      A,(S378E)       ; Flag 'freier Eintrag gefunden' holen
        OR      A               ; schon freier Eintrag gefunden  ?
        JR      NZ,A378C        ; ja --> geretteten Register - Wert holen
        INC     A               ; Flag auf 'freien Eintrag gefunden'
        LD      (S378E),A       ; im Flag 'freier Eintrag gefunden'
        LD      (S378F),HL      ; Zeiger auf freien Eintrag merken
A378C:  POP     AF              ; geretteten Datei - Typ - Modus holen
        RET
;
;
S378E:  DEFS    1               ; Flag 'freier Eintrag gefunden'
S378F:  DEFS    2               ; Zeiger auf freien Eintrag
S3791:  DEFS    1               ; Zähler 'Restanzahl Inhaltsverzeichnis-Einträge'
S3792:  DEFS    2               ; Zeiger auf aktuellen Eintrag
;
;
;    HL - und DE - Register vergleichen
;
A3794:  PUSH    HL              ; Keep register value
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Register vergleichen
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;    Sektor(en) auf Diskette wegschreiben
;
B379A:  DEFB    OR_N            ; Code for 'Sektor wegschreiben'
;
;
;    Sektor(en) von Diskette lesen
;
A379B:  XOR     A               ; Code 'Sektor lesen'
A379C:  CALL    A37B3           ; überprüfen, ob Diskette gewechselt werden
A379F:  CALL    PUSHR           ; Register IX, HL, BC, DE retten
        OR      A               ; Lesen oder Schreiben  ?
        LD      IX,(S105D)      ; Anfangsadresse 'Sektor lesen' holen
        JR      Z,A37AD         ; Sektor(en) von Diskette lesen
        LD      IX,(S105F)      ; Anfangsadresse 'Sektor schreiben' holen
A37AD:  LD      A,(ZCH)         ; Geräte - Nummer holen
        JP      IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
;
;
;    überprüfen, ob Diskette gewechselt wurde
;
A37B3:  CALL    PUSHRA          ; Register IX, HL, BC, DE, AF retten
        LD      A,(S37EA)       ; Controller - Status - Flag holen
        OR      A               ; Motor an  ?
        RET     M               ; ja --> braucht nicht überprüft zu werden
        CALL    A3528           ; Zeiger auf Sektorverzeichnis aktuelles Laufwerk
        RET     C               ; kein Sektorverzeichnis im Rechner
        JP      A35FC           ; Sektorverzeichnis lesen/mit Rechnerverzeichnis vergleichen
;
;
;    Geräte - Tabelle für Disketten - Stationen  (FDx)
;
W37C2:  DEFW    W3ADA           ; Zeiger auf nächste Geräte - Tabelle  (QD:)
        DEFM    "FD"            ; Geräte - Name
		DEFB    NUL,NUL
        DEFB    00111111B       ; Geräte - Typ - Flag
        DEFB    3               ; Geräte-Nummern - Flag
        DEFB    63              ; Anzahl freie Inhaltsverzeichnis - Einträge
        DEFW    A38C2           ; Gerät initialisieren
        DEFW    15              ; Sektornummer für Sektorverzeichnis
        DEFW    256             ; Sektorlänge
        DEFW    48              ; Anzahl reservierte Sektoren
        DEFW    254             ; Anzahl Zeichen im Sektor sequentielle Datei
        DEFW    A393A           ; Adresse 'Sektor lesen'
        DEFW    A393D           ; Adresse 'Sektor schreiben'
        DEFW    A1FAC           ; Fehler 57  Can't execute error
        DEFW    A1FAC           ; Fehler 57  Can't execute error
        DEFW    A1FAC           ; Fehler 57  Can't execute error
;
;
;   Storage area for floppy disk read/write routines
;
S37DF:  DEFS    1               ; step rate
S37E0:  DEFS    1               ; 'Read/Write' flag
S37E1:  DEFS    1               ; Drive number/mode
S37E2:  DEFS    1               ; Track number from where to start reading
S37E3:  DEFS    1               ; Sector number from where to start reading
S37E4:  DEFS    1               ; Low - Byte Number of bytes to read
S37E5:  DEFS    1               ; Number of sectors to treat
S37E6:  DEFS    2               ; Pointer to memory area
S37E8:  DEFS    1               ; lane pointer
S37E9:  DEFS    1               ; sector pointer
S37EA:  DEFS    1               ; Controller - Status - Flag
                                ; Bit 7 = engine on
                                ; Bit 6 = second side
                                ; Bit 5 = MZ-80K mode
S37EB:  DEFS    1               ; last command
S37EC:  DEFS    4               ; Drive-flags
S37F0:  DEFS    4               ; last track - numbers
S37F4:  DEFS    1               ; Remaining number of errors
;
;
;    Calculate track and sector number from absolute sector number
;
A37F5:  PUSH    BC              ; Save register value
        LD      A,L             ; Low - byte remember absolute sector number
        LD      B,4             ;!  Divide sector number by 16
A37F9:  SRL     H               ;!         (16 sectors per track)
        RR      L               ;!
        DJNZ    A37F9           ;!    keep sharing
        AND     00001111B       ; Mask sector number
        INC     A               ; and correct (from 1 to 16)
        LD      H,A             ; Remember sector number
        POP     BC              ; get saved register value
        RET
;
;
;    Calculate absolute sector number from track and sector number
;
A3805:  LD      A,H             ; Correct sector number
        LD      H,0             ; High - byte track number to zero
        ADD     HL,HL           ;!  Trace - number times two
        ADD     HL,HL           ;!                times four
        ADD     HL,HL           ;!                times eight
        ADD     HL,HL           ;!                times 16 (16 sectors per track)
        DEC     A               ; Correct sector number
        ADD     A,L             ; and add to sector number from track number
        LD      L,A             ; note the result
        RET
;
;
;    Switch on the motors of the drives and select density/side
;
A3810:  CALL    PUSHR           ; Save registers IX, HL, BC, DE
        LD      HL,S37EA        ; Pointer to controller - status - flag
        BIT     7,(HL)          ; engine on ?
        JR      NZ,A3820        ; Yes
        CALL    A38B1           ; Switch on engine and clear drive flags
        CALL    A3ACD           ; Time loop approx. 1.35 ms
A3820:  LD      A,(S37E1)       ; drive - get number
        BIT     2,A             ; MZ-80K - Mode ?
        SET     2,A             ; next time try MZ-80K
        JR      Z,A382B         ; still MZ-700
        SET     5,A             ; code 'single density'
A382B:  SET     7,A             ; code 'engine on'
        LD      HL,S37EA        ; Pointer to controller - status - flag
        BIT     6,(HL)          ; second page  ?
        JR      Z,A3836         ; no
        SET     6,A             ; code 'second page'
A3836:  CALL    A3851           ; Output motor flag, side and density
        LD      (HL),A          ; remember new controller status flag
        LD      HL,S37EC        ; Pointers to Drive - Flags
        CALL    A3849           ; Calculate pointer to correct drive flag
        BIT     0,(HL)          ; Drive already mentioned?
        CALL    Z,A38CA         ; no --> Output 'Restore' to the controller
        RET     C               ; Error occurred
        SET     0,(HL)          ; Set code 'Drive addressed'
        RET
;
;
;    Get pointer to memory for current drive
;
A3849:  LD      A,(S37E1)       ; Drive - get number
        AND     00000011B       ; Drive - mask number
        JP      ADDHLA          ; Add value in Accu to HL register
;
;
;    Output motor flag, side and density
;
A3851:  OUT     (MO_REG),A      ; Output engine on/off
        PUSH    AF              ; Save status
        RLCA                    ;! Shift page bit to bit zero
        RLCA                    ;!
        OUT     (PG_REG),A      ; Output page to controller
        RLCA                    ; Density - shift bit to bit zero
        OUT     (DE_REG),A      ; Output density to controller
        POP     AF              ; Get saved status
        RET
;
;
;    Output track and sector number to controller
;
A385D:  CALL    PUSHR           ; Save registers IX, HL, BC, DE
        LD      D,0             ; Default code 'no value changed'
        LD      A,(S37E8)       ; Get marker
        SRL     A               ; divided by two
        CPL                     ; Complement track number
        OUT     (DA_REG),A      ; Output track number
        LD      B,A             ; note the issued track number
        LD      A,(S37EA)       ; Get Controller - Status - Flag
        RES     6,A             ; code 'first page'
        BIT     5,A             ; MZ-80K - Mode ?
        JR      Z,A3875         ; no
        CCF                     ; Invert side flag
A3875:  JR      C,A3879         ; first page
        SET     6,A             ; code 'second page'
A3879:  CALL    A3851           ; Output motor flag, side and density
        LD      HL,S37EA        ; Pointer to controller - status - flag
        CP      (HL)            ; compare new status with old status
        LD      (HL),A          ; remember new status
        JR      Z,A3884         ; Status has not changed
        INC     D               ; Note status change
A3884:  LD      HL,S37F0        ; Pointer to memory for track numbers
        CALL    A3849           ; Pointer to track number of current drive
        LD      A,(HL)          ; get last track number
        OUT     (TR_REG),A      ; output to track
        CP      B               ; compare with new track number
        JR      Z,A389B         ; traces alike
        INC     D               ; Note status change
        CALL    A38A8           ; Output 'SEEK' to floppy controller
        PUSH    AF              ; Result - save flag
        IN      A,(TR_REG)      ; get new track number
        LD      (HL),A          ; and remember
        POP     AF              ; saved result - get flag
        RET     C               ; Error occurred
        RET     NZ              ; Status is not correct
A389B:  LD      A,(S37E9)       ; Get sector pointer
        CPL                     ; complement for output
        OUT     (SC_REG),A      ; Output sector number to controller
        LD      A,D             ; Get status change flag
        OR      A               ; status changed ?
        CALL    NZ,A3AC2        ; yes --> time loop approx. 80 ms
        XOR     A               ; Reset carry flag ('Function OK')
        RET
;
;
;    Output 'SEEK' to floppy controller
;
A38A8:  LD      A,00011000B     ; Code for 'SEEK'
        CALL    A38F7           ; Output the step rate for the command and wait for 'Not busy'
        RET     C               ; Error occurred
        AND     10011001B       ; mask for 'READY/SEEK ERROR/BUSY'
        RET
;
;
;    Switch on engine and clear drive flags
;
A38B1:  LD      HL,S37EA        ; Pointer to controller - status - flag
        SET     7,(HL)          ; Set 'motor on' flag
        LD      A,(HL)          ; Controller - get status
        CALL    A3851           ; Output motor flag, side and density
        LD      HL,S37EC        ; Pointers to Drive - Flags
        LD      B,4             ; delete four bytes
        JP      CLRHL           ; Delete memory area (HL) (B=length)
;
;
;    Initialize "FDx" device.
;
A38C2:  XOR     A               ; Code for 'Motor off'
        CALL    A3851           ; Output motor flag, side and density
        LD      (S37EA),A       ; Controller - Status - Reset flag
        RET
;
;
;    Issue 'Restore' to controller
;
A38CA:  CALL    PUSHR           ; Save registers IX, HL, BC, DE
        LD      HL,S37F0        ; Pointer to memory for track numbers
        CALL    A3849           ; Pointer to track numbers of current drive
        LD      (HL),-1         ; Note code 'zero track'
        LD      A,00001000B     ; code 'restore'
        CALL    A38F7           ; Output step rate to the command and wait for 'Not busy'
        RET     C               ; Error occurred --> termination
        AND     10000101B       ; Mask 'READY/TRACK 0/BUSY'
        XOR     00000100B       ; TRACK 0 - reverse status
        RET     Z               ; State is OK
        JP      A3A8F           ; Specify error number
;
;
;    Output 'Force Interrupt' to floppy controller
;
A38E3:  PUSH    AF              ; Save register value
        LD      A,11010000B     ; 'Force interrupt' code
        CALL    A38F0           ; Issue command and wait for 'Not Busy'
        JR      C,A38ED         ; Error occurred --> cancel immediately
        POP     AF              ; get saved register value
        RET
;
A38ED:  POP     HL              ; discard saved register
        POP     HL              ; discard a return address
        RET
;
;
;    Issue command and wait for 'Not Busy'
;
A38F0:  CALL    PUSHR           ; Save registers IX, HL, BC, DE
        LD      D,0             ; code 'wait for Not Busy'
        JR      A3911           ; Issue command and wait for correct status
;
;
;    Set Steprate and wait for 'Not Busy'
;
A38F7:  CALL    PUSHR           ; Save registers IX, HL, BC, DE
        LD      B,A             ; rescue command
        LD      A,(S37DF)       ; Get step rate
        CPL
        AND     00000011B       ; Mask step rate
        OR      B               ; plus command
        LD      D,0             ; Code 'Wait for Not Busy'
        JR      A390B           ; Issue command and wait for correct status
;
;
;    Issue command to controller and wait for 'Busy'
;
A3906:  CALL    PUSHR           ; Save registers IX, HL, BC, DE
        LD      D,1             ; code 'wait for busy'
A390B:  CALL    A38E3           ; Issue 'force interrupt' to floppy controller
        LD      (S37EB),A       ; remember last command
A3911:  CPL                     ; Complement command for output
        OUT     (CD_REG),A      ; Issue command to controller
        CALL    A3ABC           ; Time loop approx. 0.166 ms
        LD      E,7             ; number of passes
A3919:  LD      HL,10000        ; Default for counter
A391C:  DEC     HL              ; Counter minus one
        LD      A,H             ;!  Counter equal to zero?
        OR      L               ;!
        JP      Z,A392E         ; yes --> examine whether further runs
        IN      A,(ST_REG)      ; Controller - read status
        CPL                     ; all values are complemented
        LD      B,A             ; Controller - remember status
        AND     10000001B       ; Mask READY and BUSY
        CP      D               ; same feedback status?
        JR      NZ,A391C        ; no --> keep waiting
        LD      A,B             ; Controller - get status
        OR      A               ; reset carry flag (code 'no error')
        RET
;
A392E:  DEC     E               ; Number of runs minus one
        JP      Z,A3A8F         ; Time - Out --> Specify error number
        LD      A,(S37EB)       ; get last command
        CPL                     ; complement to the output
        OUT     (CD_REG),A      ; and output to controller again
        JR      A3919           ; Query whether correct feedback value

;
;
;    Read sector
;
A393A:  SCF                     ; Code 'read sector'
        JR      A393E           ; read sector
;
;
;    Write sector
;
A393D:  OR      A               ; Code 'Write Sector'
A393E:  EX      AF,AF           ; Remember flag 'Read/Write'
        PUSH    AF              ; Save register value
        EX      AF,AF           ; Get flag 'read/write'
        LD      (S37E6),HL      ; Remember pointer to memory area
        PUSH    HL              ; Save pointer to memory area
        LD      HL,S37E0        ; Pointer to flag 'read/write'
        RL      (HL)            ;! Enter the 'Read/Write' flag
        RRC     (HL)            ;!
        LD      H,(HL)          ; 'Read/Write' flag
        LD      L,A             ; Remember drive number/mode
        AND     00000111B       ; Mask drive number and mode
        LD      (S37E1),A       ; Remember drive number
        CALL    A3810           ; Switch on the motors of the drives and select density/side
        JR      NC,A395D        ; no error --> writing or reading
        POP     HL              ; Get pointer to memory area
        EX      AF,AF           ; Save error status
        POP     AF              ; get saved register value
        EX      AF,AF           ; and again after AF'
        RET
;
A395D:  BIT     7,H             ; reading or writing
        LD      A,L             ; Drive number/sector number mode
        POP     HL              ; Get pointer to memory area
        PUSH    HL              ; and save again
        CALL    Z,A3A1C         ; read --> bytes (not) complement
        LD      (S37E4),DE      ; note the number of bytes to be read
        PUSH    DE              ; Number of bytes to read
        OR      A
        PUSH    AF              ; save the flag
        LD      H,B             ;! first sector number or track/sector number
        LD      L,C             ;! transfer
        CALL    P,A37F5         ; Calculate track and sector number from absolute sector number
        LD      (S37E2),HL      ; Track/sector number first sector
        LD      A,9             ; a maximum of nine errors
        LD      (S37F4),A       ; note errors as remaining number
        PUSH    IY              ; Save register value
        CALL    A3991           ; Determine format and read or write bytes
        EX      AF,AF           ; Save result flag
        POP     IY              ; get saved register value
        LD      HL,(S37E8)      ; Track pointer/Sector pointer
        POP     AF              ; get rescued flag
        CALL    P,A3805         ; Calculate absolute sector number from track and sector number
        LD      B,H             ;! absolute sector number or track sector
        LD      C,L             ;! remember number again
        POP     DE              ; retrieve saved number of bytes
        POP     HL              ; Retrieve pointer to memory area
        POP     AF              ; retrieve saved register
        EX      AF,AF           ; after AF' / get result flag
        JP      A3A1C           ; Bytes (not) complement
;
;
;    Determine format and read or write bytes
;
A3991:  LD      E,0             ; 256 bytes per sector
        LD      HL,(S37E4)      ; Get number of bytes to read
        LD      A,(S37EA)       ; Get Controller - Status - Flag
        BIT     5,A             ; MZ-80K - Mode ?
        JR      Z,A39A0         ; no
        ADD     HL,HL           ; bytes times two
        LD      E,128           ; 128 bytes per sector
A39A0:  LD      A,L             ; Get low byte count
        OR      A               ; equals zero  ?
        JR      Z,A39A5         ; yes --> number of sectors is correct
        INC     H               ; Correct number of sectors
A39A5:  LD      A,H             ; Get number of sectors
        LD      (S37E5),A       ; and remember
A39A9:  CALL    A3A2F           ; Specify data for sectors still to be treated
        CALL    NC,A385D        ; Output track and sector number to controller
        RET     C               ; Error occurred --> termination
        JR      NZ,A3A16        ; wrong status --> test if try again
        DI                      ; Disable interrupts
        LD      A,(S37E0)       ; 'Read/Write' flag
        BIT     7,A             ; reading or writing ?
        LD      A,10010000B     ; Code 'READ multiple records'
        LD      IY,0A2EDH       ; Z-80 - command INI
        JR      NZ,A39C6        ; read from disk
        LD      A,10110100B     ; Code 'Write Multiple Record'
        LD      IY,0A3EDH       ; Z-80 - command OUTI
A39C6:  LD      (D39DD),IY      ; Enter Z-80 command into routine
        CALL    A3906           ; Issue command and wait for 'Busy'
        RET     C               ; Error occurred --> termination
A39CE:  LD      B,E             ; Get number of bytes per sector
        PUSH    DE              ; Save remaining number of sectors/sector length
        ;LD      DE,256*(NOT  1)+NOT 3
		LD      DE,0xFE7C		; MSB:($FF XOR 1),  LSB:($FF XOR $83)

A39D3:  IN      A,(ST_REG)      ; Read the status of the controller
        OR      E               ;! Busy and bytes not ready?
        CP      D               ;!
        JR      Z,A39D3         ; no --> continue querying
        CP      11111100B       ; busy ?
        JR      NZ,A39E2        ; no --> cancel
D39DD:  NOP                     ;! Output byte to controller or byte
        NOP                     ;! get from the controller
        JP      NZ,A39D3        ; read more bytes in this sector
A39E2:  POP     DE              ; Get remaining number of sectors/sector length
        IN      A,(ST_REG)      ; Read the status of the controller
        RRA                     ; Busy - push bit after carry
        JP      C,A3A8F         ; no longer busy --> specify error number
        LD      A,(S37E9)       ; Get sector pointer
        INC     A               ; plus one
        LD      (S37E9),A       ; and remember again
        CP      17              ; right at the end of the track?
        JR      Z,A39F9         ; Yes
        DEC     D               ; Remaining number of sectors minus one
        JR      NZ,A39CE        ; read more sectors
        JR      A39FA
;
A39F9:  DEC     D               ; Remaining number of sectors minus one
A39FA:  CALL    A38E3           ; Issue 'Force Interrupt' to floppy controller
        EI                      ; Enable interrupt
        IN      A,(ST_REG)      ; Controller - read status
        CPL                     ; Data are complemented
        OR      A               ; Error  ?
        JR      NZ,A3A16        ; yes --> test whether to try again
        LD      A,(S37E0)       ; 'Read/Write' flag
        OR      A               ; To write  ?
        CALL    Z,A3A65         ; yes --> test whether written sectors can be found again
        JR      C,A3A16         ; Error --> test whether to try again
        CALL    A3A4D           ; Update track and sector number
        LD      A,D             ; Get remaining number of sectors
        OR      A               ; equals zero  ?
        JR      NZ,A39A9        ; no --> read/write more sectors
        XOR     A               ; Code 'Function OK'
        RET
;
A3A16:  CALL    A3A40           ; examine whether not too many errors
        RET     C               ; Error during restore --> termination
        JR      A39A9           ; try again
;
;
;    Bytes complement (not)
;
A3A1C:  CALL    PUSHRA          ; Save registers IX, HL, BC, DE, AF
        LD      A,(S37EA)       ; Get Controller - Status - Flag
        BIT     5,A             ; MZ-80K - Mode ?
        RET     Z               ; Do not complement bytes
A3A25:  LD      A,(HL)          ; get a byte
        CPL                     ; complement bytes
        LD      (HL),A          ; and remember again
        INC     HL              ; Pointer to bytes to next byte
        DEC     DE              ; Remaining number of bytes minus one
        LD      A,D             ;! Remaining number of bytes equal to zero ?
        OR      E               ;!
        JR      NZ,A3A25        ; no --> complement further bytes
        RET
;
;
;    Specify data for sectors still to be treated
;
A3A2F:  LD      HL,(S37E2)      ; Get track/sector number of first sector
        LD      (S37E8),HL      ; enter as track pointer/sector pointer
        LD      HL,(S37E6)      ; Get pointer to memory area
        LD      A,(S37E5)       ; Get number of sectors to treat
        LD      D,A             ; and remember
        LD      C,DA_REG        ; Specify data port of the controller
        OR      A               ; reset carry flag (code 'no error')
        RET
;
;
;    Check whether too many errors have already occurred
;
A3A40:  CALL    PUSHR           ; Save registers IX, HL, BC, DE
        LD      HL,S37F4        ; Pointer to remaining number of errors
        DEC     (HL)            ; Remaining number of errors minus one
        JP      Z,A3A8F         ; too many errors --> specify error number
        JP      A38CA           ; Issue 'Restore' to controller
;
;
;    Update track and sector number
;
A3A4D:  LD      (S37E6),HL      ; Pointer to memory area
        LD      A,D             ; remaining number of sectors
        LD      (S37E5),A       ; as the number of sectors to be treated
        LD      HL,(S37E8)      ; Track pointer/Sector pointer
        LD      A,H             ; Get sector pointer
        CP      17              ; end of track ?
        RET     NZ              ; no
        LD      H,1             ; Sector pointer to sector one
        INC     L               ; Lane pointer plus one
        LD      (S37E2),HL      ; Remember track/sector number of last error-free sector
        LD      (S37E8),HL      ; Memorize track and sector pointers
        RET
;
;
;    Test whether written sectors can be found again
;
A3A65:  LD      A,(S37E3)       ; Sector number from where to start reading
        CPL                     ; comment to the output
        OUT     (SC_REG),A      ; to sector - output register
        LD      A,10010000B     ; Code 'Read multiple sectors'
        CALL    A3906           ; Issue command and wait for 'Busy'
        RET     C               ; Error occurred
        LD      A,(S37E9)       ; Get sector pointer
        LD      B,A             ; and remember
A3A75:  IN      A,(ST_REG)      ; Read the status register of the controller
        CPL                     ; Data are complemented
        AND     10000001B       ; Mask Ready and Busy
        CP      00000001B       ; Controller Busy?
        JR      NZ,A3A87        ; no
        IN      A,(SC_REG)      ; Read the controller's sector register
        CPL                     ; Data are complemented
        CP      B               ; Compare with output sector number
        JR      NZ,A3A75        ; not immediately --> ask again
        CALL    A38E3           ; Issue 'Force Interrupt' to floppy controller
A3A87:  IN      A,(ST_REG)      ; Read the status register of the controller
        CPL                     ; Data are complemented
        AND     10011001B       ; Mask 'READY/RNF ERROR/CRC ERROR/BUSY'
        RET     Z               ; all data OK
        SCF                     ; Set flag: 'Error Occurred'
        RET
;
;
;    Define the error number basing on the status and the last command
;
A3A8F:  LD      A,(S37EB)       ; get last command
        RLA                     ; Shift bit 7 to carry
        IN      A,(ST_REG)      ; Read status value from controller
        CPL                     ; Data are complemented
        JR      NC,A3AAD        ; 'Seek' or 'Restore'
        RLA                     ; Push ready bit after carry
        JR      C,A3AB0         ; Controller or drive not ready
        RLA                     ; Write-Protect - Shift bit after carry
        JR      NC,A3AA5        ; not write protect
        LD      HL,S37E0        ; Pointer to flag 'read/write'
        BIT     7,(HL)          ; read  ?
        JR      Z,A3AB4         ; should be written --> error 46
A3AA5:  AND     11000000B       ; Mask 'Record Type/Record not found'
        JR      NZ,A3AB8        ; is set --> Error 54 unformat
A3AA9:  LD      A,41            ; Error 41 Hardware error
        SCF                     ; Set flag: 'Error Occurred'
        RET
;
A3AAD:  RLA                     ; Write-Protect - Shift bit after carry
        JR      NC,A3AA9        ; not write protect --. Error 41 Hardware error
A3AB0:  LD      A,50            ; Error 50 Not ready error
        SCF                     ; Set flag: 'Error Occurred'
        RET
;
A3AB4:  LD      A,46            ; Error 46 Write protect error
        SCF                     ; Set flag: 'Error Occurred'
        RET
;
A3AB8:  LD      A,54            ; Error 54 Unformat error
        SCF                     ; Set flag: 'Error Occurred'
        RET

;
;
;    Delay  approx. 0.166 ms
;
A3ABC:  PUSH    DE              ; Save register value            11 + 2
        LD      DE,15           ; Default for time loop          10 + 2
        JR      A3AC6           ; Entry into time loop           12 + 2
;
;
;    Delay  approx.  80 ms
;
A3AC2:  PUSH    DE              ; Save register value            11 + 2
        LD      DE,8230         ; Default for time loop          10 + 2
A3AC6:  DEC     DE              ; Counter minus one               6 + 2
        LD      A,E             ;! equals zero  ?                 4 + 2
        OR      D               ;!                                4 + 2
        JR      NZ,A3AC6        ; no --> keep waiting            12 + 2
        POP     DE              ; fetch saved register           10 + 2
        RET                     ;                           17 + 10 + 2
;
;
;    Delay  approx.  1.35 ms
;
A3ACD:  PUSH    BC              ; Save register value
        LD      B,17            ; Default for counter
A3AD0:  CALL    A3AC2           ; Time loop approx. 80 ms
        DJNZ    A3AD0           ; keep waiting
        POP     BC              ; get saved register value
        RET
;
;
;   Pseudo-device table for Cassette Recorder (CMT:)
;
W3AD7:  DEFW    W3C64           ; Pointer to Next Devices - Table (RSx:)
        DEFB    NUL             ; Code 'table does not exist'
;
;
;   Pseudo-device table for Quick Disk
;
W3ADA:  DEFW    W0F7F           ; Pointer to Next Devices Table (USR:)
        DEFB    NUL             ; Code 'table does not exist'
;
;
;   File - write identifier to tape (cassette).
;   File - write data to tape (cassette).
;   Read file identifier from tape (cassette).
;   File - read data from tape (cassette).
;   File - Compare data on BAnd with memory data
;
CMTERR: XOR     A
        SCF                     ; Set 'Error Occurred' flag
A3ADF:  RET
;
;
;   RAM - write card contents to Quick - Disk or read from Quick - Disk
;   (Software  - Kommando  59)
;
LSALL:  LD      A,1             ; Error 1 Syntax error
        SCF                     ; Set code for 'Error Occurred'
        JP      ERRORJ          ; Handle errors by number in Accu
;
D3AE6:
;        DEFS    282             ; so you can get 64 Kbytes
        DEFS 0x3C00-D3AE6

;
;   Convert ASCII characters in Accu to display code
;
;   (SVC code:  29)
;
ADCN:   CP      010H            ; known sign?
        JR      C,A3C16         ; no --> specify code for 'character not known'
        CP      080H            ; curly bracket to ?
        JR      Z,A3C19         ; yes --> convert to display code
        CP      0C0H            ; open curly bracket ?
        JR      Z,A3C19         ; yes --> convert to display code
        DI                      ; Disable interrupts
        OUT     (_00ROM),A      ; Switch to monitor ROM from 00000H-00FFFH
        CALL    _ADCN           ; Convert ASCII code to display code
        OUT     (_00RAM),A      ; Switch to RAM from 00000 - 00FFFH
        EI                      ; Release interrupt again
        RET
;
A3C16:  LD      A,0F0H          ; Code for 'character unknown'
        RET
;
A3C19:  SUB     040H            ; Convert curly bracket to display code
        RET
;
;
;   Anzeigecodezeichen im Accu in ASCII - Code umsetzen
;
;   (SVC code:  28)
;
DACN:   CP      0F0H            ; Pixel - Graphic - Wert  ?
        JR      NC,A3C38        ; ja -->  Leerzeichen  (Space)  vorgeben
        CP      073H
        JR      Z,A3C16         ; ja -->  Code for 'Zeichen nicht bekannt'  vorgeben
        CP      040H            ; geschweifte Klammer zu  ?
        JR      Z,A3C3B         ; ja -->  umrechnen in ASCII - Code
        CP      080H            ; geschweifte Klammer auf  ?
        JR      Z,A3C3B         ; ja -->  umrechnen in ASCII - Code
        DI                      ; Interrupt sperren
        OUT     (_00ROM),A      ; Umschalten auf ROM - Monitor vom 00000H - 00FFFH
        CALL    _DACN           ; Anzeigecode umsetzen in ASCII - Code
        OUT     (_00RAM),A      ; Umschalten auf RAM von 00000H - 00FFFH
        EI                      ; Interrupt wieder freigeben
        CP      0F0H            ; Code for 'Zeichen nicht bekannt'  ?
        RET     NZ              ; nein
A3C38:  LD      A,' '           ; Leerzeichen  (Space)  für unbekanntes Zeichen vorgeben
        RET
;
A3C3B:  ADD     A,040H          ; geschweifte Klammer umrechnen in ASCII
        RET
;
;
;   Code der Taste nach Tastennummer in HL und Zeiger auf
;   Tastatur - Decodiertabelle im Monitor - ROM in BC bereitstellen
;
A3C3E:  PUSH    AF              ; Keep register value
        LD      A,L             ; Tastennummer holen
        SUB     8               ; Taste in Spalte 1  ?
        JR      C,A3C48         ; ja -->  nach RAM - Tabelle decodieren
        SUB     48
        JR      C,A3C4F         ; Taste nach ROM - Tabelle decodieren
A3C48:  ADD     A,8 + 2         ; Offset für RAM - Tabelle corrigieren
        LD      L,A             ; Low - Byte Offset merken
        ADD     HL,BC           ; Zeiger auf Stelle in RAM - Tabelle errechnen
        LD      C,(HL)          ; Zeichen aus RAM - Tabelle holen
        POP     AF              ; geretteten Register - Wert holen
        RET
;
;
;   Code der Taste nach Monitor - ROM - Tabelle bereitstellen
;
A3C4F:  LD      A,(BC)          ; Low - Byte Anfangsadresse aus Tabelle holen
        PUSH    AF              ; Low - Byte Adresse retten
        INC     BC              ; Zeiger auf High - Byte Adresse
        LD      A,(BC)          ; High - Byte Adresse aus Tabelle holen
        LD      B,A             ; und merken
        POP     AF              ; Low - Byte Adresse holen
        LD      C,A             ; und merken
        ADD     HL,BC           ; Zeiger auf richtiges Zeichen errechnen
        DI                      ; Interrupt sperren
        OUT     (_00ROM),A      ; Umschalten auf ROM - Monitor von 00000H - 00FFFH
        LD      A,(HL)          ; Zeichen aus ROM - Tabelle holen
        OUT     (_00RAM),A      ; Umschalten auf RAM von 00000H - 00FFFH
        EI                      ; Interrupt wieder freigeben
        CALL    DACN            ; Anzeigecodezeichen im Accu umsetzen in ASCII - Code
        LD      C,A             ; ASCII - Wert der gedrückte Taste merken
        POP     AF              ; geretteten Register - Wert holen
        RET
;
;
;   devices - table for serial interface (RSx)
;
W3C64:  DEFW    W3EC6           ; Pointer to next devices - table (RAM:)
        DEFM    "RS"            ; Geräte - Name
		DEFB    NUL,NUL
        DEFB    10001111B       ; Geräte - Typ - Byte
        DEFB    00000001B       ; Geräte - Nummern - Flag
        DEFB    0
        DEFW    A3C7D           ; Initialize device
        DEFW    A3CAE           ; Open file for reading
        DEFW    A3CAE           ; Open file for writing
        DEFW    A3CBF
        DEFW    A3CBF
        DEFW    A3CD0           ; ein Zeichen bereitstellen
        DEFW    A3CFB           ; Output characters in Accu
        DEFW    __RET           ; RET
;
;
;   Gerät  'RSx'  initialisieren
;
A3C7D:  RET     C
        PUSH    IY              ; Keep register value
        CALL    A3D25           ; Zeiger in IY auf richtigen Geräte-Datensatz stellen
        CALL    A3C8B           ; Werte zur Initialisierung bereitstellen
        CALL    A3D6E           ; serielle Schnittstelle initialisieren
        JR      A3CE3           ; gerettetes IY - Register wieder holen
;
;
;   Werte zur Initialisierung bereitstellen
;
A3C8B:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    19              ; Code 19   ASCII-Wert (HL) umsetzen in Hex-Wert nach DE
        LD      (IY+-3),E       ; Überwachungssignale merken
        CALL    TEST1           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    ","             ; Komma  ?
        JP      NZ,A1F7F        ; nein -->  Fehler 3  Illegal data error
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    19              ; Code 19   ASCII-Wert (HL) umsetzen in Hex-Wert nach DE
        LD      (IY+-2),E       ; Datenformat merken
        CALL    TEST1           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFB    NUL             ; Textendezeichen  ?
        RET     Z               ; ja -->  fertig
        CALL    TEST1           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    ","             ; Komma  ?
        JP      NZ,A1F7F        ; nein -->  Fehler 3  Illegal data error
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    19              ; Code 19   ASCII-Wert (HL) umsetzen in Hex-Wert nach DE
        LD      (IY+-8),E       ; Textendezeichen merken
        RET
;
;
;   Datei auf Gerät  'RSx'  zum Lesen oder Schreiben eröffnen
;
A3CAE:  PUSH    IY              ; Keep register value
        CALL    A3D25           ; Zeiger in IY auf richtigen Geräte-Datensatz stellen
        LD      A,(IY+-1)       ; Schnittstellenstatus holen
        INC     (IY+-1)
        OR      A
        CALL    Z,A3DD0         ; Fehlerstatus der Schnittstelle zurücksetzen
        JR      A3CE3           ; gerettetes IY - Register wieder holen
;
;
;
;
A3CBF:  PUSH    IY              ; Keep register value
        CALL    A3D25           ; Zeiger in IY auf richtigen Geräte-Datensatz stellen
        DEC     (IY+-1)
        LD      A,(IY+-1)
        OR      A
        CALL    Z,A3DB8         ; Schnittstelle initialisieren
        JR      A3CE2           ; geretteten IY - Register - Wert holen
;
;
;   ein Zeichen von Gerät  'RSx'  lesen
;
A3CD0:  PUSH    IY              ; Keep register value
        CALL    A3D25           ; Zeiger in IY auf richtigen Geräte-Datensatz stellen
        CALL    A3CE6           ; ein Zeichen von Schnittstelle holen
        JP      C,IOERR         ; Fehler -->  Fehlernummer und Gerätenamen ausgeben
        CP      (IY+-8)         ; mit Textendezeichen vergleichen
        JR      NZ,A3CE2        ; nicht Textende -->  Zeichen durchgeben
        LD      A,CR            ; Textendezeichen vorgeben
A3CE2:  OR      A               ; Carry - Flag zurücksetzen   (Code 'kein Fehler')
A3CE3:  POP     IY              ; geretteten Register - Wert holen
        RET
;
;
;   ein Zeichen von serieller Schnittstelle holen
;
A3CE6:  BIT     6,(IY+-2)       ; Sharp - ASCII - Modus  ?
        JP      Z,A3E1F         ; ja -->  Zeichen von serieller Schnittstelle lesen
        LD      IX,A3E1F        ; Adresse  'Zeichen von Schnittstelle holen'
        PUSH    IY              ;! Zeiger auf aktuellen Schnittstellendatensatz nach HL
        POP     HL              ;!
        LD      DE,-5           ; Offset auf Spaltenzähler 'Eingabe'
        ADD     HL,DE           ; Zeiger auf Spaltenzähler 'Eingabe' errechnen
        JP      A146C           ; Zeichen bereitstellen und umsetzen in Sharp - ASCII
;
;
;   Zeichen im Accu an Gerät  'RSx'  ausgeben
;
A3CFB:  PUSH    IY              ; Keep register value
        CALL    A3D25           ; Zeiger in IY auf richtigen Geräte-Datensatz stellen
        CP      CR              ; Textendezeichen  ?
        JR      NZ,A3D07        ; nein -->  Zeichen ausgeben
        LD      A,(IY+-8)       ; vorgegebenes Textendezeichen holen
A3D07:  CALL    A3D0C           ; Accu an serielle Schnittstelle ausgeben
        JR      A3CE3           ; gerettetes IY - Register wieder holen
;
;
;   Accu an serielle Schnittstelle ausgeben
;
A3D0C:  BIT     6,(IY+-2)       ; Sharp - ASCII - Modus  ?
        JP      Z,A3E64         ; ja -->  Zeichen im Accu ausgeben
        LD      IX,A3E64        ; Adresse  'Zeichen an Schnittstelle ausgeben'
        PUSH    IY              ;! Zeiger auf Schnittstellendatensatz nach HL
        POP     HL              ;!
        LD      DE,-7           ; Offset auf Spaltenzähler  'Ausgabe'
        ADD     HL,DE           ; Zeiger auf Spaltenzähler  'Ausgabe'
        LD      DE,(DISPX)      ; Flag  'Steuerzeichen ausführen'  holen
        JP      A142B           ; Zeichen umsetzen in Standard - ASCII und ausgeben
;
;
;   Zeiger in IY auf richtigen Geräte-Datensatz stellen
;
A3D25:  PUSH    AF              ;! Register - Werte retten
        PUSH    DE              ;!
        LD      A,(ZCH)         ; Geräte - Nummer holen
        INC     A               ; für Schleife corrigieren
        LD      IY,B3D45 + -21  ; Zeiger auf Geräte - Datensatz mit Vorgabe
        LD      DE,21           ; Länge  Geräte - Datensatz
A3D32:  ADD     IY,DE           ;! Zeiger auf richtigen Geräte - Datensatz
        DEC     A               ;! errechnen
        JR      NZ,A3D32        ;!
        LD      C,(IY+0)        ; Statusport - Nummer holen
        POP     DE              ;! gerettete Register - Werte holen
        POP     AF              ;!
        RET
;
;
;   Geräte - Datensatz für serielle Schnittstelle 1
;
        DEFS    1               ; Textendezeichen
        DEFS    1               ; Spaltenzähler bei Ausgabe
        DEFS    1
        DEFS    1               ; Spaltenzähler bei Eingabe
        DEFS    1
        DEFS    1               ; Überwachungssignale bei Initialisierung
        DEFS    1               ; Datenformat bei Initialisierung
        DEFS    1               ; Schnittstellenstatus
B3D45:  DEFB    SERA_S          ; Status- / Steuerport  RS1
        DEFB    SERA_D          ; Datenport  RS1
        DEFB    00000000B       ; Bitmaske für Anzahl übertragene Zeichen
        DEFB    00010000B       ; Code for 'Reset EXT/Status Interrupt'
        DEFB    00010000B       ; Code for 'Reset EXT/Status Interrupt'
        DEFB    4               ; Code for 'Write - Register 4'
        DEFB    01000000B       ; Wert für Write - Register 4   (Clock * 16)
        DEFB    3               ; Code for 'Write - Register 3'
        DEFB    11000000B       ; Wert für Write - Register 3   (Rx 8 Bit)
        DEFB    5               ; Code for 'Write - Register 5'
        DEFB    01100000B       ; Wert für Write - Register 5   (Tx 8 Bit)
        DEFB    00110000B       ; Code for 'Error Reset'
        DEFB    3               ; Code for 'Write - Register 3'
;
;
;   Geräte - Tabelle für serielle Schnittstelle 2
;
        DEFS    1               ; Textendezeichen
        DEFS    1               ; Spaltenzähler bei Ausgabe
        DEFS    1
        DEFS    1               ; Spaltenzähler bei Eingabe
        DEFS    1
        DEFS    1               ; Überwachungssignale bei Initialisierung
        DEFS    1               ; Datenformat bei Initialisierung
        DEFS    1               ; Schnittstellenstatus
        DEFB    SERB_S          ; Status- / Steuerport  RS1
        DEFB    SERB_D          ; Datenport  RS1
        DEFB    00000000B       ; Bitmaske für Anzahl übertragene Zeichen
        DEFB    00010000B       ; Code for 'Reset EXT/Status Interrupt'
        DEFB    00010000B       ; Code for 'Reset EXT/Status Interrupt'
        DEFB    4               ; Code for 'Write - Register 4'
        DEFB    01000000B       ; Wert für Write - Register 4   (Clock * 16)
        DEFB    3               ; Code for 'Write - Register 3'
        DEFB    11000000B       ; Wert für Write - Register 3   (Rx 8 Bit)
        DEFB    5               ; Code for 'Write - Register 5'
        DEFB    01100000B       ; Wert für Write - Register 5   (Tx 8 Bit)
        DEFB    00110000B       ; Code for 'Error Reset'
        DEFB    3               ; Code for 'Write - Register 3'
;
;
;   bei Shift - BREAK -->  Abbruch Programm
;
A3D67:  CALL    BRKCHK          ; Abfrage, ob Shift - BREAK gedrückt ist
        RET     NZ              ; Shift - BREAK nicht gedrückt
        JP      BREAKZ          ; Programm mit 'BREAK' abbrechen
;
;
;   serielle Schnittstelle initialisieren
;
A3D6E:  LD      A,00011000B     ; Code for 'Chanal Reset'
        OUT     (C),A           ; an Steuerport ausgeben
        LD      A,00110000B     ; Code for 'Error Reset'
        OUT     (C),A           ; an Steuerport ausgeben
        LD      A,(IY+-2)       ; Datenformat holen
        AND     00001100B       ; Anzahl Stopbits maskieren
        JR      NZ,A3D81        ; Stopbits angegeben
        SET     2,(IY+-2)       ; Code for '1 Stopbit'  setzen
A3D81:  LD      A,(IY+-2)       ; Datenformat holen
        LD      B,A             ; und merken
        AND     00001111B       ; Parität und Stopbits maskieren
        OR      01000000B       ; plus Code for 'Clock mal 16'
        LD      (IY+6),A        ; Wert für Write - Register 4  merken
        LD      A,B             ; Datenformat holen
        AND     10000000B       ; Zeichen maskieren
        OR      01000000B       ; Code  für  'Rx 7 oder 8 Bit' zusammenstellen
        LD      (IY+8),A        ; Wert für Write - Register 3  merken
        RRA                     ; um ein Bit nach rechts schieben
        AND     01111111B       ; Empfangsformat maskieren
        OR      00001010B       ; 'RTS' und 'Tx enable'  setzen
        LD      (IY+10),A       ; Wert für Write - Register 5  merken
        LD      A,B             ; Datenformat holen
        OR      01111111B       ; alle Bits bis auf Zeichenlänge setzen
        LD      (IY+2),A        ; Bitmaske für Anzahl übertragene Bits merken
        CALL    A3DC4           ; Übertragungsformate an Schnittstelle ausgeben
A3DA5:  IN      A,(C)           ; Statusport der Schnittstelle abfragen
        RRCA                    ; Rx  Character vorhanden  ?
        RET     NC              ; nein
        DEC     C               ; Register - Nummer auf Datenport
        IN      A,(C)           ; ein Zeichen von Datenport lesen
        INC     C               ; Register - Nummer wieder auf Staus-/Steuerport
        LD      A,00000001B     ; Code for 'Register 1'
        OUT     (C),A           ; an Steuerport ausgeben
        IN      A,(C)           ; READ - Register eins abfragen
        AND     01110000B       ; Fehlerbits maskieren
        JR      Z,A3DA5         ; kein Fehler -->  warten bis kein Zeichen vorhanden
        RET
;
;
;   Schnittstelle für Senden und Empfangen zurücksetzen
;
A3DB8:  RES     0,(IY+8)        ; 'Rx - Enable'  zurücksetzen
        RES     7,(IY+10)       ; 'DTR' zurücksetzen
        LD      (IY+-1),0       ; Schnittstellenstatus zurücksetzen
A3DC4:  LD      B,10            ; 10 Byte ausgeben
        PUSH    IY              ;! Zeiger auf Tabelle zur Initialisierung
        POP     HL              ;! errechnen
        LD      DE,3            ;!
        ADD     HL,DE           ;!
        OTIR                    ; Wertetabelle an serielle Schnittstelle ausgeben
        RET
;
;
;   Fehlerstatus der seriellen Schnittstelle zurücksetzen
;
A3DD0:  LD      A,00110000B     ; Code for 'Error Reset'
        OUT     (C),A           ; an Steuerport der seriellen Schnittstelle ausgeben
        RET
;
;
;   Schnittstelle für Empfang ein Zeichen vorbereiten
;
A3DD5:  SET     0,(IY+8)        ; Code for 'Rx - Enable'  setzen
        LD      A,00010011B     ; Code for 'Reset EXT/Status Interrupt / Register 3'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        LD      A,(IY+8)        ; Wert für Write - Register 3 holen
        OUT     (C),A           ; Leseformat an Schnittstelle ausgeben
        LD      A,00110101B     ; Code for 'Error Reset / Register 5'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        LD      A,(IY+10)       ; Wert für Write - Register 5 holen
        OR      10001000B       ; 'DTR' und 'Send BREAK' setzen
        LD      (IY+10),A       ; neuen Wert für Write - Register 5  merken
        OUT     (C),A           ; Wert an Write - Register 5  ausgeben
        RET
;
;
;
;
        LD      A,00000011B     ; Code for 'Register 3'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        RES     0,(IY+8)        ; 'Rx - Enable'  zurücksetzen
        LD      A,(IY+8)        ; Wert für Write - Register 3  holen
        OUT     (C),A           ; Leseformat an Write - Register 3 holen
A3DFE:  RES     7,(IY+10)       ; 'DTR`  zurücksetzen
        JR      A3E14           ; Wert an Write - Register 5  ausgeben
;
;
;   'RTS' an serielle Schnittstelle ausgeben
;
A3E04:  SET     1,(IY+10)       ; 'RTS' setzen
        JR      A3E14           ; Wert an Write - Register 5 ausgeben
;
;
;   'RTS'  zurücknehmen
;
A3E0A:  RES     1,(IY+10)       ; 'RTS' zurücksetzen
        JR      A3E14           ; Wert an Write - Register 5  ausgeben
;
;
;   'DTR' an serielle Schnittstelle ausgeben
;
        SET     7,(IY+10)       ; 'DTR' setzen
A3E14:  LD      A,00000101B     ; Code for 'Write - Register 5'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        LD      A,(IY+10)       ; Wert für Write - Register 5  holen
        OUT     (C),A           ; an Schnittstelle ausgeben
        OR      A               ; Carry - Flag zurücksetzen   (Code 'kein Fehler')
        RET
;
;
;   ein Zeichen von serieller Schnittstelle holen
;
A3E1F:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      C,(IY+0)        ; Port - Nummer der Schnittstelle holen
A3E25:  CALL    A3D67           ; bei Shift - BREAK -->  Abbruch Programm
        CALL    A3E9D           ; Abfrage, ob DCD - Sognal vorhanden ist
        JR      C,A3E25         ; nicht vorhanden -->  weiter abfragen
        CALL    A3DD5           ; Schnittstelle für Empfang ein Zeichen vorbereiten
A3E30:  CALL    A3D67           ; bei Shift - BREAK -->  Abbruch Programm
        IN      A,(C)           ; Zeichen von serieller Schnittstelle holen
        RRCA                    ; 'Rx Available' - Bit nach Carry schieben
        JR      NC,A3E30        ; kein Zeichen vorhanden -->  weiter abfragen
        DEC     C               ; Portnummer auf Datenport
        IN      A,(C)           ; Zeichen von serieller Schnittstelle holen
        INC     C               ; Portnummer wieder auf Steuer-/Statusport
        AND     (IY+2)          ; Anzahl übertragene Bits maskieren
        PUSH    AF              ; gelesenes Zeichen retten
        LD      A,00000001B     ; Code for 'Read - Register 1'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        IN      A,(C)           ; 'Read - Register 1'  lesen
        AND     01110000B       ; Fehlerbits maskieren
        JR      NZ,A3E4F        ; Fehler aufgetreten -->  Fehlernummer bereitstellen
        CALL    A3DFE           ; 'DTR' - Signal zurücksetzen
        POP     AF              ; gelesenes Zeichen holen
        RET
;
;
;   Fehlernummer aus Fehlerstatus bereitstellen
;
A3E4F:  LD      B,A             ; Fehlerstatus merken
        POP     AF              ; gelesenes Zeichen vergessen
        PUSH    BC              ; Fehlerstatus retten
        CALL    A3D6E           ; serielle Schnittstelle initialisieren
        POP     BC              ; geretteten Fehlerstatus holen
        LD      A,29            ; Vorgabe für Fehlernummer
        RLC     B               ;! CRC / Framing - Fehler nach Carry schieben
        RLC     B               ;!
        RET     C               ; ist Fehler -->  Fehlernummer stimmt
        INC     A               ; Fehlernummer auf 30
        RLC     B               ; Rx Overrun - Fehler nach Carry schieben
        RET     C               ; ist Fehler -->  Fehlernummer stimmt
        INC     A               ; Fehlernummer auf 31
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
;
;   Wert im Accu an serielle Schnittstelle ausgeben
;
A3E64:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      C,(IY+0)        ; Portadresse der Schnittstelle holen
        LD      D,A             ; auszugebendes Zeichen merken
        CALL    A3E04           ; 'RTS' - Signal  setzen
A3E6E:  CALL    A3D67           ; bei Shift - BREAK -->  Abbruch Programm
        CALL    A3EA4           ; auf DCD - Signal reagieren  ?
        CALL    NC,A3EB5        ; ja -->  auf CTS - Signal überprüfen
        JR      C,A3E6E         ; liegt noch nicht an -->  weiter abfragen
        IN      A,(C)           ; Status der seriellen Schnittstelle holen
        BIT     2,A             ; Tx - Buffer empty  ?
        JR      Z,A3E6E         ; nein -->  warten, bis letztes Zeichen gesendet
        BIT     7,(IY+-3)       ; keine Übertragungskontrolle  ?
        JR      Z,A3E8E         ; ja -->  Zeichen ausgeben
        LD      A,00000001B     ; Code for 'Read - Register 1'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        IN      A,(C)           ; 'Read - Register 1'  lesen
        RRCA                    ; All - Send - Bit nach Carry schieben
        JR      NC,A3E6E        ; nicht gesetzt -->  weiter warten
A3E8E:  DEC     C               ; Portnummer auf Datenport der Schnittstelle
        OUT     (C),D           ; Zeichen an serielle Schnittstelle ausgeben
        INC     C               ; Portnummer wieder auf Steuerport
        BIT     6,(IY+-3)       ; aktivieren des RTS - Signals  ?
        JR      Z,A3E9B         ; nein
        CALL    A3E0A           ; 'RTS' - Signal zurücksetzen
A3E9B:  OR      A               ; Carry - Flag zurücksetzen   (Code 'kein Fehler')
        RET
;
;
;   Abfrage, ob DCD - Signal vorhanden ist
;
A3E9D:  OR      A               ; Carry - Flag zurücksetzen   (Code 'kein Fehler')
        BIT     0,(IY+-3)       ; Empfangen des DCD - Signals  ?
        JR      A3EA9           ; eventuell DCD - Signal abfragen
;
;
;
;
A3EA4:  OR      A               ; Carry - Flag zurücksetzen   (Code 'kein Fehler')
        BIT     1,(IY+-3)       ; Senden des DCD - Signals  ?
A3EA9:  RET     Z               ; nicht auf Signal abfragen
        LD      A,00010000B     ; Code for 'Reset EXT/Status Interrupt'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        IN      A,(C)           ; Status der Schnittstelle abfragen
        AND     00001000B       ; DCD - Signal maskieren
        RET     NZ              ; Signal ist gesetzt
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
;
;   auf CTS - Signal testen
;
A3EB5:  OR      A               ; Carry - Flag zurücksetzen   (Code 'kein Fehler')
        BIT     2,(IY+-3)       ; Empfangen des CTS - Signals  ?
        RET     Z               ; nein
        LD      A,00010000B     ; Code for 'Reset EXT/Status Interrupt'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        IN      A,(C)           ; Status der seriellen Schnittstelle abfragen
        AND     00100000B       ; CTS - Signal maskieren
        RET     NZ              ; OK
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
;
;   Device Table for additional RAM-card (RAM:)
;
W3EC6:  DEFW    W37C2           ; Pointer to Next Devices Table (FDx)
        DEFM    "RAM"
		DEFB    NUL             ; Device - name
        DEFB    01011111B       ; Device - Type - Byte
        DEFB    00100000B       ; Devices - numbers - bytes
        DEFB    32              ; maximum number of files on device
        DEFW    A3F14           ; Initialize device
        DEFW    A3FA9           ; Open file for reading
        DEFW    A3FEA           ; Open file for writing
        DEFW    A3F9B           ; Test device readiness
        DEFW    1024            ; maximum number of characters in the sector
        DEFW    A3FD5           ; provide data
        DEFW    A4011           ; output data
        DEFW    A4056           ; delete file
        DEFW    A4083           ; write away changed filename
        DEFW    A3EE3           ; provide free kilobytes
;
;
;   RAM - file organization
;
;      Byte 0/1    Highest usable RAM address for Basic
;      Byte 2/3    Pointer to next free pointer
;      Byte 8-15   Byte numbers 8 - 15 to determine if already initialized
; from Byte 16     RAM card data
;

;
;   Provide free kilobytes of the additional RAM card (device 'RAM:').
;
A3EE3:  CALL    A3EEF           ; Calculate free bytes of add-on RAM card
        LD      C,H             ; Number of free pages (256 blocks)
        LD      B,0             ; High - byte to zero
        SRL     C               ;!  Pages divided by four (yields kilobytes)
        SRL     C               ;!
        OR      A               ; Reset carry flag
        RET
;
;
;   Calculate free bytes of additional RAM card
;
A3EEF:  PUSH    DE              ; Save DE
        LD      HL,0            ; Address of the highest usable RAM address
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        PUSH    DE              ; Note the highest usable RAM address
        INC     HL              ;!  address to 'pointer to next free address'
        INC     HL              ;!
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        POP     HL              ; Get the highest usable additional RAM address
        SBC     HL,DE           ; deduct the next free address
        JP      C,A1F8B         ; Addresses overlap --> Error 41 Hardware error
        POP     DE              ; Restore DE
        RET
;
;
;   Delete all files in additional RAM card
;
A3F04:  LD      DE,16           ; first free address in additional RAM card
;
;
;   Enter pointer to end of user area (in DE) in additional RAM card
;
A3F07:  LD      HL,2            ; Address of 'next free pointer'
        CALL    A40AA           ; Output address in DE after additional RAM after address in HL
        EX      DE,HL           ; Pointer to next free position after HL
        LD      DE,0            ; Code 'End of concatenated offsets'
        JP      A40AA           ; Output address in DE after additional RAM after address in HL
;
;
;   Initialize device 'RAM:'
;
A3F14:  RET     C               ; Error occurred --> termination
        LD      A,(S13C3)       ; Get flag 'RAM - card present'
        OR      A               ; RAM card present ?
        JP      Z,A1F97         ; not available --> error 50' not ready error
        CALL    A1E8F           ; Query whether you really want to initialize
        CALL    TEST1           ; Comparison on byte after CALL call
        DEFM    ","             ; comma ?
        PUSH    HL              ; Save program pointer
        CALL    A3F04           ; delete all files in additional RAM card
        POP     HL              ; get saved program pointer
        CALL    TEST1           ; Comparison on byte after CALL call
        DEFB    NUL             ; end of text character ?
        RET     Z               ; yes --> done
        RST     _DOCMD          ; Software - Execute command
        DEFB    19              ; Command 19 convert ASCII value (HL) into hex value in DE
A3F2F:  LD      HL,0            ;
        DI                      ; Disable interrupts
        LD      B,1             ; code 'no spooler'
        LD      A,D             ; High - Byte Get number of bytes
        AND     11111100B       ; Mask high - byte count for full K - bytes
        CP      63 * 4          ; 63K or more ?
        LD      HL,0FFFFH       ; specify the highest usable RAM address
        JR      Z,A3F48         ; 63K or more --> nothing for spoolers
        LD      B,3             ; Code 'Spooler possible'
        LD      A,D             ; Get high byte count
        OR      A               ; equals zero ?
        LD      HL,32           ; specify minimum address
        JR      NZ,A3F49        ; not zero --> set original value
A3F48:  EX      DE,HL           ; Number of bytes after DE
A3F49:  LD      A,B             ; Spooler - get flag
        LD      (S13C3),A       ; Remember flag 'RAM - card available'
        LD      HL,0            ; Address of the highest usable RAM address
        CALL    A40AA           ; Output address in DE after additional RAM after address in HL
        CALL    A14F4           ; Set spooler data by spooler start address
        EI                      ; Release interrupt again
        RET
;
;
;   determine whether the RAM card has already been initialized
;
A3F58:  LD      HL,8            ; test from byte 8
        LD      B,L             ; test eight bytes
        LD      C,0             ; Default for result value
A3F5E:  CALL    A409F           ; Provide a byte from add-on RAM card from address (HL).
        SUB     L               ; Subtract byte number from value
        OR      C               ; plus old result
        LD      C,A             ; notice new result
        LD      A,L             ; Get low byte address
        CALL    A4094           ; Enter characters in Accu in additional RAM after address (HL).
        INC     L               ; Address to next byte
        DJNZ    A3F5E           ; test more bytes
        LD      A,C             ; get result
        OR      A               ; RAM card initialized ?
        JR      NZ,A3F81        ; no --> test whether it exists at all
        LD      HL,0            ; Address of the highest usable RAM address
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        LD      A,2             ;
        INC     D               ; High byte address equal to 0FFH?
        JR      Z,A3F7B         ; yes --> no spooler
        INC     A               ; Flag on spooler possible
A3F7B:  LD      (S13C3),A       ; Remember flag 'RAM - card available'
        JP      A14F4           ; Set spooler data by spooler start address
;
;
;   Initialize RAM card to default values
;
A3F81:  CALL    A3F04           ; delete all files in additional RAM card
        LD      HL,0            ; Address of the first byte in RAM - map
        LD      A,01011010B     ; Specify test bit pattern
        CALL    A4094           ; Enter characters in Accu in additional RAM after address (HL).
        CALL    A409F           ; Provide a byte from add-on RAM card from address (HL).
        SUB     01011010B       ; same test bit pattern ?
        LD      DE,0C000H       ; Specification of the highest additional RAM address that can be used for BASIC
        JR      Z,A3F2F         ; RAM card available --> remember the start address of the spooler
        XOR     A               ; Code 'RAM - card not present'
        LD      (S13C3),A       ; Remember flag 'RAM - card available'
        RET
;
;
;   Test device readiness and initialize routines
;
A3F9B:  LD      A,(S13C3)       ; Get flag 'RAM - card available'
        OR      A               ; RAM card present ?
        JP      Z,A1F97         ; no --> Error 50' Not ready error
        LD      HL,16           ; Address of the first offset in RAM - card
        LD      (S13C4),HL      ; remember as the address of the next offset
        RET
;
;
;   Open file on device 'RAM' for reading
;
A3FA9:  LD      B,H             ;!Pointer to location for file - identifier after BC
        LD      C,L             ;!  transfer
        LD      HL,(S13C4)      ; Get address of next offset
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        LD      A,D             ;!  offset equal to zero ?
        OR      E               ;!
        SCF                     ; Set flag: 'Error Occurred'
        RET     Z               ; no more files --> abort
        INC     HL              ;!  RAM card address on top of file entry
        INC     HL              ;!
        PUSH    HL              ; Pointer to start of file - save entry
        ADD     HL,DE           ; Pointer to next file - calculate entry
        JP      C,A1F8B         ; Carry occurred --> Error 41 Hardware error
        LD      (S13C4),HL      ; Note the address of the next offset
        POP     HL              ; saved pointer to file - get entry
        INC     HL              ; Block - skip identifier
        INC     HL              ;!  Block - skip length
        INC     HL              ;!
        LD      D,B             ;!  Pointer to position for identifier after DE
        LD      E,C             ;!
        LD      BC,30           ; length file identifier
        CALL    A40DE           ; Number of bytes specified in BC from RAM card from HL to DE
        LD      BC,34           ; Offset to file data
        ADD     HL,BC           ; Calculate pointer to file data in RAM - card
        EX      DE,HL           ; Pointer to position in identifier after HL
        LD      (HL),E          ;!  Pointer to date data in RAM - card in
        INC     HL              ;!  File - Enter identifier
        LD      (HL),D          ;!
        OR      A               ; Reset carry flag
        RET
;
;
;   provide a block of data from the RAM card
;
A3FD5:  EX      DE,HL           ; Pointer to place for data
        LD      L,(IY+30)       ;!  Start address of the next data block
        LD      H,(IY+31)       ;!  from file - get identifier
        INC     HL              ; Data block - skip identifier
        INC     HL              ;!  Skip data block length
        INC     HL              ;!
        CALL    A40DE           ; Number of bytes specified in BC from RAM card from HL to DE
        LD      (IY+30),L       ;!  Start address of the next data block
        LD      (IY+31),H       ;!  enter in file identifier
        OR      A               ; reset carry flag (code 'no error')
        RET
;
;
;   File on device RAM: open for writing
;
A3FEA:  PUSH    AF              ; Save data block identifier
        CALL    A1C3D           ; check if only one file is opened/name doesn't already exist
        PUSH    HL              ; Pointer to file - save identifier
A3FEF:  LD      HL,2            ; address 'next free pointer'
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        LD      (S13C6),DE      ; Note the start address of the new RAM file
        PUSH    DE              ; Save initial address
        LD      HL,64+3+3+1     ; minimal file - space requirements
        ADD     HL,DE           ; Calculate minimum end-of-file address
        CALL    A4045           ; check if address in HL is still OK for RAM card
        POP     DE              ; Get start address of file in RAM card
        INC     DE              ;!  Skip offset
        INC     DE              ;!
        POP     HL              ; Pointer to file - get handle
        LD      BC,64           ; Length file - identifier in RAM - file
        POP     AF              ; Get data block identifier
        CALL    A40C0           ; Data block (HL) with identification data in RAM data transferred to (DE).
        LD      (S13C8),DE      ; RAM - remember card address for data block
        RET
;
;
;   Write data block in RAM - card
;
A4011:  PUSH    AF              ; Save block ID
        PUSH    HL              ; Save main memory address
        PUSH    BC              ; Save block length
        LD      HL,(S13C8)      ; RAM - get card address for data block
        INC     BC              ;!  Length for block identifier and block length
        INC     BC              ;!  correct
        INC     BC              ;!
        ADD     HL,BC           ; Calculate end address
        CALL    A4045           ; Check if address in HL is still OK for RAM card
        POP     BC              ; Get saved block length
        POP     HL              ; Get main memory address
        LD      DE,(S13C8)      ; RAM - get card address for data block
        POP     AF              ; rescued block - get identifier
        PUSH    AF              ; and remember again
        OR      00000001B       ; plus code 'data block'
        CALL    A40C0           ; Data block (HL) with identification data in RAM data transferred to (DE).
        LD      (S13C8),DE      ; RAM - remember card address for data block
        POP     AF              ; rescued block - get identifier
        BIT     2,A             ; last block ?
        RET     Z               ; no
        PUSH    DE              ; RAM - remember end address
        CALL    A3F07           ; Enter pointer to end of used area (in DE) in RAM card
        POP     HL              ; RAM - get end address
        LD      DE,(S13C6)      ; Get the start address of the new RAM file
        DEC     HL              ;!   correct for offset
        DEC     HL              ;!
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; File - Length in RAM - Calculate file
        EX      DE,HL           ; Offset to DE / pointer to position for offset to HL
        JP      A40AA           ; Output address in DE after additional RAM after address in HL

;
;
;   Check whether address in HL is still within the usable range for BASIC
;
A4045:  JR      C,A4053         ; Transfer --> Error 53 No file space error
        PUSH    HL              ; save address to be verified
        LD      HL,0            ; Address of the highest usable RAM address
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        OR      A               ; Reset carry flag
        POP     HL              ; Get address to verify
        SBC     HL,DE           ; compare with maximum address
        RET     C               ; Address is OK
A4053:  JP      A1FA0           ; Error 53 No file space error
;
;
;   Delete file on RAM: device after setting the identification data
;
A4056:  LD      HL,(S101E)      ; Get pointer to location for data block from file handle
        LD      DE,-(64+3+2)    ; Offset on offset for file - offset
        ADD     HL,DE           ; Calculate pointer to offset for file
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        EX      DE,HL           ; Offset to HL
        ADD     HL,DE           ; Calculate pointer to end of file
        INC     HL              ;!  correct for offset
        INC     HL              ;!
        PUSH    DE              ; Save pointer to start of file
        PUSH    HL              ; Save pointer to end of file
        LD      HL,2            ; address 'next free pointer'
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        EX      DE,HL           ; End address after HL
        POP     DE              ; Get pointer to end of file
        PUSH    DE              ; and remember again
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; Calculate number of bytes after file
        INC     HL              ;!  correct for last offset
        INC     HL              ;!
        LD      B,H             ;!  Number of bytes to move to BC
        LD      C,L             ;!
        POP     HL              ; Get pointer to end of file
        POP     DE              ; Get pointer to start of file
        CALL    A40EA           ; Move number of bytes specified in BC in additional RAM from (HL) to (DE).
        DEC     DE              ;!  Set address back to last offset
        DEC     DE              ;!
        LD      HL,2            ; address 'next free pointer'
        JP      A40AA           ; Output address in DE after additional RAM after address in HL
;
;
;   Enter the (changed) file identifier back into the RAM card
;
A4083:  LD      HL,(S101E)      ; Get pointer to data block location
        LD      DE,-64          ; Offset to position for file identifier
        ADD     HL,DE           ; Calculate pointer to position for file handle
        EX      DE,HL           ; Address after DE
        LD      HL,S1000        ; Pointer to storage for file handle
        LD      BC,32           ; Length identifier record
        JP      A40D0           ; LDIR from main memory to additional RAM
;
;
;   Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
;
A4094:  PUSH    BC              ; Keep register value
        LD      C,ERAM_A        ; RAM - Karte  Adressen - Port
        LD      B,H             ; High - Byte Adresse in RAM - Karte
        OUT     (C),L           ; Adresse an RAM - Karte ausgeben
        OUT     (ERAM_D),A      ; Zeichen an RAM - Karte ausgeben
        POP     BC              ; geretteten Register - Wert holen
        OR      A               ; Carry - Flag zurücksetzen   (Code for 'Funktion OK')
        RET
;
;
;   ein Byte aus Zusatz - RAM - Karte aus Adresse (HL) bereitstellen
;
A409F:  PUSH    BC              ; Keep register value
        LD      C,ERAM_A        ; RAM - Karte  Adressen - Port
        LD      B,H             ; High - Byte Adresse in RAM - Karte
        OUT     (C),L           ; Adresse an RAM - Karte ausgeben
        IN      A,(ERAM_D)      ; Zeichen von RAM - Karte holen
        POP     BC              ; geretteten Register - Wert holen
        OR      A               ; Carry - Flag zurücksetzen   (Code for 'Funktion OK')
        RET
;
;
;   Adresse in DE nach Zusatz - RAM - Karte  nach Adresse in HL ausgeben
;
A40AA:  LD      A,E             ; Low - Byte Adresse holen
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        INC     HL              ; Zeiger auf RAM - Karte auf nächste Speicherzelle
        LD      A,D             ; High - Byte Adresse holen
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        DEC     HL              ; Zeiger auf RAM - Karte wieder corrigieren
        RET
;
;
;   zwei Byte aus Zusatz - RAM - Karte ab Adresse in HL nach DE
;
A40B5:  CALL    A409F           ; ein Byte aus Zusatz-RAM-Karte aus Adresse (HL) bereitstellen
        LD      E,A             ; Low - Byte Wert merken
        INC     HL              ; Zeiger auf RAM - Karte auf nächste Speicherzelle
        CALL    A409F           ; ein Byte aus Zusatz-RAM-Karte aus Adresse (HL) bereitstellen
        LD      D,A             ; High - Byte Wert merken
        DEC     HL              ; Zeiger auf RAM - Karte wieder corrigieren
        RET
;
;
;   Datenblock (HL) mit Kennungsdaten in RAM - Datei nach (DE) übertragen
;
A40C0:  EX      DE,HL           ; Zeiger auf RAM - Karte nach HL
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        INC     HL              ; Block - Kennung überspringen
        LD      A,C             ; Low - Byte Block - Länge holen
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        INC     HL              ; Low - Byte Länge überspringen
        LD      A,B             ; High - Byte Block - Länge holen
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        INC     HL              ; High - Byte Länge überspringen
        EX      DE,HL           ; RAM - Kartenadresse nach DE
;
;
;   in BC angegebene Anzahl Bytes vom Hauptspeicher ab Adresse (HL)
;   nach Zusatz - RAM - Karte ab Adresse (HL) ablegen
;
A40D0:  EX      DE,HL           ; RAM - Kartenadresse nach HL
A40D1:  LD      A,(DE)          ; ein Byte aus Speicher holen
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        INC     HL              ; Zeiger auf RAM - Karte auf nächste Speicherzellen
        INC     DE              ; Zeiger auf Hauptspeicher auf nächste Speicherzelle
        DEC     BC              ; Restanzahl Bytes minus eins
        LD      A,B             ;! Restanzahl Bytes gleich Null  ?
        OR      C               ;!
        JR      NZ,A40D1        ; nein -->  weitere Bytes aus Speicher an RAM-Karte ausgeben
        EX      DE,HL           ; RAM - Kartenadresse nach DE
        RET
;
;
;   in BC angegebene Anzahl Bytes von RAM-Karte ab HL nach DE
;
A40DE:  CALL    A409F           ; ein Byte aus Zusatz-RAM-Karte aus Adresse (HL) bereitstellen
        LD      (DE),A          ; gelesenes Byte im Speicher merken
        INC     HL              ; Zeiger auf RAM - Karte auf nächstes Byte
        INC     DE              ; Zeiger auf Speicher auf nächstes Byte
        DEC     BC              ; Restanzahl Bytes minus eins
        LD      A,B             ;! Restanzahl Bytes gleich Null  ?
        OR      C               ;!
        RET     Z               ; ja -->  fertig
        JR      A40DE           ; weitere Bytes aus RAM - Karte lesen
;
;
;   in BC angegebene Anzahl Bytes in Zusatz - RAM von (HL) nach (DE) verschieben
;
A40EA:  CALL    A409F           ; ein Byte aus Zusatz-RAM-Karte aus Adresse (HL) bereitstellen
        EX      DE,HL           ; Zeiger vertauschen
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        EX      DE,HL           ; Zeiger vertauschen
        INC     HL              ; Zeiger auf Quelle plus eins
        INC     DE              ; Zeiger auf Ziel plus eins
        DEC     BC              ; Restanzahl Bytes minus eins
        LD      A,B             ;! Restanzahl Bytes gleich Null  ?
        OR      C               ;!
        RET     Z               ; ja -->  fertig
        JR      A40EA           ; weitere Bytes in Zusatz - RAM - Karte verschieben

;   Speicherbereich und Tabellenbereich für TON - Routinen
;
B40FA:  DEFB    0               ; MUSIC - Status   (0 = inaktiv / 1 = MUSIC / 2 = SOUND)
;
B40FB:  DEFB    0               ; Speicher für Bits der aktiven Tongeneratorregister
;
        DEFB    0
;
;
;   Tabelle mit aktuellen Werte der programmierbaren Tongeneratoren
;
B40FD:  DEFB    080H,000H       ; Code for 'Frequenz Tongenerator 0 auf Aus'
B40FF:  DEFB    09FH            ; Code for 'Lautstärke Tongenerator 0 auf Aus'
;
        DEFB    0A0H,000H       ; Code for 'Frequenz Tongenerator 1 auf Aus'
        DEFB    0BFH            ; Code for 'Lautstärke Tongenerator 1 auf Aus'
;
        DEFB    0C0H,000H       ; Code for 'Frequenz Tongenerator 2 auf Aus'
B4105:  DEFB    0DFH            ; Code for 'Lautstärke Tongenerator 2 auf Aus'
;
;
;   Speicherbreich für aktuellen Status Tongenerator Null
;
B4106:  DEFB    0               ; Nummer des Tongenerators
        DEFS    1               ; Wiederholungszähler
        DEFS    1               ; Wiederholungsfaktor
        DEFS    2               ; Zeiger auf Wellenformtabelle
        DEFS    1               ; Lautstärkenzähler
        DEFS    1               ; Tonlängenzähler
        DEFS    1               ; Tempozähler
        DEFS    1               ; Tonlängenverhältnis
        DEFS    1               ; Tempofaktor
        DEFS    2               ; Zeiger auf Rest Wertetabelle
        DEFS    1               ; Wellenformnummer
        DEFS    1               ; Pausennotenflag
        DEFS    1               ; Lautstärkenwert
        DEFS    1               ; maximale Lautstärke
;
;
;   Speicherbereich für aktuellen Status  Tongenerator eins
;
        DEFB    1               ; Nummer des Tongenerators
        DEFS    1               ; Wiederholungszähler
        DEFS    1               ; Wiederholungsfaktor
        DEFS    2               ; Zeiger auf Wellenformtabelle
        DEFS    1               ; Lautstärkenzähler
        DEFS    1               ; Tonlängenzähler
        DEFS    1               ; Tempozähler
        DEFS    1               ; Tonlängenverhältnis
        DEFS    1               ; Tempofaktor
        DEFS    2               ; Zeiger auf Rest Wertetabelle
        DEFS    1               ; Wellenformnummer
        DEFS    1               ; Pausennotenflag
        DEFS    1               ; Lautstärkenwert
        DEFS    1               ; maximale Lautstärke
;
;
;   Speicherbereich für aktuellen Status  Tongenerator zwei
;
        DEFB    2               ; Nummer des Tongenerators
        DEFS    1               ; Wiederholungszähler
        DEFS    1               ; Wiederholungsfaktor
        DEFS    2               ; Zeiger auf Wellenformtabelle
        DEFS    1               ; Lautstärkenzähler
        DEFS    1               ; Tonlängenzähler
        DEFS    1               ; Tempozähler
        DEFS    1               ; Tonlängenverhältnis
        DEFS    1               ; Tempofaktor
        DEFS    2               ; Zeiger auf Rest Wertetabelle
        DEFS    1               ; Wellenformnummer
        DEFS    1               ; Pausennotenflag
        DEFS    1               ; Lautstärkenwert
        DEFS    1               ; maximale Lautstärke

;
;
;   Speicherbereich für aktuelles Status  Tongenerator drei
;
        DEFB    3               ; Nummer des Tongenerators
        DEFS    1               ; Wiederholungszähler
        DEFS    1               ; Wiederholungsfaktor
        DEFS    2               ; Zeiger auf Wellenformtabelle
        DEFS    1               ; Lautstärkenzähler
        DEFS    1               ; Tonlängenzähler
        DEFS    1               ; Tempozähler
        DEFS    1               ; Tonlängenverhältnis
        DEFS    1               ; Tempofaktor
        DEFS    2               ; Zeiger auf Rest Wertetabelle
        DEFS    1               ; Wellenformnummer
        DEFS    1               ; Pausennotenflag
        DEFS    1               ; Lautstärkenwert
        DEFS    1               ; maximale Lautstärke
;
;
;   Tabelle mit Umsetzverhältnissen für Tonlängenzähler
;
B4146:  DEFB    1               ; Umsetzverhältnis für Tonlänge  0
        DEFB    2               ; Umsetzverhältnis für Tonlänge  1
        DEFB    3               ; Umsetzverhältnis für Tonlänge  2
        DEFB    4               ; Umsetzverhältnis für Tonlänge  3
        DEFB    6               ; Umsetzverhältnis für Tonlänge  4
        DEFB    8               ; Umsetzverhältnis für Tonlänge  5
        DEFB    12              ; Umsetzverhältnis für Tonlänge  6
        DEFB    16              ; Umsetzverhältnis für Tonlänge  7
        DEFB    24              ; Umsetzverhältnis für Tonlänge  8
        DEFB    32              ; Umsetzverhältnis für Tonlänge  9
;
        DEFB    23              ; Faktor für Tempo 1
        DEFB    20              ; Faktor für Tempo 2
        DEFB    17              ; Faktor für Tempo 3
        DEFB    13              ; Faktor für Tempo 4
        DEFB    10              ; Faktor für Tempo 5
        DEFB    7               ; Faktor für Tempo 6
        DEFB    3               ; Faktor für Tempo 7
;
;
;   Tabelle für Wellenformwerte
;
B4157:  DEFB    000H,005H,003H,003H     ; Werte für Wellenform  0
;
        DEFB    00FH,004H,001H,003H     ; Werte für Wellenform  1
;
        DEFB    000H,005H,002H,000H     ; Werte für Wellenform  2
;
        DEFB    00FH,004H,001H,000H     ; Werte für Wellenform  3
;
        DEFB    000H,005H,002H,003H     ; Werte für Wellenform  4
;
        DEFB    00FH,004H,003H,003H     ; Werte für Wellenform  5
;
        DEFB    000H,005H,004H,000H     ; Werte für Wellenform  6
;
        DEFB    00FH,004H,005H,000H     ; Werte für Wellenform  7
;
        DEFB    000H,003H,003H,000H     ; Werte für Wellenform  8
;
;
;   Tabelle mit Teilungsverhältnissen für Tonhöhe
;
B417B:  DEFB    000H,03FH               ; Tone  9    110.61  Hz     A
        DEFB    007H,03BH               ; Tone 10    116.65  Hz    #A
        DEFB    002H,038H               ; Tone 11    121.76  Hz     B
        DEFB    00FH,034H               ; Tone 12    130.98  Hz     C
        DEFB    000H,032H               ; Tone 13    138.67  Hz    #C
        DEFB    003H,02FH               ; Tone 14    146.94  Hz     D
        DEFB    009H,02CH               ; Tone 15    155.46  Hz    #D
        DEFB    001H,02AH               ; Tone 16    164.69  Hz     E
        DEFB    00BH,027H               ; Tone 17    174.55  Hz     F
        DEFB    007H,025H               ; Tone 18    185.04  Hz    #F
        DEFB    006H,023H               ; Tone 19    195.83  Hz     G
        DEFB    006H,021H               ; Tone 20    207.57  Hz    #G
;
        DEFB    008H,01FH               ; Tone 21    219.92  Hz     A
        DEFB    00CH,01DH               ; Tone 22    232.86  Hz    #A
        DEFB    001H,01CH               ; Tone 23    246.86  Hz     B
        DEFB    008H,01AH               ; Tone 24    261.42  Hz     C
        DEFB    000H,019H               ; Tone 25    277.10  Hz    #C
        DEFB    009H,017H               ; Tone 26    294.01  Hz     D
        DEFB    004H,016H               ; Tone 27    311.35  Hz    #D
        DEFB    000H,015H               ; Tone 28    329.88  Hz     E
        DEFB    00DH,013H               ; Tone 29    349.65  Hz     F
        DEFB    00CH,012H               ; Tone 30    369.47  Hz    #F
        DEFB    00BH,011H               ; Tone 31    391.66  Hz     G
        DEFB    00BH,010H               ; Tone 32    415.13  Hz    #G
;
        DEFB    00CH,00FH               ; Tone 33    439.84  Hz     A
        DEFB    00EH,00EH               ; Tone 34    465.72  Hz    #A
        DEFB    000H,00EH               ; Tone 35    494.82  Hz     B
        DEFB    004H,00DH               ; Tone 36    522.83  Hz     C
        DEFB    008H,00CH               ; Tone 37    544.20  Hz    #C
        DEFB    00DH,00BH               ; Tone 38    586.46  Hz     D
        DEFB    002H,00BH               ; Tone 39    622.70  Hz    #D
        DEFB    008H,00AH               ; Tone 40    659.76  Hz     E
        DEFB    00FH,009H               ; Tone 41    697.11  Hz     F
        DEFB    006H,009H               ; Tone 42    738.94  Hz    #F
        DEFB    00DH,008H               ; Tone 43    786.10  Hz     G
        DEFB    005H,008H               ; Tone 44    833.39  Hz    #G
;
        DEFB    00EH,007H               ; Tone 45    879.69  Hz     A
        DEFB    007H,007H               ; Tone 46    931.43  Hz    #A
        DEFB    000H,007H               ; Tone 47    989.65  Hz     B
        DEFB    00AH,006H               ; Tone 48   1045.7   Hz     C
        DEFB    004H,006H               ; Tone 49   1108.4   Hz    #C
        DEFB    00EH,005H               ; Tone 50   1179.2   Hz     D
        DEFB    009H,005H               ; Tone 51   1245.4   Hz    #D
        DEFB    004H,005H               ; Tone 52   1319.5   Hz     E
        DEFB    00FH,004H               ; Tone 53   1403.0   Hz     F
        DEFB    00BH,004H               ; Tone 54   1477.9   Hz    #F
        DEFB    007H,004H               ; Tone 55   1561.1   Hz     G
        DEFB    003H,004H               ; Tone 56   1654.3   Hz    #G
;
        DEFB    00FH,003H               ; Tone 57   1759.4   Hz     A
        DEFB    00BH,003H               ; Tone 58   1878.7   Hz    #A
        DEFB    008H,003H               ; Tone 59   1979.3   Hz     B
        DEFB    005H,003H               ; Tone 60   2091.3   Hz     C
        DEFB    002H,003H               ; Tone 61   2216.3   Hz    #C
        DEFB    00FH,002H               ; Tone 62   2358.3   Hz     D
        DEFB    00DH,002H               ; Tone 63   2463.1   Hz    #D
        DEFB    00AH,002H               ; Tone 64   2639.1   Hz     E
        DEFB    008H,002H               ; Tone 65   2771.0   Hz     F
        DEFB    005H,002H               ; Tone 66   2995.7   Hz    #F
        DEFB    003H,002H               ; Tone 67   3166.9   Hz     G
        DEFB    001H,002H               ; Tone 68   3358.8   Hz    #G
;
        DEFB    00FH,001H               ; Tone 69   3575.5   Hz     A
        DEFB    00EH,001H               ; Tone 70   3694.7   Hz    #A
        DEFB    00CH,001H               ; Tone 71   3958.6   Hz     B
        DEFB    00AH,001H               ; Tone 72   4263.1   Hz     C
        DEFB    009H,001H               ; Tone 73   4433.6   Hz    #C
        DEFB    008H,001H               ; Tone 74   4618.4   Hz     D
        DEFB    006H,001H               ; Tone 75   5038.2   Hz    #D
        DEFB    005H,001H               ; Tone 76   5278.1   Hz     E
        DEFB    004H,001H               ; Tone 77   5542.0   Hz     F
        DEFB    003H,001H               ; Tone 78   5833.7   Hz    #F
        DEFB    002H,001H               ; Tone 79   6157.8   Hz     G
        DEFB    001H,001H               ; Tone 80   6520.0   Hz    #G
;
        DEFB    000H,001H               ; Tone 81   6927.5   Hz     A
        DEFB    00FH,000H               ; Tone 82   7389.4   Hz    #A
        DEFB    00EH,000H               ; Tone 83   7917.1   Hz     B
;
;
;   Table with values for switching off all tone generators
;
B4211:  DEFB    09FH            ; Tone generator 0 volume to OFF
        DEFB    0BFH            ; Tone generator 1 volume to OFF
        DEFB    0DFH            ; Tone generator 2 volume to OFF
        DEFB    0FFH            ; Noise generator volume to OFF
;
;
;   Output table for sound by note number and duration (SOUND)
;
B4215:  DEFB    080H,000H       ; Code for 'Frequency Tone Generator 0 to OFF'
        DEFB    090H            ; Code for 'volume tone generator 0 to OFF'
;
S4218:  DEFS    2               ; Tone length (with SOUND)
;
;
;   Music - process interrupt by counter 8253 and PIO channel A
;
PSGINT: PUSH    IY              ; Register - save value
        CALL    A4224           ; Process interrupt for MUSIC
        POP     IY              ; rescued register - fetch value
        EI                      ; Enable interrupt
        RETI                    ; Interrupt - complete treatment
;
;
;   Process music interrupt
;
A4224:  CALL    PUSHRA          ; Save registers IX, HL, BC, DE and AF
        CALL    MSTART          ; Initialize blocks for 'MUSIC - Interrupt'
        LD      A,(B40FA)       ; MUSIC - get status
        OR      A               ; Sound output active?
        JP      Z,A447E         ; no --> turn off the sound
        DEC     A               ; MUSIC ?
        JP      NZ,A43B9        ; no --> process interrupt at SOUND
        LD      BC,256*9+PSGOUT ; 9 values ??in table / port number of tone generator
        LD      HL,B40FD        ; Table with current values ??of the tone generators
        OTIR                    ; Output table with new values ??of the tone generators
        LD      B,8             ; eight registers in the tone generator
        LD      A,(B40FB)       ; Get bits of active tone generator registers
        OR      A               ; no tone generator active?
        JP      Z,A447E         ; yes --> turn off the sound
        LD      C,A             ; Note the bits of the tone generators
A4247:  DEC     B               ; Counter minus one
        RET     M               ; finished
        RLC     C               ; shift a tone generator bit after carry
        JR      NC,A4247        ; Bit not set --> generator register not active
        PUSH    BC              ; Save counters and remainder bits
        LD      A,B             ; get counter
        CALL    A43FC           ; Provide pointers to memory by register number
        BIT     0,(IY+13)       ; break mark ?
        CALL    Z,A425F         ; no --> prepare volume from waveform
        CALL    A42AC           ; Wait counter minus one if 0 --> next note value
        POP     BC              ; get saved counter and remainder bits
        JR      A4247           ; Test remaining tone generator registers
;
;
;   Process volume from waveform
;
A425F:  DEC     (HL)            ; Rep count minus one
        RET     NZ              ; not zero yet --> done
        INC     HL              ; Pointer to repetition factor
        LD      A,(HL)          ; Get repetition factor from table
        DEC     HL              ; Pointer back to repeat count
        LD      (HL),A          ; Enter the repetition factor as repetition counter
        INC     HL              ; Pointer to repetition factor
        INC     HL              ; Pointer to low - byte pointer to waveform table
        LD      E,(HL)          ;! Pointer to waveform table from Generator - Status -
        INC     HL              ;! get record
        LD      D,(HL)          ;!
        EX      DE,HL           ; Pointer to waveform table after HL
A426B:  LD      A,(HL)          ; Get next value from waveform table
        OR      A               ; equals zero  ?
        JR      NZ,A4273        ; no --> evaluate
        DEC     HL              ;! Pointer to last but one value in table
        DEC     HL              ;!
        JR      A426B           ; examine again
;
A4273:  EX      DE,HL           ; Pointer to waveform table back to DE
        INC     HL              ; Pointer to generator table on volume counter
        DEC     A               ; value equal to one ?
        JR      Z,A4288         ; yes --> specify code for 'no sound'
        DEC     A               ; Worth two?
        JR      Z,A4296         ; yes --> note the attenuation of 4 dB
        DEC     A               ; Worth three?
        RET     Z               ; yes --> old volume
        DEC     A               ; Value equal to four?
        LD      A,(HL)          ; get old volume value
        JR      Z,A428C         ; yes --> decrease attenuation (volume up)
        INC     A               ; Volume value plus one (sound decreases)
        CP      00001111B       ; Code for 'mute' ?
        JR      Z,A429A         ; yes --> enter
        JR      C,A429A         ; still OK --> remember new volume value
A4288:  LD      A,00001111B     ; Code for 'mute'
        JR      A4299           ; Correct the pointer from the table and note the new volume
;
A428C:  DEC     A               ; Attenuation minus one
        JP      M,A4296         ; Overflow --> specify maximum volume
        LD      C,(IY+14)       ; get maximum volume value
        CP      C               ; compare with current volume value
        JR      NC,A429A        ; Value is still OK --> remember
A4296:  LD      A,(IY+14)       ; get maximum volume value
A4299:  INC     DE              ; Waveform table pointer to next value
A429A:  LD      (HL),A          ; Enter volume counter in status table
        DEC     HL
        LD      (HL),D          ;! Pointer to waveform table in status table
        DEC     HL              ;! of the tone generator
        LD      (HL),E          ;!
A429F:  AND     00001111B       ; Mask Loudness
        LD      B,A             ; and remember
        LD      A,(IX+2)        ; get old volume value
        AND     11110000B       ; Mask the register mask of the tone generator
        OR      B               ; plus new volume value
        LD      (IX+2),A        ; remember new volume value for next tone
        RET
;
;
;   Count down the wait counter for the tone generator when the tone has finished playing -->
;   Evaluate remainder of melody text for tone generator (pointer to data record in IY)
;
A42AC:  DEC     (IY+6)          ; Tone length counter minus one
        RET     NZ              ; not zero yet
        DEC     (IY+7)          ; Speed ??counter minus one
        LD      A,(IY+8)        ; Get Tone Length Ratio
        LD      (IY+6),A        ; and remember again as a tone length counter
        RET     NZ              ; Speed ??counter not yet zero --> continue to wait
        LD      A,(IY+9)        ; Get pace factor
        LD      (IY+7),A        ; and remember as a tempo counter
        LD      E,(IY+10)       ;! Pointer to remainder value table for tone generator
        LD      D,(IY+11)       ;! to fetch
;
;
;   Process next note value in table (DE).
;
A42C6:  LD      A,(DE)          ; get the next tonal value
        INC     DE              ; Skip Tone
        CP      -1              ; End of table?
        JR      Z,A4331         ; yes --> turn off the tone generator
        CP      0A0H            ; repetition factor ?
        JR      Z,A432A         ; yes --> evaluate repetition factor
        CP      090H            ; waveform ?
        JR      NC,A4339        ; yes --> evaluate waveform
        CP      080H            ; Volume  ?
        JR      NC,A4340        ; yes --> evaluate volume
        CP      060H            ; tone length ?
        JR      NC,A434A        ; yes --> Evaluate tone length
        SUB     9               ; the first nine notes are rests
        LD      (IY+10),E       ;! Remember pointer to remainder table of values
        LD      (IY+11),D       ;!
        SET     0,(IY+13)       ; Set pause bit
        JR      C,A42F1         ; Note is rest
        RES     0,(IY+13)       ; Reset the pause bit
        CALL    A4362           ; Provide frequency value of note number
A42F1:  LD      A,(IY+2)        ; Get repetition factor
        LD      (IY+1),A        ; and remember as a rep counter
        LD      A,(IY+8)        ; Get Tone Length Ratio
        LD      (IY+6),A        ; note as tone length counter
        LD      A,(IY+9)        ; Get pace factor
        LD      (IY+7),A        ; and remember as a tempo counter
        BIT     0,(IY+13)       ; break mark ?
        JR      NZ,A4334        ; yes --> specify code for 'no sound'
        LD      A,(IY+12)       ; Get waveform number
        LD      BC,B4157        ; Pointer to table of waveform values
        ADD     A,A             ;! waveform number times two
        ADD     A,A             ;! times four (four values ??per number)
        LD      H,0             ; High - byte offset to zero
        LD      L,A             ; Specify low - byte offset
        ADD     HL,BC           ; Calculate pointers to correct waveform values
        LD      A,(HL)          ; Get first value from table
        OR      A               ; equals zero  ?
        JR      NZ,A431C        ; no --> remember value
        LD      A,(IY+14)       ; Get volume value
A431C:  LD      (IY+5),A        ; set as a volume counter
        CALL    A429F           ; Enter volume counter in output table
        INC     HL              ; skip first value in waveform table
        LD      (IY+3),L        ;! Remember pointer to waveform table
        LD      (IY+4),H        ;!
        RET
;
;
;   Evaluate repetition factor from value table
;
A432A:  LD      A,(DE)          ; Get repetition factor
        INC     DE              ; Skip repetition factor
        LD      (IY+2),A        ; Note the repetition factor
A432F:  JR      A42C6           ; next value in tone - evaluate table
;
;
;   Value table for tone generator processed --> specify code for 'no sound'
;
A4331:  CALL    A4464           ; notice that the tone generator is no longer active
A4334:  LD      A,00001111B     ; Code for 'volume off'
        JP      A429F           ; Remember Accu as volume value for next tone
;
;
;   Waveform from tone - Evaluate table of values
;
A4339:  SUB     090H            ; Convert code to waveform number
        LD      (IY+12),A       ; remember waveform
        JR      A432F           ; next value in tone - evaluate table
;
;
;   Evaluate volume from value table
;
A4340:  SUB     080H            ; Convert code to volume value
        CPL                     ; highest value is lowest volume
        AND     00001111B       ; Mask loudness bits
        LD      (IY+14),A       ; Note volume value
        JR      A432F           ; next value in tone - evaluate table
;
;
;   Evaluate tone length from value table
;
A434A:  SUB     060H            ; Convert code to tone length
        LD      B,0             ; High - byte offset to zero
        LD      C,A             ; Tone length as low - byte offset
        LD      HL,B4146        ; Pointer to table of tone length ratios
        ADD     HL,BC           ; Calculate pointer to correct table value
        CP      9 + 1           ; Tone length or tempo?
        LD      A,(HL)          ; Get tone length ratio from table
        JR      NC,A435D        ; tempo
        LD      (IY+8),A        ; Note pitch ratio
        JR      A432F           ; next value in tone - evaluate table
;
A435D:  LD      (IY+9),A        ; note the tempo factor
        JR      A432F           ; next value from Ton - evaluate table
;
;
;   Get frequency value of note number from table
;
A4362:  ADD     A,A             ; Note number times two (two bytes per frequency)
        LD      HL,B417B        ; Specify pointer to table with frequency values
        LD      B,0             ; High - byte offset to zero
        LD      C,A             ; Note number value as low - byte offset
        ADD     HL,BC           ; Calculate pointer to frequency value of note
        LD      B,(HL)          ; Get low byte frequency value from table
        LD      A,(IX+0)        ; Get low - byte frequency of old note
        AND     11110000B       ; Register - Mask number of tone generator
        OR      B               ; plus low - byte new frequency value
        LD      (IX+0),A        ; Remember frequency value for next note
        INC     HL              ; Pointer to frequency table on high byte
        LD      A,(HL)          ; Get high byte frequency value from table
        LD      (IX+1),A        ; and enter in table for tone generator
        RET
;
;
;   Tone by generator - play number and frequency or note number and length
;
;   (SVC code:  34)
;
MSOUND: OR      A               ; Frequency or note number?
        JP      P,A43C6         ; Note number and length given
        AND     00001111B       ; Mask tone generator number
        LD      C,PSGOUT        ; Specify the port address of the tone generator
        ADD     A,A             ;! Tone generator - number times 2
        ADD     A,A             ;! times 4
        ADD     A,A             ;! times 8
        ADD     A,A             ;! times 16
        OR      10000000B       ; plus code for 'control word'
        LD      B,A             ; Note the tone generator number
        BIT     4,A             ; frequency register ?
        JR      NZ,A43AB        ; no --> volume
        CP      11100000B       ; noise generator ?
        JR      Z,A43A7         ; Yes
        LD      A,D             ; Get high byte frequency
        CP      3 + 1           ; compare with maximum high byte
        JR      NC,A43B6        ; too big --> Error 3 Illegal data error
        LD      A,E             ; Get low byte frequency
        AND     00001111B       ; mask lower 4 bits
        OR      B               ; plus tone generator - number
        OUT     (C),A           ; Output first byte for frequency to tone generator
        LD      A,D             ; Get high byte frequency divider
        LD      B,4             ; shift four bits
A439F:  RL      E               ;! shift higher 6 bits of frequency to correct bits
        RLA                     ;!
        DJNZ    A439F           ;!
        OUT     (C),A           ; output higher 6 bits of frequency
        RET
;
A43A7:  BIT     3,E             ; Value greater than 15 ?
        JR      NZ,A43B6        ; yes --> Error 3 Illegal data error
A43AB:  LD      A,E             ;! Check volume value for size
        AND     11110000B       ;!
        OR      D               ;!
        JR      NZ,A43B6        ; too big --> Error 3 Illegal data error
        LD      A,E             ; Get volume value
        OR      B               ; plus register number
        OUT     (C),A           ; and output to tone generator
        RET
;
A43B6:  JP      A1F7F           ; Error 3 Illegal data error
;
;
;   Process interrupt at SOUND
;
A43B9:  LD      HL,(S4218)      ; Remainder - get tone length
        DEC     HL              ; minus one
        LD      (S4218),HL      ; and remember again
        LD      A,L             ;! Tone length equal to zero?
        OR      H               ;!
        RET     NZ              ; no --> finished with interrupt
        JP      A447E           ; turn off all tone generators
;
;
;   Play note by note number and length
;
A43C6:  LD      C,A             ; Remember note number
        LD      A,D             ;! zero length?
        OR      E               ;!
        RET     Z               ; yes --> done
        LD      A,C             ; Get note number
        LD      IX,B4215        ; Pointer to tone generator output table
        CP      83 + 1          ; known note number ?
        RET     NC              ; no
        SUB     9               ; Break  ? (Tones from 0 - 8)
        PUSH    AF              ; Rest of the tone - remember the number
        LD      A,10010000B     ; Code for 'maximum volume tone generator 0'
        JR      NC,A43DB        ; no break
        LD      A,10011111B     ; Code for 'volume off tone generator 0'
A43DB:  LD      (IX+2),A        ; Enter volume value in output table
        CALL    A44A3           ; wait for old tunes to finish playing
        POP     AF              ; Rest of tone - get number
        CALL    NC,A4362        ; no rest --> provide frequency value of note number
        DI                      ; Disable interrupts
        LD      A,2             ; Code for 'SOUND'
        LD      (B40FA),A       ; as MUSIC - save status
        LD      (S4218),DE      ; Enter tone length
        LD      HL,B4215        ; Pointer to edited output table for tone generator
        LD      BC,256*3+PSGOUT ; Output 3 values ??/ address tone generator
        OTIR                    ; Output provided values ??to tone generator
        CALL    MSTART          ; Initialize blocks for 'MUSIC - Interrupt'
        EI                      ; Release interrupt again
        RET
;
;
;   Pointers to memory areas by tone generator - provide register number
;
A43FC:  PUSH    BC              ; Register - save value
        PUSH    AF              ; Tone generator - save the number
        CP      3               ; noise generator ?
        JR      C,A4403         ; no
        DEC     A               ; correct for tone generator 2
A4403:  LD      HL,B40FD        ; Pointer to start of output table for generators
        LD      B,A             ; Remember counter
        ADD     A,A             ;! times two (three bytes per output table)
        ADD     A,B             ;! times three
        LD      C,A             ; remember as low - byte offset
        LD      B,0             ; High - byte offset to zero
        ADD     HL,BC           ; Compute pointer to tone generator output table
        PUSH    HL              ;! and transferred to IX
        POP     IX              ;!
        POP     AF              ; Tone generator - get number
        ADD     A,A             ;! times 2 (16 bytes per tone generator status table)
        ADD     A,A             ;! times 4
        ADD     A,A             ;! times 8
        ADD     A,A             ;! times 16
        LD      HL,B4106        ; Pointer to Start Tone Generator - Status - Table
        LD      B,0             ; High - byte offset to zero
        LD      C,A             ; Specify low - byte offset
        ADD     HL,BC           ; Calculate pointer to data set of current tone generator
        PUSH    HL              ;! and transferred to IY
        POP     IY              ;!
        INC     HL              ; Pointer to table on repetition factor
        POP     BC              ; rescued register - fetch value
        RET
;
;
;   Note the value table (DE) for the tone generator in the Accu
;   (if Accu equals -1 --> remember for all tone generators)
;
;   (SVC code:  33)
;
PLAY:   CP      -1              ; Table for all tone generators ?
        JR      NZ,A4435        ; no --> remember new value table
        LD      A,3             ; Default tone generator number
A4428:  PUSH    AF              ; Tone generator - remember number
        PUSH    DE              ; Remember pointer to value table for tone generator
        CALL    A4435           ; Assign table values ??(DE) to the tone generator in the Accu
        POP     DE              ; Get pointer to table of values
        POP     AF              ; Tone generator - get number
        DEC     A               ; minus one
        JP      M,A445A         ; all generators processed --> initialize interrupt
        JR      A4428           ; Assign table to next tone generator
;
A4435:  PUSH    AF              ; Tone generator - remember number
        LD      HL,B4105        ; Pointer to volume value tone generator 2
        CP      3               ; noise generator ?
        JR      Z,A4441         ; Yes
        LD      A,11011111B     ; Code for 'volume tone generator 2 to OFF'
        JR      A4447           ; notice
;
A4441:  LD      A,11100111B     ; Code for 'white noise after tone generator two'
        OUT     (PSGOUT),A      ; output to tone generator
        LD      A,11111111B     ; Code for 'Noise Volume OFF'
A4447:  LD      (HL),A          ; Remember volume value for next tone
        DI                      ; Disable interrupts
        LD      A,1             ; Code for 'MUSIC'
        LD      (B40FA),A       ; as MUSIC - save status
        POP     AF              ; Tone generator - get number
        CALL    A43FC           ; Provide pointers to memory by register number
        CALL    A4468           ; notice that the tone generator is active
        CALL    A42C6           ; Process next value in table (DE).
        EI                      ; Enable interrupt
        RET
;
;
;   if MUSIC is active --> activate interrupt - modules for sound - interrupt
;
A445A:  DI                      ; Disable interrupts
        LD      A,(B40FA)       ; MUSIC - get status
        OR      A               ; Sound output active?
        CALL    NZ,MSTART       ; yes --> Initialize blocks for 'MUSIC - Interrupt'
        EI                      ; Release interrupt again
        RET
;
;
;   notify the tone generator is no longer active
;
A4464:  LD      B,RES_HL        ; Code for 'Res x,(HL)'
        JR      A446A           ; Set tone generator status to 'not active'
;
;
;   notify that the tone generator is active
;
A4468:  LD      B,SET_HL        ; Code for 'Set x,(HL)'
A446A:  LD      HL,B40FB        ; Pointers to bits of active tone generator registers
        LD      A,(IY+0)        ; Tone generator - get number
        OR      A               ; Reset carry flag
        RLCA                    ;! tone generator number to correct bits for
        RLCA                    ;! Significance in Z-80 - shift command
        RLCA                    ;!
        OR      B               ; plus code for 'Set/Res'
        LD      (D4478 + 1),A   ; Rest Z-80 - Enter command
D4478:  RLC     B               ; Execute command (Set x,(HL) / Res x,(HL))
        RET
;
;
;   stop all sound output (MUSIC STOP)
;
MLDSP:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
A447E:  XOR     A               ; Accu to zero
        LD      (B40FA),A       ; as MUSIC - save status
        LD      (B40FB),A       ; Reset active tone generator register bits
        LD      BC,256*4+PSGOUT ; four values in table / address tone generator - building block
        LD      HL,B4211        ; Table with values for switching off all tone generators
        OTIR                    ; Output values to tone generators
        LD      B,3             ; three tone generator output tables
        LD      HL,B40FF        ; Pointer to volume value for tone generator 1
A4492:  LD      A,(HL)          ; Get loudness value from output table
        AND     11110000B       ; Mask register number of tone generator
        OR      00001111B       ; plus code for 'volume off'
        LD      (HL),A          ; enter the new value in the output table again
        INC     HL              ;! Pointer to the volume value of the
        INC     HL              ;! next tone generator
        INC     HL              ;!
        DJNZ    A4492           ; remaining output - correct table values
        LD      A,00000011B     ; Code for 'Interrupt not possible'
        OUT     (PIOA_C),A      ; output to control word register Z-80 PIO channel A
        XOR     A               ; reset carry flag (code 'no error')
        RET
;
;
;   wait for old tunes to finish playing
;
A44A3:  LD      A,(B40FA)       ; MUSIC - get status
        OR      A               ; inactive ?
        RET     Z               ; yes --> done
        RST     _DOCMD          ; Software - Execute command
        DEFB    14              ; Code 14 Query whether (Shift) - BREAK is pressed
        JR      NZ,A44A3        ; not pressed --> continue to wait
        JP      BREAKZ          ; Abort the program with 'BREAK`
;
;
;   Deal with music. Status in B
;       (B = 1 -->  play value table(s) (DE)
;       (B = 2 -->  cancel sound output)
;       (B = 3 -->  wait until all melodies are played)
;       (B = 4 -->  MUSIC - initialize routines)
;
;   (SVC code:  35)
;
MCTRL:  DEC     B               ; Play MUSIC according to table (DE) ?
        JP      Z,A445A         ; yes --> process table (DE).
        DEC     B               ; MUSIC STOP?
        JR      Z,MLDSP         ; yes --> cancel all audio output
        DEC     B               ; MUSIC WAIT?
        JR      Z,A44A3         ; yes --> wait until old melodies have been played completely
;
;
;   MUSIC - initialize routines
;
A44B9:  CALL    MLDSP           ; cancel all audio output
        LD      BC,256*5+PIOA_C ; 5 values / control word register Z-80 PIO channel A
        LD      HL,PIOTBL       ; Pointer to table of values for initializing the Z-80 PIO
        OTIR                    ; Output table of values to Z-80 PIO
        LD      DE,B44ED        ; Pointer to table for initializing sound routines
        LD      A,-1            ; Code for 'all tone generators'
        JP      PLAY            ; Assign table (DE) to the tone generators
;
;
;   Initialize blocks for 'MUSIC - Interrupt'
;
MSTART: LD      HL,PIOTBL       ; Pointer to table of values for initializing the Z-80 PIO
        LD      BC,256*5+PIOA_C ; 5 values / control word register Z-80 PIO channel A
        OTIR                    ; Output table of values to Z-80 PIO
        LD      HL,CTCTBL       ; Pointer to table for initialization
        LD      B,6             ; output six values
        JP      IOOUT           ; Output table of values (HL) to ports
;
;
;   Values for initializing control word register Z - 80 - PIO channel A
;
PIOTBL: DEFB    (IV_PSG)%256    ; Low-Byte Interrupt-Vector
        DEFB    11111111B       ; Mode 3
        DEFB    00111111B       ; Bit 0 - 5 = INPUT / Bit 6 - 7 = OUTPUT
        DEFB    00010111B       ; Interrupt Control-Word (mask follows)
        DEFB    11101111B       ; 8253 interrupt mask
;
;
;   Table of values for initializing the control modules for MUSIC - Interrupt
;
CTCTBL: DEFB    00110000B       ; Counter 0/Read'Load 2 bytes/Mode 0/Binary
        DEFB    CTC_53          ; Port - address control port counter module 8253
;
        DEFB    10110000B       ; Low - byte division ratio for interrupt every 10 ms
        DEFB    CT0_53          ; Port address counter 0 in counter module 8253
;
        DEFB    00101010B       ; High - byte division ratio for interrupt every 10ms
        DEFB    CT0_53          ; Port address counter 0 in counter module 8253
;
        DEFB    00000100B       ; Code for 'Counter - interrupt allowed'
        DEFB    KEYP_F          ; Port address control module input/output module 8255
;
        DEFB    00000000B       ; Code for 'lock sound - issue 8253'
        DEFB    KEYP_F          ; Port address control module input/output module 8255
;
        DEFB    10000011B       ; Code for 'interrupt possible'
        DEFB    PIOA_C          ; Port - address control word register Z-80 PIO channel A
;
;
;   Table for initializing the tone generator routines
;
B44ED:  DEFB    065H            ; Code for 'tone length 5'
        DEFB    06DH            ; Code for 'tempo 4'
        DEFB    098H            ; Code for 'waveform 8'
        DEFB    0A0H            ; Code for 'repetition factor'
        DEFB    255             ;        'repetition factor'
        DEFB    -1              ; 'End of table'
;
;
;   Output reference tone      (SVC code:  32)
;
CTRLG:  CALL    PUSHR           ;  Save registers IX, HL, BC and DE
        RST     _DOCMD          ;  Software - Execute command
        DEFB    16              ;  Command 16 disable interrupt
        LD      HL,B4514        ;  Pointer to table for initializing reference tone
        LD      B,4             ;  four values in table
        CALL    IOOUT           ;  Output table of values (HL) to ports
        LD      BC,24           ;! Time loop approx. 55 msec
A4503:  EX      (SP),HL         ;! 19 clock cycles
        DJNZ    A4503           ;! 13"
        DEC     C               ;! 4"
        JR      NZ,A4503        ;! 12"
        LD      HL,B451C        ;  Pointer to table for switching off reference tone
        LD      B,2             ;  two values in table
        CALL    IOOUT           ;  Output table of values (HL) to ports
        RST     _DOCMD          ;  Software - Execute command
        DEFB    17              ;  Code 17 enable interrupt
        RET
;
;
;   Table for initializing the reference tone according to the MZ-80 K mode
;
B4514:  DEFB    00110110B       ; Counter 0/Read'Load 2 Bytes/Mode 3/Binary
        DEFB    CTC_53          ; Port - address control port counter module 8253
;
        DEFB    00000001B       ; Code for 'sound - output 8253 allowed'
        DEFB    KEYP_F          ; Port address control port input/output module 8255
;
        DEFB    11111001B       ; Low - byte division ratio for sound
        DEFB    CT0_53          ; Port address counter 0 in counter module 8253
;
        DEFB    00000011B       ; High - byte division ratio for sound
        DEFB    CT0_53          ; Port address counter 0 in counter module 8253
;
;
;    Table for switching off the reference tone
;
B451C:  DEFB    00110110B       ; Counter 0/Read'Load 2 Bytes/Mode 3/Binary
        DEFB    CTC_53          ; Port - address control port counter module 8253
;
        DEFB    00000000B       ; Code for 'lock sound - issue 8253'
        DEFB    KEYP_F          ; Port address control port input/output module 8255
;
;
;   Set tempo according to value in Accu
;
_TEMP:  CALL    PUSHRA          ; Save registers IX, HL, BC, DE and AF
        LD      DE,T4538        ; Pointer to space for tempo code
        AND     00001111B       ; Mask tempo value
        ADD     A,069H          ; convert to tempo code
        LD      (DE),A          ; Enter speed code
        LD      B,3             ; Code 'wait for old tune to end'
        RST     _DOCMD          ; Software - Execute command
        DEFB    35              ; Code 35 Treat MUSIC by status in B
        LD      A,-1            ; Code 'Values for all tone generators'
        RST     _DOCMD          ; Software - Execute command
        DEFB    33              ; Assign code 33 value table (DE) to the tone generators
        LD      B,1             ; code 'play melody'
        RST     _DOCMD          ; Software - Execute command
        DEFB    35              ; Code 35 Treat MUSIC by status in B
        RET
;
T4538:  DEFS    1               ; Space for speed code
        DEFB    -1              ; end of table

;   Initialize device screen ("CRT:")
;
A453A:  CALL    TEST1           ; Comparison on byte after CALL call
        DEFM    "M"             ; M (MODE) ?
        JR      Z,A4561         ; yes --> Set screen mode
        OR      A               ; end of table ?
        JR      Z,ICRT          ; yes --> no values specified --> initialize with old values
        CP      'B'             ; B (BLOCK) ?
        JP      NZ,A1F7F        ; no --> Error 3 Illegal data error
        XOR     A               ; Accu to zero
        LD      (S137E),A       ; Reset palette block number
        LD      A,(S137A)       ; Screen - Mode - Get number
        CP      2               ; Mode 2 (320 x 200 dots / 16 colors) ?
        JP      NZ,A1FBB        ; no --> Error 68 Dev. mode error
        INC     HL              ; Skip command letters
        LD      B,3 + 1         ; Specify maximum pallet block number
        CALL    DEVASC          ; Convert ASCII value (HL) to hex/compare with upper limit in B
        LD      (S137E),A       ; Remember palette block number
        RST     _DOCMD          ; Software - Execute command
        DEFB    81              ; Code 81 Remember pallet block number/output to controller
        JR      A4581           ; examine whether additional values are specified
;
;
;   neuen Bildschirm - Modus bestimmen
;
A4561:  LD      B,4 + 1         ; maximale Bildschirm - Modus - Nummer vorgeben
        CALL    DEVASC          ; ASCII-Wert (HL) umsetzen in Hex/mit Obergrenze in B vergleichen
        OR      A               ; gleich Null  ?
        JR      Z,A458B         ; ja -->  Fehler 3  Illegal data error
        LD      B,A             ; Modus - Nummer merken
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    80              ; Code 80   Bildschirm - Betriebsart setzen
        JP      C,A1FBB         ; Fehler aufgetreten -->  Fehler 68   Dev. mode error
        LD      A,B             ; Modus - Nummer holen
        LD      (S137A),A       ; Bildschirm - Modus - Nummer merken
        XOR     A               ; Accu auf Null
        LD      (INPFLG),A      ; Parallelausgabeflag Drucker zurücksetzen
        SCF                     ;! Bit nach Bildschirm - Modus - Nummer
A4578:  ADC     A,A             ;! setzen
        DJNZ    A4578           ;!
        LD      (S1379),A       ; Bildschirm - Modus - Bit merken
        CALL    A4593           ; maximalen Palettenwert/aktuelle Farbebenen merken
A4581:  CALL    TEST1           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFB    NUL             ; Textendezeichen  ?
        RET     Z               ; ja -->  fertig
        CP      ','             ; Komma als Trennzeichen  ?
        INC     HL              ; Trennzeichen überspringen
        JR      Z,A453A         ; weitere Parameter bein Initialisierung auswerten
A458B:  JP      A1F7F           ; Fehler 3  Illegal data error
;
;
;   Bildschirm initialisieren     (SVC code:  86)
;
ICRT:   LD      A,(S137A)       ; Bildschirm - Modus - Nummer holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    80              ; Code 80   Bildschirm - Betriebsart setzen
;
;
;   maximalen Palettenwert und aktuelle Farbebenen merken
;
A4593:  CALL    A459D           ; maximalen Palettenwert/aktuelle Farbebenen setzen
        XOR     A               ; Accu auf Null
        LD      (S137E),A       ; Palettenblocknummer zurücksetzen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    81              ; Code 81   Palettenblock-Nummer merken/an Controller ausgeben
        RET
;
;
;   maximalen Palettenwert bereitstellen und aktuelle benutze Farbebenen setzen
;
A459D:  LD      A,(S1379)       ; Bildschirm - Modus - Bit holen
        LD      B,3             ; Palettenwert 0 - 3 erlaubt
        RRA                     ; ein Bit nach Carry schieben
        JR      C,A45B1         ; Modus eins -->  maximalen Palettenwert merken
        LD      B,15            ; Palettenwert 0 - 15 erlaubt
        RRA                     ; ein Bit nach Carry schieben
        JR      C,A45B1         ; Modus zwei -->  maximalen Palettenwert merken
        LD      B,1             ; Palettenwert 0 und 1 erlaubt
        RRA                     ; ein Bit nach Carry schieben
        JR      C,A45B1         ; Modus drei -->  maximalen Palettenwert merken
        LD      B,3             ; Palettenwert 0 - 3 erlaubt
A45B1:  LD      A,B             ; maximalen Palettenwert holen
        LD      (S137B),A       ; und merken
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    84              ; Code 84  aktuell benutze Farbebenen merken
        RET
;
;
;   Tabelle zum Setzen der rechten Punkte im Graphic - Byte nach Bit - Nummer
;
B45B8:  DEFB    11111111B       ; Pattern for  Bit  0
        DEFB    11111110B       ; Pattern for  Bit  1
        DEFB    11111100B       ; Pattern for  Bit  2
        DEFB    11111000B       ; Pattern for  Bit  3
        DEFB    11110000B       ; Pattern for  Bit  4
        DEFB    11100000B       ; Pattern for  Bit  5
        DEFB    11000000B       ; Pattern for  Bit  6
        DEFB    10000000B       ; Pattern for  Bit  7
;
;
;   Tabelle zum Setzen der linken Punkte im Graphic - Byte nach Bit - Nummer
;
B45C0:  DEFB    00000001B       ; Pattern for  Bit  0
        DEFB    00000011B       ; Pattern for  Bit  1
        DEFB    00000111B       ; Pattern for  Bit  2
        DEFB    00001111B       ; Pattern for  Bit  3
        DEFB    00011111B       ; Pattern for  Bit  4
        DEFB    00111111B       ; Pattern for  Bit  5
        DEFB    01111111B       ; Pattern for  Bit  6
        DEFB    11111111B       ; Pattern for  Bit  7
;
;
;   Tabelle mit Vorgabe für Bit nach Bit - Nummer
;
B45C8:  DEFB    00000001B       ; Pattern for  Bit  0
        DEFB    00000010B       ; Pattern for  Bit  1
        DEFB    00000100B       ; Pattern for  Bit  2
        DEFB    00001000B       ; Pattern for  Bit  3
        DEFB    00010000B       ; Pattern for  Bit  4
        DEFB    00100000B       ; Pattern for  Bit  5
        DEFB    01000000B       ; Pattern for  Bit  6
        DEFB    10000000B       ; Pattern for  Bit  7
;
;
;   Graphic - Routinen auf 320 x 200 oder 640 x 200 Bildpunkte umstellen
;
A45D0:  LD      BC,256 * 7 + 3  ; 7 zwei - Byte - Werte  /  3 ein - Byte - Werte
        LD      HL,W45D9        ; Zeiger auf Tabelle mit zu ändernden Werten
        JP      A0531           ; Programm entsprechend Tabelle (HL) umstellen
;
;
;   Tabelle zum Umsetllen der Graphic - Routine auf Bildschirm -
;   Ausgabe mit 320 x 200 oder 640 x 200  Bildpunkten
;
W45D9:  DEFW    A4EC7 + 1       ; Adresse
        DEFW    BITBUF + 16000  ; Wert für 80 Zeichen je Zeile
        DEFW    BITBUF +  8000  ; Wert für 40 Zeichen je Zeile
;
        DEFW    A46C4 + 1       ; Adresse
        DEFW    -640            ; Wert für 80 Zeichen je Zeile
        DEFW    -320            ; Wert für 40 Zeichen je Zeile
;
        DEFW    A542F + 1       ; Adresse
        DEFW    640             ; Wert für 80 Zeichen je Zeile
        DEFW    320             ; Wert für 40 Zeichen je Zeile
;
        DEFW    A4CC0 + 1       ; Adresse
        DEFW    80              ; Wert für 80 Zeichen je Zeile
        DEFW    40              ; Wert für 40 Zeichen je Zeile
;
        DEFW    A4CD3 + 1       ; Adresse
        DEFW    80              ; Wert für 80 Zeichen je Zeile
        DEFW    40              ; Wert für 40 Zeichen je Zeile
;
        DEFW    A4CFB + 1       ; Adresse
        DEFW    -640            ; Wert für 80 Zeichen je Zeile
        DEFW    -320            ; Wert für 40 Zeichen je Zeile
;
        DEFW    A4D02 + 1       ; Adresse
        DEFW    640 - 1         ; Wert für 80 Zeichen je Zeile
        DEFW    320 - 1         ; Wert für 40 Zeichen je Zeile
;
        DEFW    ADCH            ; Adresse
        DEFB    ADD_HL          ; Wert für 80 Zeichen je Zeile
        DEFB    _NOP            ; Wert für 40 Zeichen je Zeile
;
        DEFW    A4E22 + 1       ; Adresse
        DEFB    80              ; Wert für 80 Zeichen je Zeile
        DEFB    40              ; Wert für 40 Zeichen je Zeile
;
        DEFW    A4EBD + 1       ; Adresse
        DEFB    80              ; Wert für 80 Zeichen je Zeile
        DEFB    40              ; Wert für 40 Zeichen je Zeile
;
;
;   absolute Graphic - Speicheradresse und Bitnummer des Bildpunktes aus
;   X- und Y - Koordinaten in DE,HL errechnen
;
ADCH:   ADD     HL,HL           ; Y-Koordinate mal 2, wenn im 640 x 200 Modus (oder NOP)
        LD      A,E             ; Low - Byte  X - Koordinate
        AND     00000111B       ; Bits für Bitnummer  (0 - 7)  maskieren
        LD      B,A             ; Bitnummer merken
        LD      A,E             ; Low - Byte  X - Koordinate holen
        AND     11111000B       ; für Adresse relevante Bits maskieren
        ADD     A,D             ; plus High - Byte  X - Koordinate
        RRCA                    ;! Bits auf richtige Wertigkeit für Graphic -
        RRCA                    ;! Byte schieben   (X - Koordinate durch 8)
        RRCA                    ;!
        LD      C,A             ; Offset aus X - Koordinate merken
        LD      A,B             ; Bitnummer holen
        LD      B,BITBUF/256    ; High - Byte Anfangsadresse Graphic - Speicher vorgeben
        LD      D,H             ;! Y - Koordinate duplizieren
        LD      E,L             ;!
        ADD     HL,HL           ; mal  2
        ADD     HL,HL           ; mal  4
        ADD     HL,DE           ; mal  5
        ADD     HL,HL           ; mal 10
        ADD     HL,HL           ; mal 20
        ADD     HL,HL           ; mal 40
        ADD     HL,BC           ; plus Anfangsadresse und X - Offset
        RET
;
;
;   Abfrage, ob Punkt in einer der Farbebenen gesetzt ist
;   (Koordinaten des Punktes in DE,HL)
;
;   (SVC code:  78)
;
WPOINT: CALL    RNGCK           ; überprüfen, ob Koordinaten in DE,HL im angezeigten Bereich
        JP      C,A479B         ; nein -->  Code 'Fehler aufgetreten' vorgeben und Abbruch
        CALL    ADCH            ; absolute Graphic-Adresse und Bitnr. aus Koordinaten errechnen
        RLCA                    ;! Bit - Nummer auf richtige Wertigkeit
        RLCA                    ;! für Bit - Nummer schieben
        RLCA                    ;!
        OR      046H            ; plus Code for 'Bit x,(HL)'
        LD      (D464B + 1),A   ; Rest  Z-80 - Befehl in Routine eintragen
        LD      C,CRTCRF        ; Port-Nummer des 'Read-Format-Registers' des Bildschirm-Controllers
        LD      A,(MAXCF)       ; maximalen Palettenwert holen
        LD      B,A             ; als Zähler für zu testende Ebenen merken
        DI                      ; Interrupt sperren
        IN      A,(_CGVIN)      ; ZeichensatzROM und Video-RAM einschalten
        XOR     A               ; Vorgabe für Ergebniswert
A4644:  RR      B               ; Palettenwert durch zwei
        JR      C,A4653         ; Carry-Flag gesetzt -->  alle Farb-Ebenen getestet
        OUT     (C),B           ; Farbebene an Bildschirm - Controller ausgeben
        OR      A               ; Carry - Flag zurücksetzen   (Code for 'kein Fehler')
D464B:  BIT     0,(HL)          ; Abfrage, ob Punkt in Farbebene gesetzt ist
        JR      Z,A4650         ; Punkt ist nicht gesetzt
        SCF                     ; Code for 'Punkt ist gesetzt'
A4650:  RLA                     ; Ergebnis einer Farbebene merken
        JR      A4644           ; weitere Farbebenen testen
;
A4653:  LD      B,A             ; Ergebnis merken
        IN      A,(_CGVOT)      ; ZeichensatzROM und Video-RAM ausschalten
        EI                      ; Interrupt wieder freigeben
        LD      A,(CPLANE)      ; Vorgabe für benutzte Farbebenen holen
        AND     B               ; gesetzte Punkte in aktuellen Farbebenen maskieren
        LD      B,A             ; Punktwert merken
        LD      A,(DMD)         ; Wert für 'Display-Mode-Register' des Bildschirm-Controllers
        CP      00000110B       ; 640 x 200 Bildpunkte / einfarbig  ?
        LD      A,B             ; Punktwert holen
        RET     NZ              ; anderer Modus
        CP      4               ; Punkte in Bildschirm zwei gesetzt  ?
        RET     C               ; nein -->  Wert ist OK
        SUB     2               ; für Punkte in Bildschirm eins corrigieren
        RET
;
;
;   Write - Format - Register für  'Punkt setzen'  initialisieren
;
A4669:  LD      A,-1            ; Code for 'Punkt setzen'
;
;
;   Write - Format - Register nach Status im Accu setzen
;
A466B:  PUSH    BC              ; Keep register value
        OR      A               ; Punkt setzen oder zurücksetzen  ?
        LD      A,(GMODE)       ; aktuellen Graphic - Palettenwert holen
        LD      C,A             ; aktuellen Graphic - Plettenwert merken
        LD      A,(PWMODE)      ; aktuellen Überschreib - Modus holen
        JR      Z,A4682         ; Punkt zurücksetzen
        OR      A               ; Überschreiben oder Farben verknüpfen  ?
        LD      A,11000000B     ; Code for 'PSET'   (Punkt in Farbe setzen)
        JR      Z,A467D         ; Überschreiben
        LD      A,01000000B     ; Code for 'OR'     (neuen Farbwert mit altem Farbwert verknüpfen)
A467D:  OR      C               ; Kommandowert plus Farbwert
        OUT     (CRTCWF),A      ; an 'Write-Format-Register' Bildschirm-Controller ausgeben
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Write - Format - Register für 'Punkt zurücksetzen' setzen
;
A4682:  OR      A               ; Überschreiben oder Farben verknüpfen  ?
        LD      A,01100000B     ; Code for 'RESET'   (Punkt zurücksetzen)
        JR      NZ,A467D        ; Überschreibmodus  'Oder'
        LD      A,(CPLANE)      ; Vorgabe für benutzte Farbebenen holen
        LD      B,A             ; Farbebenen merken
        LD      A,C             ; aktuellen Graphic - Farbwert holen
        CPL                     ; Bits umkehren
        AND     B               ; benutzte Graphic - Farbebenen maskieren
        OR      11000000B       ; Code for 'PSET'   (Punkt in Farbe setzen)
        OUT     (CRTCWF),A      ; an 'Write-Format-Register' Bildschirm-Controller ausgeben
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Punkt mit Koordinaten in DE,HL setzen oder zurücksetzen
;
;   (SVC code:  72)
;
PSET:   CALL    A466B           ; Write - Format - Register nach Status im Accu setzen
A4697:  CALL    RNGCK           ; überprüfen, ob Koordinaten in DE,HL im angezeigten Bereich
        JP      C,A479B         ; nein -->  Code 'Fehler aufgetreten' vorgeben und Abbruch
        CALL    ADCH            ; absolute Graphic-Adresse und Bitnr. aus Koordinaten errechnen
        EX      DE,HL           ; Graphic - Speicher - Adresse nach DE
        LD      HL,B45C8        ; Zeiger auf Tabelle mit Vorgabe für Bit nach Bit-Nummer
        LD      B,0             ; High - Byte Offset auf Null
        LD      C,A             ; Bit - Nummer als Low - Byte Offset
        ADD     HL,BC           ; Zeiger auf Bitmuster errechnen
        DI                      ; Interrupt sperren
        IN      A,(_CGVIN)      ; ZeichensatzROM und Video-RAM einschalten
        LDI                     ; Bit pattern for  Punkt an Bildschirm - Controller ausgeben
        IN      A,(_CGVOT)      ; ZeichensatzROM und Video-RAM ausschalten
        EI                      ; Interrupt wieder freigeben
        XOR     A               ; Carry - Flag zurücksetzen   (Code for 'kein Fehler')
        RET
;
;
;   überprüfen, ob Koordinaten in DE,HL im angezeigten Graphic - Bereich liegen
;   (Carry - Flag ist gesetzt, wenn die Koordinaten nicht im angezeigten Bereich)
;
RNGCK:  PUSH    BC              ; Keep register value
        PUSH    DE              ; X - Koordinate des Punktes
        PUSH    HL              ; Y - Koordinate des Punktes
        LD      A,H             ; High - Byte Y - Koordinate holen
        RLCA                    ; Koordinate negativ  ?
        JR      C,A46C8         ; ja -->  liegt nicht im angezeigten Bereich
        LD      BC,-200         ; maximale Y - Koordinate vorgeben  (Komplement)
        ADD     HL,BC           ; Y - Koordinate im angezeigten Bereich  ?
        JR      C,A46C8         ; nein
        LD      A,D             ; High - Byte X - Koordinate holen
        RLCA                    ; Koordinate negativ  ?
        JR      C,A46C8         ; ja -->  liegt nicht im angezeigten Bereich
        EX      DE,HL           ; X - Koordinate nach HL
A46C4:  LD      BC,-640         ; maximale X - Koodinate vorgeben  (-320/-640)
        ADD     HL,BC           ; X - Koordinate im angezeigten Bereich  ?
A46C8:  POP     HL              ;! gerettete Register - Werte wieder holen
        POP     DE              ;!
        POP     BC              ;!
        RET
;
;
;   Linie von Koordinate in DE`,HL' nach Koordinate in DE,HL ziehen
;
A46CC:  LD      A,-1            ; Code for 'Linie ziehen'
;
;
;   Linie ziehen oder zurücksetzen
;   (DE' = X - Koordinate Anfang / HL' = Y - Koordinate Anfang)
;   (DE  = X - Koordinate Ende   / HL  = Y - Koordinate Ende  )
;
;     (SVC code:  73)
;
WLINE:  CALL    A466B           ; Write - Format - Register nach Status im Accu setzen
        PUSH    DE              ; X - Koordinate Endpunkt
        PUSH    HL              ; Y - Koordinate Endpunkt
        EXX
        LD      (S11A4),DE      ; X - Koordinate Anfangspunkt
        LD      (S11A9),HL      ; Y - Koordinate Anfangspunkt
        EXX
        PUSH    HL              ; Y - Koordinate Endpunkt
        PUSH    DE              ; X - Koordinate Endpunkt
        EX      DE,HL           ; Y - Koordiante Endpunkt nach DE
        LD      HL,(S11A9)      ; Y - Koordinate Anfangspunkt holen
        CALL    A478B           ; Koordinaten in DE und HL vergleichen
        LD      (S11AD),A       ; Flag  Y - Koordinate Endpunkt kleiner  (<>0)
        LD      (S11AB),HL      ; Y - Koordinaten - Differenz merken
        POP     DE              ; X - Koordinate Endpunkt holen
        JP      NC,A4778        ; Y - Koordinaten sind gleich
        PUSH    HL              ; Y - Koordinatendifferenz merken
        LD      HL,(S11A4)      ; Y - Koordinate Anfangspunt holen
        CALL    A478B           ; Koordinaten in DE und HL vergleichen
        LD      (S11A8),A       ; Flag  X - Koordinate Endpunkt kleiner  (<>0)
        LD      (S11A6),HL      ; X - Koordinatendifferent merken
        POP     BC              ; Y - Koordinatendifferenz holen
        POP     DE              ; Y - Koordinate Endpunkt holen
        JP      NC,A4784        ; X - Koordinaten sind gleich
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; untersuchen, welche Koordinate größer ist
        JR      NC,A4719        ; X-Koordinatendifferenz größer --> X-Koordinate als Zähler
        LD      HL,S11A4        ; Zeiger auf  X - Koordinaten - Datensatz
        LD      DE,S11A9        ; Zeiger auf  Y - Koordinaten - Datensatz
        LD      B,5             ; Anzahl Bytes je Datensatz
A470E:  LD      A,(DE)          ;! X -  und Y - Koordinatensatensatz vertauschen
        LD      C,(HL)          ;!
        LD      (HL),A          ;!
        LD      A,C             ;!
        LD      (DE),A          ;!
        INC     HL              ;!
        INC     DE              ;!
        DJNZ    A470E           ;!     weitere Dsatenbytes vertauschen
        LD      A,EX_DE         ; Z-80 Befehl EX DE,HL  um Koordinaten zu vertauschen
A4719:  LD      (A4753),A       ;! EX DE,HL oder NOP in Routine eintragen
        LD      (D475D),A       ;
        LD      A,(S11AD)       ; Flag  'Endpunkt zweite Koordinate kleiner'  holen
        AND     A               ; Endpunkt kleiner  ?
        LD      A,INC_HL        ; INC HL   (Z-80 - Befehl)
        JR      Z,A4729         ; Endpunkt größer -->  hochzählen
        LD      A,DEC_HL        ; DEC HL   (Z-80 - Befehl)
A4729:  LD      (D476F),A       ; Wert für zweite Koordinate eintragen
        LD      A,(S11A8)       ; Flag  'Endpunkt erste Koordinate kleiner'  holen
        AND     A               ; Endpunkt kleiner
        LD      A,INC_DE        ; INC DE   (Z-80 - Befehl)
        JR      Z,A4736         ; Endpunkt größer -->  hochzählen
        LD      A,DEC_DE        ; DEC DE   (Z-80 - Befehl)
A4736:  LD      (D4763),A       ; Wert für erste Koordinate in Routine eintragen
        EXX
        LD      HL,(S11A6)      ; erste Koordinaten - Differenz holen
        LD      D,H             ;! nach DE duplizieren
        LD      E,L             ;!
        SRL     H               ;! durch zwei als Vorgabe für Zähler
        RR      L               ;! für zweite Koordinate
        LD      BC,(S11AB)      ; zweite Koordinatendifferenz holen
        EXX
        LD      HL,(S11A9)      ; zweite Koordinate Anfangspunkt holen
        LD      DE,(S11A4)      ; erste Koordinate Anfangspunkt holen
        LD      BC,(S11A6)      ; erste Koordinatendifferenz holen
A4753:  EX      DE,HL           ; oder NOP, wenn X - Koordinate der Zähler ist
        PUSH    HL              ; aktuelle Y - Koordinate retten
        PUSH    DE              ; aktuelle X - Koordinate retten
        PUSH    BC              ; erste Koordinatendifferenz merken
        CALL    A4697           ; Punkt nach Koordinaten setzen oder zurücksetzen
        POP     BC              ; erste Koordinatendifferenz holen
        POP     DE              ; gerettete X - Koordinate holen
        POP     HL              ; gerettete Y - Koordinate holen
D475D:  EX      DE,HL           ; oder NOP, wenn X - Koordinate der Zähler ist
        DEC     BC              ; Zähler minus eins
        LD      A,B             ;! fertig  ?
        INC     A               ;!
        JR      Z,A4773         ; ja -->  gerettete Koordinate des Endpunktes holen
D4763:  NOP                     ; erste Koordinate für nächsten Punkt ändern (INC/DEC DE)
        EXX
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; testen, ob Koordinate geändert werden muß
        EXX
        JP      NC,A4753        ; nein -->  nächsten Punkt zeichnen
        EXX
        ADD     HL,DE           ; Offsetzähler plus Koordinatendiffernz
        EXX
D476F:  NOP                     ; zweite Koordinate für nächsten Punkt ändern  (INC/DEC HL)
        JP      A4753           ; nächsten Punkt zeichnen
;
A4773:  EXX
        POP     HL              ; Y-Koordinate des Endpunktes als aktuelle Graphic-Koordinate
        POP     DE              ; X-Koordinate des Endpunktes als aktuelle Graphic-Koordinate
        EXX
        RET
;
;
;   Y - Koordinaten sind gleich
;
A4778:  POP     HL              ; Y - Koordinate Anfangspunkt holen
A4779:  CALL    A4C16           ; X mit Y-Koord. in DE,HL , DE',HL' tauschen/Y-Max nach HL
        CALL    A4C16           ; X mit Y-Koord. in DE,HL , DE',HL' tauschen/Y-Max nach HL
        CALL    A4C47           ; Linie parallel zu einer Koordinatenachse zeichnen
        JR      A4773           ; gerettete Endpunktkoordinaten holen
;
;
;   X - Koordinaten sind gleich
;
A4784:  EX      DE,HL           ; Y - Koordinate Anfangspunkt nach HL
        LD      DE,(S11A4)      ; X - Koordinate Endpunkt holen
        JR      A4779           ; Linie parallel zur Y - Achse zeichnen
;
;
;   Koordinaten in DE und HL vergleichen   (DE = Anfangspunkt / HL = Endpunkt)
;   (Zero -->  Koordinaten gleich / Accu = 0 und Carry -->  Anfangspunkt größer)
;
A478B:  LD      A,H             ; High - Byte der Koordinate holen
        ADD     A,040H          ; auf jeden Fall umrechnen in positive Koordinate
        LD      H,A             ; Ergebnis merken
        LD      A,D             ; High - Byte der Koordinate holen
        ADD     A,040H          ; auf jeden Fall umrechnen in positive Koordinate
        LD      D,A             ; Ergebnis merken
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Koordinaten in HL und DE vergleichen
        JR      C,A479F         ; Koordinate in DE ist größer
        LD      A,H             ;! Differenz gleich Null  ?
        OR      L               ;!
        RET     Z               ; ja
A479B:  LD      A,-1            ; Code for 'Koordinate in HL ist größer'
        SCF                     ; Code for 'Differenz in Koordinaten'  setzen
        RET
;
A479F:  OR      A               ; Carry - Flag zurücksetzen
        EX      DE,HL           ; negative Differenz nach DE
        LD      HL,0            ;! positive Differenz errechnen
        SBC     HL,DE           ;!
        XOR     A               ; Code for 'Koordinate in DE ist größer'
        SCF                     ; Code for 'Differenz in Koordinaten'  setzen
        RET
;
;
;   Linie vom Anfangspunkt über Mittelpunkt zum Endpunkt des Kreises
;   oder der Ellipse zeichnen
;
A47A9:  CALL    A47BA           ; absolute Kreis- (Ellipsen-)koordinaten aus Kreisoffset
        LD      HL,(POINTX)     ; X - Koordinate Graphic - Cursor holen
        PUSH    HL              ; X - Koordinate Mittelpunkt ablegen
        PUSH    BC              ; Y - Koordinate Mittelpunkt ablegen
        EXX
        CALL    A47BA           ; absolute Kreis- (Ellipsen-)koordinaten aus Kreisoffset
        LD      B,2             ; zwei Linien zeichnen
        JP      A4C08           ; bereitgestellte Koordinaten mit Linine verbinden
;
;
;   absolute Kreis- (Ellipsen-)koordinaten aus Kreisoffset errechnen
;
A47BA:  POP     IX              ; Rücksprungadresse vom Stack holen
        EX      DE,HL           ; X - Offset nach HL
        CP      2               ; Radius gleich Y - Radius  ?
        CALL    Z,A47D6         ; ja -->  Offset für Ellipse corrigieren
        LD      BC,(POINTX)     ; X - Koordinate Graphic - Cursor holen
        ADD     HL,BC           ; absolute Koordinate errechnen
        PUSH    HL              ; und auf Stack merken
        EX      DE,HL           ; Y - Offset nach HL
        CP      1               ; Radius gleich X - Radius  ?
        CALL    Z,A47D6         ; ja -->  Offset für ellipse corrigieren
        LD      BC,(POINTY)     ; Y - Koordinate Graphic - Cursor holen
        ADD     HL,BC           ; absolute Koordinate errechnen
        PUSH    HL              ; und auf Stack ablegen
        JP      (IX)            ; Rücksprung auf aufrufendes Programmstück
;
;
;   Offset für Ellipse corrigieren   (wenn Offset negativ -->  erst Vorzeichen umkehren)
;
A47D6:  BIT     7,H             ; Wert positiv  ?
        JP      Z,A4BA7         ; ja -->  Offset für Ellipse corrigieren
        CALL    A47E1           ; Vorzeichen des Integer - Wertes in HL umkehren
        CALL    A4BA7           ; Offset für Ellipse corrigieren
A47E1:  EX      AF,AF           ; Keep register value
        CALL    A4B80           ; Vorzeichen des Integer - Wertes in HL umkehren
        EX      AF,AF           ; geretteten Register - Wert holen
        RET
;
;
;   Kreis (-ausschnitt)  zeichnen     (DE  = X - Offset Endpunkt   / HL  = Y - Offset Endpunkt)
;    (DE' = X - Offset Startpunkt / HL' = Y - Offset Startpunkt)
;    (B'  = Radius - Verhältnis   / C'  = Aspekt - Flag)
;    (IX = Radius / A = Winkelflag)
;
;   (SVC code:   77)
;
WCIRCL: PUSH    AF              ; Winkelflag merken
        CALL    A4669           ; Write-Format-Register für 'Punkt setzen' setzen
        POP     AF              ; Winkelflag holen
        PUSH    AF              ; und wieder merken
        LD      (A4873 + 1),IX  ; Radius in Routine eintragen
        LD      (S11C7),DE      ; X - Offset auf Endpunkt merken
        LD      (S11C9),HL      ; Y - Offset auf Endpunkt merken
        EXX
        LD      (S11D3),BC      ; Aspekt - Flag und Verhältnis merken
        LD      (S11C3),DE      ; X - Offset auf Anfangspunkt merken
        LD      (S11C5),HL      ; Y - Offset auf Anfangspunkt merken
        LD      A,C             ; Aspekt - Flag holen
        CALL    C,A47A9         ; Torte -->  Linie vom Anfangs- über Mittel- zum Endpunkt
        LD      HL,(S11C3)      ; X - Offset auf Anfangspunkt holen
        LD      DE,(S11C5)      ; Y - Offset auf Anfangspunkt holen
        CALL    A4B44           ; Octantenflag aus Koordinatenoffset bereitstellen
        LD      (S11AE),A       ; Octantenflag des Anfangspunktes merken
        LD      HL,(S11C7)      ; X - Offset auf Endpunkt holen
        LD      DE,(S11C9)      ; Y - Offset auf Endpunkt holen
        CALL    A4B44           ; Octantenflag aus Koordinatenoffset bereitstellen
        LD      (S11AF),A       ; Octantenflag des Endpunktes merken
        LD      HL,S11BA        ; Zeiger auf Octantentabelle vorgeben
        LD      B,8             ; acht 45 Grad - Winkelteile im Vollkreis
        CALL    CLRHL           ; Speicherbereich (HL) löschen
        LD      HL,S11AE        ; Zeiger auf Octantenflag des Anfangspunktes
        POP     AF              ; Winkelflag holen
        LD      B,A             ; und merken
        AND     00001111B       ; Anzahl Pi - Winkel maskieren
        JR      Z,A4858         ; Startwinkel gleich Endwinkel
        CP      3               ; zu zeichnender Winkel größer als 2 x Pi  ?
        JR      Z,A4843         ; ja -->  Vollkreis (-ellipse)  zeichnen
        LD      A,(HL)          ; Octantenflag des Anfangspunktes holen
        INC     HL              ; Zeiger auf Octantenflag des Endpunktes
        CP      (HL)            ; Octantenflags Anfangs- und Endpunkt vergleichen
        JR      NZ,A4858        ; kein Vollkreis -->  Octantenflag der zu zeichnenden Octanten
        LD      A,B             ; Winkelflag holen
        CP      081H            ; - Pi  <  Startwinkel - Endwinkel  <  0  ?
        JR      Z,A4858         ; Octantenflags für Teilkreis  (-ellipse) setzen
        JR      A4848
;
;
;   Vollkreis oder Vollellipse zeichnen
;
A4843:  LD      A,9             ; Code for 'Vollkreis'
        LD      (HL),A          ; als Octantenflag des Anfangspunktes eintragen
        INC     HL              ; Zeiger auf Octantenflag des Endpunktes
        LD      (HL),A          ; als Octantenflag des Endpunktes eintragen
A4848:  LD      B,8             ; acht 45 Grad - Stücke
        LD      HL,S11BA        ; Zeiger auf Octantentabelle
        INC     A
        CALL    SETHL           ; Speicherbereich (HL) mit Konstante im Acc belegen
        LD      A,OR_B          ; Wert für 'Punkt auf jeden Fall setzen'
        CALL    A4BD0           ; Routine umstellen
        JR      A4873           ; alle Punkte ausrechnen und setzen
;
;
;   Octantenflags für Teilkreis oder Teilellipse setzen
;
A4858:  LD      A,AND_B         ; Code for 'testen, ob Punkt gesetzt werden muß'
        CALL    A4BD0           ; Routine umstellen
        LD      D,0             ; High - Byte Offset auf Null
        LD      HL,(S11AE)      ; Octantenflag des Anfangspunktes/Endpunktes
        LD      B,H             ; Octantenflag des Endpunktes holen
        LD      A,L             ; Octantenflag des Anfangspunktes holen
A4864:  LD      HL,S11BA - 1    ; Zeiger auf Octantenbytes vorgeben
        LD      E,A             ; aktuelles Octantenflag als Low - Byte Offset
        ADD     HL,DE           ; Zeiger auf Octantenbyte errechnen
        LD      (HL),1          ; Code for 'Punkt im Octanten setzen'  eintragen
        CP      B               ; aktueller Zähler gleich Octantenflag Endpunkt  ?
        JR      Z,A4873         ; ja -->  Punkte errechnen und setzen
        AND     00000111B       ; Octantenflag von 1 bis 8
        INC     A               ; Octantenflag plus eins
        JR      A4864           ; weitere Octanten mit zu setzenden Punkten markieren
;
;
;   alle Punkte für CIRCLE - Befehl errechnen und setzen
;
A4873:  LD      HL,0            ; Kreis - (Ellipse-) Radius   (wird eingetragen)
        LD      (S11A6),HL      ; als Radius - Offsetzähler merken
        LD      (S11A8),HL      ; als Durchlaufzähler merken
        LD      HL,1
        LD      (S11A4),HL
        LD      (S11AA),HL
A4885:  LD      HL,(S11A6)      ; Radius - Offsetzähler holen
        LD      DE,(S11A4)
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE
        LD      (S11A6),HL      ; neuen Radius - Offsetzähler merken
        LD      HL,(S11AA)
        DEC     HL
        LD      (S11AC),HL
        LD      A,(S11D3)       ; Aspekt - Flag holen
        OR      A               ; Kreis  ?
        LD      D,H             ;! Wert nach DE duplizieren
        LD      E,L             ;!
        CALL    NZ,A4BA7        ; nicht Kreis -->  Offset für Ellipse corrigieren
        CP      1               ; Radius gleich X - Radius  ?
        JR      Z,A48A7         ; ja
        EX      DE,HL           ; X - und Y - Offset vertauschen
A48A7:  LD      (S11D1),DE      ; X - Offset für 2ten / 7ten Octanten merken
        LD      (S11CD),HL      ; Y - Offset für 5ten / 8ten Octanten merken
        LD      HL,(S11A8)      ; Durchlaufzähler holen
        OR      A               ; Kreis  ?
        LD      D,H             ;! Wert nach DE duplizieren
        LD      E,L             ;!
        CALL    NZ,A4BA7        ; nicht Kreis -->  Offset für Ellipse corrigieren
        CP      1               ; Radius gleich X - Radius  ?
        JR      Z,A48BC         ; ja
        EX      DE,HL           ; X - und Y - Offset vertauschen
A48BC:  LD      (S11CF),DE      ; X - Offset für 1ten / 8ten Octanten merken
        LD      (S11CB),HL      ; Y - Offset für 6ten / 7ten Octanten merken
        LD      HL,(S11CF)      ; X - Offset für 1ten / 8ten Octanten holen
        CALL    A4B80           ; Vorzeichen des Integer - Wertes in HL umkehren
        LD      (S11B2),HL      ; X - Offset für 4ten / 5ten Octanten merken
        LD      HL,(S11D1)      ; X - Offset für 2ten / 7ten Octanten holen
        CALL    A4B80           ; Vorzeichen des Integer - Wertes in HL umkehren
        LD      (S11B0),HL      ; X - Offset für 3ten / 6ten Octanten merken
        LD      HL,(S11CD)      ; Y - Offset für 5ten / 8ten Octanten holen
        CALL    A4B80           ; Vorzeichen des Integer - Wertes in HL umkehren
        LD      (S11B4),HL      ; Y - Offset für 1ten / 4ten Octanten merken
        LD      HL,(S11CB)      ; Y - Offset für 6ten / 7ten Octanten holen
        CALL    A4B80           ; Vorzeichen des Integer - Wertes in HL umkehren
        LD      (S11B6),HL      ; Y - Offset für 2ten / 3ten Octanten merken
        LD      HL,(S11AC)
        CALL    A4B80           ; Vorzeichen des Integer - Wertes in HL umkehren
        LD      (S11B8),HL      ; aktuellen Y - Offset Kreispunkt merken
        LD      HL,S11BA        ; Zeiger auf Octantentabelle vorgeben
        LD      A,(HL)          ; Byte für Octantenwinkel eins holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf nächstes Octantenbyte
        JR      Z,A4938         ; Byte nicht gesetzt -->  kein Punkt in diesem Octanten
        EXX
        LD      HL,(S11CF)      ; X - Offset für 1ten / 8ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      DE,(S11B8)      ; aktuellen Y - Offset Kreispunkt holen
        BIT     7,D             ; negativ  ?
        JR      Z,A491B         ; nein -->  nicht vergleichen
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      1               ; Anfangspunkt im ersten Octanten  ?
        JR      NZ,A491A        ; nein
        LD      HL,(S11C5)      ; Y - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A491A         ; Punkt zeichnen
        JR      C,A491B         ; Punkt nicht zeichnen
A491A:  INC     B               ; Code auf  'Punkt setzen'
A491B:  LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      1               ; Endpunkt im ersten Octanten  ?
        JR      NZ,A492C        ; nein
        LD      HL,(S11C9)      ; Y - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A492C         ; Punkt zeichnen
        JR      NC,A492E        ; Punkt nicht zeichnen
A492C:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A492E:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4937         ; Punkt im ersten Octanten nicht setzen
        LD      HL,(S11B4)      ; Y - Offset für 1ten / 4ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4937:  EXX
A4938:  LD      A,(HL)          ; Byte für Octantenwinkel zwei holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf nächstes Octantenbyte
        JR      Z,A4979         ; nein
        EXX
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      HL,(S11D1)      ; X - Offset für 2ten / 7ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11AC)
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      2               ; Anfangspunkt im zweiten Octanten  ?
        JR      NZ,A495B        ; nein
        LD      HL,(S11C3)      ; X - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A495B         ; Punkt zeichnen
        JR      C,A495C         ; Punkt nicht zeichnen
A495B:  INC     B               ; Code auf  'Punkt setzen'
A495C:  LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      2               ; Endpunkt im zweiten Octanten  ?
        JR      NZ,A496D        ; nein
        LD      HL,(S11C7)      ; X - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A496D         ; Punkt zeichnen
        JR      NC,A496F        ; Punkt nicht zeichnen
A496D:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A496F:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4978         ; Punkt im zweiten Octanten nicht setzen
        LD      HL,(S11B6)      ; Y - Offset für 2ten / 3ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4978:  EXX
A4979:  LD      A,(HL)          ; Byte für Octantenwinkel drei holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf nächstes Octantenbyte
        JR      Z,A49BE         ; kein Punkt im Octanten 3 setzen
        EXX
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      HL,(S11B0)      ; X - Offset für 3ten / 6ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11B8)      ; aktuellen Y - Offset Kreispunkt holen
        BIT     7,D             ; negativ  ?
        JR      Z,A49A1         ; nein -->  nicht vergleichen
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      3               ; Anfangspunkt im dritten Octanten  ?
        JR      NZ,A49A0        ; nein -->  Punkt setzen
        LD      HL,(S11C3)      ; X - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A49A0         ; Punkt zeichnen
        JR      C,A49A1         ; Punkt nicht zeichnen
A49A0:  INC     B               ; Code auf  'Punkt setzen'
A49A1:  LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      3               ; Endpunkt im dritten Octanten  ?
        JR      NZ,A49B2        ; nein -->  testen, ob Punkt setzen
        LD      HL,(S11C7)      ; X - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A49B2         ; Punkt zeichnen
        JR      NC,A49B4        ; Punkt nicht zeichnen
A49B2:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A49B4:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A49BD         ; Punkt im dritten Octanten nicht setzen
        LD      HL,(S11B6)      ; Y - Offset für 2ten / 3ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A49BD:  EXX
A49BE:  LD      A,(HL)          ; Byte für Octantenwinkel vier holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf nächstes Octantenbyte
        JR      Z,A4A04         ; kein Punkt im Octanten 4 -->  nächsten Octanten testen
        EXX
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      HL,(S11B2)      ; X - Offset für 4ten / 5ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11B8)      ; aktuellen Y - Offset Kreispunkt holen
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      4               ; Anfangspunkt im vierten Octanten  ?
        JR      NZ,A49E1        ; nein -->  Punkt setzen
        LD      HL,(S11C5)      ; Y - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A49E1         ; Punkt zeichnen
        JR      NC,A49E2        ; Punkt nicht zeichnen
A49E1:  INC     B               ; Code auf  'Punkt setzen'
A49E2:  XOR     A               ; Code for 'Punkt setzen nicht erlaubt'
        BIT     7,D             ; aktueller Offset positiv  ?
        JR      Z,A49FA         ; ja -->  gar nicht erst vergleichen
        LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      4               ; Endpunkt im vierten Octanten  ?
        JR      NZ,A49F8        ; nein -->  testen, ob Punkt setzen
        LD      HL,(S11C9)      ; Y - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A49F8         ; Punkt zeichnen
        JR      C,A49FA         ; Punkt nicht zeichnen
A49F8:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A49FA:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4A03         ; Punkt im vierten Octanten nicht setzen
        LD      HL,(S11B4)      ; Y - Offset für 1ten / 4ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4A03:  EXX
A4A04:  LD      A,(HL)          ; Byte für Octantenwinkel fünf holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf nächstes Octantenbyte
        JR      Z,A4A45         ; kein Punkt im Octanten 5 -->  nächsten Octanten testen
        EXX
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      HL,(S11B2)      ; X - Offset für 4ten / 5ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11AC)
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      5               ; Anfangspunkt im fünften Octanten  ?
        JR      NZ,A4A27        ; nein -->  Punkt setzen
        LD      HL,(S11C5)      ; Y - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4A27         ; Punkt zeichnen
        JR      NC,A4A28        ; Punkt nicht zeichnen
A4A27:  INC     B               ; Code auf  'Punkt setzen'
A4A28:  LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      5               ; Endpunkt im fünften Octanten  ?
        JR      NZ,A4A39        ; nein -->  testen, ob Punkt setzen
        LD      HL,(S11C9)      ; Y - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4A39         ; Punkt zeichnen
        JR      C,A4A3B         ; Punkt nicht zeichnen
A4A39:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A4A3B:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4A44         ; Punkt im fünften Octanten nicht setzen
        LD      HL,(S11CD)      ; Y - Offset für 5ten / 8ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4A44:  EXX
A4A45:  LD      A,(HL)          ; Byte für Octantenwinkel sechs holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf nächstes Octantenbyte
        JR      Z,A4A8B         ; kein Punkt im Octanten 6 -->  nächsten Octanten testen
        EXX
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      HL,(S11B0)      ; X - Offset für 3ten / 6ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11B8)      ; aktuellen Y - Offset Kreispunkt holen
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      6               ; Anfangspunkt im sechsten Octanten  ?
        JR      NZ,A4A68        ; nein -->  Punkt setzen
        LD      HL,(S11C3)      ; X - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4A68         ; Punkt zeichnen
        JR      NC,A4A69        ; Punkt nicht zeichnen
A4A68:  INC     B               ; Code auf  'Punkt setzen'
A4A69:  XOR     A               ; Code for 'Punkt setzen nicht erlaubt'
        BIT     7,D             ; Offset positiv  ?
        JR      Z,A4A81         ; ja -->  gar nicht erst vergleichen
        LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      6               ; Endpunkt im sechsten Octanten  ?
        JR      NZ,A4A7F        ; nein -->  testen, ob Punkt setzen
        LD      HL,(S11C7)      ; X - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4A7F         ; Punkt zeichnen
        JR      C,A4A81         ; Punkt nicht zeichnen
A4A7F:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A4A81:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4A8A         ; Punkt im sechsten Octanten nicht setzen
        LD      HL,(S11CB)      ; Y - Offset für 6ten / 7ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4A8A:  EXX
A4A8B:  LD      A,(HL)          ; Byte für Octantenwinkel sieben holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf nächstes Octantenbyte
        JR      Z,A4ACC         ; kein Punkt im Octanten 7 -->  nächsten Octanten testen
        EXX
        LD      HL,(S11D1)      ; X - Offset für 2ten / 7ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11AC)
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      7               ; Anfangspunkt im siebten Octanten  ?
        JR      NZ,A4AAE        ; nein -->  Punkt setzen
        LD      HL,(S11C3)      ; X - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4AAE         ; Punkt zeichnen
        JR      NC,A4AAF        ; Punkt nicht zeichnen
A4AAE:  INC     B               ; Code auf  'Punkt setzen'
A4AAF:  LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      7               ; Endpunkt im siebten Octanten  ?
        JR      NZ,A4AC0        ; nein -->  testen, ob Punkt setzen
        LD      HL,(S11C7)      ; X - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4AC0         ; Punkt zeichnen
        JR      C,A4AC2         ; Punkt nicht zeichnen
A4AC0:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A4AC2:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4ACB         ; Punkt im siebten Octanten nicht setzen
        LD      HL,(S11CB)      ; Y - Offset für 6ten / 7ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4ACB:  EXX
A4ACC:  LD      A,(HL)          ; Byte für Octantenwinkel acht holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf nächstes Octantenbyte
        JR      Z,A4B0D         ; kein Punkt im Octanten 8 -->  nächsten Punkt durchspielen
        EXX
        LD      HL,(S11CF)      ; X - Offset für 1ten / 8ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11AC)
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      8               ; Anfangspunkt im achten Octanten  ?
        JR      NZ,A4AEF        ; nein -->  Punkt setzen
        LD      HL,(S11C5)      ; Y - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4AEF         ; Punkt zeichnen
        JR      C,A4AF0         ; Punkt nicht zeichnen
A4AEF:  INC     B               ; Code auf  'Punkt setzen'
A4AF0:  LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      8               ; Endpunkt im achten Octanten  ?
        JR      NZ,A4B01        ; nein -->  testen, ob Punkt setzen
        LD      HL,(S11C9)      ; Y - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4B01         ; Punkt zeichnen
        JR      NC,A4B03        ; Punkt nicht zeichnen
A4B01:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A4B03:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4B0C         ; Punkt im achten Octanten nicht setzen
        LD      HL,(S11CD)      ; Y - Offset für 5ten / 8ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4B0C:  EXX
A4B0D:  LD      HL,(S11A6)      ; Radius - Offsetzähler holen
        BIT     7,H             ; Wert positiv  ?
        JR      Z,A4B32         ; ja
        LD      DE,(S11AA)
        LD      HL,(S11A8)      ; Durchlaufzähler holen
        DEC     HL              ; minus eins
        LD      (S11A8),HL      ; und wieder merken
        BIT     7,H             ; Wert negativ  ?
        RET     NZ              ; ja -->  fertig
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE
        RET     C               ; fertig
        LD      HL,(S11A8)      ; Durchlaufzähler holen
        ADD     HL,HL
        LD      DE,(S11A6)      ; Radius - Offsetzähler holen
        ADD     HL,DE
        LD      (S11A6),HL      ; neuen Radius - Offsetzähler merken
A4B32:  LD      HL,(S11AA)
        INC     HL
        LD      (S11AA),HL
        LD      HL,(S11A4)
        INC     HL
        INC     HL
        LD      (S11A4),HL
        JP      A4885           ; neuen Punkt in allen 8 Octanten durchspielen
;
;
;                   !                   Octantenflag aus Koordinatenoffset bereitstellen
;                  3!2
;                   !                           1 = 315 - 360  Grad
;              4    !    1                      2 = 270 - 315  Grad
;          ---------+---------->  +X            3 = 225 - 270  Grad
;              5    !    8                      4 = 180 - 225  Grad
;                   !                           5 = 135 - 180  Grad
;                  6!7                          6 =  90 - 135  Grad
;                   !                           7 =  45 -  90  Grad
;                   !     +Y                    8 =   0 -  45  Grad
;
A4B44:  PUSH    HL              ; X - Offset retten
        PUSH    DE              ; Y - Offset retten
        CALL    A4B7D           ; Absolutbetrag des Integer - Wertes in HL bilden
        EX      DE,HL           ; Offsets vertauschen
        CALL    A4B7D           ; Absolutbetrag des Integer - Wertes in HL bilden
        EX      DE,HL           ; Offsets vertauschen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Punkt näher an X- oder an Y - Achse  ?
        POP     DE              ; geretteten Y - Offset holen
        POP     HL              ; geretteten X - Offset holen
        JR      C,A4B69         ; Punkt näher an Y - Achse
        BIT     7,H             ; X - Offset negativ  ?
        JR      NZ,A4B61        ; ja
        BIT     7,D             ; Y - Offset negativ  ?
        LD      A,8             ; Code for 'zwischen 0 und 45 Grad'
        RET     Z               ; Y - Offset positiv
        LD      A,1             ; Code for 'zwischen 315 und 360 Grad'
        RET
;
A4B61:  BIT     7,D             ; Y - Offset negativ  ?
        LD      A,5             ; Code for 'zwischen 135 und 180 Grad'
        RET     Z               ; Y - Offset positiv
        LD      A,4             ; Code for 'zwischen 180 und 225 Grad'
        RET
;
A4B69:  BIT     7,H             ; X - Offset positiv  ?
        JR      NZ,A4B75        ; nein
        BIT     7,D             ; Y - Offset negativ  ?
        LD      A,7             ; Code for 'zwischen 45 und 90 Grad'
        RET     Z               ; Y - Offset positiv
        LD      A,2             ; Code for 'zwischen 270 und 315 Grad'
        RET
;
A4B75:  BIT     7,D             ; Y - Offset negativ  ?
        LD      A,6             ; Code for 'zwischen 90 und 135 Grad'
        RET     Z               ; Y - Offset positiv
        LD      A,3             ; Code for 'zwischen 225 und 270 Grad'
        RET
;
;
;   Absolutbetrag des Integer - Wertes in HL bereitstellen
;
A4B7D:  BIT     7,H             ; Wert in HL positiv  ?
        RET     Z               ; ja -->  fertig
;
;
;   Vorzeichen des Integer - Wertes in HL umkehren
;
A4B80:  LD      A,H             ;! 2er Complement des Wertes in HL bilden
        CPL                     ;!
        LD      H,A             ;!
        LD      A,L             ;!
        CPL                     ;!
        LD      L,A             ;!
        INC     HL              ;!
        RET
;
;
;   Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
;
A4B88:  LD      DE,(POINTY)     ; Y - Koordinate Graphic - Cursor holen
        ADD     HL,DE           ; absolute Y - Koordinate errechnen
        LD      DE,-200         ; maximale Y - Koordinate vorgeben
        LD      B,H             ;! Y - Koordinate nach BC merken
        LD      C,L             ;!
        ADD     HL,DE           ; testen, ob Y - Koordinate im angezeigten Bereich
        RET     C               ; nicht im angezeigten Bereich -->  fertig
D4B94:  LD      HL,0            ; X - Offset holen   (wird eingetragen)
        LD      DE,(POINTX)     ; X - Koordinate Graphic - Cursor holen
        ADD     HL,DE           ; absolute X - Koordinate errechnen
        EX      DE,HL           ; X - Koordinate nach DE
        LD      HL,-640         ; maximale X - Koordinate vorgeben
        ADD     HL,DE           ; testen, ob X - Koordinate im angezeigten Bereich
        RET     C               ; nicht im angezeigten Bereich -->  fertig
        LD      H,B             ;! Y - Koordinate wieder nach HL
        LD      L,C             ;!
        JP      A4697           ; Punkt nach Koordinaten setzen oder zurücksetzen
;
;
;   Offset für Ellipse corrigieren
;
A4BA7:  PUSH    AF              ;! Register - Werte retten
        PUSH    DE              ;!
        LD      B,8             ; acht Bit testen
        LD      C,L             ; Low - Byte Offset
        LD      E,H             ; High - Byte Offset
        XOR     A               ; Accu auf Null
        LD      D,A             ;! Null
        LD      H,A             ;!
        LD      L,A             ;!
        EX      AF,AF           ; Null retten
        LD      A,(S11D4)       ; Aspekt - Verhältnis holen
A4BB5:  RRA                     ; ein Bit nach Carry schieben
        JR      NC,A4BBF        ; nicht gesetzt -->  nicht addieren
        ADD     HL,DE           ; High - Bytes der Faktoren addieren
        EX      AF,AF           ; Low - Byte Faktor holen
        ADD     A,C             ; und addieren
        JR      NC,A4BBE        ; kein Übertrag
        INC     HL              ; Übertrag corrigieren
A4BBE:  EX      AF,AF           ; Low - Byte Faktor wieder merken
A4BBF:  SLA     C               ;! Multiplikator um eine Stelle schieben
        RL      E               ;!
        RL      D               ;!
        DJNZ    A4BB5           ; weitere Bits multiplizieren
        EX      AF,AF           ; Low - Byte Ergebniszähler holen
        BIT     7,A             ; MSBit gleich Null  ?
        JR      Z,A4BCD         ; ja -->  Ergebnis nicht aufrunden
        INC     HL              ; Ergebnis aufrunden
A4BCD:  POP     DE              ;! gerettete Register - Werte holen
        POP     AF              ;!
        RET
;
;
;   Routine für 'Punkt auf jeden Fall setzen / testen, ob Punkt setzen' umstellen
;
A4BD0:  LD      (A492E),A       ;! richtigen Z-80 Befehl in Routine eintragen
        LD      (A496F),A       ;!
        LD      (A49B4),A       ;!
        LD      (A49FA),A       ;!
        LD      (A4A3B),A       ;!
        LD      (A4A81),A       ;!
        LD      (A4AC2),A       ;!
        LD      (A4B03),A       ;!
        RET
;
;
;   Rechteck zeichnen     ( DE  = X - Koordinate erster Eckpunkt  /  HL  = Y - Koordinate )
;                         ( DE' = X - Koordinate zweiter Eckpunkt /  HL' = Y - Koordinate )
;                         ( Carry - Flag gesetzt -->  Rechteck ausfüllen )
;                         ( Accu = Füllpalettencode)
;
;   (SVC code:  75)
;
WBOX:   LD      (S11A8),SP      ; Stackpointer retten
        EX      AF,AF           ; Flag  'Rechteck ausfüllen'  retten
        CALL    A4C16           ; X mit Y-Koord. in DE,HL , DE',HL' tauschen/Y-Max nach HL
        CALL    A4C16           ; X mit Y-Koord. in DE,HL , DE',HL' tauschen/Y-Max nach HL
        EXX
        PUSH    DE              ; X - Koordinate Punkt 1
        PUSH    HL              ; Y - Koordinate Punkt 1
        PUSH    DE              ; X - Koordinate Punkt 1
        EXX
        PUSH    HL              ; Y - Koordinate Punkt 2
        PUSH    DE              ; X - Koordinate Punkt 2
        PUSH    HL              ; Y - Koordinate Punkt 2
        PUSH    DE              ; X - Koordinate Punkt 2
        EXX
        PUSH    HL              ; Y - Koordinate Punkt 1
        PUSH    DE              ; X - Koordinate Punkt 1
        PUSH    HL              ; Y - Koordinate Punkt 1
        EXX
        EX      AF,AF           ; Flag  'Rechteck ausfüllen'  holen
        CALL    C,A4C2C         ; gesetzt -->  Rechteck ausfüllen
        LD      B,4             ; vier Linienstücke für ein Rechteck
A4C08:  EXX
        POP     HL              ; Y - Koordinate Anfangspunkt holen
        POP     DE              ; X - Koordinate Anfangspunkt holen
        EXX
A4C0C:  POP     HL              ; Y - Koordinate Endpunkt holen
        POP     DE              ; X - Koordinate Endpunkt holen
        PUSH    BC              ; Restanzahl Linien retten
        CALL    A46CC           ; Linie von Koordinaten in DE,HL nach DE',HL' zeichnen
        POP     BC              ; Restanzahl Linien holen
        DJNZ    A4C0C           ; weitere Linien für Rechteck zeichnen
        RET
;
;
;   X -Koordinate mit Y - Koordinate vertauschen   (DE<>HL  DE'<>HL')
;   und größere Y - Koordinate nach HL
;
A4C16:  EX      DE,HL           ; X- mit Y - Koordinate vertauschen
        LD      A,H             ; High - Byte Y - Koordinate holen
        EXX                     ; erste mit zweiter Koordinate vertauschen
        EX      DE,HL           ; X- mit Y - Koordinate vertauschen
        CP      H               ; High - Bytes der Y - Koordinaten vergleichen
        EXX
        JR      Z,A4C21         ; High - Bytes gleich -->  Low - Bytes vergleichen
        RET     P               ; größere Y - Koordinate ist in HL
        JR      A4C26           ; Y - Koordinaten vertauschen
;
A4C21:  LD      A,L             ; Low - Byte Y - Koordinate holen
        EXX
        CP      L               ; mit Low - Byte Y - Koordinate vergleichen
        EXX
        RET     NC              ; Y - Koordinate in HL ist größer
A4C26:  PUSH    HL              ; Y - Koordinate ablegen
        EXX                     ; umschalten auf andere Koordinate
        EX      (SP),HL         ; Y - Koordinate mit Koordinate auf Stack vertauschen
        EXX                     ; wieder umschalten auf erste Koordinate
        POP     HL              ; größere Y - Koordinate wieder holen
        RET
;
;
;   Rechteck mit Palettencode im Accu ausfüllen
;
A4C2C:  CALL    A049C           ; Palettenwert für maximale Auflösung corrigieren
        LD      B,A             ; Palettenwert zum Ausfüllen merken
        LD      A,(GMODE)       ; aktuellen Graphic - Palettenwert holen
        CP      B               ; gleich Ausfüllpalettenwert  ?
        JR      NZ,A4C3A        ; nein -->  Rand muß noch gezeichnet werten
        LD      SP,(S11A8)      ; Stackpointer bei Anfang Routine holen  (Rand nicht zeichnen)
A4C3A:  LD      A,(PWMODE)      ; aktuellen Überschreib - Modus holen
        OR      A               ; Überschreiben  ?
        LD      A,11000000B     ; Code for 'PSET'   (Punkt in Farbe setzen)
        JR      Z,A4C44         ; Fläche in Farbe ausmalen
        LD      A,01000000B     ; Code for 'OR'     (neuen Farbwert mit altem Farbwert verknüpfen)
A4C44:  OR      B               ; plus Palettenwert
        OUT     (CRTCWF),A      ; an 'Write-Format-Register' Bildschirm-Controller ausgeben
;
;
;   Linie(n) parallel zu einer Koordinatenachse zeichnen
;
A4C47:  LD      A,H             ; High - Byte Y - Koordinate
        OR      D               ; und High - Byte X - Koordinate
        RET     M               ; mindestens eine der Koordinaten ist außerhalb Anzeigebereich
        CALL    A4CEC           ; wenn Koordinaten außerhalb Graphic -->  Maximum vorgeben
        LD      A,L             ; Low - Byte Y - Koordinate holen
        EXX
        BIT     7,H             ; Y-Koordinate im negativen Nicht - Anzeige - Bereich  ?
        JR      Z,A4C56         ; nein
        LD      HL,0            ; kleinste anzeigbare Koordinate vorgeben
A4C56:  BIT     7,D             ; X-Koordinate im negativen Nicht - Anzeige - Bereich  ?
        JR      Z,A4C5D         ; nein
        LD      DE,0            ; kleinste anzeigbare Koordinate vorgeben
A4C5D:  EX      AF,AF           ; Low - Byte Y - Koordinate retten
        CALL    A4CEC           ; wenn Koordinaten außerhalb Graphic -->  Maximum vorgeben
        RET     C               ; Fehler aufgetreten -->  Abbruch
        EX      AF,AF           ; Low - Byte größere Y - Koordinate wieder holen
        INC     A               ; plus eins  (Anzahl ist um eins größer als Differenz)
        SUB     L               ; Low - Byte kleinere Koordinate abziehen
        RET     C               ; Fehler aufgetreten -->  Abbruch
        RET     Z               ; nichts zeichnen
        EX      AF,AF           ; Anzahl Graphic - Zeilen merken
        PUSH    HL              ; Y - Koordinate merken
        CALL    ADCH            ; absolute Graphic-Adresse und Bitnr. aus Koordinaten errechnen
        LD      (S11A4),HL      ; Graphic - Adresse der linken Ecke merken
        EXX
        POP     HL              ; Y - Koordinate wieder holen
        LD      B,A             ; Bit - Nummer der linken Ecke
        PUSH    BC              ; Bit - Nummer der linken Ecke merken
        CALL    ADCH            ; absolute Graphic-Adresse und Bitnr. aus Koordinaten errechnen
        POP     BC              ; Bit - Nummer der linken Ecke holen
        LD      (S11A6),HL      ; Graphic - Adresse der rechten Ecke merken
        LD      C,A             ; Bit - Nummer der rechten Ecke
        LD      DE,(S11A4)      ; Graphic - Adresse der linken Ecke holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Graphic - Adressen vergleichen
        JR      Z,A4CAA         ; beide Ecken liegen im gleichen Graphic-Byte
        DEC     HL              ; Differenz corrigieren
        INC     DE              ; Zeiger auf Graphic - Speicher corrigieren
        LD      A,L             ; Anzahl vollständige 8ter Spalten holen
        OR      A               ; gleich Null  ?
        CALL    NZ,A4CCD        ; nein -->  Punkte in vollständigen 8ter Spalten setzen
        LD      HL,B45C0        ; Tabelle zum Setzen der linken Punkte nach Bit-Nummer
        LD      A,B             ; Bitnummer der linken Ecke merken
        LD      B,0             ; High - Byte Offset auf Null
        ADD     HL,BC           ; Zeiger auf richtigen Tabellenwert
        LD      L,(HL)          ; Setzmaske aus Tabelle holen
        LD      C,A             ; Bitnummer der linken Ecke als Low - Byte Ofset
        LD      A,L             ; Bitmaske für rechte Ecke merken
        LD      HL,B45B8        ; Tabelle zum Setzen der rechten Punkte nach Bit-Nummer
        ADD     HL,BC           ; Zeiger auf richtigen Tabellenwert errechnen
        LD      B,(HL)          ; Bitmasken für linkes Byte aus Tabelle holen
        LD      DE,(S11A6)      ; Graphic - Adresse der rechten Ecke holen
        PUSH    BC              ; Bitmaske der linken Ecke merken
        CALL    A4CBA           ; Punkte nach Muskermaske im Accu in Graphic setzen
        POP     BC              ; gerettete Bitmaske holen
        LD      DE,(S11A4)      ; Graphic - Adresse der linken Ecke holen
        LD      A,B             ; neuen Setzwert vorgeben
        JR      A4CBA           ; Punkte nach Mustermaske im Accu in Graphic setzen
;
;
;   zwei Punkte im gleichen Graphic - Byte mit Linie verbinden
;
A4CAA:  LD      HL,B45C0        ; Tabelle zum Setzen der linken Punkte nach Bit-Nummer
        LD      A,B             ; Bit - Nummer der linken Ecke retten
        LD      B,0             ; High - Byte Offset auf Null
        ADD     HL,BC           ; Zeiger auf Tabelle auf richtige Maske
        LD      C,A             ; Bit - Nummer der linken Ecke
        LD      A,11111111B     ; erst einmal alle Bits vorgeben
        AND     (HL)            ; zu setzende Bits maskieren  (LD A,(HL) macht das Gleiche)
        LD      HL,B45B8        ; Tabelle zum Setzen der rechten Punkte nach Bit-Nummer
        ADD     HL,BC           ; Zeiger auf richtigen Tabellenwert für linke Ecke
        AND     (HL)            ; noch zu setzende Bits maskieren
;
;
;   Punkte nach Mustermaske in Accu in Graphic setzen
;
A4CBA:  LD      C,A             ; neuen Setzwert merken
        EX      AF,AF           ; Anzahl Graphic - Zeilen holen
        LD      B,A             ; und für Schleife vorgeben
        EX      AF,AF           ; Anzahl Graphic - Zeilen merken
        EX      DE,HL           ; Zeiger auf Graphic - Speicher nach HL
        DI                      ; Interrupt sperren
A4CC0:  LD      DE,80           ; Offset auf nächste Graphic-Zeile   (wird eingetragen)
        IN      A,(_CGVIN)      ; ZeichensatzROM und Video-RAM einschalten
A4CC5:  LD      (HL),C          ; neues Muster in Graphic - Speicher eintragen
        ADD     HL,DE           ; Zeiger auf nächste Graphic - Zeile
        DJNZ    A4CC5           ; weitere Graphic - Zeilen beeinflussen
        IN      A,(_CGVOT)      ; ZeichensatzROM und Video-RAM ausschalten
        EI                      ; Interrupt wieder freigeben
        RET
;
;
;   Punkte in vollständigen 8ter Zeilen setzen
;   (Komplette Bytes im Graphic - Speicher)
;
A4CCD:  PUSH    BC              ; Keep register value
        EX      DE,HL           ; Zeiger auf Graphic - Speicher nach HL
        LD      B,A             ; Anzahl vollständige 8ter Spalten merken
        EX      AF,AF           ; Anzahl Graphic - Zeilen holen
        LD      C,A             ; und für Schleife merken
        EX      AF,AF           ; Anzahl Graphic - Zeilen wieder merken
A4CD3:  LD      DE,80           ; Offset auf nächste Graphic-Zeile   (wird eingetragen)
        DI                      ; Interrupt sperren
A4CD7:  PUSH    HL              ; Zeiger auf Graphic - Speicher merken
        PUSH    BC              ; Restanzahl Zeilen merken
        IN      A,(_CGVIN)      ; ZeichensatzROM und Video-RAM einschalten
        LD      A,11111111B     ; Code for 'alle Punkte in diesem Byte beeinflussen'
A4CDD:  LD      (HL),A          ; an Graphic ausgeben   (Punkte nach Palettenwert setzen)
        INC     HL              ; Zeiger auf Graphic - Speicher auf nächste 8ter Spalte
        DJNZ    A4CDD           ; Punkte in weiteren 8ter - Spalten setzen
        IN      A,(_CGVOT)      ; ZeichensatzROM und Video-RAM ausschalten
        POP     BC              ; Restanzahl Zeilen holen
        POP     HL              ; Zeiger auf Graphic - Speicher holen
        ADD     HL,DE           ; Zeiger auf nächste Zeile errechnen
        DEC     C               ; Restanzahl Zeilen minus eins
        JR      NZ,A4CD7        ; Punkte in weiteren Zeilen setzen
        EI                      ; Interrupt wieder freigeben
        POP     BC              ; geretteten Register - Wert wieder holen
        RET
;
;
;   tesen, ob Graphic - Koordinaten innerhalb des angezeigten Graphic-Bereichs
;   wenn nicht -->  die jeweilige maximal - Koordinate vorgeben
;
A4CEC:  LD      A,H             ; High - Byte  Y - Koordinate holen
        OR      A               ; gleich Null  ?
        JR      NZ,A4CF5        ; nein -->  maximale Y - Koordinate vorgeben
        LD      A,199           ; maximale Y - Koordinate im Anzeigebereich
        CP      L               ; mit aktueller Y - Koordinate vergleichen
        JR      NC,A4CF9        ; Y - Koordinate liegt im angezeigten Bereich
A4CF5:  LD      HL,199          ; maximale Y - Koordinate vorgeben
        SCF                     ; Code for 'Koordinate nicht im Bereich'
A4CF9:  RRA                     ; eventuellen Fehler bei Y - Koordinate merken
        PUSH    HL              ; Y - Koordinate retten
A4CFB:  LD      HL,-640         ; maximale negative X - Koordinate vorgeben
        ADD     HL,DE           ; X - Koordinate testen
        POP     HL              ; gerettete Y - Koordinate wieder holen
        JR      NC,A4D06        ; X - Koordinate ist OK
A4D02:  LD      DE,639          ; maximale X - Koordinate vorgeben   (wird eingetragen)
        RET
;
A4D06:  RLA                     ; eventuellen Fehler aus Y - Koordinate wieder vorgeben
        RET
;
;
;   Überprüfen, ob Graphic-Koordinate in DE',HL' im angezeigten Graphic-Bereich liegt
;
;   (SVC code:  70)
;
POSCK:  EXX                     ; Graphic - Koordinaten in Erstregistersatz holen
        CALL    RNGCK           ; überprüfen, ob Koordinaten in DE,HL im angezeigten Bereich
        EXX                     ; Graphic - Koordinaten wieder in Zweitregistersatz stecken
        RET     NC              ; Koordinaten sind OK
        LD      A,3             ; Fehler 3   Illegal data error
        JP      ERRORJ          ; Fehler mit Nummer im Accu behandeln
;
;
;   aktuelle Graphic - Cursor - Koordinaten im Zweitregistersatz merken
;
;   (SVC code:  71)
;
POSSV:  EXX                     ; Graphic - Koordinaten in Erstregistersatz holen
        LD      (POINTX),DE     ; X - Koordinate Graphic - Cursor merken
        LD      (POINTY),HL     ; Y - Koordinate Graphic - Cursor merken
        EXX                     ; Graphic - Koordinaten wieder in Zweitregistersatz stecken
        RET
;
S4D1D:  DEFS    8               ; Speicher für aktuelles Zeichen   (SYMBOL)
;
;
;   Tabelle mit Anfangsadressen der Teilroutine für verschiedene Zeichenrichtungen
;
W4D25:  DEFW    A4EE1           ; Standardlage  (0 Grad)
        DEFW    A4EED           ; Rotation um  90 Grad
        DEFW    A4F03           ; Rotation um 180 Grad
        DEFW    A4F1C           ; Rotation um 270 Grad
;
;
;   Output text with magnification     (DE = pointer to text)
;     (H  = Y - enlargement)
;     (L  = X - enlargement)
;     (A  = direction)
;     (B  = number of characters)
;
;   (SVC code:  87)
;
SYMBOL: PUSH    BC              ; Save number of characters
        PUSH    DE              ; Save pointer to text
        LD      BC,S1218        ; Specify pointer to memory for current X reference position
        LD      D,L             ; Horizontal magnification
        LD      E,H             ; Vertical Magnification
        BIT     0,A             ; Horizontal writing direction ?
        JR      Z,A4D3B         ; yes --> character is in the X direction
        EX      DE,HL           ; Swap X and Y magnification
        INC     BC              ;! Pointer to memory for current Y - reference position
        INC     BC              ;! to pretend
A4D3B:  LD      (D4DB3 + 1),BC  ; Enter pointer in routine
        LD      (S1212),HL      ; remember horizontal and vertical magnification
        LD      H,0             ; High - byte increase to zero
        ADD     HL,HL           ;! times two (8 rows of dots on top of each other)
        ADD     HL,HL           ;! times four
        ADD     HL,HL           ;! times eight
        LD      (S1214),HL      ; Number of points per character in the X character direction
        LD      L,E             ; Y - magnification
        LD      H,0             ; High - byte to zero
        ADD     HL,HL           ;! times two (8 points next to each other)
        ADD     HL,HL           ;! times four
        ADD     HL,HL           ;! times eight
        LD      (S1216),HL      ; Number of points per character in the Y character direction
        LD      DE,0            ; EN to zero
        EX      DE,HL           ; swap values
        SBC     HL,DE           ; Calculate the negative value of the number of points in the Y direction
        LD      (S1221),HL      ; Offset from end character to start next character
        BIT     1,A             ; Output text in Y - direction ?
        JR      Z,A4D64         ; no
        LD      (S1221),DE      ; Offset from end character to start next character
A4D64:  OR      A               ; drawing direction flag
        JP      PO,A4D6B        ; Characters in the direction of the Y - axis
        LD      HL,0            ; Default zero as offset for X - axis
A4D6B:  LD      DE,(POINTY)     ; Y - Coordinate Graphic - Cursor
        ADD     HL,DE           ; Calculate reference coordinates
        LD      (S121A),HL      ; current Y - reference position for SYMBOL
        LD      DE,(S1214)      ; Number of points per character in the X character direction
        LD      HL,0            ; Default zero
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; Calculate complement
        BIT     0,A             ; Drawing direction parallel to the X - axis ?
        JR      NZ,A4D8C        ; Drawing direction in Y - axis
        BIT     1,A             ; Rotate character 270 degrees ?
        LD      (S1221),DE      ; Offset from end character to start next character
        JR      Z,A4D8C         ; Yes
        LD      (S1221),HL      ; Offset from end character to start next character
A4D8C:  EX      DE,HL
        LD      HL,(POINTX)     ; X - Coordinate Graphic - Get cursor
        BIT     1,A             ; Drawing direction along positive axis ?
        JR      Z,A4D95         ; Yes
        ADD     HL,DE
A4D95:  LD      (S1218),HL      ; current X - reference position for SYMBOL
        ADD     A,A             ; character position times two (two bytes per address)
        LD      HL,W4D25        ; Starting address table to reverse byte by character position
        LD      D,0             ; High - byte offset to zero
        LD      E,A             ; Specify low - byte offset
        ADD     HL,DE           ; Calculate pointer to correct address
        LD      E,(HL)          ;! Get address from table
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      (D4DE9 + 1),DE  ; and enter into routine
        CALL    A4669           ; Write - Set format register for 'set point'
        POP     HL              ; Get pointer to text to output
        POP     BC              ; Get number of characters to be output
A4DAC:  DEC     B               ; Number of characters to print minus one
        RET     M               ; done
        PUSH    HL              ; Save pointer to text to be output
        PUSH    BC              ; Save remaining number of characters to be output
        CALL    A4DC8           ; output a character according to the magnification factor
D4DB3:  LD      HL,S1218        ; Pointer to current reference position
        LD      E,(HL)          ;! fetch current reference position from memory
        INC     HL              ;!
        LD      D,(HL)          ;!
        PUSH    HL              ; Remember pointer to memory for position
        LD      HL,(S1221)      ; Offset from end character to start next character
        ADD     HL,DE           ; Calculate pointer to next position
        EX      DE,HL           ; Result after DE
        POP     HL              ; Get pointer to memory for reference position
        LD      (HL),D          ;! enter the new reference position back into the memory
        DEC     HL              ;!
        LD      (HL),E          ;!
        POP     BC              ; Get remaining number of characters to be output
        POP     HL              ; Get pointer to rest of text
        INC     HL              ; Pointer to text on next character
        JR      A4DAC           ; display additional characters enlarged
;
;
;   Output a character according to the magnification factor
;
A4DC8:  LD      IY,S1208        ; Pointer to memory containing characters
        LD      A,(HL)          ; get the character to be output
        RST     _DOCMD          ; Software - Execute command
        DEFB    29              ; Convert Code 29 ASCII characters in Accu to display code
        LD      H,0             ; High - byte value to zero
        LD      L,A             ; Character code as low - byte value
        ADD     HL,HL           ;! offset times two (8 bytes per character in ROM)
        ADD     HL,HL           ;!            four
        ADD     HL,HL           ;!            eight
        LD      A,010H          ; High - byte starting address of the character ROM
        ADD     A,H             ; add to the previous high byte
        LD      H,A             ; note the result
        LD      DE,S4D1D        ; Pointer to memory for current character (SYMBOL)
        LD      BC,8            ; Number of bytes for a character in the character - ROM
        DI                      ; Disable interrupts
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        LDIR                    ; Get Bit pattern for characters from Character - ROM
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Release interrupt again
        LD      B,8             ; 8 bytes per character
D4DE9:  CALL    A4EE1           ; Prepare characters according to angle (address is entered)
        LD      HL,256 * 8 + 8  ; Original character consists of 8 x 8 matrix
        LD      (S1209),HL      ; specify horizontal and vertical loop counters
        LD      DE,(S1212)      ; get horizontal / vertical magnification
        LD      (S121F),DE      ; Enter horizontal / vertical enlargement counter
        LD      HL,(S1218)      ; current X - reference position for SYMBOL
        BIT     7,H             ; value positive ?
        JR      Z,A4E16         ; yes --> output characters
        CALL    A4F32           ; test whether coordinates are positive at some point in the case of characters
        RET     C               ; all characters in the negative graphic area --> finished
A4E05:  EXX
        LD      B,8             ; eight bytes per character
        LD      HL,S1200        ; Pointer to in-place character pattern memory
A4E0B:  RLC     (HL)            ; shift a byte of the character by one bit
        INC     HL              ; Pointer to character to next byte
        DJNZ    A4E0B           ; shift more bytes of the character
        EXX
        DJNZ    A4E05           ; further investigate whether parts need to be issued
        LD      HL,0            ; Specification for the current X - position
A4E16:  LD      (D4E45 + 1),HL  ; Enter current X position in routine
        LD      A,11111000B     ; Mask for bit number in graphic byte
        AND     L               ; Hide the bit number of the graphic byte
        OR      H               ; plus high-order bits of the coordinate
        RRC     A               ;! Bits to correct value for
        RRC     A               ;! Slide Column Offset (by 8)
        RRC     A               ;!
A4E22:  SUB     80              ; compare with number of bytes per line (is entered)
        RET     NC              ; X - coordinate is outside the displayed range
        LD      L,A             ; Remember low - byte address
        LD      H,0+(S1200-1)/256 ; Specify high byte address
        LD      (S1210),HL      ; Remember pointers for provided byte masks of a row
        LD      HL,(S121A)      ; current Y - reference position for SYMBOL
        XOR     A               ; Accu to zero
        BIT     7,H             ; Y - coordinate positive ?
        JR      Z,A4E42         ; yes --> enlarge characters
        INC     IY              ; Correct base address for Y - values
        CALL    A4F32           ; test whether coordinates are positive at some point in the case of characters
        DEC     IY              ; Base address back to X values
        RET     C               ; Error occurred --> termination
        LD      HL,0            ; Specify Y coordinate
        LD      A,8             ;! calculate from which character position
        SUB     B               ;! is only issued.
A4E42:  LD      (D4E61 + 1),A   ; Enter offset to character in routine
D4E45:  LD      DE,0            ; current X - coordinate (is entered)
        PUSH    HL              ; Y - save coordinate
        PUSH    DE              ; X - save coordinate
        CALL    RNGCK           ; check whether coordinates in DE,HL are in the displayed range
        POP     DE              ; Retrieve saved X coordinate
        POP     HL              ; retrieve saved Y coordinate
        RET     C               ; Error occurred --> termination
        CALL    ADCH            ; absolute graphic address and bit no. calculate from coordinates
        LD      (S121C),HL      ; Pointer to graphic memory at SYMBOL
        LD      HL,B45C8        ; Table with specifications for bit by bit number
        LD      D,0             ; High - byte offset to zero
        LD      E,A             ; Bit number as low byte offset
        ADD     HL,DE           ; Calculate pointer to correct table value
        LD      A,(HL)          ; Get bit mask from table
        LD      (S121E),A       ; and remember
D4E61:  LD      HL,S1200        ; Pointer to the bit pattern of the character (is entered)
A4E64:  LD      DE,(S1210)      ; Pointer to provided byte masks of a row
        LD      BC,(S121E)      ; Get the start bit and the number of bits to be processed in the character
        XOR     A               ; Accu to zero
        EXX
        LD      B,(IY+1)        ; get second magnification factor
A4E71:  EXX
        LD      (DE),A          ; specify a byte for expanded characters
        XOR     A               ; Code 'NOP'
        RRC     (HL)            ; fetch a bit of character
        JR      NC,A4E7A        ; Point not set --> NOP
        LD      A,OR_C          ; Z-80 - Command OR C
A4E7A:  LD      (A4E7E),A       ; Z-80 - enter command in routine
        LD      A,(DE)          ; get default result
A4E7E:  OR      C               ; possibly plus new point
        RLC     C               ; Shift bit for next bit
        JR      NC,A4E88        ; not published yet
        LD      (DE),A          ; remember one byte of result
        INC     E               ; Result pointer to next byte
        JR      Z,A4E93         ; Offset reached at the end of the screen
        XOR     A               ; Default for result back to zero
A4E88:  DJNZ    A4E7E           ; more bits for magnification factor
        LD      B,(IY+10)       ; Remainder Get magnification factor
        EXX
        DJNZ    A4E71           ; prepare further values ??for horizontal enlargement
        EXX
        LD      (DE),A          ; Remember last edited value
        INC     E               ; Correct offset for loop end
A4E93:  DEC     E               ; Correct the offset of the provided data
        INC     L               ; Pointer to character default to next byte
        LD      (S120E),HL      ; Remember pointer to next byte of character
        LD      HL,(S1210)      ; Pointer to provided byte masks of a row
        EX      DE,HL           ; Swap pointers
        XOR     A               ; Reset carry flag
        SBC     HL,DE           ;! calculate how much values ??provided
        INC     HL              ;!
        LD      (S1223),HL      ; Note the number of values ??provided
        LD      A,(S1220)       ; get vertical magnification factor
        LD      B,A             ; and remember for loop
A4EA7:  EXX
        LD      DE,(S121C)      ; Pointer to graphic memory at SYMBOL
        LD      HL,(S1210)      ; Pointer to provided byte masks of a row
        LD      BC,(S1223)      ; Get number of provided values
        DI                      ; Disable interrupts
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 00FFFH
        LDIR                    ; Output values for a graphic series
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Release interrupt again
A4EBD:  LD      DE,80           ; Number of bytes per graphic line (is entered)
        LD      HL,(S121C)      ; Pointer to graphic memory at SYMBOL
        ADD     HL,DE           ; Calculate pointer to next graphic line
        LD      (S121C),HL      ; and remember
A4EC7:  LD      DE,BITBUF+16000 ; Specify end of used color memory (is entered)
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; Graphic - check memory address
        RET     NC              ; from the graphic memory --> stop
        EXX
        DJNZ    A4EA7           ; Output characters more times for vertical enlargement
        LD      A,(S1213)       ; get vertical magnification factor
        LD      (S1220),A       ; and pretend again
        LD      HL,(S120E)      ; Get pointer to remainder bit pattern of character
        DEC     (IY+2)          ; horizontal loop counter minus one
        JP      NZ,A4E64        ; more layers
        RET
;
;
;   Output characters in standard position
;
A4EE1:  LD      HL,S4D1D        ; Pointer to memory for current character (SYMBOL)
        LD      DE,S1200        ; Pointer to in-place character pattern memory
        LD      C,B             ; Eight bytes for characters
        LD      B,0             ; High - byte count to zero
        LDIR                    ; Transfer character pattern 1 / 1 to memory
        RET
;
;
;   Zeichen um 90 Grad gedreht ausgeben
;
A4EED:  LD      DE,S1200        ; Zeiger auf Speicher für Zeichenmuster in richtiger Lage
A4EF0:  EXX
        LD      HL,S4D1D        ; Zeiger auf Speicher für aktuelles Zeichen  (SYMBOL)
        LD      B,8             ; acht Bit je Byte
        XOR     A               ; Vorgabe für Ergebnisbyte
A4EF7:  RLC     (HL)            ; Originalzeichen um ein Bit schieben
        RRA                     ; ein Bit des Bytes des Originalzeichens merken
        INC     HL              ; Zeiger auf Originalzeichen auf nächstes Byte
        DJNZ    A4EF7           ; weitere Bits aus Originalzeichen holen
        EXX
        LD      (DE),A          ; ein Byte des gedrehten Zeichens merken
        INC     DE              ; Zeiger auf Speicher auf nächstes Byte
        DJNZ    A4EF0           ; weitere Bytes gedrehtes Zeichen bereitstellen
        RET
;
;
;   Zeichen um 180 Grad gedreht ausgeben
;
A4F03:  LD      DE,S1200 + 7    ; Zeiger auf Speicher für Zeichenmuster in richtiger Lage
        LD      HL,S4D1D        ; Zeiger auf Speicher für aktuelles Zeichen  (SYMBOL)
A4F09:  LD      A,(HL)          ; ein Byte Originalzeichen holen
        EXX
        LD      C,A             ; Byte des Originalzeichens
        LD      B,8             ; acht Bit je Byte
        XOR     A               ; Vorgabe für Ergebnis
A4F0F:  RR      C               ;! Bits im Byte des Zeichens umkehren
        RL      A               ;!
        DJNZ    A4F0F           ;!
        EXX
        LD      (DE),A          ; ein Byte des gedrehten Zeichens merken
        INC     HL              ; Zeiger auf Original auf nächstes Byte
        DEC     DE              ; Zeiger für gedrehtes Zeichen auf nächstes Byte
        DJNZ    A4F09           ; weitere Bytes umkehren
        RET
;
;
;   Zeichen um 270 Grad gedreht ausgeben
;
A4F1C:  LD      DE,S1200 + 7    ; Zeiger auf Speicher für Zeichenmuster in richtiger Lage
A4F1F:  EXX
        LD      HL,S4D1D        ; Zeiger auf Speicher für aktuelles Zeichen  (SYMBOL)
        XOR     A               ; Vorgabe für Ergebnis
        LD      B,8             ; acht Bit je Byte
A4F26:  RLC     (HL)            ; ein Byte Originalzeichen um ein Bit schieben
        RLA                     ; ein Bit des Originalzeichens merken
        INC     HL              ; Zeiger auf Originalzeichen auf nächstes Byte
        DJNZ    A4F26           ; ein Byte gedrehtes Zeichen zusammenstellen
        EXX
        LD      (DE),A          ; ein Byte des gedrehten Zeichens merken
        DEC     DE              ; Zeiger auf Speicher für gedrehtes Zeichen auf nächstes Byte
        DJNZ    A4F1F           ; Vollständiges gedrehtes Zeichen bereitstellen
        RET
;
;
;   testen, ob Koordinate irgendwann einmal bei Zeichen positiv
;
A4F32:  LD      B,8             ; acht Punktreihen in Zeichenrichtung
        LD      E,(IY+10)       ; Vergrößerung der Richtung holen
        LD      D,0             ; High - Byte Vergrößerung auf Null
A4F39:  ADD     HL,DE           ; Vergrößerung ein mal zur Koordinate addieren
        BIT     7,H             ; Koordinate positiv  ?
        JR      Z,A4F42         ; ja -->  Werte merken
        DJNZ    A4F39           ; weiter testen
A4F40:  SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
A4F42:  LD      A,H             ;! Koordinate gleich Null  ?
        OR      L               ;!
        JR      NZ,A4F4A        ; nein -->  merken
        LD      L,E             ; Vergrößerung als Koordinate vorgeben
        DEC     B               ; Zähler minus eins
        JR      Z,A4F40         ; gleich null -->  Fehler setzen
A4F4A:  LD      (IY+23),L       ; Koordinate merken
        LD      (IY+1),B        ; Restanzahl abzuarbeitende Punktreihen merken
        OR      A               ; Carry - Flag zurücksetzen   (Code 'kein Fehler')
        RET
;
;
;   Graphic - Bitmuster in Bildspeicher eintragen     (A  = Anzahl Lagen)
;                    (B  = Textlänge)
;                    (DE = Zeiger auf Text)
;                    (H  = 0 -->  Lagen psoitiv)
;   (Software - Kommanod  74)
;
CHARW:  OR      A               ; Anzahl Lagen gleich Null  ?
        RET     Z               ; ja -->  alles vergessen
        LD      (S11A6),DE      ; Zeiger auf Graphic - Text merken
        LD      E,A             ;! Anzahl Lagen merken
        LD      C,A             ;!
        LD      A,H             ; Flag  'Lagen positiv'  holen
        OR      A               ; Lagen positiv  ?
        LD      A,INC_HL        ; Vorgabe  INC HL     (Z-80 - Befehl)
        JR      NZ,A4F62        ; Anzahl Lagen negativ
        LD      A,DEC_HL        ; Vorgabe  DEC HL     (Z-80 - Befehl)
A4F62:  LD      (D4FF5),A       ;! richtigen Befehl in Routine eintragen
        LD      (D4FE1),A       ;!
        LD      A,B             ; Anzahl Bytes Graphic-Text holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  fertig
        LD      HL,(POINTX)     ; X - Koordinate Graphic - Cursor holen
        LD      A,00000111B     ; acht Punkte je Byte = 3 Bit in Koordinate
        AND     L               ; Bit - Nummer im Graphic - Byte maskieren
        LD      D,A             ; Anfangsbitnummer in Koordinate merken
        EXX
        LD      HL,B45B8        ; Tabelle zum Setzen der rechten Punkte nach Bit - Nummer
        LD      D,0             ; High - Byte Offset auf Null
        LD      E,A             ; Anfangsbitnummer in Koordinate
        ADD     HL,DE           ; Zeiger auf richtigen Maskenwert errechnen
        LD      A,(HL)          ; Maskenwert aus Tabelle holen
        LD      (D4F84 + 1),A   ; und in Routine eintragen
A4F7E:  LD      HL,(POINTY)     ; Y - Koordinate Graphic - Cursor
A4F81:  LD      (S11A4),HL      ; aktuelle Y - Koordinate Graphic bei PATTERN
D4F84:  LD      C,11111111B     ; Vorgabe für zu setzendes Punktmuster in Byte   (wird eingetragen)
        LD      HL,(S11A6)      ; Zeiger auf Graphic - Text holen
        LD      A,(HL)          ; ein Byte des Graphic - Textes holen
        EXX
        LD      H,A             ; Byte des auszugebenden Graphic - Text - Musters
        LD      A,D             ; Anfangsbitnummer in Koordinate holen
        OR      A               ; gleich Null  ?
        JR      Z,A4F95         ; ja -->  Graphic-Text-Byte deckt sich mit Graphic-Speicher
A4F90:  RRC     H               ; Graphic - Text - Byte um ein Bit schieben
        DEC     A               ; Zähler minus eins
        JR      NZ,A4F90        ; weiter schieben
A4F95:  LD      A,H             ; Graphic - Text - Byte holen
        EXX
        LD      HL,S129E        ; Zeiger auf Speicher für aufbereitetes Punktmuster
        LD      B,8             ; acht Bit im Byte
        LD      D,A             ; Graphic - Textmuster merken
A4F9D:  SRL     D               ;! Graphic - Textmuster umkehren
        RLA                     ;!
        DJNZ    A4F9D           ; weiter schieben
        LD      D,A             ; Graphic - Text - Bit - Muster merken
        AND     C               ; Bits im ersten Byte maskieren
        LD      (HL),A          ; Pattern for  erstes Byte Betriebsart 1 merken
        LD      A,D             ;! Bits im Graphic - Text - Byte umkehren
        CPL                     ;!
        LD      B,A             ;!
        AND     C               ; relevante Bits im ersten Byte maskieren
        INC     HL              ; Zeiger auf Speicher für Muster auf nächste Stelle
        LD      (HL),A          ; Pattern for  erstes Byte Betriebsart 0 merken
        LD      A,C             ;! Bitmaske für zweites Byte  (Restbits)  errechnen
        CPL                     ;!
        LD      C,A             ;!
        AND     D               ; zu setzende Bits maskieren
        INC     HL              ; Zeiger auf Speicher für Muster auf nächste Stelle
        LD      (HL),A          ; Pattern for  zweites Byte Betriebsart 1 merken
        LD      A,C             ; Bitmaske holen
        AND     B               ; Bits für zweites Byte maskieren
        INC     HL              ; Zeiger auf Speicher für Muster auf nächste Stelle
        LD      (HL),A          ; Pattern for  zweites Byte Betriebsart 0 merken
        LD      DE,(POINTX)     ; X - Koordinate Graphic - Cursor holen
        LD      HL,(S11A4)      ; aktuelle Y - Koordinate Graphic bei PATTERN
        PUSH    DE              ; X - Koordinate Graphic merken
        PUSH    HL              ; Y - Koordinate Graphic merken
        EX      DE,HL           ; X - Koordinate und Y - Koordinate vertauschen
        LD      BC,8            ; Anzahl Punkte in einer Lage
        ADD     HL,BC           ; X - Koordinate der nächsten Lage errechnen
        EX      DE,HL           ; X - Koordinate wieder nach DE
        LD      A,1             ; Code for 'zweites Byte behandeln'
        CALL    A5003           ; aufbereitetes Bitmuster in Graphic-Speicher übertragen
        POP     HL              ; Y - Koordinate Graphic holen
        POP     DE              ; X - Koordinate Graphic holen
        XOR     A               ; Code for 'erstes Byte behandeln'
        CALL    A5003           ; aufbereitetes Bitmuster in Graphic-Speicher übertragen
        LD      HL,(S11A6)      ; aktuelle Y - Koordinate Graphic bei PATTERN
        INC     HL              ; plus eins
        LD      (S11A6),HL      ; und wieder merken
        EXX
        DJNZ    A4FE7           ; weitere Graphic - Text - Zeichen ausgeben
        DEC     C               ; Anzahl Lagen minus eins
        EXX
        JP      Z,A4FF8         ; X - Koordinate Graphic für eine Lage corrigieren
        LD      HL,(S11A4)      ; aktuelle Y - Koordinate Graphic bei PATTERN
D4FE1:  INC     HL              ; für nächste LAge corrigieren  (Befehl wird eingetragen)
        LD      (POINTY),HL     ; Y - Koordinate Graphic - Cursor merken
        XOR     A
        RET
;
A4FE7:  DEC     C               ; Anzahl Lagen minus eins
        JR      NZ,A4FF1        ; weitere Lagen
        LD      C,E             ; Anzahl Lagen wieder vorgeben
        EXX
        CALL    A4FF8           ; X - Koordinate Graphic für eine Lage corrigieren
        JR      A4F7E           ; Rest Graphic - Text ausgeben
;
A4FF1:  EXX
        LD      HL,(S11A4)      ; aktuelle Y - Koordinate Graphic bei PATTERN
D4FF5:  INC     HL              ; für nächste Lage corrigieren
        JR      A4F81
;
;
;   X - Koordinate Graphic für eine Lage corrigieren
;
A4FF8:  LD      HL,(POINTX)     ; X - Koordinate Graphic - Cursor holen
        LD      BC,8            ; acht Punkte je Lage
        ADD     HL,BC           ; X - Koordinate corrigieren
        LD      (POINTX),HL     ; X - Koordinate Graphic - Cursor merken
        RET
;
;
;   ein Byte aufbereitetes Bit pattern for  PATTERN in Graphic-Speicher übertragen
;
A5003:  EX      AF,AF           ; Flag 'erstes/zweites Byte' merken
        CALL    RNGCK           ; überprüfen, ob Koordinaten in DE,HL im angezeigten Bereich liegen
        RET     C               ; Fehler aufgetreten -->  Abbruch
        CALL    ADCH            ; absolute Graphic-Adresse und Bitnr. aus Koordinaten errechnen
        LD      B,A             ; Bit - Nummer merken
        LD      DE,S129E        ; Zeiger auf Speicher für aufbereitetes Punktmuster
        EX      AF,AF           ; Flag 'erstes/zweites Byte' holen
        OR      A               ; erstes Byte  ?
        JR      Z,A5018         ; ja -->  auf jeden Muster ausgeben
        LD      A,B             ; Bit - Nummer holen
        OR      A               ; gleich null  ?
        RET     Z               ; ja -->  alle Bits im ersten Byte
        INC     DE              ;! Zeiger auf Bit pattern for  zweites Byte
        INC     DE              ;!
A5018:  CALL    A4669           ; Write - Format Register für 'Punkt setzen' setzen
        DI                      ; Interrupt sperren
        IN      A,(_CGVIN)      ; Zeichensatzrom und Video-Ram einschalten
        OUT     (_00RAM),A      ; Umschalten auf RAM von 00000H - 00FFFH
        LD      A,(DE)          ; ein Byte des Bitmusters holen
        LD      (HL),A          ; und in Graphic - Speicher eintragen
        LD      A,(PWMODE)      ; aktuellen Überschreibmodus holen
        OR      A               ; Farbwerte addieren  ?
        JR      NZ,A5032        ; ja
        LD      A,(CPLANE)      ; Vorgabe für benutzte Farbebenen holen
        OR      01100000B       ; Code for 'RESET
        OUT     (CRTCWF),A      ; Steuerwort an Graphic-Controller ausgeben
        INC     DE              ; Zeiger auf richtiges Bitmuster
        LD      A,(DE)          ; Bit pattern for  Graphic-Byte holen
        LD      (HL),A          ; und in Graphic-Speicher eintragen
A5032:  IN      A,(_CGVOT)      ; Zeichensatzrom und Video-Ram ausschalten
        EI                      ; Interrupt wieder freigeben
        RET
;
;
;   Fläche ausfüllen      (HL = Zeiger auf Palettencodes für Rand)
;                         (B  = Anzahl Palettencodes)
;
;   (SVC code:  76)
;
WPAINT: LD      A,(GMODE)       ; aktuellen Graphic - Palettenwert holen
        OR      11000000B       ; plus Code for 'PSET
        OUT     (CRTCWF),A      ; an 'Write-Format-Register' des Bildschirm-Controllers ausgeben
        EXX
        LD      DE,S27D0        ; Zeiger auf Speicher für Routinenstück
        LD      HL,T5556        ; Zeiger auf ersten Teil Routinenstück zur Punktabfrage
        LD      BC,9            ; Länge erstes Teilstück
        LDIR                    ; Routinenstück in Speicher übertragen
        EXX
A504A:  LD      A,(HL)          ; einen Palettencodewert für Rand holen
        CALL    A049C           ; Wert eventuell für Bildschirm II corrigieren
        OR      10000000B       ; plus Code for 'COLOR SEARCH'
        LD      (D555F + 1),A   ; für Read - Format - Register in Routine eintragen
        INC     HL              ; Zeiger auf nächsten Palettenwert
        EXX
        LD      HL,D555F        ; Zeiger auf Routinenstück zur Abfrage einer Palettencodeebene
        LD      BC,5            ; Länge Routinenstück
        LDIR                    ; Routinestück für einen Palettenwert bereitstellen
        EXX
        DJNZ    A504A           ; Routinenstücke für weitere Palettenwerte bereitstellen
        EXX
        LD      BC,7            ; Länge Routinenstück zum Wegschalten der Graphic-Speicher
        LDIR                    ; Routinenstück hinter Rest Routine eintragen
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich  (Anfang freier Speicher)  holen
        LD      (S11A6),HL      ; als aktuellen Zeiger für PAINT - Werte merken
        LD      (A51CD + 2),HL  ; und als Zeiger auf Anfang PAINT-Werte in Routine eintragen
        LD      HL,(S137C)      ; Ende Arbeitsbereich für PAINT - Routine holen
        LD      DE,-6           ;! noch ein bischen Sicherheit dazupacken
        ADD     HL,DE           ;!
        LD      (D54D9 + 1),HL  ; und als maximale nutzbare Adresse in Routine eintragen
        LD      HL,(POINTX)     ; X - Koordinate Graphic - Cursor holen
        DEC     HL              ; minus eins
        LD      (S11B1),HL      ; als linke X - Koordinate merken
        INC     HL              ; Wert wieder auf Originalkoordinate
        INC     HL              ; X - Koordinate plus eins
        LD      (S11B3),HL      ; als rechte X - Koordinate merken
        DEC     HL              ; Wert wieder auf Originalkoordinate
        EX      DE,HL           ; X - Koordinate nach DE
        LD      HL,0            ; HL auf Null
        LD      (S11A4),HL      ; als Anzahl noch zu testende Koordinaten merken
        LD      HL,(POINTY)     ; Y - Koordinate Graphic - Cursor holen
        LD      (S11AF),HL      ; als Y - Koordinate für PAINT - Routine merken
        CALL    RNGCK           ; überprüfen, ob Koordinaten in DE,HL im angezeigten Bereich liegen
        CCF                     ; Ergebnis umkehren
        RET     NC              ; Graphic - Koordinaten liegen nicht im angezeigten Bereich
        LD      (A54E1 + 1),SP  ; Stackpointer für Fehlerabbruch merken
        LD      SP,S2ED0        ; neuen Stackpointer vorgeben
        CALL    ADCH            ; absolute Graphic-Adresse und Bitnr. aus Koordinaten errechnen
        LD      DE,B45C8        ; Tabelle mit Vorgabe für Bit nach Bit - Nummer
        PUSH    HL              ; Graphic - Speicheradresse errechnen
        LD      H,0             ; High - Byte Offset auf Null
        LD      L,A             ; Bit - Nummer als Low - Byte Offset merken
        ADD     HL,DE           ; Zeiger auf Bitwert in Tabelle errechnen
        LD      C,(HL)          ; Bitmaske aus Tabelle holen
        POP     HL              ; Graphic - Speicheradresse wieder holen
        CALL    S27D0           ; Abfrage, ob Punkt in angegebenen Palettenfarben gesetzt
        AND     C               ; richtiges Bit im Byte maskieren
        JP      NZ,A5163        ; PAINT - Punkt ist gesetzt -->  fertig
        CALL    A5425           ; ausgehend von vorgegeb. Koord. rechte X - Koordinate  suchen
        LD      (S11B3),IX      ; rechte X - Koordinate PAINT merken
        CALL    A53F5           ; ausgehend von vorgegeb. Koord. linke X - Koordinate  suchen
        LD      (S11B1),IX      ; als linke X - Koordinate merken
        LD      A,11111111B
        LD      (S11B5),A       ; PAINT - Wert - Status merken
        CALL    A54D5           ; bereitgestellten PAINT - Datensatz merken
        LD      HL,S12A0
        LD      (S11A9),HL
        XOR     A               ; Accu auf Null
        LD      (S11B5),A       ; PAINT - Wert - Status zurücksetzen
        LD      (S11A8),A
A50D6:  LD      A,(S11B5)       ; PAINT - Wert - Status holen
        CALL    A53C4           ; Y - Koordinate entsprechend Status ändern
        LD      A,199           ; maximale Y - Koordinate vorgeben
        CP      L               ; mit Y - Koordinate vergleichen
        JR      C,A5115         ; Richtung bis Bildschirmende abgearbeitet
        CALL    A539D
        JR      C,A5115
        LD      (S11B6),A
        AND     00001001B
        CALL    NZ,A518A
        CALL    A51CD
        LD      A,(S11B7)
        OR      A
        JR      NZ,A5115
A50F7:  CALL    A54FA           ; Punkte von rechter Koordinate bis Grenze setzen
        JR      Z,A50D6         ; Punkte bis zur linken X - Koordinate gesetzt -->  nächste Zeile
        LD      HL,(S11B3)      ; rechte X - Koordinate PAINT holen
        PUSH    HL              ; X - Koordinate merken
        PUSH    DE              ; linke Koordinate, bis wohin gezeichnet wurde
        CALL    A5429           ; rechte X - Koordinate ab Punkt suchen
        LD      (S11B3),IX      ; rechte X - Koordinate PAINT merken
        CALL    A54D5           ; bereitgestellten PAINT - Datensatz merken
        POP     HL              ; linke Koordinate, bis wohin gezeichnet wurde
        LD      (S11B1),HL      ; als linke X - Koordinate merken
        POP     HL              ; X - Koordinate holen
        LD      (S11B3),HL      ; als rechte X - Koordinate PAINT merken
        JR      A50D6           ; nächste Zeile untersuchen
;
A5115:  LD      HL,(S11A6)      ; aktuellen Zeiger für PAINT - Werte holen
        DEC     HL              ; Zeiger auf letztes Byte des letzten Wertes
        LD      DE,-7           ; Länge eines PAINT - Wertsatzes   (Complement)
        LD      BC,(S11A4)      ; aktuelle Anzahl PAINT - Werte holen
A5120:  LD      A,B             ;! Restanzahl Werte gleich Null  ?
        OR      C               ;!
        JR      Z,A515C         ; ja -->  untersuchen, ob noch weitere PAINT - Werte
        LD      A,00001111B
        DEC     BC              ; Restanzahl Datensätze minus eins
        CP      (HL)            ; Status vergleichen
        ADD     HL,DE           ; Zeiger auf Ende des vorherigen Datensatzes
        JR      Z,A5120         ; falscher Status -->  untersuchen, ob weitere Datensätze
        INC     HL              ; Zeiger auf Anfang PAINT - Wertsatz
        PUSH    HL              ; Zeiger auf Anfang PAINT - Wertsatz merken
        LD      (D5148 + 1),HL  ; und in Routine eintragen
        LD      DE,S11AF        ; Zeiger auf Speicher für PAINT - Datensatz
        LD      BC,7            ; Länge PAINT - Datensatz
        LDIR                    ; PAINT - Wertsatz in Speicher für PAINT - Datensatz übertragen
        EX      DE,HL           ; Zeiger auf Ende PAINT - Wertsatz nach DE
        LD      HL,(S11A6)      ; aktuellen Zeiger für PAINT - Werte holen
        XOR     A               ; Carry - Flag zurücksetzen
        POP     BC              ; Zeiger auf Anfang PAINT - Wertsatz holen
        LD      (S11A6),BC      ; als aktuellen Zeiger für PAINT - Werte merken
        SBC     HL,DE           ; aktueller PAINT - Wertsatz gleich letzter Wertsatz  ?
        JR      Z,A5152         ; ja -->  nur Anzahl PAINT - Wertsätze corrigieren
        LD      B,H             ;! Anzahl Bytes der PAINT - Wertsätze, die noch
        LD      C,L             ;! dahinter liegen, nach BC übertragen
D5148:  LD      HL,0            ; Zeiger auf PAINT - Wertsatz  (wird eingetragen)
        EX      DE,HL           ; Zeiger vertauschen
        LDIR                    ; restliche PAINT - Wertsätze verschieben
        LD      (S11A6),DE      ; aktuellen Zeiger für PAINT - Werte holen
A5152:  LD      HL,(S11A4)      ; Anzahl PAINT - Werte holen
        DEC     HL              ; minus eins
        LD      (S11A4),HL      ; und wieder merken
        JP      A50F7           ; bereitgestellten PAINT - Datensatz abarbeiten
;
A515C:  LD      HL,(S11A4)      ; Anzahl PAINT - Werte holen
        LD      A,L             ;! Anzahl gleich Null  ?
        OR      H               ;!
        JR      NZ,A5168        ; nein -->  nächsten bereitgestellten PAINT - Wert abarbeiten
A5163:  LD      SP,(A54E1 + 1)  ; Stackpointer wieder richtig setzen
        RET
;
A5168:  DEC     HL              ; Anzahl PAINT - Werte minus eins
        LD      (S11A4),HL      ; Restanzahl PAINT - Werte merken
        LD      HL,(S11A6)      ; aktuellen Zeiger für PAINT - Werte holen
        DEC     HL              ; Zeiger auf letztes Byte im letzten Datensatz
        LD      DE,S11B5        ; Zeiger auf Ende Speicher für PAINT - Datensatz
        LD      BC,7            ; Länge PAINT - Datensatz
        LDDR                    ; PAINT - Datensatz vorgeben
        INC     HL              ; Zeiger wieder corrigieren
        LD      (S11A6),HL      ; aktuellen Zeiger für PAINT - Werte merken
A517C:  CALL    A54FA           ; Punkte von rechter Koordinate bis Grenze setzen
        JR      Z,A515C         ; bis zur linken Koordinate gezeichnet -->  testen, ob fertig
        CALL    A5429           ; rechte X - Koordinate ab Punkt suchen
        LD      (S11B3),IX      ; rechte X - Koordinate PAINT merken
        JR      A517C           ; weiter zeichnen
;
;
;
;
A518A:  LD      HL,S11AB
        LD      DE,S11B9
        CALL    A51C7           ; 11 Byte vom (HL) nach (DE) übertragen
        LD      A,(S11B6)
        BIT     0,A
        JR      Z,A51B2
A519A:  LD      HL,(S11AB)
        LD      (S11B3),HL      ; rechte X - Koordinate PAINT merken
        CALL    A53D1
        JR      C,A51A9
        BIT     0,A
        JR      NZ,A519A
A51A9:  CALL    A51C1
        LD      A,(S11B6)
        CP      9
        RET     NZ
A51B2:  LD      HL,(S11AD)
        LD      (S11B1),HL      ; als linke X - Koordinate merken
        CALL    A53D1
        JR      C,A51C1
        BIT     3,A
        JR      NZ,A51B2
A51C1:  LD      HL,S11B9
        LD      DE,S11AB
A51C7:  LD      BC,11
        LDIR
        RET
;
;
;
;
;
A51CD:  LD      IY,0            ; Zeiger auf Anfang PAINT - Werte   (wird eingetragen)
        LD      BC,(S11A4)      ; Anzahl PAINT - Werte holen
        LD      HL,0
        LD      (S11B7),HL
A51DB:  CALL    A5203
        LD      A,(S11A8)
        OR      A
        RET     Z
        DEC     A
        LD      (S11A8),A
        LD      (D51FE + 1),SP
        LD      SP,(S11A9)
        POP     IY
        POP     BC
        POP     HL
        LD      (S11B3),HL      ; rechte X - Koordinate aus PAINT - Datensatz merken
        POP     HL
        LD      (S11B1),HL      ; linke X - Koordinate aus PAINT - Datensatz merken
        LD      (S11A9),SP
D51FE:  LD      SP,0
        JR      A51DB
;
;
;
;
A5203:  LD      A,B             ;! Anzahl PAINT - Werte gleich Null  ?
        OR      C               ;!
        LD      (D528D + 1),BC  ; Anzahl PAINT - Werte in Routine eintragen
        JP      Z,A5294
        LD      HL,(S11AF)      ; Y - Koordinate Graphic (PAINT) holen
        LD      E,(IY+0)        ;! X - Koordinate aus PAINT - Wert - Datensatz holen
        LD      D,(IY+1)        ;!
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Y - Koordinaten vergleichen
        JR      NZ,A5288        ; nicht gleich -->  Zeiger auf nächsten Datensatz vorgeben und erneut testen
        CALL    A556B           ; X - Koordinaten im PAINT - Datensatz mit Wertsatz vergleichen
        CP      00000101B
        JR      Z,A5258
        CP      00001111B
        JR      NZ,A529C
        LD      L,(IY+2)        ;! linke X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+3)        ;!
        LD      DE,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Koordinaten vergleichen
        JR      NC,A5288        ;              -->  Zeiger auf nächsten Datensatz vorgeben und erneut testen
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL              ; und merken
        LD      L,(IY+2)        ;! linke X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+3)        ;!
        PUSH    HL              ; und merken
        LD      (S11B1),HL      ; als linke X - Koordinate PAINT - Datensatz vorgeben
        LD      A,00000011B
        CALL    A5334
        POP     HL              ; gemerkte linke X - Koordinate aus PAINT - Wertsatz
        LD      (S11B3),HL      ; rechte X - Koordinate aus PAINT - Datensatz holen
        POP     HL              ; gemerkte linke X - Koordinate aus PAINT - Wertsatz
        LD      (S11B1),HL      ; linke X - Koordinate aus PAINT - Datensatz holen
        CALL    A5425           ; ausgehend von vorgegeb. Koord. rechte X - Koordinate suchen
        LD      (S11B3),IX      ; rechte X - Koordinate aus PAINT - Datensatz holen
        JR      A5288           ; Zeiger auf nächsten Datensatz vorgeben und erneut testen
;
A5258:  LD      E,(IY+4)        ;! rechte X - Koordinate aus PAINT - Wertsatz holen
        LD      D,(IY+5)        ;!
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE
        JR      NC,A5288        ;        Zeiger auf nächsten Datensatz vorgeben und erneut testen
        LD      HL,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL              ; und merken
        LD      L,(IY+4)        ;! rechte X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+5)        ;!
        PUSH    HL              ; und merken
        LD      (S11B3),HL      ; als rechte X - Koordinate in PAINT - Datensatz eintragen
        LD      A,00000100B
        CALL    A5334
        POP     HL              ; gerettete rechte X - Koordinate au PAINT - Wertsatz
        LD      (S11B1),HL      ; als linke X - Koordinate in PAINT - Datensatz eintragen
        POP     HL              ; gerettete rechte X - Koordinate aus PAINT - Datensatz
        LD      (S11B3),HL      ; wieder als rechte X - Koordinate in PAINT - Datensatz
        CALL    A53F5           ; ausgehend von vorgegebenen Koordinaten linke X - Koordinate suchen
        LD      (S11B1),IX      ; linke X - Koordinate in PAINT - Datensatz merken
A5288:  LD      DE,7            ; Länge PAINT - Wertsatz
        ADD     IY,DE           ; Zeiger auf nächsten PAINT - Wertsatz errechnen
D528D:  LD      BC,0            ; Restanzahl PAINT - Werte   (wird eingetragen)
        DEC     BC              ; minus eins
        JP      A5203           ; nächsten Datensatz testen
;
;
;
;
A5294:  LD      A,(S11B8)
        OR      A
        CALL    NZ,A54D5        ; einen Koordinatensatz als PAINT - Werte merken
        RET
;
;
;
;
A529C:  EX      AF,AF
        LD      A,00001111B
        LD      (S11B7),A
        EX      AF,AF
        OR      A
        JR      NZ,A52AC
        LD      A,00001111B
        LD      (IY+6),A
        RET
;
A52AC:  CP      00000001B
        JR      NZ,A52C2
        LD      L,(IY+4)        ;! rechte X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+5)        ;!
        LD      (S11B1),HL      ; linke X - Koordinate aus PAINT - Datensatz holen
        CALL    A53F5           ; ausgehend von vorgegebenen Koordinaten linke X - Koordinate suchen
        LD      (S11B1),IX      ; linke X - Koordinate aus PAINT - Datensatz holen
        JR      A52D6
;
A52C2:  CP      00001100B
        JR      NZ,A52E0
A52C6:  LD      L,(IY+2)        ;! linke X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+3)        ;!
        LD      (S11B3),HL      ; rechte X - Koordinate aus PAINT - Datensatz holen
        CALL    A5425           ; ausgehend von vorgegeb. Koord. rechte X - Koordinate suchen
        LD      (S11B3),IX      ; rechte X - Koordinate aus PAINT - Datensatz holen
A52D6:  LD      A,00001111B
        LD      (IY+6),A        ; Status in PAINT - Wertsatz merken
        LD      (S11B8),A
        JR      A5288
;
A52E0:  CP      00001101B
        JP      NZ,A5334
        LD      A,(S11A8)
        INC     A
        CP      01BH
        CCF
        JP      C,A54E1
        LD      (S11A8),A
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL              ; Koordinate retten
        LD      L,(IY+4)        ;! rechte X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+5)        ;!
        LD      (S11B1),HL      ; linke X - Koordinate aus PAINT - Datensatz holen
        CALL    A53F5           ; ausgehend von vorgegebenen Koordinaten linke X - Koordinate suchen
        LD      (D5329 + 2),IY
        LD      DE,7            ; Länge PAINT - Wertsatz
        ADD     IY,DE           ; Zeiger auf nächsten PAINT - Wertsatz errechnen
        LD      BC,(D528D + 1)
        DEC     BC
        LD      (D5326 + 1),SP
        LD      SP,(S11A9)
        PUSH    IX
        LD      DE,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        PUSH    DE
        PUSH    BC
        PUSH    IY
        LD      (S11A9),SP
D5326:  LD      SP,0
D5329:  LD      IY,0
        POP     HL
        LD      (S11B1),HL      ; linke X - Koordinate aus PAINT - Datensatz merken
        JP      A52C6
;
A5334:  EX      AF,AF
        CALL    A54D5           ; einen Koordinatensatz als PAINT - Werte merken
        DEC     DE
        LD      A,00001111B
        LD      (DE),A
        EX      AF,AF
        CP      00000011B
        JR      NZ,A535D
A5341:  LD      HL,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        LD      (S11B1),HL      ; linke X - Koordinate aus PAINT - Datensatz holen
        LD      L,(IY+4)        ;! rechte X - Koordinate aus PAINT - Wertdatensatz holen
        LD      H,(IY+5)        ;!
        LD      (S11B3),HL      ; rechte X - Koordinate aus PAINT - Datensatz holen
        CALL    A53F5           ; ausgehend von vorgegebenen Koordinaten linke X - Koordinate suchen
        PUSH    IX              ;! bereitgestellte linke X - Koordinate nach HL
        POP     HL              ;!
        LD      (IY+2),L        ;! linke X - Koordinate in PAINT - Wertsatz eintragen
        LD      (IY+3),H        ;!
        RET
;
A535D:  CP      00000100B
        JR      Z,A5381
        LD      HL,(S11A6)      ; Zeiger auf aktuelle PAINT - Werte holen
        PUSH    HL
        LD      (A54E6 + 1),IY
        CALL    A54D5           ; einen Koordinatensatz als PAINT - Werte merken
        LD      HL,S11AF
        LD      (A54E6 + 1),HL
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL
        CALL    A5341
        POP     HL
        LD      (S11B3),HL      ; rechte X - Koordinate im PAINT - Datensatz merken
        POP     IY
        JR      A5387
;
A5381:  LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        LD      (S11B3),HL      ; als rechte X - Koordinate in PAINT - Datensatz merken
A5387:  LD      L,(IY+2)        ;! linke X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+3)        ;!
        LD      (S11B1),HL      ; linke X - Koordinate im PAINT - Datensatz merken
        CALL    A5425           ; ausgehend von vorgegeb. Koord. rechte X - Koordinate suchen
        PUSH    IX              ;! herausgesuchte rechte X - Koordinate nach HL
        POP     HL              ;!
        LD      (IY+4),L        ;! rechte X - Koordinate im PAINT - Wertsatz merken
        LD      (IY+5),H        ;!
        RET
;
;
;
;
A539D:  LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        LD      (S11AB),HL      ; im Speicher für linke X - Koordinate merken
        LD      HL,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        LD      (S11AD),HL      ; im Speicher für rechte X - Koordinate merken
        CALL    A53F5           ; ausgehend von vorgegebenen Koordinaten linke X - Koordinate suchen
        RET     C
        LD      (S11B1),IX      ; linke X - Koordinate aus PAINT - Datensatz holen
        CALL    A5425           ; ausgehend von vorgegeb. Koord. rechte X - Koordinate suchen
        LD      (S11B3),IX      ; rechte X - Koordinate aus PAINT - Datensatz holen
        CALL    A54B1
        LD      A,B
        RET
;
;
;   Paint - Status umkehren und Y - Koordinate entsprechend PAINT - Status ändern
;
A53BD:  LD      A,(S11B5)       ; PAINT - Status aus PAINT - Datensatz holen
        CPL                     ; Status umkehren
        LD      (S11B5),A       ; und neuen Datensatz merken
;
;
;   Y - Koordinate entsprechend Status ändern
;
A53C4:  LD      HL,(S11AF)      ; Y - Koordinate Graphic (PAINT) holen
        INC     L               ; Y - Koordinate plus eins
        OR      A               ; Status abfragen
        JR      NZ,A53CD        ; Koordinate ist OK
        DEC     L               ; Y - Koordinate wieder auf alten Wert
        DEC     L               ; Y - Koordinate minus eins
A53CD:  LD      (S11AF),HL      ; Y - Koordinate Graphic (PAINT) holen
        RET
;
;
;
;
A53D1:  CALL    A53BD           ; Status umkehren und Y - Koordinate entsprechend Status ändern
        CALL    A539D
        RET     C
        PUSH    AF
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL              ; und merken
        LD      HL,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL              ; und merken
        CALL    A51CD
        LD      A,(S11B7)
        OR      A
        CALL    Z,A54D5         ; einen Koordinatensatz als PAINT - Werte merken
        POP     H               ; gerettete rechte X - Koordinate holen
        LD      (S11B3),HL      ; rechte X - Koordinate wieder im PAINT - Datensatz merken
        POP     HL              ; gerettete linke X - Koodinate holen
        LD      (S11B1),HL      ; linke X - Koordinate wieder im PAINT - Datensatz merken
        POP     AF
        RET
;
;
;   ausgehend von vorgegebenen Koordinaten linke X - Koordinate suchen
;
A53F5:  LD      DE,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL              ; Koordinate, von der ausgesucht werden soll, merken
        LD      (D54A8 + 1),DE  ; rechte Koordinate in Routine eintragen
        LD      HL,0            ; minimale Koordinate vorgeben
        LD      (D547C + 1),HL  ; und in Routine eintragen
        LD      A,DEC_HL        ; Z-80 - Befehl  DEC HL
        LD      (D546E + 1),A   ; in Routine eintragen
        LD      A,_CPL           ; Z-80 - Befehl  CPL
        LD      (D54A0),A       ; in Routine eintragen
        XOR     A               ; Z-80 - Befehl  NOP
        LD      (D548A),A       ; in Routine eintragen
        LD      HL,A5471
        LD      (D5468 + 1),HL
        LD      HL,A5490
        LD      (D546B + 1),HL
        POP     DE              ; Koordinate, von der ausgegangen werden soll, holen
        INC     DE              ; Koordinate corrigieren
        JR      A5450           ; linke X - Koordinate suchen
;
;
;    ausgehend von vorgegebenen Koordinaten rechte X - Koordinate suchen
;
A5425:  LD      DE,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
A5429:  LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        LD      (D547C + 1),HL  ; linke Koordinate in Routine eintragen
A542F:  LD      HL,BITBUF+2
        LD      (D54A8 + 1),HL
        LD      A,INC_HL        ; Z-80 - Befehl  INC HL
        LD      (D546E + 1),A   ; in Routine eintragen
        LD      A,_CPL           ; Z-80 - Befehl  CPL
        LD      (D548A),A       ; in Routine eintragen
        XOR     A               ; Z-80 - Befehl  NOP
        LD      (D54A0),A       ; in Routine eintragen
        LD      HL,A5490
        LD      (D5468 + 1),HL
        LD      HL,A5471
        LD      (D546B + 1),HL
        DEC     DE              ; X - Koordinate corrigieren
A5450:  LD      HL,(S11AF)      ; Y - Koordinate Graphic (PAINT) holen
        PUSH    DE              ;! aktuelle X - Koordinate als Ergebniskoordinate vorgeben
        POP     IX              ;!
        CALL    ADCH            ; absolute Graphic-Adresse und Bit-Nr. aus Koordinaten errechnen
        LD      DE,B45C8        ; Tabelle für Bit - Maske nach Bit - Nummer
        PUSH    HL              ; Graphic - Koordinate merken
A545B:  ;=??
        LD      H,0             ; High - Byte Offset auf Null
        LD      L,A             ; Bit - Nummer als Low - Byte Offset vorgeben
        ADD     HL,DE           ; Zeiger auf Tabelle auf richtiges Muster
        LD      C,(HL)          ; Pattern for  Bitnummer aus Tabelle holen
        POP     HL              ; Zeiger auf Graphic - Speicher holen
        CALL    S27D0           ; Abfrage, ob Punkte mit Palettenfarben gesetzt sind
        LD      E,A             ; Ergebnis merken
        AND     C               ; richtiges Bits maskieren
D5468:  JP      Z,A5471         ; Punkt in angegebenen Palettenfarben nicht gesetzt
D546B:  CALL    A5490
D546E:  DEC     IX              ; X - Koordinate Ergebnis corrigieren
        RET
;
A5471:  DEC     IX              ; X - Koordinate minus eins
        RRC     C               ; ein Bit Abfrage - Ergebnis
        JR      NC,A5489        ; keine Umrandung gefunden
        PUSH    IX              ; bisher gefundene X - Koordinate
        EXX
        POP     DE              ; nach DE holen
        INC     DE              ; Umrandung nicht mitzählen
D547C:  LD      HL,0
        INC     HL
        SBC     HL,DE           ; Differenz errechnen
        EXX
        RET     NC
        DEC     HL              ; Zeiger auf Graphic - Speicher auf voriges Byte
        CALL    S27D0           ; Abfrage, ob Punkte mit Palettenfarben gesetzt sind
        LD      E,A             ; Ergebnis der Abfrage merken
A5489:  LD      A,E
D548A:  NOP
        AND     C
        JP      Z,A5471
        RET
;
A5490:  INC     IX              ; X - Koordinate plus eins
        RLC     C
        JR      NC,A549F
        CALL    A54A4
        RET     C
        INC     HL              ; Zeiger auf Graphic - Speicher auf nächstes Byte
        CALL    S27D0           ; Abfrage, ob Punkte mit Palettenfarben gesetzt sind
        LD      E,A             ; Ergebnis der Abfrage merken
A549F:  LD      A,E
D54A0:  CPL
        AND     C
        JR      Z,A5490
A54A4:  PUSH    IX
        EXX
        POP     HL
D54A8:  LD      DE,S11B3
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Differenz errechnen
        EXX
        CCF                     ; Ergebnis umkehren
        RET
;
A54B1:  LD      B,0             ; Vorgabe für Ergebnis
        LD      HL,(S11AD)      ; Wert aus Speicher für rechte X - Koordinate holen
        LD      DE,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        CALL    A54C6           ; Koordinaten vergleichen und Ergebnis merken
        LD      HL,(S11AB)      ; Wert aus Speicher für linke X - Koordinate holen
        LD      DE,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        INC     HL
        INC     DE
A54C6:  PUSH    HL              ; Koordinate retten
        XOR     A               ; Carry - Flag zurücksetzen
        INC     HL
        SBC     HL,DE           ; Koordinaten vergleichen
        POP     HL              ; gerettete Koordinate holen
        RL      B               ; Ergebnis merken
        INC     DE
        EX      DE,HL
        SBC     HL,DE           ; Koordinaten vergleichen
        RL      B               ; Ergebnis merken
        RET
;
;
;   testen, ob noch Platz vorhanden und bereitgestellten PAINT - Datensatz merken
;
A54D5:  LD      DE,(S11A6)      ; Zeiger auf aktuelle PAINT - Werte holen
D54D9:  LD      HL,0            ; maximal nutzbare Adresse für Paint  (wird eingetragen)
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; mit aktueller Adresse vergleichen
        JR      NC,A54E6        ; Adresse ist OK -->  Datensatz merken
A54E1:  LD      SP,0            ; Stackpointer neu setzen   (Adresse wird eingetragen)
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET                     ; Kommando abbrechen
;
;
;   bereitgestellten Koordinaten - Datensatz für PAINT merken
;
A54E6:  LD      HL,S11AF        ; Zeiger auf Speicher mit PAINT - Datensatz
        LD      BC,7            ; Datensatzlänge
        LDIR                    ; einen PAINT - Datensatz merken
        LD      (S11A6),DE      ; Zeiger auf aktuellen Speicher für PAINT - Werte merken
        LD      HL,(S11A4)      ; Anzahl PAINT - Werte holen
        INC     HL              ; plus eins
        LD      (S11A4),HL      ; und wieder merken
        RET
;
;
;   Punkte von rechts bis Randpunkt setzen
;
A54FA:  LD      HL,(S11AF)      ; Y - Koordinate Graphic (PAINT) holen
        LD      DE,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        DEC     DE              ; X - Koordinate minus eins
        CALL    ADCH            ; absolute Graphic-Adresse und Bit-Nr. aus Koordinaten errechnen
        LD      DE,B45C0        ; Tabelle zum Setzen der rechten Bits nach Bit-Nummer
        PUSH    HL              ; Zeiger auf Graphic - Speicher merken
        LD      H,0             ; High - Byte Offset auf Null
        LD      L,A             ; Bit - Nummer im Graphic - Byte
        ADD     HL,DE           ; Zeiger auf richtiges Bitmuster errechnen
        INC     C               ; Differenz für Anzahl Bytes corrigieren
        LD      B,C             ; Anzahl zu testende Bytes merken
        LD      C,(HL)          ; Maske aus Tabelle holen
        POP     HL              ; Zeiger auf Graphic - Speicher holen
A5511:  CALL    S27D0           ; Abfrage, ob Punkte mit Palettenfarben gesetzt sind
        AND     C               ; testen, ob Rand im Byte liegt
        JR      NZ,A5528        ; Rand im Byte -->  nur fehlende Punkte setzen
        DI                      ; Interrupt sperren
        IN      A,(_CGVIN)      ; Zeichensatzrom und Video-RAM einschalten
        LD      (HL),C          ; Bits setzen
        IN      A,(_CGVOT)      ; Zeichensatzrom und Video-RAM ausschalten
        EI                      ; Interrupt wieder freigeben
        LD      C,11111111B     ; neue Setzmaske vorgeben
        DEC     HL              ; Zeiger auf Graphic - Speicher auf voriges Byte
        DJNZ    A5511           ; weitere Bytes behandeln
        LD      DE,-1
        JR      A554F
;
A5528:  LD      E,B             ; Restanzahl zu testende Bytes merken
        LD      B,7             ; maximal sieben Bit schieben
        LD      D,0             ; Vorgabe für Setzmaske
A552D:  RLC     A               ; ein Bit nach Carry schieben
        JR      C,A5536         ; Rand gefunden
        SCF                     ; Carry - Bit setzen
        RR      D               ; ein Bit für Setzmaske merken
        DJNZ    A552D           ; weiter nach Rand suchen
A5536:  IN      A,(_CGVIN)      ; Zeichensatzrom und Video-RAM einschalten
        LD      A,C             ; Originalsetzmaske holen
        AND     D               ; richtige Setzmaske errechnen
        LD      (HL),A          ; und nach Graphic - Speicher ausgeben
        IN      A,(_CGVOT)      ; Zeichensatzrom und Video-RAM ausschalten
        LD      A,E             ; Restanzahl zu testende Bytes holen
        DEC     A               ; corrigieren
        RLC     A
        RLC     A
        RLC     A
        LD      C,A
        LD      A,00000111B
        AND     C
        LD      D,A
        LD      A,11111000B
        AND     C
        OR      B
        LD      E,A
A554F:  XOR     A               ; Carry - Flag zurücksetzen
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        SBC     HL,DE
        RET
;
;
;   Programmvorgaben zur Abfrage, ob Punkte mit speziellem Palettenwert im Graphic-Speicher gesetzt sind
;
T5556:  PUSH    HL              ; Bildspeicheradresse auf Stack ablegen
        EXX
        POP     HL              ; Bildspeicheradresse holen
        DI                      ; Interrupt sperren
        IN      A,(_CGVIN)      ; Zeichensatzrom und Video-RAM einschalten
        LD      C,CRTCRF        ; Portnummer des Read-Format-Registers vorgeben
        XOR     A               ; Vorgabe für Ergebniswert
;
D555F:  LD      B,0             ; abzufragender Palettencode  (wird eingetragen)
        OUT     (C),B           ; an Bildschirm - Controller ausgeben
        OR      (HL)            ; merken, ob Punkt mit Palettencodewert gesetzt ist
;
        LD      E,A             ; Ergebnis merken
        IN      A,(_CGVOT)      ; Zeichensatzrom und Video-RAM ausschalten
        EI                      ; Interrupt sperren
        LD      A,E             ; gerettetetes Ergebnis holen
        EXX
        RET
;
;
;   X - Koordinaten im PAINT - Datensatz mit X - Koordinaten im PAINT - Wertsatz vergleichen
;
A556B:  LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        LD      E,(IY+2)        ;! linke X - Koordinate aus PAINT - Wert - Satz holen
        LD      D,(IY+3)        ;!
        INC     HL              ; PAINT - Datensatzkoordinate plus eins
        INC     DE              ; PAINT - Wert - Satzkoordinate plus eins
        XOR     A               ; Vorgabe für Ergebnis
        CALL    A5583           ; Koordinaten vergleichen
        LD      HL,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        LD      E,(IY+4)        ;! rechte X - Koordinate aus PAINT - Wert - Satz holen
        LD      D,(IY+5)        ;!
A5583:  SBC     HL,DE           ; Koordinaten vergleichen
        RLA                     ;! Ergebnis nach Accu retten
        RLA                     ;!
        RET     Z               ; Ergebnis gleich Null
        OR      00000001B       ; Code for 'Ergebnis <> 0' merken
        RET
;
        DEFS    629             ; kann nur von einem miserablem Linker kommen  (ist nicht genutzt)

;   Kaltstart  BASIC - Interpreter
;
_START: PUSH    BC              ; Auto - Run - Flag retten
        CALL    A585D           ; Bildschirm auf Standardwerte initialisieren
        POP     BC              ; Auto - Run - Flag holen
        LD      HL,BASIC_PGM    ; Zeiger auf Ende Basic - Interpreter
        LD      (TEXTST),HL     ; als Anfangsadresse für BASIC - Programm merken
        LD      HL,T586F        ; Warmstartadresse  BASIC
        LD      (SYSSTA),HL     ; als Start - Adresse für Basic - Interpreter merken
        LD      A,B             ; Auto - Run - Flag holen
        OR      A               ; gesetzt  ?
D5813:  JP      Z,A5825         ; nein -->  kein Auto - Run
        CP      1
        JR      Z,A5825
        LD      HL,B584D        ; Text  'RUN "AUTO RUN"'
        LD      DE,S1353        ; Zeiger auf Speicher für Funktionstastentext
        LD      BC,16           ; Länge Text
        LDIR                    ; Text übertragen
A5825:  LD      DE,IMDBUF       ; Zeiger auf Copyright - Meldung
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    5               ; Code 5  Text (DE) mit Groß-/Kleinschreibung ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    32              ; Code 32  Referenzton ausgeben
        LD      A,_JP           ; JP nn   (Z-80 - Befehl)
        LD      (D5813),A       ; in Routine eintragen
        LD      HL,T5837        ; Adresse für Start ohne Auto - Run
        LD      (D5813 + 1),HL  ; in Routine eintragen
T5837:  LD      HL,BASIC_PGM    ; Zeiger auf Anfang Speicher für Basic - Programm
A583A:  LD      (HL),0          ; ein Byte Speicher löschen
        INC     HL              ; Zeiger auf Speicher auf nächstes Byte
        LD      A,H             ; High - Byte Speicheradresse holen
        CP      XFF00/256       ; gleich High - Byte Speicherende  ?
        JR      C,A583A         ; nein -->  Rest Speicher löschen
        CALL    A616E           ; Zeiger auf Rechenspeicher merken
        CALL    A6180           ; alle BASIC - Werte löschen
        CALL    A755E           ; Cassettenroutinen und RS232 initialisieren
        JR      A5872           ; Warmstart  BASIC - Interpreter
;
;
;   Funktionstastentextvorgabe für Auto - Start
;
B584D:  DEFB    15
        DEFM    "RUN "
		DEFB    '"'
		DEFM    "AUTO RUN"
		DEFB    '"',CR
;
;
;   Bildschirm auf Standardwerte initialisieren
;
A585D:  LD      A,1             ; Bildschirm-Modus 1   (320 x 200 Punkte/4 Farben)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    80              ; Code 80  Bildschirmbetriebsart setzen
        XOR     A               ; Code for 'Punkte in angegebener Farbe setzen'
        LD      (PWMODE),A      ; als aktuellen Überschreibmodus merken
        INC     A               ; Accu auf eins
        LD      (S137A),A       ; Bildschirm - Modus - Nummer setzen
        LD      (S1379),A       ; Bildschirm - Modus - Bit setzen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    86              ; Code 86   Bildschirm initialisieren
        RET
;
;
;   Warmstart  BASIC - Interpreter
;
T586F:  CALL    A585D           ; Bildschirm auf Standardwerte initialisieren
;
;
;   Interpreter  Eingabe - Schleife
;
A5872:  LD      HL,A6403        ;  Anfangsadresse  BASIC - Fehlerbehandlung
        LD      (ERRORP),HL     ; als Fehlerbehandlungsadresse eintragen
A5878:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    2               ; Code 2  Zeilenvorschub, wenn Cursor nicht auf Anfang Zeile
        LD      DE,M63F0        ; Text  'Ready'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    5               ; Code 5  Text (DE) mit Groß-/Kleinschreibung ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    1               ; Code 1  Zeilenvorschub auf Bildschirm ausgeben
;
;
;   nächste Zeile von Tastatur holen und abarbeiten
;
A5881:  LD      A,(M63F6)       ; CONT - Flag holen
        OR      A               ; CONT möglich  ?
        JR      NZ,A5893        ; ja -->  Stack nicht verändern
        LD      SP,(INTFAC)     ; höchste nutzbare Basic - Adresse holen
        LD      HL,-1           ; Code for 'keine Werte auf Stack'
        PUSH    HL              ; auf Stack ablegen
        LD      (S9E64),SP      ; Stackpointer bei Anfang Befehl merken
A5893:  LD      HL,0            ; Code for 'in direkter Programmierung'
        LD      (S9E51),HL      ; als aktuelle Zeilennummer merken
        XOR     A               ; Accu auf Null
        LD      (CMTMSG),A      ; Textausgabeflag für Cassette zurücksetzen
        CALL    A611D           ; wenn im AUTO-Modus -->  Zeilennummer (und Zeile) ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    67              ; Code 67  Datei-Daten der Ausgabe-Datei bei Fehler löschen
        LD      DE,S11A4        ; Zeiger auf Speicher für Zeile vorgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    12              ; Code 12  Zeile von Tastatur nach Speicher (DE) holen
        JR      NC,NORINP       ; Eingabe nicht geBREAKt -->  Zeile abarbeiten
AUTOFF: LD      HL,S611C        ; Zeiger auf AUTO - Flag
        LD      A,(HL)          ; AUTO - Flag holen
        OR      A               ; im AUTO - Modus  ?
        LD      (HL),0          ; AUTO - Flag zurücksetzen
        JR      NZ,A5878        ; AUTO-Modus -->  Ready ausgeben und nächste Zeile abarbeiten
        JR      A5881           ; nächste Zeilen von Tastatur holen
;
;
;   eingegebenen Text auswerten und abarbeiten
;
NORINP: CALL    A79BC           ; Zeiger in DE auf nächstes relevantes Zeichen
        OR      A               ; Zeilenendezeichen  ?
        JR      Z,A5881         ; ja -->  nächste Zeilen von Tastatur holen
        CALL    A79F6           ; testen, ob Zeichen im Accu gleich Ziffer ist
        JP      NC,A5FAD        ; Ziffer -->  Zeile umsetzen in Zwischencode und merken
        LD      HL,IMDBUF       ; Pointer to temporary storage for tokenized line
        PUSH    HL              ; Zeiger auf Anfang Speicher merken
        CALL    CVIMTX          ; ASCII - Text - Zeile (DE) umsetzen in Zwischencode
        INC     HL              ; Zeilenendezeichen überspringen
        LD      (S9E4B),HL      ; Zeiger auf nächste Programmzeile merken
        CALL    A61C5           ; (HL)  Bereichsende  (00 00)  eintragen
        POP     HL              ; Get pointer to tokenized line
        JR      A58D4           ; Zeile abarbeiten
;
T58D1:  CALL    A797A           ; auf Syntax 'Befehlsende' überprüfen
;
;
;   Process token code line (HL).
;
A58D4:  LD      (S9E64),SP      ; Remember stack pointer at start of command
A58D8:  LD      DE,T58D1        ; Return address for end of command
        PUSH    DE              ; put on stack
A58DC:  LD      (S9E66),HL      ; Remember program pointer at start of command
        CALL    BRKCHK          ; Query whether Shift - BREAK is pressed
        JP      Z,BREAKZ        ; yes --> interrupt program
A58E5:  LD      A,(HL)          ; fetch next program byte
        INC     HL              ; Skip program byte
        CP      080H            ; token code ?
        JR      NC,A593F        ; yes --> Call command routine
        CP      '\''             ; comment ?
        JP      Z,A67FE         ; yes --> search for the end of the comment
        CP      ' '             ; spaces ?
        JR      Z,A58E5         ; yes --> get the next character and process it
        CP      ':'             ; colon ?
        JR      Z,A58DC         ; yes --> process next command
        OR      A               ; newline character ?
        JR      Z,A5906         ; yes --> fetch and process the next line
        DEC     HL              ; Set pointer back to program byte
        SUB     'A'             ;! Letter  ?
        CP      26              ;!
        JP      C,A650D         ; yes --> LET - routine
        JP      A6364           ; Error 1 Syntax error
;
;
;   nächste BASIC - Programm - Zeile holen und abarbeiten
;
A5906:  LD      HL,(S9E4B)      ; Get pointer to next program line
A5909:  LD      E,(HL)          ;! Get offset to next line
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      A,D             ;! Offset to next line equal to zero ?
        OR      E               ;!
        JR      Z,A5928         ; yes --> output any pending errors
        LD      (CMTMSG),A      ; Set text output flag cassette to output
        EX      DE,HL           ; Pointer to current line after DE
        ADD     HL,DE           ;! Calculate pointer to next program line
        DEC     HL              ;!
        LD      (S9E4B),HL      ; Remember pointer to next program line
        EX      DE,HL           ; Pointer to current line after HL
        INC     HL              ; Skip remainder offset
        CALL    LDDEMI          ; Get line number of line from program text
        LD      (S9E51),DE      ; remember as the current line number
        CALL    A61E4           ; if TRON --> output line number
        POP     DE              ; Discard return address
        JR      A58D4           ; process line
;
;
;   Program ended --> check whether there are still errors
;
A5928:  POP     HL              ; Rücksprungadresse vom Stack holen
        CALL    A596B           ; Abfrage, ob in direkter Programmierung
        JP      Z,A5878         ; ja -->  nächste Zeile von Tastatur holen
        XOR     A               ; Code for 'kein CONT möglich'
        LD      (M63F6),A       ; CONT - Flag zurücksetzen
        LD      A,(S9E54)       ; ON - ERROR - GOTO - Status holen
        CP      2               ; Code for 'Fehler aufgetreten'  ?
        JP      Z,A6391         ; ja -->  Fehler 20  Can't RESUME error
        PUSH    HL              ; Rücksprungadresse wieder ablegen
        JP      A60B9           ; END - Routine aufrufen
;
;
;   einen BASIC - Befehl abarbeiten
;
A593F:  CP      0FFH            ; prebyte table three ?
        JP      Z,A653F         ; yes --> examine for command in table three
        LD      DE,W5D1B        ; Pointer to address table commands table two
        CP      0FEH            ; prebyte table two ?
        JR      NZ,A594F        ; no --> process command from table one
        LD      A,(HL)          ; get actual token code
        INC     HL              ; Skip token code
        JR      A5957           ; Get the start address of the command from the table
;
A594F:  CP      0E0H            ; largest command in table one
        JP      NC,A6364        ; Function --> Error 1 Syntax error
        LD      DE,W5C5B        ; Pointer to address table commands table one
A5957:  ADD     A,A             ; token code times two
        PUSH    HL              ; Save program pointer
        EX      DE,HL           ; Pointer to address table according to HL
        LD      E,A             ;! Load DE with offset on table
        LD      D,0             ;!
        ADD     HL,DE           ; Calculate pointer to start address of command
        LD      A,(HL)          ;! Get the start address of the command from the table
        INC     HL              ;!
        LD      H,(HL)          ;!
        LD      L,A             ;!
        EX      (SP),HL         ; Get address on stack/program pointer
;
;
;   testen, ob nächstes Byte Befehlsendezeichen ist   (wenn ja -->  Zero gesetzt)
;
A5963:  CALL    HLFTCH          ; Leerzeichen  (Spaces)  (HL) überspringen
A5966:  OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja
        CP      ':'             ; Befehlsendezeichen  ?
        RET
;
;
;   Query whether in direct programming (if yes --> zero flag set)
;
A596B:  PUSH    HL              ; Keep register value
        LD      HL,(S9E51)      ; aktuelle Zeilennummer holen
        LD      A,L             ;! Zeilennummer gleich Null  (in direkter
        OR      H               ;!                            Programmierung)  ?
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;	Tables for converting the BASIC command words into the token code (TOKEN)
;
M5973:  DEFM    "GOT"           ; 128  GOTO
        DEFB    'O'+0x80
        DEFM    "GOSU"          ; 129  GOSUB
        DEFB    'B'+0x80
        DEFB    _free           ; 130  (free for GO)

        DEFM    "RU"            ; 131  RUN
        DEFB    'N'+0x80
        DEFM    "RETUR"         ; 132  RETURN
        DEFB    'N'+0x80
        DEFM    "RESTOR"        ; 133  RESTORE
        DEFB    'E'+0x80
        DEFM    "RESUM"         ; 134  RESUME
        DEFB    'E'+0x80
        DEFM    "LIS"           ; 135  LIST
        DEFB    'T'+0x80
        DEFB    _free           ; 136

        DEFM    "DELET"         ; 137  DELETE
        DEFB    'E'+0x80
        DEFM    "RENU"          ; 138  RENUM
        DEFB    'M'+0x80
        DEFM    "AUT"           ; 139  AUTO
        DEFB    'O'+0x80
        DEFM    "EDI"           ; 140  EDIT
        DEFB    'T'+0x80
        DEFM    "FO"            ; 141  FOR
        DEFB    'R'+0x80
        DEFM    "NEX"           ; 142  NEXT
        DEFB    'T'+0x80
        DEFM    "PRIN"          ; 143  PRINT
        DEFB    'T'+0x80
        DEFB    _free           ; 144

        DEFM    "INPU"          ; 145  INPUT
        DEFB    'T'+0x80
        DEFB    _free           ; 146

        DEFM    "I"             ; 147  IF
        DEFB    'F'+0x80
        DEFM    "DAT"           ; 148  DATA
        DEFB    'A'+0x80
        DEFM    "REA"           ; 149  READ
        DEFB    'D'+0x80
        DEFM    "DI"            ; 150  DIM
        DEFB    'M'+0x80
        DEFM    "RE"            ; 151  REM
        DEFB    'M'+0x80
        DEFM    "EN"            ; 152  END
        DEFB    'D'+0x80
        DEFM    "STO"           ; 153  STOP
        DEFB    'P'+0x80
        DEFM    "CON"           ; 154  CONT
        DEFB    'T'+0x80
        DEFM    "CL"            ; 155  CLS
        DEFB    'S'+0x80
        DEFB    _free           ; 156

        DEFM    "O"             ; 157  ON
        DEFB    'N'+0x80
        DEFM    "LE"            ; 158  LET
        DEFB    'T'+0x80
        DEFM    "NE"            ; 159  NEW
        DEFB    'W'+0x80
        DEFM    "POK"           ; 160  POKE
        DEFB    'E'+0x80
        DEFM    "OF"            ; 161  OFF
        DEFB    'F'+0x80
        DEFM    "PMOD"          ; 162  PMODE    (MODE on MZ-700)
        DEFB    'E'+0x80
        DEFM    "PSKI"          ; 163  PSKIP    (SKIP on MZ-700)
        DEFB    'P'+0x80
        DEFM    "PLO"           ; 164  PLOT
        DEFB    'T'+0x80
        DEFM    "PLIN"          ; 165  PLINE    (LINE on MZ-700)
        DEFB    'E'+0x80
        DEFM    "RLIN"          ; 166  RLINE
        DEFB    'E'+0x80
        DEFM    "PMOV"          ; 167  PMOVE    (MOVE on MZ-700)
        DEFB    'E'+0x80
        DEFM    "RMOV"          ; 168  RMOVE
        DEFB    'E'+0x80
        DEFM    "TRO"           ; 169  TRON
        DEFB    'N'+0x80
        DEFM    "TROF"          ; 170  TROFF
        DEFB    'F'+0x80
        DEFM    "INP"           ; 171  INP@
        DEFB    '@'+0x80
        DEFM    "DEFAUL"        ; 172  DEFAULT
        DEFB    'T'+0x80
        DEFM    "GE"            ; 173  GET
        DEFB    'T'+0x80
        DEFM    "PCOLO"         ; 174  PCOLOR
        DEFB    'R'+0x80
        DEFM    "PHOM"          ; 175  PHOME
        DEFB    'E'+0x80
        DEFM    "HSE"           ; 176  HSET
        DEFB    'T'+0x80
        DEFM    "GPRIN"         ; 177  GPRINT
        DEFB    'T'+0x80
        DEFM    "KE"            ; 178  KEY
        DEFB    'Y'+0x80
        DEFM    "AXI"           ; 179  AXIS
        DEFB    'S'+0x80
        DEFM    "LOA"           ; 180  LOAD
        DEFB    'D'+0x80
        DEFM    "SAV"           ; 181  SAVE
        DEFB    'E'+0x80
        DEFM    "MERG"          ; 182  MERGE
        DEFB    'E'+0x80
        DEFM    "CHAI"          ; 183  CHAIN
        DEFB    'N'+0x80
        DEFM    "CONSOL"        ; 184  CONSOLE
        DEFB    'E'+0x80
        DEFM    "SEARC"         ; 185  SEARCH
        DEFB    'H'+0x80
        DEFM    "OUT"           ; 186  OUT@
        DEFB    '@'+0x80
        DEFM    "PCIRCL"        ; 187  PCIRCLE  (CIRCLE on MZ-700)
        DEFB    'E'+0x80
        DEFM    "PTES"          ; 188  PTEST    (TEST on MZ-700)
        DEFB    'T'+0x80
        DEFM    "PAG"           ; 189  PAGE
        DEFB    'E'+0x80
        DEFM    "WAI"           ; 190  WAIT
        DEFB    'T'+0x80
        DEFM    "SWA"           ; 191  SWAP
        DEFB    'P'+0x80
        DEFB    _free           ; 192

        DEFM    "ERRO"          ; 193  ERROR
        DEFB    'R'+0x80
        DEFM    "ELS"           ; 194  ELSE
        DEFB    'E'+0x80
        DEFM    "US"            ; 195  USR
        DEFB    'R'+0x80
        DEFM    "BY"            ; 196  BYE
        DEFB    'E'+0x80
        DEFB    _free           ; 197

        DEFB    _free           ; 198

        DEFM    "DE"            ; 199  DEF
        DEFB    'F'+0x80
        DEFB    _free           ; 200

        DEFB    _free           ; 201

        DEFM    "LABE"          ; 202  LABEL
        DEFB    'L'+0x80
        DEFB    _free           ; 203

        DEFB    _free           ; 204

        DEFB    _free           ; 205

        DEFM    "WOPE"          ; 206  WOPEN
        DEFB    'N'+0x80
        DEFM    "CLOS"          ; 207  CLOSE
        DEFB    'E'+0x80
        DEFM    "ROPE"          ; 208  ROPEN
        DEFB    'N'+0x80
        DEFM    "XOPE"          ; 209  XOPEN
        DEFB    'N'+0x80
        DEFB    _free           ; 210

        DEFB    _free           ; 211

        DEFB    _free           ; 212

        DEFM    "DI"            ; 213  DIR
        DEFB    'R'+0x80
        DEFB    _free           ; 214

        DEFB    _free           ; 215

        DEFM    "RENAM"         ; 216  RENAME
        DEFB    'E'+0x80
        DEFM    "KIL"           ; 217  KILL
        DEFB    'L'+0x80
        DEFM    "LOC"           ; 218  LOCK
        DEFB    'K'+0x80
        DEFM    "UNLOC"         ; 219  UNLOCK
        DEFB    'K'+0x80
        DEFM    "INI"           ; 220  INIT
        DEFB    'T'+0x80
        DEFB    _free           ; 221

        DEFB    _free           ; 222

        DEFB    _free           ; 223           (RMOV on MZ-700)

        DEFM    "T"             ; 224  TO
        DEFB    'O'+0x80
        DEFM    "STE"           ; 225  STEP
        DEFB    'P'+0x80
        DEFM    "THE"           ; 226  THEN
        DEFB    'N'+0x80
        DEFM    "USIN"          ; 227  USING
        DEFB    'G'+0x80
        DEFB    _free           ; 228  (free for PI)

        DEFM    "AL"            ; 229  ALL
        DEFB    'L'+0x80
        DEFM    "TA"            ; 230  TAB
        DEFB    'B'+0x80
        DEFM    "SP"            ; 231  SPC
        DEFB    'C'+0x80
        DEFB    _free           ; 232

        DEFB    _free           ; 233

        DEFM    ".XO"           ; 234  XOR
        DEFB    'R'+0x80
        DEFM    ".O"            ; 235  OR
        DEFB    'R'+0x80
        DEFM    ".AN"           ; 236  AND
        DEFB    'D'+0x80
        DEFM    ".NO"           ; 237  NOT
        DEFB    'T'+0x80
        DEFM    ">"             ; 238  ><
        DEFB    '<'+0x80
        DEFM    "<"             ; 239  <>
        DEFB    '>'+0x80
        DEFM    "="             ; 240  =<
        DEFB    '<'+0x80
        DEFM    "<"             ; 241  <=
        DEFB    '='+0x80
        DEFM    "="             ; 242  =>
        DEFB    '>'+0x80
        DEFM    ">"             ; 243  >=
        DEFB    '='+0x80
        DEFB    '='+0x80        ; 244  =

        DEFB    '>'+0x80        ; 245  >

        DEFB    '<'+0x80        ; 246  <

        DEFB    '+'+0x80        ; 247  +

        DEFB    '-'+0x80        ; 248  -

        DEFB    0x7D+0x80       ; 249  (Backslash)

        DEFM    ".MO"           ; 250  MOD
        DEFB    'D'+0x80
        DEFB    '/'+0x80        ; 251  /

        DEFB    '*'+0x80        ; 252  *

        DEFB    '^'+0x80        ; 253  ^
        DEFB    -1              ; 'End of table'
;
;
;   Tabelle mit BASIC - Befehlswörtern mit Vorbyte 0FEH im Zwischencode
;
M5B16:  DEFB    _free           ; 254 128

        DEFM    "CSE"           ; 254 129  CSET     (SET   on MZ-700)
        DEFB    'T'+0x80
        DEFM    "CRESE"         ; 254 130  CRESET   (RESET on MZ-700)
        DEFB    'T'+0x80
        DEFM    "CCOLO"         ; 254 131  CCOLOR   (COLOR on MZ-700)
        DEFB    'R'+0x80
        DEFB    _free           ; 254 132

        DEFB    _free           ; 254 133

        DEFB    _free           ; 254 134  (free for VARLEN)

        DEFB    _free           ; 254 135  (free for MAXDIM)

        DEFB    _free           ; 254 136

        DEFB    _free           ; 254 137

        DEFM    "SOUN"          ; 254 138  SOUND
        DEFB    'D'+0x80
        DEFB    _free           ; 254 139

        DEFM    "NOIS"          ; 254 140  NOISE
        DEFB    'E'+0x80
        DEFM    "BEE"           ; 254 141  BEEP
        DEFB    'P'+0x80
        DEFB    _free           ; 254 142  (free for VOICE)

        DEFB    _free           ; 254 143  (free for BORDER)

        DEFM    "COLO"          ; 254 144  COLOR
        DEFB    'R'+0x80
        DEFB    _free           ; 254 145  (free for PRTY)

        DEFM    "SE"            ; 254 146  SET
        DEFB    'T'+0x80
        DEFM    "RESE"          ; 254 147  RESET
        DEFB    'T'+0x80
        DEFM    "LIN"           ; 254 148  LINE
        DEFB    'E'+0x80
        DEFM    "BLIN"          ; 254 149  BLINE
        DEFB    'E'+0x80
        DEFM    "PA"            ; 254 150  PAL
        DEFB    'L'+0x80
        DEFM    "CIRCL"         ; 254 151  CIRCLE
        DEFB    'E'+0x80
        DEFM    "BO"            ; 254 152  BOX
        DEFB    'X'+0x80
        DEFM    "PAIN"          ; 254 153  PAINT
        DEFB    'T'+0x80
        DEFM    "POSITIO"       ; 254 154  POSITION
        DEFB    'N'+0x80
        DEFM    "PATTER"        ; 254 155  PATTERN
        DEFB    'N'+0x80
        DEFM    "HCOP"          ; 254 156  HCOPY
        DEFB    'Y'+0x80
        DEFB    _free           ; 254 157  (free for KPATTERN)

        DEFB    _free           ; 254 158  (free for FPRINT)

        DEFB    _free           ; 254 159  (free for TCOPY)

        DEFM    "SYMBO"         ; 254 160  SYMBOL
        DEFB    'L'+0x80
        DEFB    _free           ; 254 161

        DEFM    "MUSI"          ; 254 162  MUSIC
        DEFB    'C'+0x80
        DEFM    "TEMP"          ; 254 163  TEMPO
        DEFB    'O'+0x80
        DEFM    "CURSO"         ; 254 164  CURSOR
        DEFB    'R'+0x80
        DEFM    "VERIF"         ; 254 165  VERIFY
        DEFB    'Y'+0x80
        DEFM    "CL"            ; 254 166  CLR
        DEFB    'R'+0x80
        DEFM    "LIMI"          ; 254 167  LIMIT
        DEFB    'T'+0x80
        DEFB    _free           ; 254 168

        DEFB    _free           ; 254 169

        DEFB    _free           ; 254 170

        DEFB    _free           ; 254 171

        DEFB    _free           ; 254 172

        DEFB    _free           ; 254 173

        DEFM    "BOO"           ; 254 174  BOOT
        DEFB    'T'+0x80
        DEFB    -1              ; 'End of table'

;
;
;   Tabelle mit BASIC - Befehlswörtern mit Vorbyte 0FFH im Zwischencode
;
M5BAD:  DEFM    "IN"            ; 255 128  INT
        DEFB    'T'+0x80
        DEFM    "AB"            ; 255 129  ABS
        DEFB    'S'+0x80
        DEFM    "SI"            ; 255 130  SIN
        DEFB    'N'+0x80
        DEFM    "CO"            ; 255 131  COS
        DEFB    'S'+0x80
        DEFM    "TA"            ; 255 132  TAN
        DEFB    'N'+0x80
        DEFM    "L"             ; 255 133  LN
        DEFB    'N'+0x80
        DEFM    "EX"            ; 255 134  EXP
        DEFB    'P'+0x80
        DEFM    "SQ"            ; 255 135  SQR
        DEFB    'R'+0x80
        DEFM    "RN"            ; 255 136  RND
        DEFB    'D'+0x80
        DEFM    "PEE"           ; 255 137  PEEK
        DEFB    'K'+0x80
        DEFM    "AT"            ; 255 138  ATN
        DEFB    'N'+0x80
        DEFM    "SG"            ; 255 139  SGN
        DEFB    'N'+0x80
        DEFM    "LO"            ; 255 140  LOG
        DEFB    'G'+0x80
        DEFM    "FRA"           ; 255 141  FRAC
        DEFB    'C'+0x80
        DEFM    "PA"            ; 255 142  PAI
        DEFB    'I'+0x80
        DEFM    "RA"            ; 255 143  RAD
        DEFB    'D'+0x80
        DEFB    _free           ; 255 144

        DEFB    _free           ; 255 145

        DEFB    _free           ; 255 146

        DEFB    _free           ; 255 147

        DEFB    _free           ; 255 148

        DEFB    _free           ; 255 149

        DEFB    _free           ; 255 150

        DEFB    _free           ; 255 151

        DEFB    _free           ; 255 152

        DEFB    _free           ; 255 153

        DEFB    _free           ; 255 154

        DEFB    _free           ; 255 155

        DEFM    "STIC"          ; 255 156  STICK
        DEFB    'K'+0x80
        DEFM    "STRI"          ; 255 157  STRIG
        DEFB    'G'+0x80
        DEFB    _free           ; 255 158  (free for JOY)

        DEFB    _free           ; 255 159

        DEFM    "CHR"           ; 255 160  CHR$
        DEFB    '$'+0x80
        DEFM    "STR"           ; 255 161  STR$
        DEFB    '$'+0x80
        DEFM    "HEX"           ; 255 162  HEX$
        DEFB    '$'+0x80
        DEFB    _free           ; 255 163

        DEFB    _free           ; 255 164

        DEFB    _free           ; 255 165

        DEFB    _free           ; 255 166

        DEFB    _free           ; 255 167

        DEFM    "SPACE"         ; 255 168  SPACE$
        DEFB    '$'+0x80
        DEFB    _free           ; 255 169  (free for ASCCHR$)

        DEFB    _free           ; 255 170

        DEFM    "AS"            ; 255 171  ASC
        DEFB    'C'+0x80
        DEFM    "LE"            ; 255 172  LEN
        DEFB    'N'+0x80
        DEFM    "VA"            ; 255 173  VAL
        DEFB    'L'+0x80
        DEFB    _free           ; 255 174

        DEFB    _free           ; 255 175

        DEFB    _free           ; 255 176

        DEFB    _free           ; 255 177

        DEFB    _free           ; 255 178  (free for HEXCHR$)

        DEFM    "ER"            ; 255 179  ERN
        DEFB    'N'+0x80
        DEFM    "ER"            ; 255 180  ERL
        DEFB    'L'+0x80
        DEFM    "SIZ"           ; 255 181  SIZE
        DEFB    'E'+0x80
        DEFM    "CSR"           ; 255 182  CSRH
        DEFB    'H'+0x80
        DEFM    "CSR"           ; 255 183  CSRV
        DEFB    'V'+0x80
        DEFM    "POS"           ; 255 184  POSH
        DEFB    'H'+0x80
        DEFM    "POS"           ; 255 185  POSV
        DEFB    'V'+0x80
        DEFM    "LEFT"          ; 255 186  LEFT$
        DEFB    '$'+0x80
        DEFM    "RIGHT"         ; 255 187  RIGHT$
        DEFB    '$'+0x80
        DEFM    "MID"           ; 255 188  MID$
        DEFB    '$'+0x80
        DEFB    _free           ; 255 189  (free for FONT$)

        DEFB    _free           ; 255 190

        DEFB    _free           ; 255 191

        DEFB    _free           ; 255 192

        DEFB    _free           ; 255 193

        DEFB    _free           ; 255 194

        DEFB    _free           ; 255 195

        DEFM    "TI"            ; 255 196  TI$
        DEFB    '$'+0x80
        DEFM    "POIN"          ; 255 197  POINT
        DEFB    'T'+0x80
        DEFM    "EO"            ; 255 198  EOF
        DEFB    'F'+0x80
        DEFM    "F"             ; 255 199  FN
        DEFB    'N'+0x80
        DEFB    -1              ; 'End of table'
;
;
;   Tabelle mit Anfangsadressen der Befehle ohne Vorbyte
;
W5C5B:  DEFW    A69AF           ; 128  GOTO
        DEFW    A692A           ; 129  GOSUB
        DEFW    A6364           ; 130  (frei für GO)
        DEFW    A606E           ; 131  RUN
        DEFW    A68F9           ; 132  RETURN
        DEFW    A6E9E           ; 133  RESTORE
        DEFW    A64B6           ; 134  RESUME
        DEFW    A6A9D           ; 135  LIST
        DEFW    A6364           ; 136
        DEFW    A620C           ; 137  DELETE
        DEFW    A62AB           ; 138  RENUM
        DEFW    A60CA           ; 139  AUTO
        DEFW    A6125           ; 140  EDIT
        DEFW    A6602           ; 141  FOR
        DEFW    A6699           ; 142  NEXT
        DEFW    A6C9F           ; 143  PRINT
        DEFW    A6364           ; 144
        DEFW    INPUT           ; 145  INPUT
        DEFW    A6364           ; 146
        DEFW    A69C2           ; 147  IF
        DEFW    A67FE           ; 148  DATA
        DEFW    READ            ; 149  READ
        DEFW    A8DCC           ; 150  DIM
        DEFW    A67FE           ; 151  REM
        DEFW    A60B9           ; 152  END
        DEFW    A6468           ; 153  STOP
        DEFW    A6499           ; 154  CONT
        DEFW    A7972           ; 155  CLS
        DEFW    A6364           ; 156
        DEFW    A6952           ; 157  ON
        DEFW    A650D           ; 158  LET
        DEFW    A618E           ; 159  NEW
        DEFW    A68A1           ; 160  POKE
        DEFW    A6364           ; 161  OFF
        DEFW    AA017           ; 162  PMODE    (MODE bei MZ-700)
        DEFW    AA07C           ; 163  PSKIP    (SKIP bei MZ-700)
        DEFW    AA42A           ; 164  PLOT
        DEFW    AA0BE           ; 165  PLINE    (LINE bei MZ-700)
        DEFW    AA0C1           ; 166  RLINE
        DEFW    AA0C4           ; 167  PMOVE    (MOVE bei MZ-700)
        DEFW    AA0C7           ; 168  RMOVE
        DEFW    A61CC           ; 169  TRON
        DEFW    A61DF           ; 170  TROFF
        DEFW    A681F           ; 171  INP@
        DEFW    A6F41           ; 172  DEFAULT
        DEFW    A686C           ; 173  GET
        DEFW    AA12C           ; 174  PCOLOR
        DEFW    AA161           ; 175  PHOME
        DEFW    AA164           ; 176  HSET
        DEFW    AA16F           ; 177  GPRINT
        DEFW    A6B84           ; 178  KEY
        DEFW    AA1D7           ; 179  AXIS
        DEFW    A6FFD           ; 180  LOAD
        DEFW    A73C0           ; 181  SAVE
        DEFW    A7068           ; 182  MERGE
        DEFW    A7053           ; 183  CHAIN
        DEFW    A6A61           ; 184  CONSOLE
        DEFW    A6A9B           ; 185  SEARCH
        DEFW    A680A           ; 186  OUT@
        DEFW    AA217           ; 187  PCIRCLE  (CIRCLE bei MZ-700)
        DEFW    AA3E5           ; 188  PTEST    (TEST bei MZ-700)
        DEFW    AA3F3           ; 189  PAGE
        DEFW    A67EE           ; 190  WAIT
        DEFW    A74A6           ; 191  SWAP
        DEFW    A6364           ; 192
        DEFW    A63F8           ; 193  ERROR
        DEFW    A69E4           ; 194  ELSE
        DEFW    A67A4           ; 195  USR
        DEFW    A6A59           ; 196  BYE
        DEFW    A6364           ; 197
        DEFW    A6364           ; 198
        DEFW    A6C31           ; 199  DEF
        DEFW    A6364           ; 200
        DEFW    A6364           ; 201
        DEFW    A67FE           ; 202  LABEL
        DEFW    A6364           ; 203
        DEFW    A6364           ; 204
        DEFW    A6364           ; 205
        DEFW    A6F59           ; 206  WOPEN
        DEFW    B6F8A           ; 207  CLOSE
        DEFW    A6F56           ; 208  ROPEN
        DEFW    A6F5C           ; 209  XOPEN
        DEFW    A6364           ; 210
        DEFW    A6364           ; 211
        DEFW    A6364           ; 212
        DEFW    A7424           ; 213  DIR
        DEFW    A6364           ; 214
        DEFW    A6364           ; 215
        DEFW    A744B           ; 216  RENAME
        DEFW    A6F8B           ; 217  KILL
        DEFW    A7418           ; 218  LOCK
        DEFW    A7416           ; 219  UNLOCK
        DEFW    A6F47           ; 220  INIT
        DEFW    A6364           ; 221
        DEFW    A6364           ; 222
        DEFW    A6364           ; 223
;
;
;   Tabelle mit Anfangsadressen der Routinen mit Vorbyte 0FEH
;
W5D1B:  DEFW    A6364           ; 254 128
        DEFW    A6364           ; 254 129  CSET
        DEFW    A6364           ; 254 130  CRESET
        DEFW    A6364           ; 254 131  CCOLOR
        DEFW    A6364           ; 254 132
        DEFW    A6364           ; 254 133
        DEFW    A6364           ; 254 134
        DEFW    A6364           ; 254 135
        DEFW    A6364           ; 254 136
        DEFW    A6364           ; 254 137
        DEFW    A9BAC           ; 254 138  SOUND
        DEFW    A6364           ; 254 139
        DEFW    A9BE3           ; 254 140  NOISE
        DEFW    A6A56           ; 254 141  BEEP
        DEFW    A6364           ; 254 142
        DEFW    A6364           ; 254 143
        DEFW    A7675           ; 254 144  COLOR
        DEFW    A6364           ; 254 145
        DEFW    B7592           ; 254 146  SET
        DEFW    A7593           ; 254 147  RESET
        DEFW    B75A1           ; 254 148  LINE
        DEFW    A75A2           ; 254 149  BLINE
        DEFW    A7619           ; 254 150  PAL
        DEFW    A774C           ; 254 151  CIRCLE
        DEFW    A7648           ; 254 152  BOX
        DEFW    A76FD           ; 254 153  PAINT
        DEFW    A75F5           ; 254 154  POSITION
        DEFW    A75C4           ; 254 155  PATTERN
        DEFW    A7968           ; 254 156  HCOPY
        DEFW    A6364           ; 254 157
        DEFW    A6364           ; 254 158
        DEFW    A6364           ; 254 159
        DEFW    A790F           ; 254 160  SYMBOL
        DEFW    A6364           ; 254 161
        DEFW    A9BE6           ; 254 162  MUSIC
        DEFW    A9BD9           ; 254 163  TEMPO
        DEFW    A683B           ; 254 164  CURSOR
        DEFW    A73A9           ; 254 165  VERIFY
        DEFW    A619B           ; 254 166  CLR
        DEFW    A68B5           ; 254 167  LIMIT
        DEFW    A6364           ; 254 168
        DEFW    A6364           ; 254 169
        DEFW    A6364           ; 254 170
        DEFW    A6364           ; 254 171
        DEFW    A6364           ; 254 172
        DEFW    A6364           ; 254 173
        DEFW    A6A95           ; 254 174  BOOT
;
;
;   Tabelle mit Anfangsadressen der Routinen für Funktionen mit Vorbyte 0FFH
;
W5D79:  DEFW    A95C2           ; 255 128  INT
        DEFW    A95BD           ; 255 129  ABS
        DEFW    A9709           ; 255 130  SIN
        DEFW    A96F9           ; 255 131  COS
        DEFW    A97E8           ; 255 132  TAN
        DEFW    A9A4F           ; 255 133  LN
        DEFW    A992B           ; 255 134  EXP
        DEFW    A961F           ; 255 135  SQR
        DEFW    A98E6           ; 255 136  RND
        DEFW    A98DA           ; 255 137  PEEK
        DEFW    A963D           ; 255 138  ATN
        DEFW    A98A0           ; 255 139  SGN
        DEFW    A9A43           ; 255 140  LOG
        DEFW    A7BC0           ; 255 141  FRAC
        DEFW    A98B8           ; 255 142  PAI
        DEFW    A98B3           ; 255 143  RAD
        DEFW    A6364           ; 255 144
        DEFW    A6364           ; 255 145
        DEFW    A6364           ; 255 146
        DEFW    A6364           ; 255 147
        DEFW    A6364           ; 255 148
        DEFW    A6364           ; 255 149
        DEFW    A6364           ; 255 150
        DEFW    A6364           ; 255 151
        DEFW    A6364           ; 255 152
        DEFW    A6364           ; 255 153
        DEFW    A6364           ; 255 154
        DEFW    A6364           ; 255 155
        DEFW    A9060           ; 255 156  STICK
        DEFW    A907F           ; 255 157  STRIG
        DEFW    A6364           ; 255 158
        DEFW    A6364           ; 255 159
        DEFW    A6364           ; 255 160  CHR$
        DEFW    A8931           ; 255 161  STR$
        DEFW    A88F0           ; 255 162  HEX$
        DEFW    A6364           ; 255 163
        DEFW    A6364           ; 255 164
        DEFW    A6364           ; 255 165
        DEFW    A6364           ; 255 166
        DEFW    A6364           ; 255 167
        DEFW    A8913           ; 255 168  SPACE$
        DEFW    A6364           ; 255 169
        DEFW    A6364           ; 255 170
        DEFW    A8992           ; 255 171  ASC
        DEFW    A899C           ; 255 172  LEN
        DEFW    A89A4           ; 255 173  VAL
        DEFW    A6364           ; 255 174
        DEFW    A6364           ; 255 175
        DEFW    A6364           ; 255 176
        DEFW    A6364           ; 255 177
        DEFW    A6364           ; 255 178
        DEFW    A887A           ; 255 179  ERN
        DEFW    A8888           ; 255 180  ERL
        DEFW    A8852           ; 255 181  SIZE
        DEFW    A8864           ; 255 182  CSRH
        DEFW    A8869           ; 255 183  CSRV
        DEFW    A886E           ; 255 184  POSH
        DEFW    A8874           ; 255 185  POSV
        DEFW    A89B6           ; 255 186  LEFT$
        DEFW    A89D3           ; 255 187  RIGHT$
        DEFW    A89F0           ; 255 188  MID$
        DEFW    A6364           ; 255 189
        DEFW    A6364           ; 255 190
        DEFW    A6364           ; 255 191
        DEFW    A6364           ; 255 192
        DEFW    A6364           ; 255 193
        DEFW    A6364           ; 255 194
        DEFW    A6364           ; 255 195
        DEFW    A8A46           ; 255 196  TI$
        DEFW    A896C           ; 255 197  POINT
        DEFW    A893F           ; 255 198  EOF
        DEFW    A8FBF           ; 255 199  FN
        DEFW    A6364           ; 255 200
        DEFW    A6364           ; 255 201
        DEFW    A6364           ; 255 202
        DEFW    A6364           ; 255 203
        DEFW    A6364           ; 255 204
        DEFW    A6364           ; 255 205
        DEFW    A6364           ; 255 206
        DEFW    A6364           ; 255 207
;
;
;   Zeiger auf Zeile nach Programmtext (HL) nach DE bereitstellen
;
A5E19:  CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    _LIN_P          ; Code for 'Zeiger auf Zeile'  ?
        JR      NZ,A5E25        ; nicht Zeiger auf Zeile
        CALL    LDDEMI          ; Zeiger auf Zeile aus Programmtext nach DE holen
        OR      0FFH            ; Carry- und Zero - Flag zurücksetzen
        RET
;
A5E25:  INC     HL              ; Programmbyte überspringen
        CP      _LINNO          ; Code for 'Integer - Zeilennummer'  ?
        JR      NZ,A5E49        ; nein -->  auf Labelnamen testen
        LD      E,(HL)          ;! Zeilennummer aus Programmtext holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL
        LD      A,E             ;! Zeilennummer gleich Null  ?
        OR      D               ;!
        RET     Z               ; ja
        EX      DE,HL           ; Zeilennummer nach HL
        CALL    A5E78           ; Zeiger auf Zeile nach Zeilennummer in HL bereitstellen
        JP      C,A6385         ; Zeile nicht gefunden -->  Fehler 16  Un def. line error
        EX      DE,HL           ; Zeiger auf Zeile nach DE
        DEC     HL              ; Programmzeiger auf Stelle für Zeiger auf Zeile
        LD      (HL),D          ;! Zeiger auf Zeile anstatt Zeilennummer im
        DEC     HL              ;! Programmtext eintragen (braucht beim nächsten
        LD      (HL),E          ;!                         mal nicht mehr gesucht werden)
        DEC     HL
        LD      (HL),_LIN_P     ; Code for 'Zeiger auf Zeile'  in Programmtext eintragen
        INC     HL              ; Code überspringen
        INC     HL              ;! Zeiger auf Zeile überspringen
        INC     HL              ;!
        OR      0FFH            ; Carry - und Zero - FLag zurücksetzen
        LD      (S5FAC),A       ; Zeilen-Nummern-Flag auf 'Zeiger auf Zeile vorhanden'
        RET
;
A5E49:  CP      '\"'            ; Code for 'Label'  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
        LD      (D5EBE + 1),HL  ; Zeiger auf Label in Routine eintragen
        LD      B,0             ; Vorgabe für Labellänge
A5E53:  LD      A,(HL)          ; ein Zeichen Labelname holen
        OR      A               ; Zeilenendezeichen  ?
        JR      Z,A5E5F         ; ja -->  Länge Labelname untersuchen
        INC     HL              ; Zeichen des Labelnamens überspringen
        CP      '\"'            ; Labelendezeichen  ?
        JR      Z,A5E5F         ; ja -->  Länge Labelname untersuchen
        INC     B               ; Länge Labelname plus eins
        JR      A5E53           ; Ende Labelname suchen
;
A5E5F:  LD      A,B             ; Länge Labelname holen
        OR      A               ; gleich Null  ?
        JP      Z,A6364         ; ja -->  Fehler 1  Syntax error
        LD      (D5EBC + 1),A   ; Länge Labelname in Routine eintragen
        EX      DE,HL           ; Programmzeiger nach DE
        CALL    A5E72           ; Zeiger auf Zeile nach Labelnamen bereitstellen
        JP      C,A6385         ; Zeile nicht gefunden -->  Fehler 16   Un def. line error
        EX      DE,HL           ; Programmzeiger nach HL/Zeiger auf Zeile nach DE
        OR      0FFH            ; Carry- und Zero - Flag zurücksetzen
        RET
;
;
;   Zeiger auf Zeile nach bereitgestelltem Labelnamen bereitstellen
;
A5E72:  PUSH    BC              ; Keep register value
        LD      BC,T5EAB        ; Adresse  'auf LABEL - Namen vergleichen'
        JR      A5E7C           ; richtige Zeile suchen
;
;
;   Zeiger auf Zeile nach Zeilennummer in HL bereitstellen
;
A5E78:  PUSH    BC              ; Keep register value
        LD      BC,T5E9F        ; Adresse  'auf Zeilennummer vergleichen'
A5E7C:  LD      (D5E91 + 1),BC  ; Adresse in Routine eintragen
        PUSH    DE              ; Keep register value
        EX      DE,HL           ; zu suchende Zeilennummer nach DE
        LD      HL,(TEXTST)     ; Anfangsadresse für BASIC - Programm holen
A5E85:  LD      C,(HL)          ;! Offset auf nächste Zeile aus Basic - Programm
        INC     HL              ;! holen
        LD      B,(HL)          ;!
        LD      A,B             ;! Offset gleich Null  ?
        OR      C               ;!
        SCF                     ; Code for 'Zeile nicht gefunden'  setzen
        JR      Z,A5E9C         ; Programmende -->  gerettete Register - Werte holen
        DEC     HL              ; Zeiger wieder auf Anfang Zeile
        PUSH    HL              ; Zeiger auf Anfang Zeile merken
        ADD     HL,BC           ; Zeiger auf nächste Zeile errechnen
        EX      (SP),HL         ; Zeiger merken / Zeiger auf aktuelle Zeile holen
D5E91:  CALL    0               ; auf Zeilennummer oder Label vergleichen
        JR      C,A5E9B         ; Zeilennummer größer als zu suchende Zeilennummer
        JR      Z,A5E9B         ; Zeile gefunden -->  gerettete Register - Werte holen
        POP     HL              ; Zeiger auf nächte Zeile holen
        JR      A5E85           ; nächste Zeile untersuchen
;
A5E9B:  POP     DE              ; Zeiger auf nächste Zeile verwerfen
A5E9C:  POP     DE              ;! gerettete Register - Werte holen
        POP     BC              ;!
        RET
;
;
;   auf zu suchende Zeilennummer vergleichen
;
T5E9F:  INC     HL              ;! Offset auf nächste Zeile überspringen
        INC     HL              ;!
        INC     HL              ; Zeiger auf High - Byte Zeilennummer
        LD      A,D             ; High - Byte zu suchende Zeilennummer
        CP      (HL)            ; mit High - Byte aktuelle Zeilennummer vergleichen
        RET     NZ              ; Bytes nicht gleich
        DEC     HL              ; Zeiger auf Low - Byte Zeilennummer
        LD      A,E             ; Low - Byte zu suchende Zeilennummer holen
        CP      (HL)            ; mit Low - Byte aktueller Zeilennummer vergleichen
        DEC     HL              ;! Zeiger auf Zeile wieder auf Anfang Zeile
        DEC     HL              ;!
        RET
;
;
;   auf LABEL und Labelnamen vergleichen
;
T5EAB:  PUSH    HL              ; Zeiger auf Anfang Zeile retten
        INC     HL              ;! Offset auf nächste Zeile überspringen
        INC     HL              ;!
        INC     HL              ;! Zeilennummer überspringen
        INC     HL              ;!
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    _LABEL          ; LABEL   (Zwischencode)  ?
        JR      NZ,A5ECF        ; nicht LABEL -->  geretteten Register - Wert holen
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    '\"'            ; Anfang Labelname  ?
        JR      NZ,A5ECF        ; kein Label - Namen - Anfangszeichen
D5EBC:  LD      B,0             ; Länge Labelname   (wird eingetragen)
D5EBE:  LD      DE,0            ; Zeiger auf Labelnamen   (wird eingetragen)
A5EC1:  LD      A,(DE)          ; ein Zeichen vorgegebener Labelname
        CP      (HL)            ; mit einem Zeichen Labelname in Zeile vergleichen
        JR      NZ,A5ECF        ; Zeichen nicht gleich -->  geretteten Register - Wert holen
        INC     HL              ; Zeiger auf Labelnamen in Programmzeile
        INC     DE              ; Zeiger auf vorgegebenen Labelnamen
        DJNZ    A5EC1           ; weitere Zeichen Labelname vergleichen
        LD      A,(HL)          ; letztes Zeichen Labelname aus Programmzeile holen
        CP      '\"'            ; gleich  'Ende  Labelname'  ?
        JR      Z,A5ECF         ; ja -->  geretteten Register - Wert holen
        OR      A               ; Zero-Flag zurücksetzen, wenn nicht Zeilenendezeichen
A5ECF:  SCF                     ;! Carry - Flag zurücksetzen
        CCF                     ;!
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;   Anfangs- und Endzeilennummer aus Programmtext bereitstellen
;
A5ED3:  LD      DE,0            ; Vorgabe für Anfangszeilennummer
        LD      BC,65535        ; Vorgabe für Endzeilennummer
        CALL    A5F15           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        RET     Z               ; keine Zeilennummer angegeben
        CP      '-'             ; -   (bis)
        JR      Z,A5EFD         ; ja -->  keine Anfangszeilennummer angegeben
        CP      '.'             ; .   (letzte Zeilennummer)  ?
        LD      DE,(S9E4D)      ; Get editor line number 
        JR      Z,A5EF0         ; ja -->  noch auf Endzeilennummer untersuchen
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    _LINNO          ; Code for 'Integer - Zeilennummer'
        LD      E,(HL)          ;! Anfangszeilennummer aus Programmtext holen
        INC     HL              ;!
        LD      D,(HL)          ;!
A5EF0:  INC     HL              ; ausgewertetes Programmbyte überspringen
        CALL    A5F15           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A5EFA         ; Befehlsende -->  Anfangszeilennr. als Endzeilennummer
        CP      '-'             ; -   (bis)   ?
        JR      Z,A5EFD         ; ja -->  untersuchen, ob Endzeilennummer
A5EFA:  LD      C,E             ;! Anfangszeilennummer als Endzeilennummer
        LD      B,D             ;!
        RET
;
A5EFD:  INC     HL              ; ausgewertetes Programmbyte überspringen
        CALL    A5F15           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        RET     Z               ; ja -->  fertig
        CP      '.'             ; .   (letzte Zeilennummer)  ?
        JR      NZ,A5F0C        ; nein
        LD      BC,(S9E4D)      ; Get editor line number 
        INC     HL              ; Punkt überspringen
        RET
;
A5F0C:  CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    _LINNO          ; Code for 'Integer - Zeilennummer'  ?
        LD      C,(HL)          ;! Endzeilennummer aus Programmtext holen
        INC     HL              ;!
        LD      B,(HL)          ;!
        INC     HL              ;!
        RET
;
;
;   überprüfen, ob Zeichen (HL) gleich Befehlsende oder Ende Zeilennummer ist
;
A5F15:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        RET     Z               ; Befehlsendezeichen
        CP      ','             ; Komma  ?
        RET
;
;
;   Zeilennummern im Programm in Zeiger auf Zeile umsetzen
;
A5F1C:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      A,-1            ; Code for 'Zeiger auf Zeile im Text'
        LD      (S5FAC),A       ; im Zeilen - Nummer - Flag merken
        LD      HL,T5F72        ; Adresse  'Zeilennummer umsetzen in Zeiger auf Zeile'
        JR      A5F3B           ; Programm durchforsten und Zeilennummern umsetzen
;
;
;   Zeiger auf Zeilen im Programm in Zeilennummern umsetzen
;
A5F29:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        CALL    A60A2           ; alle Statusflags zurücksetzen
A5F2F:  LD      A,(S5FAC)       ; Zeilen - Nummern - Flag holen
        OR      A               ; nur Zeilennummern  ?
        RET     Z               ; ja -->  fertig
        XOR     A               ; Code for 'nur Zeilennummern'
        LD      (S5FAC),A       ; im Zeilen - Nummern - Flag merken
        LD      HL,T5F58        ; Adresse  'Zeiger umsetzen in Zeilennummer'
A5F3B:  LD      (D5F55 + 1),HL  ; Adresse in Routine eintragen
        LD      HL,(TEXTST)     ; Anfangsadresse des BASIC - Programms holen
        DEC     HL
A5F42:  INC     HL
        LD      A,(HL)          ;! Offset auf nächste Zeile vorhanden  ?
        INC     HL              ;!
        OR      (HL)            ;!
        RET     Z               ; nein -->  Programmende -->  Fertig
        INC     HL
        LD      E,(HL)          ;! Zeilennummer der aktuelle Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      (D5FA0 + 1),DE  ; und in Routine eintragen
A5F4F:  CALL    A6A0A           ; Zeiger in HL auf nächstes relevantes Programmbyte
        OR      A               ; Zeilenendezeichen  ?
        JR      Z,A5F42         ; ja -->  untersuchen, ob weitere Zeilen
D5F55:  JP      0               ; richtiges Umsetzprogramm aufrufen
;
;
;   Zeiger auf Zeile umsetzen in Zeilennummer
;
T5F58:  CP      _LIN_P          ; Code for 'Zeiger auf Zeile'   ?
        JR      NZ,A5F4F        ; nein -->  nächstes Byte untersuchen
        DEC     HL
        LD      E,(HL)          ;! Zeiger auf Zeile aus Programm holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        PUSH    HL              ; Stelle für Zeilennummer merken
        EX      DE,HL           ; Zeiger auf Zeile nach HL
        INC     HL              ;! Offset auf nächste Zeile überspringen
        INC     HL              ;!
        LD      E,(HL)          ;! Zeilennummer der Zeile aus Programm holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        POP     HL              ; Zeiger auf Stelle für Zeilennummer holen
        LD      (HL),D          ;! Zeilennummer in Programm eintragen
        DEC     HL              ;!
        LD      (HL),E          ;!
        DEC     HL
        LD      (HL),_LINNO     ; Code for 'Integer - Zeilennummer'  eintragen
        INC     HL
        INC     HL
        JR      A5F4F           ; Restprogramm untersuchen und umsetzen
;
;
;   Zeilennummer im Programm umsetzen in Zeiger auf Zeile
;
T5F72:  CP      _LINNO          ; Code for 'Integer - Zeilennummer'  ?
        JR      NZ,A5F4F        ; nein -->  nächstes Byte untersuchen
        DEC     HL              ; Zeiger auf Stelle für Zeiger auf Zeile
        PUSH    HL              ; Zeiger merken
        CALL    INDRCT          ; Offset auf nächste Zeile nach HL holen
        LD      E,L             ;! Zeilennummer nach DE
        LD      D,H             ;!
        LD      A,L             ;! Zeilennummer gleich Null  ?
        OR      H               ;!
        JR      Z,A5FA8         ; ja -->  Zeilennummer stehen lassen
        CALL    A5E78           ; Zeiger auf Zeile nach Zeilennummer in HL bereitstellen
        JR      C,A5F91         ; Zeile nicht vorhanden -->  Fehler ausgeben
        EX      DE,HL           ; Zeiger auf Zeile nach DE
        POP     HL              ; Zeiger auf Stelle für Zeiger auf Zeile
        DEC     HL              ; Zeiger auf Stelle für Code
        LD      (HL),_LIN_P     ; Code for 'Zeiger auf Zeile'  eintragen
        INC     HL              ; Code  überspringen
        LD      (HL),E          ;! Zeiger auf Zeile anstatt Zeilennummer
        INC     HL              ;! in Programmtext eintragen
        LD      (HL),D          ;!
        JR      A5F4F           ; Restprogramm umsetzen
;
;
;   Zeile nicht gefunden -->  Fehlermeldung ausgeben
;
A5F91:  PUSH    DE              ; Zeilennummer retten
        LD      A,16            ; Fehler 16  Un def. line error
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    27              ; Code 27  Fehlertext nach Fehlernummer in A ausgeben
        LD      A,' '           ; Leerzeichen  (Space)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausführung Steuerzeichen)
        POP     HL              ; Zeilennummer holen
        CALL    A7998           ; Hex-Wert in HL umsetzen in Dezimal nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    5               ; Code 5  Text (DE) mit Groß-/Kleinschreibung ausgeben
D5FA0:  LD      HL,0            ; Zeilennummer der aktuellen Zeile   (wird eingetragen)
        CALL    A63D6           ; Text 'in' und Zeilennummer ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    2               ; Code 2  Zeilenvorschub, wenn Cursor nicht auf Anfang Zeile
A5FA8:  POP     HL              ; Zeiger auf Stelle für Zeile holen
        INC     HL
        JR      A5F4F           ; Restprogramm umsetzen
;
S5FAC:  DEFS    1               ; Zeilen - Nummern - Flag   (=0 -->  nur Zeilennummern)
;
;
;   ASCII - Zeile (DE) umsetzen in Zwischencode und in Programmspeicher eintragen
;
A5FAD:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    40              ; Code 40   alle Datei - Daten im Rechner löschen
        CALL    A5F29           ; Zeiger auf Zeilen im Programm in Zeilennummern umsetzen
        CALL    CVBCAS          ; ASCII-Wert (DE) umsetzen in Hex-Wert nach BC
        LD      A,B             ;! Zeilennummer gleich Null  ?   (direkte
        OR      C               ;!                                Programmierung)
        JP      Z,A5881         ; ja -->  Zeile ausführen
        LD      (S9E4D),BC      ; als Editor Zeilennummer merken
        LD      A,(DE)          ; nächstes Textzeichen holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      NZ,A5FC4        ; nein -->  relevantes Zeichen
        INC     DE              ; Leerzeichen überspringen
A5FC4:  PUSH    AF              ; Zeichen merken
        LD      HL,IMDBUF       ; Pointer to temporary storage for tokenized line
        CALL    CVIMTX          ; ASCII - Text - Zeile (DE) umsetzen in Zwischencode
        PUSH    HL              ; Keep pointer to end of tokenized line 
        LD      HL,(S9E4D)      ; Get editor line number 
        LD      E,L             ;! auch als Endzeilennummer vorgeben
        LD      D,H             ;!
        CALL    A622C           ; eventuell vorhanden alte Zeile(n) löschen
        POP     HL              ; Get pointer to end of tokenized line
        POP     AF              ; erstes Textzeichen holen
        OR      A               ; gleich Zeilenendezeichen  ?
        JR      Z,A5FEB         ; ja -->  Zeile nur löschen
        LD      DE,IMDBUF       ; Pointer to memory holding the tokenized line
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Compute the length of the tokenized line
        LD      DE,5            ; 5 Byte für Zeilenverwaltung
        ADD     HL,DE           ; Speicherlänge für Zeile errechnen
        LD      B,H             ;! Länge der Zeile nach BC übertragen
        LD      C,L             ;!
        LD      HL,IMDBUF       ; Pointer to memory holding the tokenized line
        CALL    A6003           ; Zeile in Programmspeicher eintragen
A5FEB:  LD      A,(S611C)       ; AUTO - Flag holen
        OR      A               ; im AUTO - Modus  ?
        JP      Z,A5881         ; nein -->  nächste Zeile von Tastatur holen
        LD      DE,(S9E4F)      ; Offset für AUTO holen
        LD      HL,(S9E4D)      ; Get editor line number 
        ADD     HL,DE           ; nächste Zeilennummer errechnen
        LD      (S9E4D),HL      ; neue Editor Zeilennummer merken
        JP      NC,A5881        ; kein Übertrag -->  nächste Zeile von Tastatur holen
        JP      AUTOFF          ; AUTO - Modus aufheben
;
;
;   Zwischencodezeile (HL) mit Länge in BC in Programmspeicher eintragen
;
A6003:  LD      (D6064 + 1),HL  ; Zeiger auf Zwischencodezeile eintragen
        PUSH    BC              ; Länge der Zeile retten
        LD      BC,(S9E4D)      ; Get editor line number 
        LD      HL,(TEXTST)     ; BASIC - Programmanfang holen
        JR      A6014           ; Stelle für Zeile suchen und Zeile eintragen
;
A6010:  CALL    LDDEMD          ; Offset auf nächste Zeile holen
        ADD     HL,DE           ; Zeiger auf nächste Zeile errechnen
A6014:  CALL    LDDEMD          ; Offset auf nächste Zeile holen
        LD      A,D             ;! Offset gleich Null  ?
        OR      E               ;!
        JR      Z,A6028         ; ja -->  letzte Programmzeile
        INC     HL              ;! Zeiger auf Zeilennummer der Zeile
        INC     HL              ;! setzen
        CALL    LDDEMD          ; Zeilennummer der Zeile holen
        EX      DE,HL           ; Zeilennummer nach HL
        SBC     HL,BC           ; testen, ob Zeilennummern gleich
        DEC     DE              ;! Zeiger wieder auf Anfang Zeile
        DEC     DE              ;!
        EX      DE,HL           ; und nach HL
        JR      C,A6010         ; Zeilennummer ist kleiner als einzufügende Zeilennummer
A6028:  POP     DE              ; Länge der neuen Zeile holen
        PUSH    HL              ; Zeiger auf Stelle für Zeile merken
        PUSH    DE              ; Länge der neuen Zeile merken
        LD      HL,40           ;! Vorgabe für freien Bereich
        ADD     HL,DE           ;!
        LD      BC,(VARED)      ; Anfang Stringarbeitsbereich holen
        LD      (TMPEND),BC     ; als Ende Stringarbeitsbereich merken
        ADD     HL,BC           ; Ende benutzter Speicher errechnen
        JP      C,A63A7         ; Übertrag -->  Fehler 6  Memory error
        EX      DE,HL           ; Adresse nach DE
        CALL    A8C08           ; Überprüfen, ob Adresse in DE mit Stack collidiert
        POP     DE              ; Länge der neuen Zeile holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    24              ; Code 24  Zeiger auf I/O-Work-Area,Basic-Var.,Strings corrigieren
        POP     HL              ; Zeiger auf Stelle für neue Zeile holen
        PUSH    DE              ; Länge der neuen Zeile merken
        PUSH    BC              ; Anfang Stringarbeitsbereich ablegen
        EX      (SP),HL         ; mit Zeiger auf Stelle für Zeile vertauschen
        POP     BC              ; Zeiger auf Stelle für neue Zeile
        PUSH    HL              ; Anfang Stringarbeitsbereich merken
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; Anzahl zu verschiebende Bytes errechnen
        LD      B,H             ;! Anzahl nach BC
        LD      C,L             ;!
        POP     HL              ; alten Stringarbeitsbereichanfang holen
        LD      DE,(VARED)      ; Anfang Stringarbeitsbereich holen
        INC     BC              ; Länge corrigieren
        LDDR                    ; Platz für neue Zeile schaffen
        INC     HL
        POP     BC              ; Länge der neuen Zeile holen
        LD      (HL),C          ;! Länge der Zeile als Offset auf nächste
        INC     HL              ;! Zeile eintragen
        LD      (HL),B          ;!
        INC     HL
        LD      DE,(S9E4D)      ; Get editor line number   (line number for new line)
        LD      (HL),E          ;! Zeilennummer der neuen Zeile in
        INC     HL              ;! Programmspeicher eintragen
        LD      (HL),D          ;!
        INC     HL
        EX      DE,HL           ; Zeiger auf Stelle für Zeile nach DE
D6064:  LD      HL,IMDBUF       ; Zeiger auf Speicher mit Zwischencodezeile
        DEC     BC              ;! Zeilenlänge für Offset auf Zeile und
        DEC     BC              ;! Zeilennummer corrigieren
        DEC     BC              ;!
        DEC     BC              ;!
        LDIR                    ; neue Zeile in Programmspeicher eintragen
        RET
;
;
;   Basic - Befehl   RUN     (Token code  131 / 083H)
;
A606E:  JR      Z,A6079         ; Ende Befehl -->  Programm starten
        CALL    A69DE           ; Accu gleich Kennung für Zeilennummer   ?
        JP      Z,A69AF         ; ja -->  GOTO - Routine
        JP      A716B           ; Programm laden und starten
;
;
;   Basic - Programm starten
;
A6079:  CALL    A619B           ; Variable löschen   (CLR - Routine)
A607C:  CALL    A6090           ; alle Flags auf Anfangsbedingungen setzen
        LD      DE,(TEXTST)     ; Basic - Programmanfang holen
        LD      SP,(INTFAC)     ; höchste nutzbare Basic - Adresse holen
        LD      HL,-1           ; Code for 'keine Werte auf Stack'
        PUSH    HL              ; auf Stack ablegen
        PUSH    HL
        EX      DE,HL           ; Zeiger auf Programm nach HL
        JP      A5909           ; Programm abarbeiten
;
;
;   alle Flags auf Anfangsbedingungen setzen
;
A6090:  PUSH    HL              ; Keep register value
        CALL    A60A2           ; alle Statusflags zurücksetzen
        LD      (S611C),A       ; AUTO - Flag zurücksetzen
        LD      HL,10           ; Vorgabe für Anfangszeilennummer und Offset
        LD      (S9E4D),HL      ; als Anfangszeilennummer merken
        LD      (S9E4F),HL      ; Offset für AUTO merken
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;   alle Statusflags zurücksetzen
;
A60A2:  LD      HL,0            ; Null
        LD      (S9E55),HL      ; als Fehlerzeilennummer merken
        XOR     A               ; Accu auf Null
        LD      (S9E5D),A       ; DATA - Status zurücksetzen
        LD      (M63F6),A       ; CONT - Flag zurücksetzen
        LD      (S9E54),A       ; ON - ERROR - GOTO - Status löschen
        LD      (S9E53),A       ; Fehlernummer löschen
        LD      (S9E68),A       ; Code for 'nicht im SWAP - Programm'
        RET
;
;
;   Basic - Befehl   END     (Token code  152 / 098H)
;
A60B9:  LD      A,(S9E68)       ; SWAP - Flag holen
        OR      A               ; im SWAP - Programm  ?
        ;JP      NZ,A748B        ; ja -->  Hauptprogramm wieder laden
		JP      NZ,A750C        ; ja -->  Hauptprogramm wieder laden
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    40              ; Code 40   alle Datei - Daten im Rechner löschen
        XOR     A               ; Code for 'kein CONT möglich'
        LD      (M63F6),A       ; CONT - Flag zurücksetzen
        POP     BC              ; Rücksprungadresse vergessen
        JP      A5878           ; nächste Zeile von Tastatur holen und abarbeiten
;
;
;   Basic - Befehl   AUTO     (Token code  139 / 08BH)
;
A60CA:  CALL    A7340           ; wenn im Programm-Modus -->  Fehler 19  Instruction error
        LD      DE,10           ; Vorgabe für Anfangszeilennummer
        LD      BC,10           ; Vorgabe für Offset
        JR      Z,A6103         ; keine Werte angegeben -->  Vorgaben merken
        CP      ','             ; Komma  ?
        JR      NZ,A60E4        ; nein -->  Anfangszeilennummer auswerten
        INC     HL              ; Komma überspringen
        CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        LD      B,D             ;! angegebenen Offset nach BC übertragen
        LD      C,E             ;!
        LD      DE,10           ; Anfangszeilennummer 10 vorgeben
        JR      A6103           ; Anfangszeilennummer und Offset merken
;
A60E4:  CP      '.'             ; .   (letzte Zeilennummer)  ?
        LD      DE,(S9E4D)      ; Editor - Zeilennummer holen
        JR      Z,A60F5         ; ja -->  noch auf Offset untersuchen
        CP      _LINNO          ; Code for 'Integer - Zeilennummer'  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
        INC     HL              ; Code überspringen
        LD      E,(HL)          ;! Zeilennumer aus Programmtext holen
        INC     HL              ;!
        LD      D,(HL)          ;!
A60F5:  INC     HL
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      NZ,A6103        ; nein -->  kein Offset angegeben
        PUSH    DE              ; Anfangszeilennummer merken
        CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        LD      C,E             ;! Offset für AUTO nach BC übertragen
        LD      B,D             ;!
        POP     DE              ; Anfangszeilennummer für AUTO holen
A6103:  CALL    A797A           ; auf Syntax 'Befehlsende' überprüfen
        LD      A,C             ;! Offset gleich Null  ?
        OR      B               ;!
        JP      Z,A636A         ; ja -->  Fehler 3  Illegal data error
        LD      (S9E4D),DE      ; Editor - Zeilennummer merken   (Anfangszeilennummer AUTO)
        LD      (S9E4F),BC      ; Offset für AUTO merken
        LD      A,1             ; Code for 'im AUTO - Modus'
        LD      (S611C),A       ; als AUTO - Flag merken
        POP     AF              ; Rücksprungadresse vergessen
        JP      A5881           ; nächste Zeile von Tastatur holen
;
S611C:  DEFS    1               ; AUTO - Flag   (<>0 -->  AUTO - Modus)
;
;
;   Überprüfen, ob im AUTO - Modus. Wenn ja -->  Zeilennummer
;   oder wenn vorhanden komplette Zeile ausgeben
;
A611D:  LD      A,(S611C)       ; AUTO - FLag holen
        OR      A               ; AUTO - Modus  ?
        RET     Z               ; nein -->  ferig
        XOR     A               ; Code for 'Editor - Zeile'
        JR      A612B           ; Zeile aufbereiten, ausgeben, Cursor auf Anfang
;
;
;   Basic - Befehl   EDIT     (Token code  140 / 08CH)
;
A6125:  CALL    A612B           ; Zeile aufbereiten, ausgeben, Cursor auf Anfang
        JP      A5881           ; Zeile von Tastatur holen
;
;
;   Zeilennummer  (und wenn vorhanden komplette Zeile)  für AUTO oder EDIT
;   aufbereiten und ausgeben, Cursor auf Anfang Zeile stellen
;
A612B:  LD      DE,(S9E4D)      ; Editor - Zeilennummer holen
        CALL    NZ,A5ED3        ; Zeilennummer aus Eingabe bereitstellen
        PUSH    DE              ; Zeilennummer merken
        EX      DE,HL           ; Zeilennummer nach HL
        CALL    A5E78           ; Zeiger auf Zeile nach Zeilennummer in HL bereitstellen
        POP     DE              ; Zeilennummer der Zeile holen
        INC     HL              ;! Offset auf nächste Zeile und
        INC     HL              ;! Zeilennummer überspringen
        INC     HL              ;!
        INC     HL              ;!
        JR      NC,A6141        ; Zeile gefunden
        LD      HL,NOTXT        ; Zeiger auf Text  NUL
A6141:  EX      DE,HL           ; Zeiger auf Zeile nach DE
        PUSH    DE              ; Zeiger merken
        LD      (S9E4D),HL      ; Zeilennummer als Editor - Zeilennummer merken
        CALL    A7998           ; Hex-Wert in HL umsetzen in Dezimal nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    5               ; Code 5  Text (DE) mit Groß-/Kleinschreibung ausgeben
        LD      A,' '           ; Leerzeichen  (Space)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausführung Steuerzeichen)
        POP     HL              ; Get pointer to tokenized line
        LD      DE,S11A4        ; Zeiger auf Speicher für ASCII-Text vorgeben
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
		CALL    CVTXIM          ; Zwischencodezeile (HL) umsetzen in ASCII nach (DE)
        POP     DE              ; Zeiger auf Anfang ASCII-Zeile holen
        LD      B,0             ; Vorgabe für Länge der Zeile
A615A:  LD      A,(DE)          ; ein Zeichen Text der aufbereiteten Zeile
        OR      A               ; Textendezeichen  ?
        JR      Z,A6164         ; ja -->  Cursor wieder auf Anfang Zeile stellen
        INC     B               ; Zähler  'Anzahl Zeichen'  plus eins
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    4               ; Code 4  Accu auf Bildschirm ausgeben  (Anzeige Steuerzeichen)
        INC     DE              ; Zeiger auf ASCII-Text-Zeile auf nächstes Zeichen
        JR      A615A           ; Rest der Zeile ausgeben
;
;
;   Cursor auf Anfang des ausgegebenen Zeilentextes stellen
;
A6164:  LD      A,B             ; Anzahl Zeichen Zeilentext holen
        OR      A               ; Anzahl gleich Null  ?
        RET     Z               ; ja -->  fertig
A6167:  LD      A,C_LEFT        ; Steuerzeichen  'Cursor links'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausführung Steuerzeichen)
        DJNZ    A6167 + 1       ; weitere 'Cursor links' ausgeben   (Sprung falsch)
        RET
;
;
;   Zeiger auf Rechenspeicher merken
;
A616E:  PUSH    DE              ; Keep register value
        LD      DE,-16          ; Vorgabe für Sicherheitsbereich
        ADD     HL,DE           ; Ende Rechenspeicher errechnen
        POP     DE              ; geretteten Register - Wert holen
        LD      (MEMLMT),HL     ; Ende Rechenspeicherbereich merken
        DEC     H               ; 256 Bytes für Rechenspeicher reservieren
        LD      (INTFAC),HL     ; höchste nutzbare Basic - Adresse merken
        XOR     A               ; Code for 'nicht SWAP'
        LD      (S9E68),A       ; im SWAP - Flag merken
        RET
;
;
;   alle BASIC - Werte löschen
;
A6180:  LD      HL,(TEXTST)     ; Basic - Programmanfang holen
        CALL    A61C5           ; (HL)  Bereichsende  (00 00)  eintragen
        LD      (POOL),HL       ; Zeiger auf Ein- Ausgabe - Arbeitsbereich merken (I/O-Work-Area)
        CALL    A6090           ; alle Flags auf Anfangsbedingungen setzen
        JR      A619B           ; Variable löschen   (CLR - Routine)
;
;
;   Basic - Befehl   NEW     (Token code  159 / 09FH)
;
A618E:  CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    ____ON          ; ON   (Zwischencode)  ?
        ;CALL    Z,A9FCF         ; NEW ON -->  Plotter - Routinen löschen
		CALL    Z,A9FD1         ; NEW ON -->  Plotter - Routinen löschen
        CALL    A6180           ; alle BASIC - Werte löschen
        JP      A5872           ; Warmstart  BASIC - Interpreter
;
;
;   Basic - Befehl   CLR     (Token code  254 166 / 0FEH 0A6H)
;
A619B:  PUSH    HL              ; Programmzeiger retten
        CALL    A61AC           ; I/O-Work-Area und BASIC-Variable/Funktionen löschen
        POP     HL              ; geretteten Programmzeiger holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    40              ; Code 40   alle Datei - Daten im Rechner löschen
        RET
;
;
;   Basic - Programm, Ein- Ausgabe - Arbeitsbereich  (I/O - Work - Area) und
;   Basic - Variable / Funktionen löschen
;
A61A3:  LD      HL,(TEXTST)     ; Basic - Programmanfang holen
        CALL    A61C5           ; (HL)  Bereichsende  (00 00)  eintragen
        LD      (POOL),HL       ; Zeiger auf Ein- Ausgabe - Arbeitsbereich merken (I/O-Work-Area)
;
;
;   Ein- Ausgabe - Arbeitsbereich und BASIC - Variable/-Funktionen löschen
;
A61AC:  LD      HL,(POOL)       ; Zeiger auf Ein- Ausgabe - Arbeitsbereich holen (I/O-Work-Area)
        LD      (HL),0          ; Code for 'Bereichsende eintragen'
        INC     HL              ; Code überspringen
        LD      (VARST),HL      ; Anfang BASIC - Variable merken
        LD      (HL),0          ; Code for 'Bereichsende'  eintragen
        INC     HL              ; Code überspringen
        LD      (STRST),HL      ; Anfang Stringtextbereich merken
        CALL    A61C5           ; (HL)  Bereichsende  (00 00)  eintragen
        LD      (VARED),HL      ; Anfang Stringarbeitsbereich merken
        LD      (TMPEND),HL     ; als Ende Stringarbeitsbereich merken
        RET
;
;
;   (HL)  Bereichsende  (00 00)  eintragen
;
A61C5:  LD      (HL),0          ;! Bereichsende eintragen
        INC     HL              ;!
        LD      (HL),0          ;!
        INC     HL              ;!
        RET
;
;
;   Basic - Befehl   TRON     (Token code  169 / 0A9H)
;
A61CC:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        LD      A,1             ; Code for 'Trace auf Bildschirm'
        JR      Z,A61E0         ; Befehlsende -->  Trace - Flag merken
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    ___DIV          ; /   (Zwischencode)  ?
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "P"             ; P   (Printer)  ?
        LD      A,2             ; Code for 'Trace auf Drucker'
        JR      A61E0           ; Trace - Flag merken
;
;
;   Basic - Befehl   TROFF     (Token code  170 / 0AAH)
;
A61DF:  XOR     A               ; Code for 'kein Trace'
A61E0:  LD      (A61E4 + 1),A   ; Code im Trace - Flag merken
        RET
;
;
;   wenn TRON -->  Zeilennummer ausgeben
;
A61E4:  LD      A,0             ; Trace - Flag   (0=TROFF / 1=CRT / 2=LPT)
        OR      A               ; Trace  ?
        RET     Z               ; nein -->  fertig
        DEC     A               ; Flag für Bildschirm oder Drucker corrigieren
        LD      (FILOUT),A      ; Ausgabeflag  CRT/LPT  setzen
        JR      Z,A61F5         ; Zeilennummer auf Bildschirm ausgeben
        LD      A,(PNMODE)      ; Drucker - Modus - Flag holen
        CP      2               ; im Graphic - Modus  ?
        JR      Z,A6207         ; ja -->  Zeilennummer nicht ausgeben
A61F5:  PUSH    HL              ; Programmzeiger retten
        LD      A,'['           ; Eckige Klammer auf  (Sharp - Zeichensatz)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker  (Ausführung Steuerzeichen)
        LD      HL,(S9E51)      ; aktuelle Zeilennummer holen
        CALL    A7998           ; Hex-Wert in HL umsetzen in Dezimal nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    11              ; Code 11  Text (DE) auf Bildschirm oder Drucker ausgeben
        LD      A,']'           ; Eckige Klammer zu   (Sharp - Zeichensatz)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker  (Ausführung Steuerzeichen)
        POP     HL              ; geretteten Programmzeiger holen
A6207:  XOR     A               ; Code for 'Ausgabe auf Bildschirm'
        LD      (FILOUT),A      ; Ausgabeflag  CRT/LPT  zurücksetzen
        RET
;
;
;   Basic - command DELETE (token code 137 / 089H)
;
A620C:  CALL    A5F15           ; test whether character (HL) equals end-of-command character
        JP      Z,A6364         ; yes --> Error 1 Syntax error
        CALL    A69DE           ; Accu same identifier for line number ?
        JR      Z,A6220         ; yes --> delete program lines
        CP      '-'             ; -   (until)  ?
        JR      Z,A6220         ; yes --> delete program lines
        CP      '.'             ; . (last line number) ?
		JP      NZ,A7443        ; no --> delete file
A6220:  CALL    A5ED3           ; Provide line numbers from input
        EX      DE,HL           ; Starting line number after HL
        LD      E,C             ;!  End line number after DE
        LD      D,B             ;!
        CALL    A622C           ; delete any existing old line(s).
        JP      A5878           ; Get next line from keyboard and execute
;
;
;   Delete any existing old lines.
;   Beginning of line number in HL / end of line number in DE
;
A622C:  PUSH    AF              ;! Register - Werte retten
        PUSH    BC              ;!
        PUSH    HL              ; Anfangszeilennummer retten
        PUSH    DE              ; Endzeilennummer retten
        CALL    A5F29           ; Zeiger auf Zeilen im Programm in Zeilennummern umsetzen
        LD      C,L             ;! Anfangszeilennummer nach BC
        LD      B,H             ;!
        LD      HL,(TEXTST)     ; Basic - Programmanfang holen
A6238:  CALL    LDDEMI          ; Offset auf nächste Zeile holen
        LD      A,E             ;! Offset gleich Null  ?
        OR      D               ;!
        JR      NZ,A6247        ; nein -->  noch Programm vorhanden
A623F:  POP     DE              ; gerettete Endzeilennummer holen
        POP     HL              ; gerettete Anfangszeilennummer holen
        POP     BC              ;! gerettete Register - Werte holen
        POP     AF              ;!
        RET
;
A6244:  POP     DE              ; Zeiger auf nächste Zeile vergessen
        JR      A623F           ; gerettete Register - Werte holen
;
A6247:  EX      DE,HL           ; Zeiger auf aktuelle Zeile nach DE
        ADD     HL,DE           ;! Zeiger auf nächste Zeile errechnen
        DEC     HL              ;!
        DEC     HL              ;!
        EX      DE,HL           ; Zeiger auf aktuelle Zeile nach HL
        PUSH    DE              ; Zeiger auf nächste Zeile retten
        LD      E,(HL)          ;! Zeilennummer der aktuellen Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        EX      DE,HL
        LD      (D6260 + 1),HL  ; Zeilennummer in Routine eintragen
        SBC     HL,BC           ; Zeilennummer mit Anfangszeilennummer vergleicen
        POP     HL              ; Zeiger auf nächste Zeile holen
        JR      C,A6238         ; Zeile ist kleiner als Anfangszeile
        DEC     DE              ;! Zeiger wieder auf Anfang der Zeile stellen
        DEC     DE              ;!
        DEC     DE              ;!
        POP     BC              ; Endzeilennummer holen
        PUSH    BC              ; und wieder merken
        PUSH    DE              ; Zeiger auf Anfang zu löschende Zeilen
        PUSH    HL              ; Zeiger auf Ende merken
D6260:  LD      HL,0            ; Zeilennummer der aktuellen Zeile  (wird eingetragen)
        SBC     HL,BC           ; mit Endzeilennummer vergleichen
        POP     HL              ; Zeiger auf Ende Zeile holen
        JR      Z,A6286         ; Ende des zu löschenden Bereichs gefunden -->  löschen
        JR      NC,A6244        ; Endzeilennummer kleiner als aktuelle Zeilennummer
A626A:  CALL    LDDEMI          ; Offset auf nächste Zeile holen
        LD      A,D             ;! Offset gleich Null  ?
        OR      E               ;!
        JR      Z,A6284         ; ja -->  Programm zu Ende
        EX      DE,HL
        ADD     HL,DE           ;! Zeiger auf folgende Zeile errechnen
        EX      DE,HL
        DEC     DE              ;!
        DEC     DE              ;!
        PUSH    DE              ;!
        LD      E,(HL)          ;! Zeilennummer der Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        EX      DE,HL           ; und nach HL
        SBC     HL,BC           ; mit Endzeilennummer vergleichen
        POP     HL              ; Zeiger auf folgende Zeile holen
        JR      C,A626A         ; Endzeile suchen
        JR      Z,A6286         ; Endzeile gefunden
        EX      DE,HL
        DEC     HL              ;! Zeiger wieder auf Anfang Zeile
A6284:  DEC     HL              ;!
        DEC     HL              ;!
A6286:  POP     DE              ; Zeiger auf Anfang des zu löschenden Bereichs holen
        PUSH    DE              ; und wieder merken
        PUSH    HL              ; Zeiger auf Ende des zu löschenden Bereichs
        OR      A               ; Carry - Flag zurücksetzen
        EX      DE,HL
        SBC     HL,DE           ; zu löschende Anzahl Bytes errechnen
        EX      DE,HL
        LD      BC,(VARED)      ; Anfang Stringarbeitsbereich holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    24              ; Code 24  Zeiger auf I/O-Work-Area,Basic-Var.,Strings corrigieren
        POP     DE              ; Zeiger auf Ende des zu löschenden Bereichs
        LD      H,B             ;! alten Anfang Stringarbeitsbereich nach HL
        LD      L,C             ;!
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; zu verschiebende Anzahl Bytes errechnen
        LD      B,H             ;! Anzahl nach BC übertragen
        LD      C,L             ;!
        EX      DE,HL           ; Zeiger auf Anfang zu verschiebender Bereich nach HL
        POP     DE              ; Zeiger auf Anfang Löschbereich
        LDIR                    ; Rest Programm. I/O-Work-Area und Variable verschieben
        JR      A623F           ; gerettete Register - Werte holen
;
;
;   zwei - Byte - Wert ungleich Null bereitstellen
;
A62A2:  CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        LD      A,D             ;! Wert gleich Null  ?
        OR      E               ;!
        RET     NZ              ; nein -->  OK
        JP      A636A           ; Fehler 3  Illegal data error
;
;
;   Basic - Befehl   RENUM     (Token code  138 / 08AH)
;
A62AB:  CALL    A7340           ; wenn im Programm-Modus -->  Fehler 19  Instruction error
        LD      DE,10           ; Vorgabe 10
        LD      (D6329 + 1),DE  ; als neue Anfangszeilennummer merken
        LD      (D6340 + 1),DE  ; als neuen Offset merken
        LD      E,0             ; Null
        LD      (D6318 + 1),DE  ; als alte Anfangszeilennummer merken
        JR      Z,A62F4         ; keine Zahlen angegeben -->  Standardwerte benutzen
        CP      ','             ; Komma  ?
        JR      Z,A62D5         ; ja -->  keine neue Anfangszeilennummer angegeben
        CALL    A62A2           ; zwei - Byte - Wert ungleich Null bereitstellen
        LD      (D6329 + 1),DE  ; als neue Anfangszeilennummer merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A62F4         ; keine weiteren Werte angegeben
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        DEC     HL              ; Programmzeiger corrigieren
A62D5:  CALL    INCHLF          ; HL + 1, Leerzeichen  (Spaces)  (HL) überspringen
        CP      ','             ; Komma  ?
        JR      Z,A62EC         ; ja -->  keine alte Zeilennummer angegeben
        CALL    A62A2           ; zwei - Byte - Wert ungleich Null bereitstellen
        LD      (D6318 + 1),DE  ; alte Anfangszeilennummer merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A62F4         ; ja -->  Offset nicht angegeben
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        DEC     HL              ; Programmzeiger corrigieren
A62EC:  INC     HL              ; Trennzeichen überspringen
        CALL    A62A2           ; zwei - Byte - Wert ungleich Null bereitstellen
        LD      (D6340 + 1),DE  ; neuen Offset merken
A62F4:  PUSH    HL              ; Programmzeiger retten
        LD      HL,(D6318 + 1)  ; alte Anfangszeilennummer holen
        EX      DE,HL           ; und nach DE
        LD      HL,(D6329 + 1)  ; neue Anfangszeilennummer holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; neue Anfangszeilennummer größer alte Anfangszeilennr.  ?
        JP      C,A636A         ; nein -->  Fehler 3  Illegal data error
        CALL    A5F1C           ; Zeilennummern im Programm in Zeiger auf Zeilen umsetzen
        LD      HL,(TEXTST)     ; Basic - Programmanfang holen
A6308:  LD      E,(HL)          ;! Offset auf nächste Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      A,D             ;! Offset gleich Null  ?
        OR      E               ;!
        JR      Z,A634A         ; ja -->  Ende Programm gefunden
        EX      DE,HL
        ADD     HL,DE           ;! Zeiger auf nächste Zeile errechnen
        DEC     HL              ;!
        EX      DE,HL           ; Zeiger auf nächste Zeile nach DE
        INC     HL
        LD      C,(HL)          ;! Zeilennummer der Zeile holen
        INC     HL              ;!
        LD      B,(HL)          ;!
        PUSH    HL              ; Zeiger auf Zeile merken
D6318:  LD      HL,0            ; alte Anfangszeilennummer holen  (wird eingetragen)
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; überprüfen, ob Zeilennummer geändert werden muß
        POP     HL              ; Zeiger auf Zeile holen
        JR      Z,A6326         ; Zeilennummer ändern
        JR      C,A6326         ; Zeilennummer ändern
        EX      DE,HL           ; Zeiger auf nächste Zeile nach HL
        JR      A6308           ; nächste Zeile testen
;
A6326:  DEC     HL              ;! Zeiger wieder auf Anfang Zeile
        DEC     HL              ;!
        DEC     HL              ;!
D6329:  LD      BC,0            ; neue Anfangszeilennummer holen   (wird eingetragen)
        OR      A               ; Carry - Flag zurücksetzen   (Code for 'kein Fehler')
        PUSH    AF              ; Fehlerflag merken
A632E:  LD      E,(HL)          ;! Offset auf nächste Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      A,D             ;! Offset auf nächste Zeile gleich Null  ?
        OR      E               ;!
        JR      Z,A634A         ; ja -->  Ende Programm gefunden
        EX      DE,HL
        ADD     HL,DE           ;! Zeiger auf folgende Zeile errechnen
        DEC     HL              ;!
        EX      DE,HL           ; Zeiger in DE merken / Zeiger aktuelle Zeile nach HL
        POP     AF              ; Fehlerflag holen
        JR      C,A6350         ; Fehler aufgetreten -->  Standardwerte vorgeben
        INC     HL
        LD      (HL),C          ;! neue Zeilennummer in Zeile eintragen
        INC     HL              ;!
        LD      (HL),B          ;!
D6340:  LD      HL,0            ; neuen Offset holen   (wird eingetragen)
        ADD     HL,BC           ; Zeilennummer der nächsten Zeile errechnen
        PUSH    AF              ; Fehlerflag merken
        LD      C,L             ;! neue Zeilennummer nach BC übertragen
        LD      B,H             ;!
        EX      DE,HL           ; Zeiger auf nächste Zeile nach HL
        JR      A632E           ; nächste Zeile ändern
;
A634A:  POP     AF              ; Fehlerflag vergessen
        CALL    A5F2F           ; Zeiger auf Zeilen im Programm in Zeilennummern umsetzen
        POP     HL              ; Programmzeiger holen
        RET
;
;
;   bei Fehler bei  RENUM -->  Programm mit Standardwerten durchnumerieren
;
A6350:  LD      HL,10           ; Vorgabe 10
        LD      (D6340 + 1),HL  ; als Offset merken
        LD      (D6329 + 1),HL  ; als neue Anfangszeilennummer merken
        LD      L,0             ; Vorgabe Null
        LD      (D6318 + 1),HL  ; als alte Anfangszeilennummer merken
        CALL    A62F4           ; Programm mit Standardwerten durchnumerieren
        JP      A636A           ; Fehler 3  Illegal data error
;
;
;   Tabelle mit Fehlereinsprüngen
;
A6364:  LD      A,1             ; Fehler  1   Syntax error
        DEFB    LD_HL
A6367:  LD      A,2             ; Fehler  2   Over flow error
        DEFB    LD_HL
A636A:  LD      A,3             ; Fehler  3   Illegal data error
        DEFB    LD_HL
A636D:  LD      A,4             ; Fehler  4   Type mismatch error
        DEFB    LD_HL
A6370:  LD      A,5             ; Fehler  5   String length error
        DEFB    LD_HL
A6373:  LD      A,6             ; Fehler  6   Memory capacity error
        DEFB    LD_HL
A6376:  LD      A,7             ; Fehler  7   Array def. error
        DEFB    LD_HL
A6379:  LD      A,8             ; Fehler  8   Line length error
        DEFB    LD_HL
A637C:  LD      A,13            ; Fehler 13   NEXT error
        DEFB    LD_HL
A637F:  LD      A,14            ; Fehler 14   RETURN error
        DEFB    LD_HL
A6382:  LD      A,15            ; Fehler 15   Un def. function error
        DEFB    LD_HL
A6385:  LD      A,16            ; Fehler 16   Un def. line error
        DEFB    LD_HL
A6388:  LD      A,17            ; Fehler 17   Can't CONT error
        DEFB    LD_HL
A638B:  LD      A,18            ; Fehler 18  Memory protection error
        DEFB    LD_HL
A638E:  LD      A,19            ; Fehler 19  Instruction error
        DEFB    LD_HL
A6391:  LD      A,20            ; Fehler 20  Can't RESUME error
        DEFB    LD_HL
A6394:  LD      A,21            ; Fehler 21  RESUME error
        DEFB    LD_HL
A6397:  LD      A,22            ; Fehler 22  PAL error
        DEFB    LD_HL
A639A:  LD      A,24            ; Fehler 24  READ error
        DEFB    LD_HL
A639D:  LD      A,25            ; Fehler 25  SWAP error
        DEFB    LD_HL
A63A0:  LD      A,58            ; Fehler 58  Dev. name error
        DEFB    LD_HL
A63A3:  LD      A,64            ; Fehler 64  Logical number error
        JR      A63B5           ; Fehler behandeln
;
A63A7:  LD      A,6             ; Fehler  6  Memory capacity error
A63A9:  LD      SP,(INTFAC)     ; höchste nutzbare Basic - Adresse holen
        LD      HL,-1           ; Code for 'keine Werte auf Stack'
        PUSH    HL              ; auf Stack ablegen
        LD      (S9E64),SP      ; Stackpointer bei Anfang Befehl merken
A63B5:  JR      A63D3           ; Fehler behandeln
;
;
;   Standard  - Geräte vorgeben und Programm abbrechen
;
A63B7:  LD      HL,(__LPT)      ; Adresse  'Geräte - Tabelle  Drucker'  holen
        LD      IX,(__CRT)      ; Adresse  'Geräte - Tabelle  Bildschirm'  holen
        LD      (ZEQT),HL       ; Zeiger auf aktuelle Geräte - Tabelle merken
        XOR     A               ; Accu auf Null
        LD      (ZFLAG2),A      ; Geräte - Nummern - Flag zurücksetzen
        LD      A,68 + 128      ; Fehler 68  Dev. mode error
        DEFB    LD_HL
        LD      A,59 + 128      ; Fehler 59  Can't execute error
        DEFB    LD_HL
T63CB:  LD      A,59            ; Fehler 59  Can't execute error
        DEFB    LD_HL
A63CE:  LD      A,60 + 128      ; Fehler 60  Illegal filename error
        DEFB    LD_HL
A63D1:  LD      A,61 + 128      ; Fehler 61  Illegal filemode error
A63D3:  JP      ERRORJ          ; Fehler behandeln
;
;
;   wenn Zeilennummer in HL ungleich Null -->  Text 'in' und Zeilennummer ausgeben
;
A63D6:  LD      A,L             ;! Zeilennummer gleich Null  ?
        OR      H               ;!
        RET     Z               ; ja -->  fertig
        LD      DE,M63E4        ; Text  'in'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    5               ; Code 5  Text (DE) mit Groß-/Kleinschreibung ausgeben
        CALL    A7998           ; Hex-Wert in HL umsetzen in Dezimal nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    5               ; Code 5  Text (DE) mit Groß-/Kleinschreibung ausgeben
        RET
;
;
;   allgemeine Texte für Basic - Interpreter
;
M63E4:  DEFM    " IN "          ; Text  ' in '
        DEFB    NUL
M63E9:  DEFM    "B"             ; Text  'Break'
        DEFB    _SML
        DEFM    "REAK"
		DEFB    NUL
;
M63F0:  DEFM    "R"             ; Text  'Ready'
        DEFB    _SML
        DEFM    "EADY"
M63F6:  DEFB    NUL             ; CONT - Flag   (NUL oder .)
        DEFB    NUL             ; Textendezeichen
;
;
;   Basic - Befehl   ERROR     (Token code 193 / 0C1H)
;
A63F8:  CALL    IBYTE           ; ein - Byte - Wert nach DE / Accu bereitstellen
        DEC     A               ;! bekannte Fehlernummer  ?
        CP      70              ;!
        JR      C,A6402         ; ja -->  Fehlernummer wieder corrigieren
        LD      A,69 -1         ; Fehler 69  Unprintable error
A6402:  INC     A               ; Fehlernummer wieder corrigieren
;
;
;   Fehler mit Fehlernummer im Accu behandeln
;
A6403:  LD      SP,(S9E64)      ; Stackpointer bei Anfang Befehl holen
        PUSH    AF              ; Fehlernummer retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    67              ; Code 67  Datei-Daten der Ausgabedatei bei Fehler löschen
        CALL    A737C           ; Zwischenspeicher für Programmladeroutine löschen
        POP     AF              ; Fehlernummer holen
        OR      A               ; Programmende  ?
        JR      Z,A6463         ; ja -->  'kein CONT möglich'  merken
        CP      080H            ; Code for 'BREAK'  ?
        JR      Z,A6461         ; ja -->  Daten für 'CONT' retten
        LD      C,A             ; Fehlernummer merken
        LD      HL,0            ; HL auf Null
        LD      (S9048),HL      ; Zeiger auf Parameter bei FN zurücksetzen
        CALL    A596B           ; Abfrage, ob in direkter Programmierung
        LD      A,C             ; Fehlernummer holen
        JR      Z,A644C         ; direkte Programmierung -->  Fehler ausgeben
        LD      HL,(S9E51)      ; aktuelle Zeilennummer holen
        LD      (S9E55),HL      ; als Fehlerzeilennummer merken
        LD      (S9E4D),HL      ; als Editor - Zeilennummer merken
        LD      HL,(S9E4B)      ; Zeiger auf nächste Programmzeile holen
        LD      (S9E57),HL      ; Zeiger auf nächste Zeile bei Fehler merken
        LD      HL,(S9E66)      ; Programmzeiger bei Anfang Befehl holen
        LD      (S9E59),HL      ; als Programmzeiger bei Fehler merken
        AND     01111111B       ; eigentliche Fehlernummer maskieren
        LD      (S9E53),A       ; Fehlernummer merken
        LD      A,(S9E54)       ; ON - ERROR - GOTO - Status holen
        INC     A               ; plus eins
        CP      2               ; Code for 'Fehler aufgetreten'  ?
        JR      Z,A6457         ; ja -->  merken und Fehlerbehandlung aufrufen
        XOR     A               ; Code for 'kein CONT möglich'
        LD      (M63F6),A       ; als CONT - Flag merken
        LD      (S9E68),A       ; SWAP - Flag zurücksetzen
        LD      A,C             ; Fehlernummer holen
A644C:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    27              ; Code 27  Fehlertext nach Fehlernummer in A ausgeben
A644E:  LD      HL,(S9E51)      ; aktuelle Zeilennummer holen
        CALL    A63D6           ; wenn Zeilennummer ungleich Null -->  ausgeben
        JP      A5878           ; Ready ausgeben und nächste Zeile von Tastatur holen
;
A6457:  LD      (S9E54),A       ; neuen ON - ERROR - GOTO - Status merken
        LD      HL,(S9E5B)      ; Zeiger auf Fehlerbehandlungsprogramm holen
        PUSH    HL              ; auf Stack ablegen
        JP      A5909           ; Zeile abarbeiten
;
;
;   Programm mit Shift - BREAK abgebrochen
;
A6461:  LD      A,'.'           ; Code for 'CONT möglich'
A6463:  LD      HL,(S9E66)      ; Programmzeiger bei Anfang Befehl holen
        JR      A646B           ; aktuelle Programmdaten für CONT merken
;
;
;   Basic - Befehl   STOP     (Token code  153 / 099H)
;
A6468:  LD      A,'.'           ; Code for 'CONT möglich'
        POP     DE              ; Rücksprungadresse vergessen
A646B:  PUSH    AF              ; Flag  'CONT möglich/nicht möglich'
        PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    2               ; Code 2  Zeilenvorschub, wenn Cursor nicht auf Anfang Zeile
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    32              ; Code 32  Referenzton ausgeben
        LD      DE,M63E9        ; Text  'Break'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    5               ; Code 5  Text (DE) mit Groß-/Kleinschreibung ausgeben
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A596B           ; Abfrage, ob in direkter Programmierung
        JR      Z,A6495         ; ja -->  Stack corrigieren und Zeile von Tastatur holen
        LD      (D64B0 + 1),HL  ; Programmzeiger für CONT merken
        LD      HL,(S9E4B)      ; Zeiger auf nächste Programmzeile holen
        LD      (D64AA + 1),HL  ; für CONT merken
        LD      HL,(S9E51)      ; aktuelle Zeilennummer holen
        LD      (D64A4 + 1),HL  ; und für CONT merken
        LD      (S9E4D),HL      ; als Editor - Zeilennummer merken
        POP     AF              ; CONT - Status holen
        LD      (M63F6),A       ; als CONT - Flag merken
        JP      A644E           ; Zeilennummer ausgeben
;
A6495:  POP     AF              ; CONT - Status holen
        JP      A5878           ; Ready ausgeben und nächste Zeile von Tastatur
;
;
;   Basic - Befehl   CONT     (Token code  154 / 09AH)
;
A6499:  POP     DE              ; Rücksprungadresse holen
        LD      HL,M63F6        ; Zeiger auf CONT - FLag
        LD      A,(HL)          ; CONT - Flag holen
        OR      A               ; gesetzt  ?
        JP      Z,A6388         ; nein -->  Fehler 17  Can't CONT error
        LD      (HL),0          ; CONT - Flag zurücksetzen
D64A4:  LD      HL,0            ; Zeilennummer holen   (wird eingetragen)
        LD      (S9E51),HL      ; als aktuelle Zeilennummer merken
D64AA:  LD      HL,0            ; Zeiger auf Zeile holen   (wird eingetragen)
        LD      (S9E4B),HL      ; als Zeiger auf nächste Programmzeile merken
D64B0:  LD      HL,0            ; Programmzeiger für CONT holen   (wird eingetragen)
        JP      A58D4           ; Rest der Zeile bearbeiten
;
;
;   Basic - Befehl   RESUME     (Token code  134 / 086H)
;
A64B6:  LD      A,(S9E54)       ; ON - ERROR - GOTO - Status holen
        CP      2               ; Code for 'Fehler aufgetreten'  ?
        JP      C,A6394         ; nein -->  Fehler 21  RESUME error
        DEC     A               ; Code wieder auf  'ON ERROR GOTO gesetzt'
        LD      (S9E54),A       ; ON - ERROR - GOTO - Status merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        EX      DE,HL           ; Programmzeiger nach DE retten
        LD      HL,(S9E55)      ; Fehlerzeilennummer holen
        LD      (S9E51),HL      ; als aktuelle Zeilennummer merken
        LD      HL,(S9E57)      ; Zeiger auf nächste Zeile bei Fehler holen
        LD      (S9E4B),HL      ; als Zeiger auf nächste Programmzeile merken
        LD      HL,(S9E59)      ; Programmzeiger bei Fehler holen
        JR      NZ,A64DB        ; nicht Befehlsende -->  untersuchen, welcher RESUME
        POP     BC              ; Rücksprungadresse verwerfen
        JP      A58D8           ; Befehl noch einmal abarbeiten
;
A64DB:  CP      __NEXT          ; RESUME NEXT  ?
        JP      Z,A67FE         ; ja -->  Anfang des nächsten Befehls suchen
        EX      DE,HL           ; Programmzeiger auf Zeilennummer nach HL
        JP      A69AF           ; GOTO   (RESUME Zeilennummer)
;
;
;   Basic - Befehl   ON ERROR GOTO
;
A64E4:  CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    __GOTO          ; GOTO  (Zwischencode)  ?
        CALL    A5E19           ; Zeiger auf Zeile nach Programmtext (HL) bereitstellen
        JR      Z,A64F7         ; Zeilennummer gleich Null -->  ON ERROR GOTO zurücksetzen
        LD      (S9E5B),DE      ; Zeiger auf Fehlerbehandlungsprogramm merken
        LD      A,1             ; Code for 'ON ERROR GOTO'  gesetzt
A64F3:  LD      (S9E54),A       ; ON - ERROR - GOTO - Status merken
        RET
;
A64F7:  LD      A,(S9E54)       ; ON - ERROR - GOTO - Status holen
        DEC     A               ; ON ERROR GOTO gesetzt  ?
        JR      Z,A64F3         ; ja -->  zurücksetzen
        XOR     A               ; Accu auf Null
        LD      (S9E54),A       ; ON - ERROR - GOTO - Status zurücksetzen
        LD      HL,(S9E55)      ; Fehlerzeilennummer holen
        LD      (S9E51),HL      ; als aktuelle Zeilennummer merken
        LD      A,(S9E53)       ; Fehlernummer holen
        JP      A6403           ; Fehler mit Nummer im Accu behandeln
;
;
;   Basic - Befehl   LET     (Token code  158 / 09EH)
;
A650D:  CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    0FFH            ; Vorbyte Tabelle drei  ?
        JP      Z,A653F         ; ja -->  auf TI$ untersuchen
        CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        PUSH    BC              ;! Zeiger auf Variable merken
        PUSH    BC              ;!
        PUSH    AF              ; Variablenartcode merken
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    ____EQ          ; =   (Zwischencode)  ?
        CALL    EXPR            ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
        POP     BC              ; Variablenartcode holen
        LD      A,(S9E9C)       ; Wertartflag holen
        CP      B               ; gleich Variablenartcode  ?
        JP      NZ,A636D        ; nein -->  Fehler 4  Type mismatch error
        EX      (SP),HL         ; Programmzeiger retten / Variablenzeiger holen
        EX      DE,HL           ; Variablenzeiger nach HL
        CP      5               ; Zahlvariable  ?
        JR      Z,A6537         ; ja -->  Zahlwert der Variablen zuweisen
        PUSH    BC              ; Variablenarttyp merken
        CALL    A654A           ; String mit Descriptor (HL) der Variablen (DE) zuweisen
        POP     AF              ; Variablenartcode holen
        POP     HL              ; Programmzeiger holen
        POP     BC              ; Zeiger auf Variable holen
        RET
;
A6537:  LD      C,A             ; Wertlänge merken
        LD      B,0             ; High - Byte Länge auf Null
        LDIR                    ; Zahlwert der Variablen zuweisen
        POP     HL              ; Programmzeiger holen
        POP     BC              ; Zeiger auf Variable holen
        RET
;
;
;   Basic - Process command from table three 
;
A653F:  CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    ____TI          ; TI$   (Zwischencode)  ?
        JP      A8AE2           ; Uhrzeit bereitstellen und zuweisen
;
;
;   Zeichenkette (HL) der Variablen (DE) zuweisen
;
A6546:  PUSH    DE              ; Zeiger auf Variable retten
        EX      DE,HL           ; Zeiger auf Zeichenkette nach DE
        JR      A654E           ; Zeichenkette der Variable zuweisen
;
;
;   Zeichenkette mit Descriptor (HL) der Variablen mit
;   Descriptor (DE) zuweisen
;
A654A:  PUSH    DE              ; Zeiger auf Variablendescriptor retten
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
A654E:  LD      HL,S11A3        ; Zeiger auf Zwischenspeicher vorgeben
        LD      (HL),A          ; Zeichenkettenlänge eintragen
        LD      B,A             ;! Zeichenkettenlänge
        LD      C,A             ;!
        INC     HL              ; Zeichenkettenlänge überspringen
        CALL    LDHLDE          ; Speicherbereich von (DE) nach (HL) verschieben
        POP     HL              ; Zeiger auf Variablendescriptor holen
        LD      A,(HL)          ; Länge Variablentext holen
        CP      C               ; gleich neuer Länge  ?
        JR      Z,A659F         ; Länge gleich -->  kann direkt zugewiesen werden
        PUSH    HL              ; Zeiger auf Variablendescriptor wieder retten
        OR      A               ; alte Länge gleich Null  ?
        CALL    NZ,A65AF        ; nein -->  alten Variablentext löschen
        POP     HL              ; Zeiger auf Variablendescriptor holen
        LD      A,(S11A3)       ; neue Textlänge holen
        OR      A               ; gleich Null  ?
        JR      Z,A659C         ; ja -->  Länge in Descriptor eintragen
        PUSH    HL              ; Zeiger auf Variablendescriptor merken
        LD      BC,(VARST)      ; Anfang BASIC - Variable holen
        SBC     HL,BC           ; Offset auf Descriptor errechnen
        EX      DE,HL           ; Offset nach DE
        LD      HL,(VARED)      ; Anfang Stringarbeitsbereich holen
        DEC     HL              ;! corrigieren auf Ende Stringtextbereich
        DEC     HL              ;!
        LD      (HL),E          ;! Offset auf Variable eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL
        LD      BC,(STRST)      ; Anfang Stringtextbereich holen
        OR      A               ; Carry - Flag zurücksetzen
        POP     DE              ; Zeiger auf Variablendescriptor holen
        PUSH    HL              ; Zeiger für Stringtext retten
        SBC     HL,BC           ; Offset auf Stringtext errechnen
        EX      DE,HL
        LD      (HL),A          ; Stringlänge in Descriptor eintragen
        LD      B,A             ; Länge des neuen Strings
        INC     HL              ; Stringlänge in Descriptor überspringen
        LD      (HL),E          ;! Offset auf Stringtext in Descriptor eintrgen
        INC     HL              ;!
        LD      (HL),D          ;!
        POP     HL              ; Zeiger für Stringtext holen
        LD      DE,S11A3        ; Zeiger auf Speicher mit String vorgeben
        INC     DE              ; Länge überspringen
        CALL    A8BFC           ; Zeichenkette mit Länge in B von (DE) nach (HL) übertragen
        CALL    A61C5           ; (HL)  Bereichsende  (00 00)  eintragen
        LD      (TMPEND),HL     ; als Ende Stringarbeitsbereich merken
        LD      (VARED),HL      ; Anfang Stringarbeitsbereich merken
        RET
;
A659C:  LD      (HL),0          ; Länge Null in Variablendescriptor eintragen
        RET
;
;
;   Stringtext in Stringtextbereich eintragen
;
A659F:  INC     HL              ; Stringlänge überspringen
        LD      E,(HL)          ;! Offset auf String aus Variablendescriptor holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      HL,(STRST)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf Stringtext errechnen
        LD      DE,S11A3        ; Zeiger auf Zwischenspeicher mit neuem String
        LD      B,C             ; Textlänge des neuen Strings
        INC     DE              ; Textlänge überspringen
        JP      A8BFC           ; Zeichenkette mit Länge in B von (DE) nach (HL) übertragen
;
;
;   Zeichenkette mit Variablendescriptor (HL) löschen
;
A65AF:  LD      C,(HL)          ; Stringlänge aus Descriptor holen
        LD      B,0             ; High - Byte Länge auf Null
        INC     BC              ;! Länge für Offset auf Variablendescriptor
        INC     BC              ;! corrigieren
        INC     HL              ; Stringlänge in Descriptor überspringen
        LD      E,(HL)          ;! Offset auf Stringtextanfang holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      HL,(STRST)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf Stringtext errechnen
        DEC     HL              ;! auf Offset auf Variablendescriptor
        DEC     HL              ;! corrigieren
        LD      E,L             ;! Zeiger auf Offset nach DE
        LD      D,H             ;!
        ADD     HL,BC           ; Zeiger auf Ende String errechnen
        PUSH    BC              ; Anzahl zu löschende Bytes merken
        PUSH    DE              ; Zeiger auf Offset auf Variablendescriptor merken
        EX      DE,HL           ; Zeiger auf Ende zu löschender String nach DE
        LD      HL,(VARED)      ; Anfang Stringarbeitsbereich holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Restlänge Stringtextbereich errechnen
        LD      C,L             ;! Restlänge Stringtextbereich nach BC
        LD      B,H             ;!
        EX      DE,HL           ; Zeiger auf Anfang zu verschiebender Bereich nach HL
        POP     DE              ; Zeiger auf neuen Anfang holen
        PUSH    DE              ; und wieder merken
        JR      Z,A65D3         ; Restlänge gleich Null -->  nicht verschieben
        LDIR                    ; Rest Stringtextbereich verschieben
A65D3:  POP     DE              ; Zeiger auf Offset holen
        POP     BC              ; gelöschte Länge holen
        LD      HL,(VARED)      ; Anfang Stringarbeitsbereich holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; neues Ende Stringtextbereich errechnen
        LD      (VARED),HL      ; Anfang Stringarbeitsbereich merken
        EX      DE,HL           ; Zeiger auf Offset nach HL
A65DF:  LD      E,(HL)          ;! Offset auf Variablendescriptor holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      A,D             ;! gleich Null  ?
        OR      E               ;!
        RET     Z               ; ja -->  fertig
        LD      HL,(VARST)      ; Anfang BASIC - Variable holen
        ADD     HL,DE           ; Zeiger auf Variablendescriptor errechnen
        LD      A,(HL)          ; Länge Stringtext holen
        INC     HL              ; Länge in Descriptor überspringen
        LD      E,(HL)          ;! Offset auf Stringtext aus Variablen-
        INC     HL              ;! descriptor holen
        LD      D,(HL)          ;!
        OR      A               ; Carry - Flag zurücksetzen
        EX      DE,HL
        SBC     HL,BC           ; Offset für Stringtext corrigieren
        EX      DE,HL
        LD      (HL),D          ;! corrigierten Offset wieder in Variablen-
        DEC     HL              ;! descriptor eintragen
        LD      (HL),E          ;!
        PUSH    BC              ; gelöschte Länge retten
        LD      C,A             ; Stringlänge
        LD      B,0             ; High - Byte Länge auf Null
        LD      HL,(STRST)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf Anfang String errechnen
        ADD     HL,BC           ; Zeiger auf nächsten String errechnen
        POP     BC              ; gelöschte Länge holen
        JR      A65DF           ; untersuchen, ob weitere Descriptoren corrigiert werden müssen
;
;
;   Basic - Befehl   FOR     (Token code  141 / 08DH)
;
A6602:  POP     BC              ; Rücksprungadresse holen
        LD      (D6696 + 1),BC  ; und in Routine eintragen
        CALL    A650D           ; Schleifenvariable Anfangswert zuweisen
        LD      IX,0            ;! Stackpointer nach IX holen
        ADD     IX,SP           ;!
        LD      (D6678 + 1),HL  ; Programmzeiger in Routine eintragen
        CALL    A6772           ; Offset auf Variablen errechnen
        LD      (D6674 + 1),BC  ; Offset auf Variable in Routine eintragen
A661A:  LD      E,(IX+0)        ;! ersten Wert vom Stack holen
        LD      D,(IX+1)        ;!
        LD      HL,256*0FFH+18  ; Code for 'FOR - Daten'
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; gleich Code for 'FOR - Daten'  ?
        JR      NZ,A6642        ; nein -->  keine weiteren Schleifen überprüfen
        LD      E,(IX+6)        ;! Offset auf Schleifenvariable
        LD      D,(IX+7)        ;! aus vorhandenen Werte holen
        EX      DE,HL           ; nach HL übertragen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; gleiche Variable  ?
        JR      Z,A663B         ; ja -->  alte Daten vergessen
        LD      DE,18           ; Länge FOR - Datensatz
        ADD     IX,DE           ; Zeiger auf nächsten Datensatz errechnen
        JR      A661A           ; nächsten Datensatz überprüfen
;
A663B:  LD      DE,18           ; Länge FOR - Datensatz
        ADD     IX,DE           ; Zeiger auf Ende Datensatz errechnen
        LD      SP,IX           ; alle Datensätze davor vergesen
A6642:  LD      HL,(D6678 + 1)  ; Programmzeiger holen
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    ____TO          ; TO   (Zwischencode)  ?
        CALL    EXPR            ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger merken
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        LD      DE,S677E        ; Zeiger auf Speicher für Schleifenende
        CALL    A79C5           ; Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; nächstes Programmbyte holen
        CP      __STEP          ; Zwischencode STEP  ?
        LD      DE,B7C45        ; Zeiger auf +1   (Real - Format)
        JR      NZ,A6662        ; kein STEP angegeben
        INC     HL              ; Zwischencode STEP überspringen
        CALL    EXPR            ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
A6662:  LD      (D6678 + 1),HL  ; Programmzeiger merken
        LD      HL,-10          ; Offset für Schleifenende
        ADD     HL,SP           ; Zeiger auf Stelle für Schleifenende errechnen
        LD      SP,HL           ; Zeiger auf Stelle setzen
        EX      DE,HL           ; Zeiger auf Zahlwert nach HL
        CALL    A79C5           ; Zahlwert von (HL) nach (DE) übertragen
        LD      HL,S677E        ; Zeiger auf Speicher für Schleifenende
        CALL    A79C5           ; Zahlwert von (HL) nach (DE) übertragen
D6674:  LD      HL,0            ; Offset auf Schleifenvariable   (wird eingetragen)
        PUSH    HL              ; für NEXT auf Stack merken
D6678:  LD      HL,0            ; Programmzeiger auf Anfang Schleife  (wird eingetragen)
        PUSH    HL              ; für NEXT auf Stack merken
        LD      HL,(S9E4B)      ; Zeiger auf nächste Programmzeile holen
        PUSH    HL              ; und für NEXT auf Stack merken
        LD      HL,256*0FFH+18  ; Code for 'FOR - Datensatz'
        PUSH    HL              ; auf Stack ablegen
        LD      HL,-512         ; Vorgabe für freien Arbeitsbereich
        ADD     HL,SP           ; kleinste Stackadresse errechnen
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        SBC     HL,DE           ; Adressen vergleichen
        LD      A,11            ; Fehler 11  FOR nesting error
        JP      C,A63A9         ; Adressen überschneiden sich -->  Fehler behandeln
        LD      HL,(D6678 + 1)  ; Programmzeiger holen
D6696:  JP      0               ; nächsten Befehl abarbeiten   (Adresse wird eingetragen)
;
;
;   Basic - Befehl   NEXT     (Token code  142 / 08EH)
;
A6699:  LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; im Wertartflag merken
        POP     BC              ; Rücksprungadresse holen
        LD      (A670D + 1),BC  ; und in Routine eintragen
A66A3:  PUSH    AF              ;! Befehlsendeflag merken
        POP     BC              ;!
        LD      (D6678 + 1),HL  ; Programmzeiger merken
        LD      IX,0            ;! Stackpointer holen
        ADD     IX,SP           ;!
        LD      (D66FC + 1),IX  ; und merken
        LD      E,(IX+0)        ;! Steuerwort vom Stack holen
        LD      D,(IX+1)        ;!
        LD      HL,256*0FFH+18  ; Code for 'FOR - Datensatz'
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; gleich Steuerwort  'FOR - Daten'  ?
        JP      NZ,A637C        ; nein -->  Fehler 13  Next without FOR error
        PUSH    BC              ;! Befehlsendeflag wieder ins Flag - Register
        POP     AF              ;!
        JR      NZ,A6724        ; nicht Befehlsende -->  auf Namen untersuchen
        LD      E,(IX+4)        ;! Programmzeiger auf Anfang Schleife aus
        LD      D,(IX+5)        ;! Datensatz holen
        EX      DE,HL           ; nach HL
        LD      (D670A + 1),HL  ; und in Routine eintragen
        LD      E,(IX+6)        ;! Offset auf Laufvariable der Schleife holen
        LD      D,(IX+7)        ;!
        LD      HL,(VARST)      ; Anfang BASIC - Variable holen
        ADD     HL,DE           ; Zeiger auf Variablenwert errechnen
        LD      BC,8            ; Offset zur Schrittweite
        ADD     IX,BC           ; Zeiger auf Schrittweite errechnen
        PUSH    IX              ;! und nach DE übertragen
        POP     DE              ;!
        CALL    A90BC           ; Schrittweite zur Laufvariablen addieren
        INC     DE              ; Zeiger auf MSByte Mantisse Schrittweite
        LD      A,(DE)          ; MSByte Mantisse der Schrittweite holen
        LD      IX,(D66FC + 1)  ; Zeiger auf Anfang FOR - Datensatz holen
        LD      DE,13           ; Offset zum Schleifenende
        ADD     IX,DE           ; Zeiger auf Schleifenende errechnen
        PUSH    IX              ;! nach DE übertragen
        POP     DE              ;!
        BIT     7,A             ; Vorzeichen Schrittweite abfragen
        JR      NZ,A66F7        ; Schrittweite negativ
        EX      DE,HL           ; Zeiger auf Zahlen vertauschen
A66F7:  CALL    A9153           ; Wert Laufvariable und Schleifenende vergleichen
        JR      C,A6710         ; Schleife beenden
D66FC:  LD      SP,0            ; Stackpointer setzen   (wird eingetragen)
        LD      HL,2            ; Offset zum Zeiger auf nächste Zeile
        ADD     HL,SP           ; Zeiger auf Zeilenzeiger errechnen
        LD      A,(HL)          ;! Zeiger auf nächste Zeile aus
        INC     HL              ;! FOR - Datensatz holen
        LD      H,(HL)          ;!
        LD      L,A             ;!
        LD      (S9E4B),HL      ; Zeiger auf nächste Programmzeile merken
D670A:  LD      HL,0            ; Programmzeiger holen   (wird eingetragen)
A670D:  JP      0               ; nächsten Befehl ausführen   (Adresse wird eingetragen)
;
;
;   Schleife beenden
;
A6710:  LD      DE,18           ; Anzahl Bytes FOR - Datensatz
        LD      HL,(D66FC + 1)  ; Zeiger auf Anfang FOR - Datensatz holen
        ADD     HL,DE           ; neuen Zeiger errechnen
        LD      SP,HL           ; Stackpointer neu setzen
        LD      HL,(D6678 + 1)  ; Programmzeiger holen
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      NZ,A670D        ; keine weiteren Schleifen -->  nächsten Befehl
        LD      (D6678 + 1),HL  ; Programmzeiger wieder merken
A6724:  LD      IX,0            ;! Zeiger auf Datensätze holen
        ADD     IX,SP           ;!
        LD      (D66FC + 1),IX  ; und in Routine eintragen
        LD      HL,(D6678 + 1)  ; Programmzeiger holen
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JP      Z,A66A3         ; nächste Schleife überprüfen
        CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        LD      (D6678 + 1),HL  ; Programmzeiger wieder merken
        CALL    A6772           ; Offset auf Variable errechnen
        LD      IX,(D66FC + 1)  ; Stackpointer holen
A6745:  LD      E,(IX+0)        ;! Steuerwort vom Stack holen
        LD      D,(IX+1)        ;!
        LD      HL,256*0FFH+18  ; Code for 'FOR - Datensatz'  vorgeben
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; FOR - Datensatz  ?
        JP      NZ,A637C        ; nein -->  Fehler 13  NEXT without FOR error
        LD      L,(IX+6)        ;! Offset auf Schleifenvariable holen
        LD      H,(IX+7)        ;!
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; Offset's vergleichen
        LD      HL,(D6678 + 1)  ; Programmzeiger holen
        JP      Z,A66A3         ; Schleife gefunden -->  testen, ob Ende
        LD      DE,18           ; Länge FOR - Datensatz
        ADD     IX,DE           ; Zeiger auf nächsten FOR - Datensatz errechnen
        LD      (D66FC + 1),IX  ; und als Zeiger auf Stack merken
        LD      SP,(D66FC + 1)  ; Stackpointer neu setzen
        JR      A6745           ; nächsten Datensatz überprüfen
;
;
;   Offset auf Basic - Variable nach Zeiger auf Variable in BC nach BC errechnen
;
A6772:  LD      H,B             ;! Zeiger auf Schleifenvariable nach HL
        LD      L,C             ;!
        LD      BC,(VARST)      ; Anfang BASIC - Variable holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; Offset auf Basic - Variable errechnen
        LD      B,H             ;! und nach BC übertragen
        LD      C,L             ;!
        RET
;
S677E:  DEFS    5               ; Speicher für Schleifenende
;
;
        DEFS    1
S6784:  DEFS    2               ; Zeilennummer der Zeile
S6786:  DEFS    1               ; Offset auf nächste Zeile
                                ;  (sollten eigentlich 2 Byte sein)
;
;
;   das folgende Programmstück ist kaputt und wird auch nicht gebraucht
;
A6787:  CALL    A6A0A           ; Zeiger in HL auf nächstes relevantes Programmbyte
        OR      A               ; Zeilenende  ?
        RET     NZ              ; nein
        INC     HL              ; Zeiger auf Anfang nächste Zeile
        PUSH    DE              ; Keep register value
        LD      E,(HL)          ;! Offset auf nächste Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      A,D             ;! Offset gleich Null ?
        OR      E               ;!
        INC     HL
        LD      (S6786),DE      ;! Offset auf nächste Zeile merken
                                ;! (Überschreibt Programm und ist schon seit MZ-700 falsch)
        LD      E,(HL)          ;! Zeilennummer der Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      (S6784),DE      ; und merken
        POP     DE              ; geretteten Register - Wert holen
        SCF                     ; Code for 'Ende Programm'
        RET     Z               ; Programmende gefunden
        JR      A6787           ; nächstes relevante Byte suchen
;
;
;   Basic - Befehl   USR     (Token code  195 / 0C3H)
;
A67A4:  CALL    A79A6           ; Syntax 'Klammer auf'
        CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        LD      (D67DC + 1),DE  ; USR - Adresse in Routine eintragen
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      NZ,A67CF        ; nein -->  keine Variable angegeben
        CALL    EXPR            ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
        CALL    A9036           ; Syntaxuntersuchung auf Zeichenkettenergebnis
        LD      (D67D1 + 1),DE  ; Zeiger auf Eingangswert merken
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      NZ,A67CF        ; nein -->  keine Ausgangsvariable angegeben
        CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        CALL    A9036           ; Syntaxuntersuchung auf Zeichenkettenergebnis
        LD      (D67E4 + 1),BC  ; Zeiger auf Ausgangsvariable merken
        XOR     A               ; Code for 'Ausgangsvariable angegeben'
A67CF:  PUSH    HL              ; Programmzeiger retten
        PUSH    AF              ; Code für Ausgangsvariable retten
D67D1:  LD      HL,0            ; Zeiger auf Eingangswert - Descriptor  (wird eingetragen)
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
        LD      IX,ERRORJ       ; Rücksprungadresse für Fehler vorgeben
        XOR     A               ; Code for 'kein Fehler'  vorgeben
D67DC:  CALL    0               ; Maschinenprogramm aufrufen   (Adresse wird eingetragen)
        POP     AF              ; Code der Ausgangsvariable holen
        JR      NZ,A67EA        ; keine Ausgangsvariable angegeben
        LD      A,B             ; Länge des übergebenen Textes holen
        EX      DE,HL           ; Zeiger auf Text nach HL
D67E4:  LD      DE,0            ; Zeiger auf Ausgangsvariable  (wird eingetragen)
        CALL    A6546           ; Zeichenkette der Variablen zuweisen
A67EA:  POP     HL              ; geretteten Programmzeiger holen
        JP      A79AA           ; auf Syntax 'Klammer zu' überprüfen
;
;
;   Basic - Befehl   WAIT     (Token code  190 / 0BEH)
;
A67EE:  CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
A67F1:  LD      A,D             ;! Wartezähler gleich Null  ?
        OR      E               ;!
        RET     Z               ; ja -->  fertig
        LD      B,251           ;! Zeitschleife  ca. 0.1 sec
A67F6:  DJNZ    A67F6           ;!
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    14              ; Code 14  Abfrage, ob (Shift) - BREAK gedrückt ist
        RET     Z               ; ja -->  fertig
        DEC     DE              ; Wartezähler minus eins
        JR      A67F1           ; untersuchen, ob fertig
;
;
;   Basic - Befehl   DATA      (Token code  148 / 094H)
;   Basic - Befehl   REM       (Token code  151 / 097H)
;   Basic - Befehl   LABEL     (Token code  202 / 0CAH)
;
A67FE:  DEC     HL              ; Programmzeiger corrigieren
A67FF:  CALL    A6A0A           ; Zeiger in HL auf nächstes relevantes Programmbyte
        OR      A               ; Zeilenendezeichen  ?
        SCF                     ; Code for 'Zeilenende'  setzen
        RET     Z               ; ja -->  fertig
        CP      ':'             ; Befehlsende  ?
        RET     Z               ; ja -->  fertig
        JR      A67FF           ; Ende des Befehls suchen
;
;
;   Basic - Befehl   OUT@     (Token code  186 / 0BAH)
;
A680A:  CALL    IBYTE           ; ein - Byte - Wert nach DE / Accu bereitstellen
        SUB     0E0H            ; Anfang Umschaltports
        CP      7               ; Anzahl Umschaltports
        JP      C,A636A         ; Umschaltport -->  Fehler 3  Illegal data error
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        PUSH    DE              ; Port - Nummer retten
        CALL    IBYTE           ; ein - Byte - Wert nach DE / Accu bereitstellen
        POP     BC              ; Port - Nummer holen
        OUT     (C),A           ; ein Byte an Port ausgeben
        RET
;
;
;   Basic - Befehl   INP@     (Token code  171 / 0BBH)
;
A681F:  CALL    IBYTE           ; ein - Byte - Wert nach DE / Accu bereitstellen
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        PUSH    DE              ; Port - Nummer retten
        CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        CP      5               ; Real - Zahlvariable  ?
        JP      NZ,A636D        ; nein -->  Fehler 4  Type mismatch error
        EX      (SP),HL         ; Programmzeiger retten / Port - Nummer holen
        PUSH    BC              ; Zeiger auf Variable retten
        EX      (SP),HL         ; Portnummer retten / Zeiger auf Variable holen
        POP     BC              ; Port - Nummer holen
        IN      E,(C)           ; Wert vom Port holen
        LD      D,0             ; High - Byte Wert auf Null
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   CURSOR     (Token code  254 164 / 0FEH 0A4H)
;
A683B:  CALL    A6843           ; angegebene Cursor - Koordinaten bereitstellen
        EX      DE,HL           ; Cursor-Koordinaten nach HL / Programmzeiger nach DE
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    18              ; Code 18  Cursor auf Koordinaten in HL setzen
        EX      DE,HL           ; Programmzeiger nach HL
        RET
;
;
;   Grenzen für Cursor - Befehl vorgeben und angegebene Werte bereitstellen
;
A6843:  LD      B,24            ; maximale Y - Koordinate Cursor
        LD      C,39            ; maximale X - Koordinate bei 40 Zeichen/Zeile
        LD      A,(S137A)       ; Bildschirm - Modus - Nummer holen
        CP      3               ; Modus eins oder zwei  ?
        JR      C,A6850         ; ja -->  40 Zeichen je Zeile
        LD      C,79            ; maximale X - Koordinate bei 80 Zeichen/Zeile
A6850:  CALL    A6857           ; zwei Werte bereitstellen und auf Grenzen untersuchen
        JP      C,A636A         ; Wert(e) zu groß -->  Fehler 3  Illegal data error
        RET
;
;
;   zwei Werte aus Ausdruck (HL) bereitstellen und auf Grenzen überprüfen
;
A6857:  PUSH    BC              ; Wertgrenzen retten
        CALL    IBYTE           ; ein - Byte - Wert nach DE / Accu bereitstellen
        PUSH    AF              ; ersten Wert retten
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    IBYTE           ; ein - Byte - Wert nach DE / Accu bereitstellen
        LD      D,E             ; zweiten Wert merken
        POP     AF              ; ersten Wert holen
        LD      E,A             ; und merken
        POP     BC              ; gerettete Grenzen holen
        LD      A,C             ; Grenze für ersten Wert holen
        CP      E               ; und mit Wert vergleichen
        RET     C               ; Wert zu groß -->  Abbruch
        LD      A,B             ; Grenze für zweiten Wert holen
        CP      D               ; und mit zweitem Wert vergleichen
        RET
;
;
;   Basic - Befehl   GET     (Token code  173 / 0ADH)
;
A686C:  CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        LD      (S9E9C),A       ; Variablenartcode im Wertartflag merken
        CP      5               ; Zahlvariable  ?
        JR      Z,A688B         ; ja -->  auf Zahlwert untersuchen
        PUSH    HL              ; Programmzeiger retten
        PUSH    BC              ; Zeiger auf Variable retten
        LD      A,-1            ; Code for 'Tastaturabfrage mit Entprellen'
                                ; (wenn 0 -->  immer wenn Taste gedrückt -->  Ergebnis)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    13              ; Code 13  Tastaturabfrage nach Status im Accu
        OR      A               ; Taste gedrückt  ?
        JR      Z,A6885         ; nein
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        LD      (HL),A          ; gedrückte Taste eintragen
        LD      A,1             ; Stringlänge  'ein Zeichen'  vorgeben
A6885:  POP     DE              ; Zeiger auf Variable holen
        CALL    A6546           ; Zeichenkette der Variablen zuweisen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   GET  Zahlvariable
;
A688B:  PUSH    HL              ; Programmzeiger retten
        PUSH    BC              ; Zeiger auf Variable retten
        LD      A,-1            ; Code for 'Tastaturabfrage mit Entprellen'  (0=mit Repeat)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    13              ; Code 13  Tastaturabfrage nach Status im Accu
        SUB     '0'             ; ASCII umsetzen in Dezimalwert
        CP      10              ; Ziffer  ?
        JR      C,A6898         ; ja
        XOR     A               ; Vorgabe 'Null'  (0)
A6898:  LD      E,A             ; Wert der Taste merken
        LD      D,0             ; High - Byte Wert auf Null
        POP     HL              ; Zeiger auf Variable holen
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   POKE     (Token code  160 / 0A0H)
;
A68A1:  CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        CALL    A79B4           ; auf Syntax 'Komma' untersuchen
A68A7:  PUSH    DE              ; POKE - Adresse merken
        CALL    IBYTE           ; ein - Byte - Wert nach DE / Accu bereitstellen
        POP     DE              ; POKE - Adresse holen
        LD      (DE),A          ; Wert im Speicher eintragen
        INC     DE              ; Zeiger auf Speicher auf nächstes Byte
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        RET     NZ              ; keine weiteren Werte
        JR      A68A7           ; nächsten Wert bereitstellen und in Speicher eintragen
;
;
;   Basic - Befehl   LIMIT     (Token code  254 167 / 0FEH 0A7H)
;
A68B5:  PUSH    HL              ; Programmzeiger bei Anfang Befehl retten
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    "M"             ; M  (Max)  ?
        JR      NZ,A68CE        ; nicht MAX -->  Wert bereitstellen
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    "A"             ; A  (mAx)  ?
        JR      NZ,A68CE        ; nicht MAX -->  Wert bereitstellen
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    "X"             ; X  (maX)  ?
        JR      NZ,A68CE        ; nicht MAX -->  Wert bereitstellen
        EX      (SP),HL         ; Programmzeiger retten / alten Zeiger verwerfen
        LD      HL,(MEMMAX)     ; maximal erlaubte RAM - Adresse holen
        JR      A68EA           ; LIMIT - Wert setzen
;
;
;   LIMIT mit Angabe der Speicheradresse
;
A68CE:  POP     HL              ; alten Programmzeiger holen
        CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        PUSH    HL              ; Programmzeiger retten
        LD      HL,(MEMMAX)     ; maximal erlaubte RAM - Adresse holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Adressen vergleichen
        JP      C,A63A7         ; LIMIT - Adresse zu groß -->  Fehler 6  Memory capacity error
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        INC     H               ;! ein KByte als Arbeitsspeicher reservieren
        INC     H               ;!
        INC     H               ;!
        INC     H               ;!
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Adressen vergleichen
        JP      NC,A636A        ; LIMIT-Adresse zu klein -->  Fehler 3  Illegal data error
        EX      DE,HL           ; LIMIT - Adresse nach DE
A68EA:  CALL    A616E           ; Zeiger auf Rechenspeicher merken
        POP     HL              ; Programmzeiger holen
        POP     DE              ; Rücksprungadresse holen
        LD      SP,(INTFAC)     ; höchste nutzbare Basic - Adresse holen
        LD      BC,-1           ; Code for 'keine Werte auf Stack'
        PUSH    BC              ; Steuerwort auf Stack ablegen
        PUSH    DE              ; Rücksprungadresse wieder auf Stack ablegen
        RET
;
;
;   Basic - Befehl   RETURN     (Token code  132 / 084H)
;
A68F9:  POP     IX              ; Rücksprungadresse vom Stack holen
A68FB:  POP     BC              ; Steuerwort vom Stack holen
        PUSH    BC              ; und wieder merken
        LD      A,B             ; High - Byte Steuerwort holen
        INC     A               ; Kennung Steuerwort  (0FFH)  ?
        JP      NZ,A637F        ; nein -->  Fehler 14  RETURN error
        LD      A,C             ; Low - Byte Steuerwort holen
        CP      18              ; Code for 'FOR - Daten'  ?
        JR      Z,A6921         ; ja -->  nächsten Datensatz vergleichen
        CP      0FEH            ; Code for 'RETURN - Daten'  ?
        JP      NZ,A637F        ; nein -->  Fehler 14  RETURN error
        POP     BC              ; Steuerwort vom Stack holen
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        EX      DE,HL           ; Programmzeiger nach DE
        POP     HL              ; Zeilennummer vom Stack holen
        LD      (S9E51),HL      ; als aktuelle Zeilennummer merken
        POP     HL              ; Zeiger auf nächste Zeile vom Stack holen
        LD      (S9E4B),HL      ; Zeiger auf nächste Programmzeile merken
        POP     HL              ; Programmzeiger vom Stack holen
        PUSH    IX              ; Rücksprungadresse wieder auf Stack ablegen
        RET     Z               ; Befehlsende -->  nächster Befehl
        EX      DE,HL           ; Programmzeiger bei RETURN wieder nach HL
        JP      A69AF           ; GOTO - Routine   (RETURN Zeilennummer)
;
A6921:  EX      DE,HL           ; Programmzeiger nach DE retten
        LD      HL,18           ; Länge FOR - Datensatz
        ADD     HL,SP           ; Zeiger auf nächsten Datensatz errechnen
        LD      SP,HL           ; Stackpointer neu setzen
        EX      DE,HL           ; Programmzeiger wieder nach HL
        JR      A68FB           ; nächsten Datensatz überprüfen
;
;
;   Basic - Befehl   GOSUB     (Token code  129 / 081H)
;
A692A:  PUSH    HL              ; Programmzeiger retten
        CALL    A67FE           ; Zeiger in HL auf Ende Befehl stellen
        EX      DE,HL           ; Zeiger in DE merken
        POP     HL              ; geretteten Programmzeiger holen
        POP     BC              ; Rücksprungadresse holen
        PUSH    DE              ; Zeiger auf nächsten Befehl merken
        EXX
        LD      HL,(S9E4B)      ; Zeiger auf nächste Programmzeile holen
        PUSH    HL              ; für RETURN auf Stack merken
        LD      HL,(S9E51)      ; aktuelle Zeilennummer holen
        PUSH    HL              ; für RETURN auf Stack merken
        LD      HL,0FFFEH       ; Code for 'RETURN - Daten'
        PUSH    HL              ; auf Stack ablegen
        LD      HL,-512         ; Vorgabe für Arbeitsspeicherlänge
        ADD     HL,SP           ; minimale Stackadresse errechnen
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        SBC     HL,DE           ; Adresse überprüfen
        LD      A,10            ; Fehler 10  GOSUB nesting error
        JP      C,A63A9         ; Adressen überschneiden sich -->  Fehler ausgeben
        EXX
        PUSH    BC              ; Rücksprungadresse wieder auf Stack ablegen
        JR      A69AF           ; GOTO - Routine
;
;
;   Basic - Befehl   ON     (Token code  157 / 09DH)
;
A6952:  CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    _ERROR          ; ERROR  (Zwischencode)  ?
        JP      Z,A64E4         ; ja -->  ON ERROR GOTO
        CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        LD      C,E             ;! Zähler nach BC übertragen
        LD      B,D             ;!
        CP      087H            ; mit maximalem Befehl für ON ___  vergleichen
        JP      NC,A6364        ; Fehler 1  Syntax error
        CP      ____GO          ; Zwischencode  GO  ?
        JR      NZ,A6977        ; nein
        CALL    INCHLF          ; HL + 1, Leerzeichen  (Spaces)  (HL) überspringen
        LD      E,_GOSUB        ; ZwischenCode for 'GOSUB'  vorgeben
        CP      ____PI          ; Zwischencode PI   (hier sollte wohl SUB stehen)
        JR      Z,A6976         ; ja -->  GOSUB
        CP      ____TO          ; Zwischencode  TO  ?
        JP      NZ,A6364        ; Fehler 1  Syntax error
        DEC     E               ; Zwischencode auf 'GOTO'
A6976:  LD      A,E             ; Zwischencode des Befehls holen
A6977:  PUSH    HL              ; Programmzeiger retten
        LD      HL,W5C5B        ; Zeiger auf Tabelle mit Anfangsadressen der Befehle
        SUB     080H            ; Zwischencode in Zähler umrechnen
        ADD     A,A             ; mal zwei   (zwei Byte je Adresse)
        LD      E,A             ; Low - Byte Offset vorgeben
        LD      D,0             ; High - Byte Offset auf Null
        ADD     HL,DE           ; Zeiger auf richtige Adresse errechnen
        CALL    INDRCT          ; Offset auf nächste Zeile nach HL holen
        EX      (SP),HL         ; Anfangsadresse retten / Programmzeiger holen
        INC     HL              ; Zwischencode des Befehls überspringen
        LD      A,B             ; High - Byte Zähler holen
        OR      A               ; gleich Null  ?
        JR      NZ,A69AB        ; nein -->  nächsten Befehl ausführen
        LD      A,C             ; Low - Byte Zähler holen
        OR      A               ; gleich Null  ?
        JR      Z,A69AB         ; ja -->  nächsten Befehl ausführen
        LD      B,A             ; Zähler merken
A6990:  DEC     B               ; Zähler minus eins
        RET     Z               ; Zeiger steht auf richtiger Zeilennummer
        CALL    HLFTCH          ; Leerzeichen  (Spaces)  (HL) überspringen
        CALL    A69DB           ; Zeichen im Accu gleich Kennung Sprungadresse  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
        CALL    A6A10           ; Sprungadresse (HL) überspringen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja
        INC     HL              ; Trennzeichen überspringen
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      Z,A6990         ; ja -->  auf richtige Adresse überprüfen
        POP     DE              ; Anfangsadresse der Routine verwerfen
        JP      A797A           ; auf Syntax 'Befehlsende' überprüfen
;
A69AB:  POP     DE              ; Anfangsadresse der Routine verwerfen
        JP      A67FE           ; Zeiger in HL auf Ende Befehl stellen
;
;
;   Basic - Befehl   GOTO    (Token code  128 / 080H)
;
A69AF:  CALL    A5E19           ; Zeiger auf Zeile nach Programmtext (HL) bereitstellen
        EX      DE,HL           ; Programmzeiger nach DE / Zeiger auf Zeile nach HL
        JR      NZ,A69B8        ; Zeilennummer war nicht Null
        LD      HL,(TEXTST)     ; Basic - Programmanfang holen
A69B8:  LD      (S9E4B),HL      ; als Zeiger auf nächste Programmzeile merken
        XOR     A               ; Code for 'kein CONT möglich'
        LD      (M63F6),A       ; CONT - Flag zurücksetzen
        JP      A5909           ; Programm ab Zeile (HL) abarbeiten
;
;
;   Basic - Befehl   IF     (Token code  147 / 093H)
;
A69C2:  CALL    EXPR            ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
        EX      AF,AF           ; nächstes Programmbyte retten
        LD      A,(DE)          ; Exponent Ergebnis holen
        OR      A               ; gleich Null  ?
        JR      Z,A69EA         ; ja -->  Bedingung nicht erfüllt
        EX      AF,AF           ; nächstes Programmbyte holen
        CP      __THEN          ; Zwischencode  THEN  ?
        JR      NZ,A69D7        ; nein -->  nächsten Befehl abarbeiten
A69CF:  CALL    INCHLF          ; HL + 1, Leerzeichen  (Spaces)  (HL) überspringen
        CALL    A69DB           ; Zeichen im Accu gleich Kennung Sprungadresse  ?
        JR      Z,A69AF         ; ja -->  GOTO ausführen
A69D7:  POP     AF              ; Rücksprungadresse vom Stack holen
        JP      A58D4           ; nächsten Befehl abarbeiten
;
;
;   testen, ob Zeichen im Accu gleich Kennung Sprungadresse ist
;
A69DB:  CP      '\"'            ; Kennung  Label  ?
        RET     Z               ; ja
;
;
;   testen, ob Zeichen im Accu gleich Kennung für Zeilennummer ist
;
A69DE:  CP      _LINNO          ; Code for 'Integer - Zeilennummer'  ?
        RET     Z               ; ja
        CP      _LIN_P          ; Code for 'Zeiger auf Zeile'  ?
        RET
;
;
;   Basic - Befehl   ELSE     (Token code  194 / 0C2H)
;
A69E4:  CALL    A69F3           ; zum IF gehöriges ELSE suchen
        JR      NC,A69E4        ; nicht Zeilenende -->  Zeilenende suchen
        RET
;
;
;   IF mit nicht erfüllter Bedingung
;
A69EA:  DEC     HL              ; Programmzeiger für Schleife corrigieren
        CALL    A69F3           ; zum IF gehöriges ELSE suchen
        JR      NC,A69CF        ; nicht Zeilenende -->  Anweisung abarbeiten
        JP      A5906           ; nächste Basic - Zeile abarbeiten
;
;
;   zum IF gehöriges ELSE suchen
;
A69F3:  CALL    A6A0A           ; Zeiger in HL auf nächstes relevantes Programmbyte
        OR      A               ; Zeilenende  ?
        SCF                     ; Code for 'Zeilenende'  setzen
        RET     Z               ; Zeilenende
        CP      __ELSE          ; Zwischencode  ELSE  ?
        RET     Z               ; ja
        CP      ____IF          ; Zwischencode  IF  ?
        JR      NZ,A69F3        ; nein -->  weiter suchen
        CALL    A69F3           ; zum IF gehöriges ELSE suchen
        RET     C               ; Zeilenende
        JR      A69F3           ; zum IF gehöriges ELSE suchen
;
A6A06:  INC     HL              ; Trennungszeichen überspringen
        LD      A,(HL)          ; nächstes Programmbyte holen
        JR      A6A10           ; Sprungadresse (HL) überspringen
;
;
;   Zeiger in HL auf nächstes relevantes Programmbyte stellen
;
A6A0A:  INC     HL              ; Programmzeiger auf nächstes Programmbyte
        LD      A,(HL)          ; nächstes Programmbyte holen
        CP      __DATA          ; Zwischencode  DATA  ?
        JR      Z,A6A2F         ; ja -->  DATA - Statement überspringen
A6A10:  OR      A               ; Zeilenendecode  ?
        RET     Z               ; ja
        CP      '\"'            ; Textkonstante  ?
        JR      Z,A6A4D         ; ja -->  Ende der Textkonstanten suchen
        CP      0FEH            ; Vorbyte für Tabellen zwei und drei  ?
        JR      NC,A6A2D        ; Process command from table two or three 
        CP      ___REM          ; Zwischencode  REM  ?
        JR      Z,A6A2F         ; ja -->  Kommentar überspringen
        CP      '\''            ; Code for 'Kommentar'  ?
        JR      Z,A6A2F         ; ja -->  Kommentar überspringen
        CP      ' '             ; Steuerzeichen  ?
        RET     NC              ; nein
        CP      _LINNO
        RET     C               ; ein - Byte - Steuerzeichen
        CP      __REAL          ; Real - Zahlwert  ?
        JR      NC,A6A44        ; ja
        INC     HL              ;! Integer - Wert / - Zeiger überspringen
A6A2D:  INC     HL              ;!
        RET
;
A6A2F:  LD      A,(HL)          ; nächstes Programmbyte holen
        OR      A               ; Zeilenendezeichen ?
        RET     Z               ; ja
        CP      ':'             ; Befehlsendezeichen  ?
        RET     Z               ; ja
        CP      '\"'            ; Anfang Textkonstante  ?
        JR      Z,A6A3C         ; ja -->  Ende der Textkonstanten suchen
        INC     HL              ; Zeichen überspringen
        JR      A6A2F           ; Ende des Befehls suchen
;
A6A3C:  CALL    A6A4D           ; Zeiger in HL auf Ende Textkonstante stellen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja
        INC     HL              ; Textendezeichen überspringen
        JR      A6A2F           ; Befehlsende suchen
;
A6A44:  AND     00001111B       ; Länge des Zahlwertes maskieren
        ADD     A,L             ; zum Low - Byte Programmzeiger addieren
        LD      L,A             ; neues Low - Byte Zeiger merken
        LD      A,' '           ; Space  (Leerzeichen)  vorgeben
        RET     NC              ; kein Übertrag
        INC     H               ; High - Byte Programmzeiger corrigieren
        RET
;
A6A4D:  INC     HL              ; Programmzeiger auf nächstes Byte stellen
        LD      A,(HL)          ; nächstes Programmbyte holen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja
        CP      '\"'            ; Textendezeichen ?
        RET     Z               ; ja
        JR      A6A4D           ; Ende der Textkonstanten suchen
;
;
;   Basic - Befehl   BEEP     (Token code  254 141 / 0FEH 08DH)
;
A6A56:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    32              ; Code 32  Referenzton ausgeben
        RET
;
;
;   Basic - Befehl   BYE     (Token code  196 / 0C4H)
;
A6A59:  CALL    A797A           ; auf Syntax 'Befehlsende' überprüfen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    40              ; Code 40   alle Datei - Daten im Rechner löschen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    0               ; Code 0   BASIC - Monitor aufrufen
        RET
;
;
;   Basic - Befehl   CONSOLE     (Token code  184 / 0B8H)
;
A6A61:  JR      Z,A6A8D         ; keine Parameter -->  Ausschnitt aufheben
        LD      A,(S136F)       ; aktuelle minimale Y - Koordinate holen
        LD      D,0             ; High - Byte auf Null
        LD      E,A             ; minimale Y - Koordinate merken
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      Z,A6A75         ; keine minimale Y - Koordinate angegeben
        CALL    IBYTE           ; ein - Byte - Wert nach DE / Accu bereitstellen
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
A6A75:  LD      C,E             ; minimale Y - Koordinate
        PUSH    BC              ; merken
        CALL    IBYTE           ; ein - Byte - Wert nach DE / Accu bereitstellen
        POP     BC              ; minimale Y - Koordinate holen
        DEC     A               ; Anzahl Zeilen gleich Null  ?
        JP      M,A636A         ; ja -->  Fehler 3  Illegal data error
        ADD     A,C             ; maximale Y - Koordinate errechnen
        CP      25              ; mit maximal möglicher Y - Koordinate vergleichen
        JP      NC,A636A        ; zu groß -->  Fehler 3  Illegal data error
        LD      B,A             ; maximale Y - Koordinate merken
        PUSH    HL              ; Programmzeiger retten
        LD      H,B             ; maximale Y - Koordinate
        LD      L,C             ; minimale Y - Koordinate
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    83              ; Code 83  Bildschirmausschnitt nach Daten in HL setzen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Bildschirmausschnitt aufheben
;
A6A8D:  PUSH    HL              ; Programmzeiger retten
        LD      HL,256 * 24 + 0 ; Y - Koordinate minimal / maximal vorgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    83              ; Code 83  Bildschirmausschnitt nach Daten in HL setzen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   BOOT     (Token code  254 174 / 0FEH 0AEH)
;
A6A95:  DI                      ; Interrupt sperren
        OUT     (_KMODE),A      ; Umschalten auf MZ-80 - K - Modus
        JP      0               ; Kaltstart Monitor
;
;
;   Basic - Befehl   SEARCH     (Token code  185 / 0B9H)
;
A6A9B:  XOR     A               ; Code for 'SEARCH'
        DEFB    LD_BC
;
;
;   Basic - LIST command  (token code 135 / 087H) 
;
A6A9D:  LD      A,1             ; Code for 'LIST'
        LD      (S6B83),A       ; in the SEARCH/LIST/SAVE flag
        PUSH    AF              ; Remember flag 'SEARCH/LIST'
        CALL    GETLU           ; Provide file or device number
        RST     _DOCMD          ; Software - Execute command
        DEFB    46              ; Code 46 Deploy file management record by no
        JP      C,A63A3         ; not found --> Error 64 Logical number error
        BIT     1,A             ; File/device open for writing ?
        JP      Z,A63A3         ; no --> Error 64 Logical number error
        CALL    TEST1           ; next program byte same byte after CALL call ?
        DEFM    ","             ; comma ?
        POP     AF              ; Get flag 'SEARCH/LIST'
        OR      A               ; SEARCH or LIST command
        JR      NZ,A6ACD        ; LIST command
        CALL    A8561           ; Evaluate string expression (HL)/pointer to string after DE
        LD      A,B             ; get string length
        LD      (S6B7E),A       ; and note for comparison
        LD      (S6B7F),DE      ; Remember pointer to search string
        CALL    A797A           ; check for 'end of command' syntax
        JR      A6ACD           ; Provide starting and ending line number
;
;
;   Programmzeilen aufbereiten in ASCII und an Datei ausgeben
;
A6AC8:  LD      A,2             ; Code for 'SAVE'
        LD      (S6B83),A       ; im Flag  SEARCH/LIST/SAVE  merken
A6ACD:  CALL    A5ED3           ; Zeilennummern aus Eingabe bereitstellen
        LD      (D6AF3 + 1),DE  ; Anfangszeilennummer in Routine eintragen
        LD      (A6B01 + 1),BC  ; Endzeilennummer in Routine eintragen
        LD      A,-1            ; Code for 'Steuerzeichen anzeigen'
        LD      (DISPX),A       ; im Flag  'Steuerzeichen anzeigen'  eintragen
        CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      HL,(TEXTST)     ; Basic - Programmanfang holen
A6AE3:  CALL    LDDEMI          ; Offset auf nächste Zeile nach DE holen
        LD      A,D             ;! Offset gleich Null  ?
        OR      E               ;!
        RET     Z               ; ja -->  fertig
        EX      DE,HL           ;! Zeiger auf nächste Zeile errechnen
        ADD     HL,DE           ;!
        DEC     HL              ;!
        DEC     HL              ;!
        EX      DE,HL           ; Zeiger auf nächste Zeile nach DE
        PUSH    DE              ; Zeiger auf nächste Zeile merken
        CALL    LDDEMI          ; Zeilennummer der Zeile nach DE holen
        PUSH    HL              ; Zeiger auf Zeile retten
D6AF3:  LD      HL,0            ; Anfangszeilennummer holen   (wird eingetragen)
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Zeilennummern vergleichen
        JR      C,A6B01         ; OK -->  auf Endzeilennummer untersuchen
        JR      Z,A6B01         ; OK -->  auf Endzeilennummer untersuchen
        POP     HL              ; Zeiger auf Zeile verwerfen
        POP     HL              ; Zeiger auf nächste Zeile holen
        JR      A6AE3           ; nächste Zeile überprüfen
;
A6B01:  LD      HL,0            ; Endzeilennummer holen   (wird eingetragen)
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Zeilennummern vergleichen
        JR      NC,A6B0C        ; Zeile muß bearbeitet werden
        POP     HL              ; Zeiger auf Zeile verwerfen
        POP     HL              ; Zeiger auf nächste Zeile verwerfen
        RET
;
A6B0C:  EX      DE,HL           ; Zeilennummer nach HL
        CALL    A7998           ; Hex-Wert in HL umsetzen in Dezimal nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    23              ; Code 23  Länge des Textes (DE) auszählen
        LD      HL,S11A4        ; Zeiger auf Zwischenspeicher vorgeben
        CALL    LDHLDE          ; Speicherbereich von (DE) nach (HL) verschieben
        LD      (HL),' '        ; Leerzeichen nach Zeilennummer eintragen
        INC     HL              ; Leerzeichen überspringen
        EX      DE,HL           ; Zeiger auf Speicher nach DE
        POP     HL              ; Get pointer to tokenized line
		CALL    CVTXIM          ; Convert tokenized line in (HL) to ASCII in (DE)
        LD      A,(S6B83)       ; Flag  SEARCH/LIST/SAVE  holen
        OR      A               ; SEARCH  ?
        JR      NZ,A6B2B        ; nein -->  Zeile ausgeben
        CALL    A6B41           ; vergleichen, ob Zeile für SEARCH ausgegeben werden muß
        JR      NC,A6B35        ; Text nicht gefunden -->  Zeile nicht ausgeben
A6B2B:  LD      DE,S11A4        ; Zeiger auf Text der aufbereiteten Zeile
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    23              ; Code 23  Länge des Textes (DE) auszählen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    55              ; Code 55  Text (DE) auf angewähltem Gerät/Datei ausgeben
        CALL    PRTCR           ; Zeilenvorschub auf angewähltem Gerät/Datei ausgeben
A6B35:  POP     HL              ; Zeiger auf nächste Zeile holen
        LD      A,(S6B83)       ; Flag  SEARCH/LIST/SAVE  holen
        CP      2               ; SAVE  ?
        JR      Z,A6AE3         ; ja -->  nächste Zeile überprüfen   (und ausgeben)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    15              ; Code 15  wenn Sapce gedrückt -->  warten bis andere Taste
        JR      A6AE3           ; nächste Zeile überprüfen (und ausgeben)
;
;
;   vergleichen, ob Zeile für SEARCH ausgegeben werden muß
;
A6B41:  EX      DE,HL           ; Zeiger auf ASCII - Text - Zeile nach HL
A6B42:  PUSH    HL              ; Zeiger auf Stelle der Zeile retten
        CALL    A6B4C           ; auf Suchtext vergleichen
        POP     HL              ; geretteten Zeiger auf Textstelle holen
        RET     C               ; Text gefunden
        RET     Z               ; Zeilenende gefunden
        INC     HL              ; Zeiger auf Text auf nächstes Zeichen
        JR      A6B42           ; Text ab neuer Anfangsstelle vergleichen
;
A6B4C:  LD      A,(S6B7E)       ; Textlänge des Suchstrings holen
        LD      B,A             ; und merken
        LD      DE,(S6B7F)      ; Zeiger auf Suchstring holen
A6B54:  LD      A,(HL)          ; ein Zeichen Text holen
        INC     HL              ; Zeiger auf Text auf nächstes Zeichen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja
        CP      _SML            ; Umschalten auf Kleinschrift  ?
        JR      Z,A6B60         ; ja -->  nächstes Zeichen holen
        CP      _CAP            ; Umschalten auf Großschrift  ?
        JR      NZ,A6B62        ; nein -->  Zeichen vergleichen
A6B60:  JR      A6B54           ; nächstes Zeichen holen und vergleichen
;
A6B62:  PUSH    HL              ; Zeiger auf Text retten
        LD      C,A             ; Zeichen merken
A6B64:  LD      A,(DE)          ; ein Zeichen Textvorgabe holen
        INC     DE              ; Zeiger auf nächstes Zeichen
        CP      _SML            ; Umschalten auf Kleinschrift  ?
        JR      Z,A6B6E         ; ja -->  nicht vergleichen
        CP      _CAP            ; Umschalten auf Großschrift  ?
        JR      NZ,A6B75        ; nein -->  Zeichen vergleichen
A6B6E:  DEC     B               ; Zähler  'Restanzahl'  minus eins
        SCF                     ; Code for 'Text gefunden'  setzen
        POP     HL              ; Zeiger auf Zeile holen
        RET     Z               ; alle Zeichen verglichen
        PUSH    HL              ; Zeiger auf Zeile retten
        JR      A6B64           ; nächstes Zeichen vergleichen
;
A6B75:  SUB     C               ; Zeichen vergleichen
        POP     HL              ; Zeiger auf Zeile holen
        OR      A               ; Zeichen gefunden  ?
        RET     NZ              ; nein
        DEC     B               ; Zähler  'Restanzahl'  minus eins
        SCF                     ; Code for 'Text gefunden'  setzen
        RET     Z               ; alle Zeichen verglichen
        JR      A6B54           ; nächstes Zeichen vergleichen
;
;
;   Speicher für SEARCH - Befehl
;
S6B7E:  DEFS    1               ; Textlänge Suchstring
;
S6B7F:  DEFS    2               ; Zeiger auf Suchstring
;
        DEFS    2
;
S6B83:  DEFS    1               ; Flag  SEARCH/LIST/SAVE
;
;
;   Basic - Befehl   KEY     (Token code  178 / 092H)
;
A6B84:  CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    __LIST          ; LIST   (Zwischencode)   ?
        CALL    A7981           ; auf /P untersuchen und Ausgabegerät vorgeben
        PUSH    HL              ; Programmzeiger retten
        LD      C,0             ; Zähler für Tastennummer auf Null
A6B8E:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    8               ; Code 8  Zeilenvorschub auf Bildschirm oder Drucker ausgeben
        LD      A,C             ; Tastenzähler holen
        ADD     A,'1'           ; umsetzen in ASCII
        LD      D,A             ; und merken
        LD      E,' '           ; Leerzeichen  (Space)  für erste Stelle vorgeben
        CP      '9' + 1         ; größer als 9 ?
        JR      NZ,A6B9D        ; nein
        LD      DE,'0'*256+'1'  ; 10 vorgeben
A6B9D:  LD      (M6C20),DE      ; Tastennummer in Text eintragen
        LD      DE,M6C18        ; Text  'DEF KEY(xx)='
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    11              ; Code 11  Text (DE) auf Bildschirm oder Drucker ausgeben
        LD      A,C             ; Tastenzähler holen
        CALL    A6C77           ; Zeiger auf Tastentextspeicher nach Nummer in A stellen
        LD      B,(HL)          ; Textlänge holen
        INC     HL              ; Textlänge überspringen
        PUSH    BC              ; Tastenzähler merken
        CALL    A6BBB           ; Text der Taste aufbereiten und ausgeben
        POP     BC              ; Tastenzähler holen
        INC     C               ; plus eins
        LD      A,C             ; neuen Wert holen
        CP      10              ; alle Tastentexte ausgegeben  ?
        JR      NZ,A6B8E        ; nein -->  weitere Tastentexte ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    8               ; Code 8  Zeilenvorschub auf Bildschirm oder Drucker ausgeben
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Tastentext (HL) aufbereiten und ausgeben
;
A6BBB:  LD      A,B             ; Textlänge holen
        OR      A               ; gleich Null  ?
        LD      C,0             ; Code for 'nicht im Text'
        JR      NZ,A6BC8        ; Textlänge ungleich Null -->  ausgeben
        LD      A,'\"'          ; Anführungszeichen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    10              ; Code 10  Accu auf Bildschirm oder Drucker (Anzeige Steuerzeichen)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    10              ; Code 10  Accu auf Bildschirm oder Drucker (Anzeige Steuerzeichen)
        RET
;
A6BC8:  LD      A,(HL)          ; ein Zeichen Text holen
        CP      ' '             ; Steuerzeichen  ?
        JR      C,A6BED         ; ja -->  als CHR$  ausgeben
        CP      '\"'            ; Anführungszeichen ?
        JR      Z,A6BED         ; ja -->  als CHR$  ausgeben
        LD      A,C             ; Textcodeflag holen
        CP      1               ; Code for 'im Text'  ?
        JR      Z,A6BE0         ; ja
        OR      A               ; Code for 'im CHR$'  ?
        LD      DE,M6C25        ; Text  ')+"'
        JR      NZ,A6BDE        ; im CHR$ -->  CHR$ abschliessen
        INC     DE              ;! Textzeiger auf Anführungszeichen stellen
        INC     DE              ;!
A6BDE:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    11              ; Code 11  Text (DE) auf Bildschirm oder Drucker ausgeben
A6BE0:  LD      A,(HL)          ; ein Zeichen Tastentext holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    10              ; Code 10  Accu auf Bildschirm oder Drucker (Anzeige Steuerzeichen)
        INC     HL              ; Zeiger auf Tastentext auf nächstes Zeichen
        LD      C,1             ; Code for 'im Text'  vorgeben
        DJNZ    A6BC8           ; weitere Zeichen ausgeben
        LD      A,'\"'          ; Anführungszeichen
A6BEA:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    10              ; Code 10  Accu auf Bildschirm oder Drucker (Anzeige Steuerzeichen)
        RET
;
A6BED:  LD      A,C             ; Textcodeflag holen
        CP      -1              ; Code for 'im CHR$'  ?
        JR      Z,A6C12         ; ja -->  Komma ausgeben
        OR      A               ; Code for 'im Text'  ?
        LD      DE,M6C29        ; Text '"+CHR$('
        JR      NZ,A6BFA        ; ja -->  Anführungszeichen mit ausgeben
        INC     DE              ;! Anführungszeichen und plus überspringen
        INC     DE              ;!
A6BFA:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    11              ; Code 11  Text (DE) auf Bildschirm oder Drucker ausgeben
A6BFC:  PUSH    BC              ; Restlänge retten
        PUSH    HL              ; Zeiger auf Resttext retten
        LD      L,(HL)          ; Steuerzeichen holen
        LD      H,0             ; High - Byte Wert auf Null
        CALL    A7998           ; Hex-Wert in HL umsetzen in Dezimal nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    11              ; Code 11  Text (DE) auf Bildschirm oder Drucker ausgeben
        POP     HL              ; geretteten Zeiger auf Resttext holen
        POP     BC              ; gerettete Restanzahl Zeichen holen
        INC     HL              ; Zeiger auf Text auf nächstes Zeichen
        LD      C,-1            ; Code for 'im CHR$'
        DJNZ    A6BC8           ; weitere Zeichen Text ausgeben
        LD      A,')'           ; Klammer zu, um CHR$ abzuschliessen
        JP      A6BEA           ; Zeichen im Accu ausgeben
;
A6C12:  LD      A,','           ; Komma als Trennzeichen zwischen Werten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    10              ; Code 10  Accu auf Bildschirm oder Drucker (Anzeige Steuerzeichen)
        JR      A6BFC           ; Steuerzeichen ausgeben
;
;
;   Texte für KEY  LIST  - Befehl
;
M6C18:  DEFM    "DEF KEY("      ; Text  'DEF KEY(  )=
M6C20:  DEFS    2               ; Freistelle für Tastennummer
        DEFM    ")="
		DEFB    NUL
;
M6C25:  DEFM    ")+\""          ; Text  ')+"'
        DEFB    NUL
;
M6C29:  DEFM    "\"+CHR$("      ; Text  '"+CHR$('
        DEFB    NUL
;
;
;   Basic - Befehl   DEF     (Token code  199 / 0C7H)
;
A6C31:  CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    ___KEY          ; KEY  (Zwischencode)  ?
        JR      Z,A6C42         ; ja -->  DEF KEY
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    0FFH            ; Vorbyte  Tabelle drei  ?
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    ____FN          ; FN   (Zwischencode)  ?
        JP      A8F44           ; Basic - Befehl   DEF FN
;
;
;   Basic - Befehl   DEF KEY     (Token code 199 178 / 0C7H 0B2H)
;
A6C42:  CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "("             ; Klammer auf  ?
        CALL    IBYTE           ; ein - Byte - Wert nach DE / Accu bereitstellen
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    ")"             ; Klammer zu  ?
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    ____EQ          ; =   (Zwischencode)  ?
        LD      A,E             ; Tastennummer holen
        DEC     A               ; für Tastenoffset corrigieren
        CP      10              ; Taste null bis neun  ?
        JP      NC,A636A        ; nein -->  Fehler 3  Illegal data error
        PUSH    HL              ; Programmzeiger retten
        CALL    A6C77           ; Zeiger auf Tastentextspeicher nach Nummer in A stellen
        EX      (SP),HL         ; Zeiger für Tastentext retten / Programmzeiger holen
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        EX      (SP),HL         ; Programmzeiger retten / Zeiger für Text holen
        LD      A,B             ; Textlänge holen
        CP      15 + 1          ; mit maximaler Länge vergleichen
        JR      C,A6C68         ; Textlänge ist OK
        LD      A,15            ; maximale Textlänge vorgeben
A6C68:  LD      (HL),A          ; Textlänge in Speicher eintragen
        OR      A               ; Textlänge gleich Null  ?
        JR      Z,A6C74         ; ja -->  geretteten Programmzeiger holen
        LD      B,A             ; Textlänge als Zähler vorgeben
        INC     HL              ; Textlänge überspringen
A6C6E:  LD      A,(DE)          ;! ein Zeichen Text übertragen
        LD      (HL),A          ;!
        INC     DE              ;!   Zeiger auf vorgegebenen Text
        INC     HL              ;!   Zeiger auf Stelle für Tastentext
        DJNZ    A6C6E           ; weitere Zeichen übertragen
A6C74:  POP     HL              ; geretteten Programmzeiger holen
        EI                      ; Interrupt freigeben
        RET
;
;
;   Zeiger auf Tastentextspeicher nach Nummer im Accu bereitstellen
;
A6C77:  ADD     A,A             ;! Tastenzähler mal  2    (16 Byte je Taste)
        ADD     A,A             ;!                   4
        ADD     A,A             ;!                   8
        ADD     A,A             ;!                  16
        LD      HL,B12B2        ; Zeiger auf Speicher für Funktionstastentexte
        JP      ADDHLA          ; Wert im Accu zum HL - Register addieren
;
;
;   Abfrage, ob aktuelles Gerät gleich Bildschirm ist
;
A6C81:  LD      A,(S1042)       ; interne aktuelle Geräte - Nummer holen
        CP      136             ; Geräte - Nummer Bildschirm   (CRT:)  ?
        RET
;
;
;   Ausdruck (HL) auswerten und Ergebnis als Zeichenketten bereitstellen
;
A6C87:  CALL    EXPR            ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
        LD      A,(S9E9C)       ; Wertartflag holen
        CP      3               ; Zeichenkettenwert  ?
        PUSH    HL              ; Programmzeiger retten
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        JR      Z,A6C9A         ; Ergebnis ist Zeichenkette
		CALL    A7B5B           ; Real-Wert (HL) umsetzen in ASCII nach Zwischenspeicher
        POP     HL              ; geretteten Programmzeiger holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    23              ; Code 23  Länge des Textes (DE) auszählen
        RET
;
A6C9A:  CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   PRINT     (Token code  143 / 08FH)
;
A6C9F:  XOR     A               ; Code for 'Steuerzeichen ausführen'
        LD      (DISPX),A       ; im Flag  'Steuerzeichen anzeigen'  merken
        CALL    GETLU           ; Datei- oder Gerätenummer bereitstellen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    46              ; Code 46  Datei-Verwaltungssatz nach Nr. bereitstellen
        JP      C,A6E2D         ; Datei nicht gefunden -->  Fehler 44  Not open error
        BIT     2,A             ; XOPEN  ?
        JP      NZ,A7459        ; ja -->  PRINT auf RANDOM - Datei
        BIT     1,A             ; Datei oder Gerät zum Schreiben eröffnet  ?
        JP      Z,A6E30         ; nein -->  Fehler 59'  Can't execute error
        CALL    A6F39           ; bei Datei auf 'Syntax Komma' überprüfen
        CALL    A6C81           ; Abfrage, ob aktuelles Gerät gleich Bildschirm ist
        JR      NZ,A6CD3        ; nicht Bildschirm -->  nicht auf Farbe untersuchen
        LD      A,(S137B)       ; maximaler Palettenwert / aktuelle Zeichenfarbe holen
        LD      (B7591),A       ; als Vorgabe für Palettenwert der Zeichen merken
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    "["             ; Eckige Klammer auf  ?
        JR      NZ,A6CD3        ; nein -->  kein Farbwert angegeben
		CALL    A76D9           ; Ausdruck (HL) auswerten und auf max. Palettenwert untersuchen
        LD      (B7591),A       ; Palettenwert für Zeichen merken
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "]"             ; eckige Klammer zu  ?
A6CD3:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JP      Z,PRTCR         ; Zeilenvorschub auf angewähltem Gerät/Datei ausgeben
A6CD9:  LD      A,(HL)          ; nächstes Programmbyte holen
        CP      _USING          ; Zwischencode  USING  ?
        JR      Z,PRUSNG        ; ja -->  PRINT USING - Routine
        LD      BC,T6CF2        ; Rücksprungadresse
        PUSH    BC              ; auf Stack ablegen
        CP      ';'             ; Trennzeichen Strichpunkt ?
        RET     Z               ; ja
        CP      ','             ; Trennzeichen Komma  ?
        RET     Z               ; ja
        CP      ___TAB          ; Zwischencode  TAB  ?
        JR      Z,A6D28         ; ja -->  PRINT TAB
        CALL    A6C87           ; Ausdruck (HL) auswerten / Ergebnis als Zeichenkette
        JP      A6DB6           ; bereitgestellten Wert auf Gerät/Datei ausgeben
;
T6CF2:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JP      Z,PRTCR         ; Zeilenvorschub auf angewähltem Gerät/Datei ausgeben
        CP      ','             ; Trennzeichen Komma  ?
        JR      NZ,A6D18        ; nein -->  auf anderes Trennzeichen untersuchen
;
;
;   Ausgabe bei PRINT auf nächste 10er - Tabulationsstelle setzen
;
        CALL    A6C81           ; Abfrage, ob aktuelles Gerät gleich Bildschirm ist
        JR      C,A6D15         ; Tabulation auf Gerät nicht möglich -->  Zeilenvorschub
        LD      IX,(S1061)      ; Adresse 'aktuelle Spaltennummer bereitstellen' holen
        CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        LD      B,A             ; aktuelle Spaltennummer merken
A6D09:  SUB     10              ; 10 abziehen
        JR      NC,A6D09        ; weiter abziehen
        NEG                     ; Anzahl auszugebender Zeichen errechnen
        LD      B,A             ; Anzahl Zeichen merken
        CALL    A6D4A           ; Zeichenkette mit Spaces aufbauen und ausgeben
        JR      A6D18           ; auf Syntax Trennzeichen untersuchen
;
A6D15:  CALL    PRTCR           ; Zeilenvorschub auf angewähltem Gerät/Datei ausgeben
A6D18:  LD      A,(HL)          ; nächstes Programmbyte holen
        CP      ','             ; Trennzeichen Komma  ?
        JR      Z,A6D1F         ; ja -->  Syntax ist OK
        CP      ';'             ; Trennzeichen Strichpunkt  ?
A6D1F:  JR      NZ,A6D22        ; nein -->  testen, ob Befehlsende
        INC     HL              ; Trennzeichen überspringen
A6D22:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        RET     Z               ; ja -->  nächster Befehl
        JR      A6CD9           ; nächsten PRINT - Teil ausführen
;
;
;   PRINT TAB
;
A6D28:  CALL    A6C81           ; Abfrage, ob aktuelles Gerät gleich Bildschirm ist
        JP      C,A6E30         ; kein tabellierbares Gerät -->  Fehler 59'  Can't execute error
		CALL    A79A2           ; auf Syntax 'Klammer auf' überprüfen
        CALL    IBYTE           ; ein - Byte - Wert nach DE / Accu bereitstellen
        CALL    A79AA           ; auf Syntax 'Klammer zu' überprüfen
        LD      IX,(S1061)      ; Adresse  'aktuelle Spaltennummer bereitstellen'  holen
        CALL    IOCALL          ; Routine (IX) mit Fehlerbehandlung aufrufen
        SUB     E               ; mit Tabulationsspalten vergleichen
        RET     NC              ; schon über Tabulationsspalte hinaus -->  Befehl vergessen
        NEG                     ; fehlende Spalten errechnen
        LD      B,A             ; und merken
        CALL    A6C81           ; Abfrage, ob aktuelles Gerät gleich Bildschirm ist
        LD      A,C_RIGHT       ; 'Cursor rechts' für Bildschirm
        JR      Z,A6D4C         ; Ausgabe auf Bildschirm
;
;
;   Zeichenkette mit Leerzeichen aufbauen und ausgeben
;
A6D4A:  LD      A,' '           ; Leerzeichen (Space)  für anderes Gerät
A6D4C:  LD      DE,S11A4+1      ; Zeiger auf Zwischenspeicher vorgeben
        PUSH    BC              ; Anzahl Zeichen retten
        PUSH    DE              ; Zeiger auf Anfang Speicher retten
        CALL    SETDE           ; Speicher (DE) mit Zeichen im Accu initiieren
        POP     DE              ; Zeiger auf Anfang Speicher holen
        POP     BC              ; Anzahl Zeichen holen
        JR      A6DB6           ; bereitgestellte Zeichenkette auf Gerät/Datei ausgeben
;
;
;   USING - Format bereitstellen und Werte entsprechend USING - Format ausgeben
;
PRUSNG: INC     HL              ; Zwischencode USING überspringen
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        LD      A,B             ; Länge Format - Text holen
        OR      A               ; gleich Null  ?
        JP      Z,A636A         ; ja -->  Fehler 3  Illegal data error
        PUSH    HL              ; Programmzeiger retten
        LD      HL,S11A4+1      ; Zeiger auf Zwischenspeicher vorgeben
        PUSH    HL              ; Zeiger auf Anfang Speicher retten
        PUSH    BC              ; Textlänge retten
        CALL    LDHLDE          ; Speicherbereich von (DE) nach (HL) verschieben
        POP     BC              ; Textlänge holen
        LD      A,240           ; Speichernummer für USING - Format
        LD      E,B             ; Textlänge
        LD      D,0             ; High - Byte Textlänge auf Null
        INC     DE              ; für Textendezeichen corrigieren
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    42              ; Code 42  dynamischen Zwischenspeicher bereitstellen
        LD      (S7E39),HL      ;! Zeiger auf Speicher in Routine eintragen
        LD      (S7E3B),HL      ;!
        POP     DE              ; Zeiger auf Speicher mit Format holen
        CALL    LDHLDE          ; Speicherbereich von (DE) nach (HL) verschieben
        LD      (HL),NUL        ; Textendezeichen eintragen
        POP     HL              ; geretteten Programmzeiger holen
A6D80:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A6DA7         ; ja -->  Speicher für USING - Format löschen
        INC     HL              ; Trennzeichen überspringen
        CP      ','             ; Trennzeichen Komma  ?
        JR      Z,A6D8F         ; ja -->  Syntax ist OK
        CP      ';'             ; Trennzeichen Strichpunkt  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
A6D8F:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A6DAA         ; ja -->  Speicher für USING - Format löschen
        CALL    A8584           ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
        PUSH    HL              ; Programmzeiger retten
        LD      BC,(TMPEND)     ; Ende Stringarbeitsbereich holen
        PUSH    BC              ; und merken
        CALL    A7E3D           ; bereitgestellten Wert entsprechend USING-Format aufbereiten
        POP     DE              ; Zeiger auf aufbereiteten Text holen
        CALL    PRTMSG          ; Text auf angewähltem Gerät / Datei ausgeben
        POP     HL              ; geretteten Programmzeiger holen
        JR      A6D80           ; testen, ob fertig
;
A6DA7:  CALL    PRTCR           ; Zeilenvorschub auf angewähltem Gerät/Datei ausgeben
;
;
;   Speicher für USING - Format löschen
;
A6DAA:  LD      A,240           ; Speichernummer für USING - Format
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    43              ; Code 43   dynamischen Zwischenspeicher löschen
        RET
;
CR_TXT:  DEFB    CR,NUL         ; Text für Zeilenvorschub
;
;
;   Zeilenvorschub auf angewähltem Gerät/Datei ausgeben
;
PRTCR:  LD      DE,CR_TXT       ; Text  'Zeilenvorschub'
;
;
;   Text auf angewähltem Gerät / Datei ausgeben
;
PRTMSG: RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    23              ; Code 23  Länge des Textes (DE) auszählen
A6DB6:  CALL    A6C81           ; Abfrage, ob aktuelles Gerät gleich Bildschirm ist
        JR      Z,PRTMC         ; Text (DE) auf Bildschirm ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    55              ; Code 55  Text (DE) auf angewähltem Gerät/Datei ausgeben
        RET
;
;
;   Text (DE) auf Bildschirm ausgeben
;
PRTMC:  PUSH    AF              ; Keep register value
        LD      A,(B7591)       ; Vorgabe für Palettenwert des Zeichens holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    84              ; Code 84  aktuell benutzte Farbebenen setzen
        POP     AF              ; geretteten Register - Wert holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    55              ; Code 55  Text (DE) auf angewähltem Gerät/Datei ausgeben
        LD      A,(S137B)       ; maximalen Palettenwert holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    84              ; Code 84  aktuell benutze Farbebenen setzen
        RET
;
;
;   Basic - Befehl   READ     (Token code  149 / 095H)
;
READ:   LD      A,138           ; interne aktuelle Geräte - Nummer für READ
        LD      (S1042),A       ; als interne aktuelle Geräte - Nummer merken
        JR      A6E0B           ; Werte bereitstellen und Variablen zuweisen
;
;
;   Basic - Befehl   INPUT     (Token code 145 / 091H)
;
INPUT:  CALL    GETLU           ; Datei- oder Gerätenummer bereitstellen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    46              ; Code 46  Datei-Verwaltungssatz nach Nr. bereitstellen
        JP      C,A6E2D         ; Datei nicht gefunden -->  Fehler 44  Not open error
        BIT     2,A             ; XOPEN  ?
        JP      NZ,A746A        ; ja -->  INPUT aus RANDOM - Datei
        BIT     0,A             ; Datei oder Gerät zum Lesen eröffnet  ?
        JP      Z,A6E30         ; nein -->  Fehler 59'  Can't execute error
        CALL    A6F39           ; bei Datei auf 'Syntax Komma' überprüfen
        CALL    A6C81           ; Abfrage, ob aktuelles Gerät gleich Bildschirm ist
        JR      NZ,A6E0B        ; nein -->  INPUT aus Datei
        CALL    HLFTCH          ; Leerzeichen  (Spaces)  (HL) überspringen
        CP      '\"'            ; Anführungszeichen  ?
        LD      DE,M6E35        ; Text  ?
        LD      B,2             ; Länge zwei Zeichen
        JR      NZ,A6E01        ; kein Text angegeben -->  Fragezeichen ausgeben
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    ";"             ; Strichpunkt  ?
A6E01:  LD      A,B             ; Textlänge holen
        OR      A               ; gleich Null  ?
        JR      Z,A6E0B         ; ja -->  kein Text vorhanden
A6E05:  LD      A,(DE)          ; ein Zeichen Text holen
        INC     DE              ; Zeiger auf Text auf nächstes Zeichen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausführung Steuerzeichen)
        DJNZ    A6E05           ; weitere Zeichen Text ausgeben
A6E0B:  LD      (D6E63 + 1),SP  ; Stackpointer merken
        LD      DE,(VARED)      ; Anfang Stringarbeitsbereich holen
        LD      (TMPEND),DE     ; als Ende Stringarbeitsbereich merken
A6E17:  LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        CALL    A8C08           ; Überprüfen, ob Adresse in DE mit Stack collidiert
        CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        PUSH    AF              ; Variablentypcode auf Stack merken
        PUSH    BC              ; Zeiger auf Variable merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A6E37         ; ja -->  alle Variablennamen ausgewertet
        CALL    A79B4           ; auf Syntax 'Komma' untersuchen
        JR      A6E17           ; Werte der weiteren Variablen auswerten
;
A6E2D:  LD      A,44            ; Fehler 44  Not open error
        DEFB    LD_HL
A6E30:  LD      A,187           ; Fehler 59  Can't execute error
        JP      ERRORJ          ; Fehler mit Nummer im Accu behandeln
;
M6E35:  DEFM    "? "            ; Textvorgabe für Abfrage ohne Textangabe
;
;
;   Werte bereitstellen und den bereitgestellten Variablen zuweisen
;
A6E37:  XOR     A               ; Code for 'Stackende'
        PUSH    AF              ; auf Stack ablegen
        PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    52              ; Code 52  wenn Bildschirm -->  eine Zeile bereitstellen
        LD      HL,(D6E63 + 1)  ; Zeiger auf Stack holen
        DEC     HL              ; Zeiger auf Wertcode
A6E40:  LD      A,(HL)          ; Wertcode vom Stack holen
        OR      A               ; Ende Werte  ?
        JR      Z,A6E62         ; ja -->  Stackpointer richtig setzen
        DEC     HL              ;!  Wertcode überspringen
        DEC     HL              ;!
        LD      B,(HL)          ;! Zeiger auf Variable vom Stack holen
        DEC     HL              ;!
        LD      C,(HL)          ;!
        DEC     HL
        PUSH    HL              ; Zeiger auf nächsten Datensatz retten
        PUSH    AF              ; Wertcode der Variablen retten
        PUSH    BC              ; Zeiger auf Variable retten
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        CALL    A6E67           ; nächste Konstante für Zuweisung bereitstellen
        LD      H,0             ; High - Byte Länge auf Null
        LD      L,B             ; Textlänge als Low - Byte vorgeben
        ADD     HL,DE           ; Zeiger auf Ende Text errechnen
        LD      (HL),NUL        ; Textendezeichen eintragen
        POP     DE              ; Zeiger auf Variable holen
        POP     AF              ; Variablenartcode holen
        CALL    A6E71           ; bereitgestellten Wert der Variablen zuweisen
        POP     HL              ; Zeiger auf nächsten Datensatz holen
        JR      A6E40           ; weitere Variable zuweisen
;
A6E62:  POP     HL              ; geretteten Programmzeiger holen
D6E63:  LD      SP,0            ; Stackpointer wieder richtig setzen   (Adresse wird eingetragen)
        RET
;
;
;   nächste Konstante aus DATA, Datei oder von Gerät bereitstellen
;
A6E67:  LD      A,(S1042)       ; interne aktuelle Geräte - Nummer holen
        CP      138             ; interne Geräte - Nummer  READ - Befehl   ?
        JR      Z,A6EB0         ; ja -->  nächste DATA-Statement-Konstante bereitstellen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    53              ; Code 53  einen Datensatz von Datei oder Gerät lesen
        RET
;
;
;   bereitgestellten Wert der Variablen zuweisen
;
A6E71:  CP      3               ; Zeichenkettenvariable  ?
        JR      NZ,A6E7C        ; nein
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        LD      A,B             ; Zeichenkettenlänge holen
        JP      A6546           ; Zeichenkette der Variablen zuweisen
;
A6E7C:  PUSH    DE              ; Zeiger auf Variable retten
        LD      HL,(INTFAC)     ; höchste nutzbare Basic - Adresse holen
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        EX      DE,HL           ; Zeiger auf Text nach HL
        CALL    HLFTCH          ; Leerzeichen  (Spaces)  (HL) überspringen
        CP      'E'             ; E  (Exponent)  ?
        JP      Z,A636A         ; ja -->  Fehler 3  Illegal data error
        EX      DE,HL           ; Zeiger auf Text wieder nach DE
        CALL    A7A0E           ; ASCII - Text (DE) umsetzen in Real-Wert nach (HL)
        EX      DE,HL           ; Zeiger auf Resttext nach HL
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    NUL             ; Textendezeichen  ?
        JP      NZ,A636A        ; nicht Textende -->  Fehler 3  Illegal data error
        EX      DE,HL           ; Zeiger auf bereitgestellten Wert nach HL
        POP     DE              ; Zeiger auf Variable holen
        JP      A79C5           ; Zahlwert von (HL) nach (DE) übertragen
;
;
;   Basic - Befehl   RESTORE     (Token code  133 / 085H)
;
A6E9E:  XOR     A               ; Accu auf Null
        LD      (S9E5D),A       ; DATA - Status zurücksetzen
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        CALL    NZ,A5E19        ; Zeiger auf Zeile nach Programmtext (HL) bereitstellen
        EX      DE,HL           ; Zeiger auf Zeile nach HL
        CALL    NZ,A6EE0        ; Zeile angegeben -->  erstes DATA - Statement suchen
        EX      DE,HL           ; Programmzeiger nach HL
        JP      A67FE           ; Zeiger in HL auf Ende Befehl stellen
;
;
;   erstes DATA - Statement ab Zeiger auf Zeile in HL suchen
;
A6EB0:  PUSH    HL              ; Zeiger auf Zeile retten
        PUSH    DE              ; Keep register value
        CALL    A6EBE           ; nächstes DATA - Statement ab Zeiger in HL suchen
        POP     DE              ; geretteten Register - Wert holen
        POP     HL              ; geretteten Zeiger auf Zeile holen
        RET
;
;
;   nächste DATA - Konstante bereitstellen
;
A6EB8:  LD      HL,(TEXTST)     ; Basic - Programmanfang holen
        CALL    A6EE0           ; nächstes DATA - Statement ab (HL) suchen
A6EBE:  LD      A,(S9E5D)       ; DATA - Flag holen
        CP      1               ; Code for 'Programmende'  ?
        JP      Z,A639A         ; ja -->  Fehler 24  READ error
        JR      C,A6EB8         ; Zeiger zurückgesetzt -->  ab Anfang suchen
        LD      HL,(S9E5E)      ; DATA - Zeiger holen
        LD      C,':'           ; Trennzeichen vorgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    54              ; Code 54  Textkonstante (HL) bis Zeichen in C nach (DE)
        LD      (S9E5E),HL      ; DATA - Zeiger merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        SCF                     ;! Carry - Flag zurücksetzen
        CCF                     ;!
        RET     NZ              ; nicht Befehlsende
        DEC     HL              ; Zeiger corrigieren
A6ED9:  CALL    A6A06           ; Zeiger in HL auf nächstes relevante Programmbyte
        OR      A               ; Zeilenendezeichen  ?
        JR      NZ,A6EEB        ; nein -->  auf DATA untersuchen
        INC     HL              ; Zeilenendezeichen überspringen
A6EE0:  LD      A,(HL)          ;! Überprüfen, ob Offset auf nächste Zeile
        INC     HL              ;! vorhanden ist
        OR      (HL)            ;!
        LD      A,1             ; Code for 'Programmende'
        JR      Z,A6EF5         ; Offset gleich Null -->  Code 'Programmende' merken
        INC     HL              ;! Rest Offset und Zeilennummer überspringen
        INC     HL              ;!
        JR      A6ED9           ; untersuchen, ob DATA - Statement
;
A6EEB:  CP      __DATA          ; Zwischencode  DATA  ?
        JR      NZ,A6ED9        ; nein -->  weiter suchen
        INC     HL              ; Zwischencode DATA überspringen
        LD      (S9E5E),HL      ; DATA - Zeiger merken
        LD      A,2             ; Code for 'Zeiger steht auf DATA'
A6EF5:  LD      (S9E5D),A       ; DATA - Status merken
        RET
;
;
;   Text (HL) auswerten und Datei- oder Gerätenummer bereitstellen
;
GETLU:  CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    "#"             ; Kennung Dateinummer  ?
        JR      NZ,A6F24        ; auf Bildschirm, /P, /T untersuchen und Geräte-Nr. bereitstellen
        CALL    HLFTCH          ; Leerzeichen  (Spaces)  (HL) überspringen
        CP      ' '             ; Wertcode  ?
        JP      NC,A6364        ; Fehler 1  Syntax error
        PUSH    DE              ;! Register - Werte retten
        PUSH    BC              ;!
		LD      DE,S9E9D        ; Zeiger auf Zwischenspeicher für Berechnung
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        CALL    A874C           ; Wert der Konstanten bereitstellen
        EX      (SP),HL         ; Programmzeiger retten / Zeiger auf Wert holen
		CALL    HLFLT           ; Real-Wert (HL) umsetzen in Integer-Wert nach HL
        LD      A,H             ; High - Byte Datei - Nummer holen
        OR      A               ; gleich Null  ?
        JP      NZ,A63A3        ; nein -->  Fehler 64  Logical number error
        OR      L               ; Low - Byte Wert holen
        JP      Z,A63A3         ; gleich Null -->  Fehler 64  Logical number error
        JP      M,A63A3         ; > 127 -->  Fehler 64  Logical number error
        POP     HL              ; Programmzeiger holen
        POP     BC              ;! gerettete Register - Werte holen
        POP     DE              ;!
        RET
;
;
;   auf Gerät Bildschirm, Drucker oder Cassette überprüfen und Gerätenummer bereitstellen
;
A6F24:  CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    ___DIV          ; /  (Zwischencode)  ?
        LD      A,136           ; Vorgabe Geräte - Nummer  'CRT:'
        RET     NZ              ; kein Gerät angegeben -->  Bildschirm
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    "P"             ; P  (Printer)  ?
        LD      A,137           ; Vorgabe Geräte - Nummer  'LPT:'
        RET     Z               ; ist /P
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "T"             ; T  (TAPE)  ?
        LD      A,128           ; Vorgabe Geräte - Nummer  'CMT:'
        RET
;
;
;   bei Datei auf 'Syntax Komma' überprüfen
;
A6F39:  LD      A,(S1042)       ; interne aktuelle Geräte - Nummer holen
        OR      A
        RET     M               ; internes Gerät -->  fertig
        JP      A79B1           ; auf Syntax  'Komma'  untersuchen
;
;
;   Basic - Befehl   DEFAULT     (Token code  172 / 0ACH)
;
A6F41:  CALL    A6FB1           ; Geräte - Namen bereitstellen und Gerät anmelden
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    58              ; Code 58  aktuelles Gerät als 'DEFAULT - Gerät' merken
        RET
;
;
;   Basic - Befehl   INIT    (Token code  220 / 0DCH)
;
A6F47:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        LD      B,0             ; Vorgabe  Länge Null
        CALL    NZ,A8561        ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
A6F4F:  PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    44              ; Code 44  Text (DE) auf Geräte - Namen auswerten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    60              ; Code 60  Gerät initialisieren
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   ROPEN     (Token code  208 / 0D0H)
;
A6F56:  LD      A,1             ; Code for 'Datei zum Lesen eröffnen'
        DEFB    LD_BC
;
;
;   Basic - Befehl   WOPEN     (Token code  206 / 0CEH)
;
A6F59:  LD      A,2             ; Code for 'Datei zum Schreiben eröffnen'
        DEFB    LD_BC
;
;
;   Basic - Befehl   XOPEN     (Token code  209 / 0D1H)
;
A6F5C:  LD      A,4             ; Code for 'Datei zum wahlfreien Zugriff eröffnen'
        PUSH    AF              ; Code merken
        LD      (S1043),A       ; Zugriffscode eintragen
        CALL    GETLU           ; Datei- oder Gerätenummer bereitstellen
        CP      136             ; Geräte - Nummer 136  (Bildschirm)  ?
        JR      NZ,A6F6B        ; nein
        LD      A,128           ; für Datei -->  Cassette vorgeben
A6F6B:  LD      (S1042),A       ; als interne aktuelle Geräte - Nummer merken
        CALL    A6F39           ; bei Datei auf 'Syntax Komma' überprüfen
        CALL    A6FA4           ; Text (HL) auf Geräte-Namen und Dateinamen auswerten
        POP     AF              ; Zugriffscode holen
        CP      4               ; RANDOM - Datei  ?
        JR      Z,A6F7B         ; ja -->  Code 'BRD - Datei'  vorgeben
A6F79:  LD      A,_BSD          ; Code for 'BSD - Datei'
A6F7B:  LD      (S1000),A       ; Datei - Typ - Code eintragen
        PUSH    AF              ; Datei - Typ - Code merken
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    51              ; Code 51  Datei nach bereitgestellten Daten eröffnen
        LD      A,(S1000)       ; gefundenen Datei - Typ holen
        POP     BC              ; vorgegebenen Datei - Typ holen
        CP      B               ; Datei - Typen vergleichen
        JP      NZ,A63D1        ; nicht gleich -->  Fehler 61  Illegal filemode error
        RET
;
;
;   Basic - Befehl   CLOSE     (Token code  207 / 0CFH)
;
B6F8A:  DEFB    OR_N            ; Code for 'CLOSE'
;
;
;   Basic - Befehl   KILL     (Token code  217 / 0D9H)
;
A6F8B:  XOR     A               ; Code for 'KILL'
        LD      B,A             ; Flag 'CLOSE/KILL'  merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A6FA0         ; ja -->  alle Dateien CLOSEn oder KILLen
A6F92:  CALL    GETLU           ; Datei- oder Gerätenummer bereitstellen
        CP      135 + 1         ; CRT oder höher  ?
        RET     NC              ; ja -->  fertig
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    56              ; Code 56  Dateien CLOSEn oder KILLen
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      A6F92           ; nächste Dateinummer auswerten
;
A6FA0:  XOR     A               ; Code for 'alle Dateien'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    56              ; Code 56  Dateien CLOSEn oder KILLen
        RET
;
;
;   Text (HL) auf Geräte-Namen und Dateinamen auswerten
;
A6FA4:  CALL    A5F15           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        LD      B,0             ; Code for 'Länge Null Zeichen'
        CALL    NZ,A8561        ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    45              ; Code 45  Geräte- und Dateinamen (DE) auswerten und aufbereiten
        POP     HL
        RET
;
;
;   Geräte - Namen bereitstellen und Gerät anmelden
;
A6FB1:  PUSH    HL              ; Programmzeiger retten
        CALL    HLFTCH          ; Leerzeichen  (Spaces)  (HL) überspringen
        LD      DE,S6FF9        ; Zeiger auf Speicher für Geräte - Namen
        LD      B,1             ; Länge  ein Zeichen
        CALL    A6FEC           ; wenn Accu gleich Buchstabe -->  merken
        CALL    NC,A6FEC        ; Buchstabe -->  wenn Accu gleich Buchstabe -->  merken
        JR      C,A6FD9         ; keine zwei Buchstaben -->  kein Geräte - Name
        CALL    A6FEC           ; wenn Accu gleich Buchstabe -->  merken
        CALL    A79F6           ; testen, ob Zeichen im Accu gleich Ziffer ist
        CALL    A6FF2           ; wenn Ziffer -->  merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      NZ,A6FD9        ; nein -->  auf Dateinamen untersuchen
        LD      A,':'           ; Code for 'Ende Geräte - Name'
        LD      (DE),A          ; hinter Text eintragen
        POP     AF              ; alten Programmzeiger verwerfen
        LD      DE,S6FF9        ; Zeiger auf bereitgestellten Geräte - Namen
        JR      A6FE2           ; Namen auswerten und Gerät anmelden
;
A6FD9:  POP     HL              ; alten Programmzeiger doch wieder holen
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        LD      B,0             ; Code for 'Länge Null Zeichen'
        CALL    NZ,A8561        ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
A6FE2:  PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    44              ; Code 44  Text (DE) auf Geräte-Namen auswerten
        INC     (HL)            ;! kompletten Text ausgewertet  ?
        DEC     (HL)            ;!
        JP      NZ,A63A0        ; nein -->  Fehler 58  Dev. name error
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   testen, ob Accu gleich Buchstabe, wenn ja -->  merken
;
A6FEC:  CP      'A'             ; Accu gleich Buchstabe  ?
        RET     C               ; nein
        CP      '['             ; Accu gleich Buchstabe  ?
        CCF                     ; Ergebnis umkehren
A6FF2:  RET     C               ; kein Buchstabe
        LD      (DE),A          ; Zeichen im Accu merken
        INC     HL              ; Zeiger auf vorgegebenen Text auf nächstes Zeichen
        INC     DE              ; Zeiger auf Speicher für Geräte - Namen
        LD      A,(HL)          ; nächstes Textzeichen holen
        INC     B               ; Zähler  'Anzahl Zeichen'  plus eins
        RET
;
S6FF9:  DEFS    4               ; Speicher für Geräte - Namen
;
;
;   Basic - Befehl   LOAD     (Token code  180 / 0B4H)
;
A6FFD:  CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    ___ALL          ; ALL  (Zwischencode)  ?
        JR      NZ,A7007        ; nicht 'LOAD ALL'
        XOR     A               ; Code for 'LOAD ALL'
A7004:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    59              ; Code 59  RAM-Karte auf Quick-Disk schreiben oder lesen
        RET
;
;
;   normaler LOAD - Befehl
;
A7007:  CALL    A6FA4           ; Text (HL) auf Geräte-Namen und Dateinamen auswerten
        CALL    TEST1           ; nächstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JP      Z,A70C5         ; ja -->  auf Sonderformat untersuchen
        PUSH    HL              ; Programmzeiger retten
        CALL    A7314           ; BASIC - Arbeitsbereich retten und Datei eröffnen
        DEC     A               ; Datei - Typ - Code
        JR      Z,A7027         ; Maschinenprogramm laden
        DEC     A               ; Datei - Typ - Code
        JP      NZ,A63D1        ; nicht BASIC-Programm -->  Fehler 61 Illegal filemode error
        CALL    A7340           ; wenn im Programm-Modus -->  Fehler 19  Instruction error
        CALL    A731D           ; Pseudo - Arbeitsbereiche vorgeben
        CALL    A7349           ; Speicher auf Platz überprüfen und Programm laden
        JR      A7043           ; Zwischenspeicher für Programmladeroutine löschen
;
;
;   Maschinenprogramm laden
;
A7027:  LD      HL,(S1016)      ; Ladeadresse holen
        PUSH    HL              ; und merken
        LD      DE,(MEMLMT)     ; Ende Rechenspeicherbereich holen
        CALL    A704D           ; Adressen in HL und DE vergleichen
        LD      DE,(S1014)      ; Programmlänge holen
        LD      BC,(MEMMAX)     ; maximal erlaubte RAM - Adresse holen
        CALL    NC,A7048        ; noch kein Fehler -->  Adressen vergleichen
        JP      C,A638B         ; Fehler 18  Memory protection error
        POP     HL              ; Ladeadresse holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    48              ; Code 48  Programm nach vorgegebener Kennung laden
A7043:  CALL    A737C           ; Zwischenspeicher für Programmladeroutine löschen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Endadresse errechnen und Adressen vergleichen
;
A7048:  ADD     HL,DE
        RET     C
        EX      DE,HL
        LD      H,B
        LD      L,C

;   Adressen in DE und HL vergleichen
;
A704D:  PUSH    HL              ; Keep register value
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Adressen vergleichen
        POP     HL              ; gerettete Register - Werte wieder holen
        RET
;
;
;   Basic - Befehl   CHAIN     (Token code  183 / 0B7H)
;
A7053:  CALL    A6FA4           ; Text (HL) auf Geräte-Namen und Datei-Nummer auswerten
        CALL    A7314           ; BASIC - Arbeitsbereich retten und Datei eröffnen
        CP      _BTX            ; Datei - Typ  BTX  ?
        JP      NZ,A63D1        ; nein -->  Fehler 61  Illegal filemode error
        LD      A,(S9E68)       ; SWAP - Flag holen
        OR      A               ; im SWAP - Modus  ?
        JP      Z,A718B         ; nein -->  Programm nachladen
        JP      A74F3           ; SWAP - Daten retten und Programm nachladen
;
;
;   Basic - Befehl   MERGE     (Token code 182 / 0B6H)
;
A7068:  CALL    A7340           ; wenn im Programm-Modus -->  Fehler 19  Instruction error
        CALL    A6FA4           ; Text (HL) auf Geräte-Namen und Datei-Nummer auswerten
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma ?
        JR      Z,A70CB         ; MERGE mit Sonderformatangabe
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    47              ; Code 47   (Programm-) Datei eröffnen
        CP      _BTX            ; Datei - Typ  BTX  ?
        JP      NZ,A63D1        ; nein -->  Fehler 61  Illegal filemode error
        PUSH    HL              ; Programmzeiger retten
        LD      HL,(VARED)      ; Anfang Stringarbeitsbereich holen
        LD      (TMPEND),HL     ; als Ende Stringarbeitsbereich merken
        LD      BC,1000         ; Vorgabe für Puffer
        ADD     HL,BC           ; Anfang freier Speicher errechnen
        JP      C,A63A7         ; Überlauf -->  Fehler 6  Memory error
        PUSH    HL              ; Pufferadresse retten
        LD      BC,(S1014)      ; Programmlänge holen
        INC     B               ; noch ein bischen Sicherheit dazutun  (256 Bytes)
        ADD     HL,BC           ; Endadresse errechnen
        JP      C,A63A7         ; Überlauf -->  Fehler 6  Memory error
        SBC     HL,SP           ; Adresse mit Stackpointer vergleichen
        JP      NC,A63A7        ; Adressen überschneiden sich -->  Fehler 6  Memory error
        POP     HL              ; Zeiger auf Puffer holen
        PUSH    HL              ; und wieder merken
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    48              ; Code 48   Programm nach vorgegebener Kennung nach (HL) laden
        POP     HL              ; Zeiger auf Puffer mit Programm holen
        CALL    A70A2           ; geladenes Programm mit vorhandenem Programm mischen
        POP     HL              ; Programmzeiger holen
        RET
;
;
;   geladenes Programm in vorhandenes Programm einmischen
;
A70A2:  CALL    LDDEMI          ; Wert (HL) nach DE holen
        LD      A,D             ;! Offset gleich Null  ?
        OR      E               ;!
        RET     Z               ; ja -->  Programm zugemischt
        PUSH    DE              ; Offset auf nächste Zeile retten
        CALL    LDDEMI          ; Zeilennummer der Zeile holen
        PUSH    HL              ; Zeiger auf Zeile retten
        LD      H,D             ;! Zeilennummer nach HL
        LD      L,E             ;!
        LD      (S9E4D),HL      ; als Editor - Zeilennummer merken
        CALL    A622C           ; eventuell vorhandene Zeile(n) löschen
        POP     HL              ; Zeiger auf Zeile holen
        POP     BC              ; Offset auf nächste Zeile holen
        PUSH    BC              ; und wieder merken
        PUSH    HL              ; Zeiger auf Zeile merken
        CALL    A6003           ; Zeile in Programmspeicher eintragen
        POP     HL              ; Zeiger auf Zeile holen
        POP     BC              ; Offset auf nächste Zeile holen
        ADD     HL,BC           ;! Zeiger auf Anfang der nächsten Zeile stellen
        DEC     HL              ;!
        DEC     HL              ;!
        DEC     HL              ;!
        DEC     HL              ;!
        JR      A70A2           ; nächste Zeile einsortieren
;
;
;   LOAD mit Sonderformatangabe
;
A70C5:  CALL    A7340           ; wenn im Programm-Modus -->  Fehler 19  Instruction error
        LD      A,1             ; Code for 'LOAD'
        DEFB    LD_BC
;
;
;   MERGE mit Sonderformatangabe
;
A70CB:  LD      A,0             ; Code for 'MERGE'
        DEFB    LD_BC
;
;
;   RUN mit Sonderformatangabe
;
A70CE:  LD      A,2             ; Code for 'RUN'
        PUSH    AF              ; Flag  'MERGE/LOAD/RUN'  retten
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    "A"             ; A   (ASCII)  ?
        CALL    A797A           ; auf Syntax Befehlsende überprüfen
        LD      A,1             ; Code for 'Datei zum Lesen eröffnen'
        LD      (S1043),A       ; als Datei - Zugriffscode eintragen
        LD      A,129           ; Datei - Nummer für Programm
        LD      (S1042),A       ; als interne aktuelle Geräte-Nummer merken
        CALL    A6F79           ; sequentielle Datei eröffnen
        POP     AF              ; Flag 'MERGE/LOAD/RUN' holen
        PUSH    AF              ; und wieder merken
        PUSH    HL              ; Programmzeiger retten
        LD      HL,0            ; Vorgabe für Anfangszeilennummer
        LD      DE,65535        ; Vorgabe für Endzeilennummer
        OR      A               ; Flag  'MERG/LOAD/RUN'
        CALL    NZ,A622C        ; nicht MERGE -->   eventuell vorhandene Zeilen löschen
        LD      A,129           ; Datei - Nummer für Programm
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    46              ; Code 46   Datei-Verwaltungssatz nach Nr. bereitstellen
        LD      HL,(VARED)      ; Anfang Stringarbeitsbereich holen
        LD      (TMPEND),HL     ; als Ende Stringarbeitsbereich merken
        LD      BC,1000         ; Vorgabe für Puffer
        ADD     HL,BC           ; Zeiger auf Anfang Puffer errechnen
        JP      C,A6373         ; Überlauf -->  Fehler 6   Memory capacity error
        PUSH    HL              ; Zeiger auf Anfang Puffer
        LD      (S7169),HL      ; merken
A7107:  LD      HL,-512         ; Vorgabe für Stackarbeitsbereich
        ADD     HL,SP           ; minimal Stackadresse errechnen
        LD      DE,(S7169)      ; Zeiger auf Anfang Puffer holen
        SBC     HL,DE           ; Adressen vergleichen
        JP      C,A6373         ; Fehler 6   Memory error
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    53              ; Code 53   einen Datensatz von Datei oder Gerät lesen
        LD      A,B             ; Datensatzlänge holen
        OR      A               ; gleich Null  ?
        JR      Z,A7154         ; ja -->  bereitgestelltes Programm einsortieren
        CALL    CVBCAS          ; ASCII - Wert (DE) umsetzen in Hex-Wert nach BC
        LD      A,B             ;! Zeilennummer gleich Null  ?
        OR      C               ;!
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        LD      HL,(S7169)      ; Zeiger auf Puffer holen
        PUSH    HL              ; Zeiger auf Anfang merken
        INC     HL              ;! Stelle für Offset übersprungen
        INC     HL              ;!
        LD      (HL),C          ;! Zeilennummer der Zeile eintragen
        INC     HL              ;!
        LD      (HL),B          ;!
        INC     HL
        PUSH    HL              ; Zeiger auf Stelle für Zwischencodetext merken
        LD      H,D             ;! Zeiger auf ASCII-Text-Zeile nach HL
        LD      L,E             ;!
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFB    NUL             ; Zeilenendezeichen  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        POP     HL              ; Zeiger auf Stelle für Zwischencode holen
        LD      A,(DE)          ; ein Textzeichen holen
        CP      ' '             ; Space  (Leerzeichen)  ?
        JR      NZ,A7141        ; nein -->  Zeichen auswerten
        INC     DE              ; Leerzeichen überspringen
A7141:  CALL    CVIMTX          ; ASCII-Text (DE) umsetzen in Zwischencode nach (HL)
        LD      (HL),NUL        ; Zeilenendezeichen eintragen
        INC     HL              ; Zeilenendezeichen überspringen
        LD      (S7169),HL      ; neuen Zeiger auf Puffer merken
        POP     DE              ; Zeiger auf Anfang Zeile holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Länge der Zeile errechnen
        EX      DE,HL           ; Länge nach DE / Zeiger für Offset nach HL
        LD      (HL),E          ;! Offset auf nächste Zeile vor
        INC     HL              ;! Zeilennummer eintragen
        LD      (HL),D          ;!
        JR      A7107           ; restliche Zeilen aus Datei einlesen
;
A7154:  LD      HL,(S7169)      ; Zeiger auf Puffer holen
        CALL    A61C5           ; (HL) Bereichsende  (00 00)  eintragen
        CALL    A619B           ; Variable löschen  (CLR - Routine)
        POP     HL              ; Zeiger auf Anfang Puffer holen
        CALL    A70A2           ; bereitgestellte Zeilen einsortieren
        POP     HL              ; Programmzeiger holen
        POP     AF              ; Flag  'MERGE/LOAD/RUN'  holen
        CP      2               ; Code for 'RUN'  ?
        RET     NZ              ; nein
        JP      A607C           ; Basic  - Programm starten
;
S7169:  DEFS    2               ; Zeiger für Pufferspeicher

;
;
;   RUN  "Dateiname"
;
A716B:  CALL    A6FA4           ; Text (HL) auf Geräte-Namen und Datei-Nummer auswerten
        PUSH    HL              ; Programmzeiger retten
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      NZ,A717D        ; nicht Komma -->  kein Sonderformat
        CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
        CP      'A'             ; A  (ASCII)  ?
        JP      Z,A70CE         ; ja -->  ASCII-Datei laden und starten
A717D:  CALL    A7314           ; BASIC - Arbeitsbereich retten und Datei eröffnen
        POP     HL              ; geretteten Programmzeiger holen
        DEC     A               ; Datei - Typ - Code
        JR      Z,A7194         ; Maschinenprogramm
        DEC     A               ; Datei - Typ - Code
        JP      NZ,A63D1        ; nicht BTX -->  Fehler 61  Illegal filemode error
        CALL    A731D           ; Pseudo - Arbeitsbereiche vorgeben
;
;
;   Programm  CHAINen
;
A718B:  CALL    A7349           ; Speicher auf Platz überprüfen und Programm laden
        CALL    A737C           ; Zwischenspeicher für Programmladeroutine löschen
        JP      A607C           ; BASIC - Programm starten
;
;
;   RUN  Maschinenprogramm
;
A7194:  LD      D,0             ; Code 'MZ-700 - Programm'
        LD      BC,0FF00H       ; maximale Speichergrenze  im MZ-800 - Modus
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      NZ,A71A8        ; nein -->  MZ-800  Maschinenprogramm laden
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    "R"             ; R   (Code for 'MZ-80 K - Programm laden)
        LD      D,1             ; Code for 'MZ-80 K - Programm'
        LD      BC,0CFF0H       ; maximale Speicheradresse im MZ-80 K - Modus
A71A8:  LD      A,D             ; Code 'MZ-800 / MZ-80 K'
        LD      (S11A4),A       ; merken
        LD      HL,(S1014)      ; Programmlänge holen
        LD      DE,(S1016)      ; Ladeadresse aus Dateikennung holen
        PUSH    HL              ; Programmlänge merken
        CALL    A7048           ; Endadresse errechnen und auf Ende Speicher überprüfen
        POP     DE              ; Programmlänge holen
        LD      HL,_START       ; Ladespeicheranfang vorgeben
        LD      BC,-256
        CALL    NC,A7048        ; Endadresse errechnen und auf Ende Speicher überprüfen
        JP      C,A63A7         ; Überlauf -->  Fehler 6  Memory error
        LD      SP,0            ; Stackpointer neu setzen
        CALL    A61A3           ; I/O-WORK-Area und BASIC-Variable/Funktionen löschen
        XOR     A               ; Code for 'keine Variable gerettet'
        LD      (S733F),A       ; im Flag  'Variable gerettet'  merken
        LD      A,00110110B     ; Code 'Zähler 0/Mode 3/Binary'
        OUT     (CTC_53),A      ; an Kontrollwortregister 8253 ausgeben
        LD      A,00000001B     ; Code 'Set Bit 0'
        OUT     (KEYP_F),A      ; Zähler 0 im 8253 sperren
        LD      HL,(S1016)      ; Ladeadresse aus Dateikennung holen
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        CALL    A704D           ; Adressen in DE und HL vergleichen
        JR      NC,A71F3        ; Ladeadresse liegt hinter Ende Stringarbeitsbereich
        PUSH    HL              ; Datei - Ladeadresse retten
        LD      HL,_START       ; minimal mögliche Ladeadresse vorgeben
        LD      (TEXTST),HL     ; als Anfang Basic - Programm merken
        CALL    A61A3           ; I/O-WORK-Area und BASIC-Variable/Funktionen löschen
        LD      HL,S122C        ; Anfangsadresse der neuen Fehlerbehandlungsroutine
		;LD      HL,0           ; Anfangsadresse der neuen Fehlerbehandlungsroutine
        LD      (ERRORP),HL     ; Adresse der Fehlerbehandlungsroutine merken
        POP     HL              ; Original - Ladeadresse holen
A71F3:  LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        CALL    A704D           ; Adressen in DE und HL vergleichen
        JR      NC,A71FD        ; Programm wird an Originaladresse geladen
        EX      DE,HL           ; Zeiger vertauschen
A71FD:  PUSH    AF              ; Programmladecode merken
        PUSH    HL              ; Programmladeadresse  merken
        LD      HL,T720C        ; Zeiger auf Ladeprogramm
		LD      DE,S11A4+1      ; Zeiger auf Speicher für Ladeprogramm
        PUSH    DE              ; Zeiger auf Anfang Ladeprogramm retten
        LD      BC,208          ; Länge des Ladeprogramms
        LDIR                    ; Ladeprogramm in Speicher übertragen
        RET
;
;
;   Load program for machine program that is to be started
;
T720C:  POP     HL              ; Get loading address
        RST     _DOCMD          ; Software - Execute command
        DEFB    48              ; Code 48 Load program according to specified identifier to (HL).
        LD      A,_JP           ; Z-80 - Command JP nn
        LD      HL,TIMIN        ; Start address 'time - interrupt' in the ROM - monitor
        LD      (INT_JP),A      ; JP - enter command
        LD      (INT_JP +1),HL  ; Enter interrupt address
        LD      A,1             ; Screen mode 1 (320x200 pixels/4 colors)
        RST     _DOCMD          ; Software - Execute command
        DEFB    80              ; Code 80 screen - set operating mode
        RST     _DOCMD          ; Software - Execute command
        DEFB    16              ; Code 16 disable interrupts
        EX      AF,AF           ; Register - save value
        LD      A,(S11A4)       ; Get flag 'MZ-800 / MZ-80 K - program'
        OR      A               ; MZ-800 - Program ?
        CALL    NZ,S1246        ; no --> Initiate peripheral modules for MZ-700 mode
        EX      AF,AF           ; rescued register - fetch value
        LD      HL,(S1018)      ; Start address from file - get identifier
        LD      A,H             ;!  Start address given?
        OR      L               ;!
        EXX
        LD      HL,(TMPEND)     ; Get end of string workspace
        LD      DE,(S1016)      ; Get load address from file identifier
        LD      BC,(S1014)      ; Get program length from file identifier
        OR      D               ;!  Load address also zero?
        OR      E               ;!
        JR      Z,A7243         ; neither load address nor start address specified
        LD      A,JP_HL         ; Z-80 - Befehl  JP (HL)
        LD      (S123E),A
A7243:  EXX
        POP     AF              ; Get program load flag
        PUSH    HL              ; Save the original start address
        LD      HL,S11EE        ; Pointer to part loading area
        LD      DE,XFF00        ; Pointer to reserved memory
        LD      BC,88           ; Length of the program to be moved
        LDIR                    ; Move the rest of the loader
        EXX
        JP      XFF00           ; Call the rest of the loader
;
;
;   zweiter Teil des Ladeprogramms
;
        JR      NC,A7259        ; geladenes Programm steht an Originaladresse
        LDIR                    ; Programm an Originaladresse verschieben
A7259:  EX      AF,AF           ; ",R" - Flag holen
        RET     Z               ; R bei RUN nicht angegeben -->  Programm starten
        IN      A,(CRTCDM)      ; Gerätestatus lesen
        AND     00000010B       ; Schalter auf MZ-700 - Modus  ?
        LD      A,00000000B     ; Code 'Umschalten auf 320x200 Punkte/4 Farben'
        OUT     (CRTCDM),A      ; an 'Display-Mode-Register' des Bildschirm-Controllers ausgeben
        LD      HL,0FF53H       ; Zeiger auf Programmteil für MZ-800 - Modus
        LD      BC,5            ; Länge
        JR      NZ,A7284        ; Schalter steht auf MZ-800 - Modus
        LD      A,00001000B     ; Code for 'MZ-700 - Modus'
        OUT     (CRTCDM),A      ; an 'Display-Mode-Register' des Bildschirm-Controllers ausgeben
        IN      A,(_CGVIN)      ; Zeichensatzrom und Video-Ram einschalten
        LD      HL,01000H       ; Zeiger auf Zeichensatzrom
        LD      DE,0C000H       ; Zeiger auf Zeichensatzram für MZ-700 - Modus
        LD      BC,4096         ; Länge Zeichensatzrom
        LDIR                    ; Zeichensatzrom in Speicher für Zeichensatz übertragen
        IN      A,(_CGVOT)      ; Zeichensatzrom und Video-RAM ausschalten
        LD      HL,0FF45H       ; Zeiger auf Programmteil für MZ-700 - Modus
        LD      BC,14           ; Länge Programmteil
A7284:  LD      DE,0CFF0H       ; Zeiger auf Stelle für Programm
        LDIR                    ; Rest Ladeprogramm an richtige Stelle übertragen
        POP     HL              ; Original - Startadresse holen
        LD      SP,S10F0        ; Stackpointer für MZ-80 K-Modus setzen
        LD      DE,ZD800        ; Zeiger auf Farbspeicher im MZ-80 K - Modus
        JP      0CFF0H          ; letzten Teil des Ladeprogramms aufrufen



;
;
;   Error handling routine for loading machine programs
;
;   (is shifted to addresses from S122C )
;
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    27              ; Code 27   Fehlertext nach Fehlernummer in A ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    67              ; Code 67  Datei-Daten der Ausgabe-DAtei (bei Fehler) löschen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    16              ; Code 16   Interrupts sperren
        HALT                    ; System aufhängen
;
;
;   letzter Teil Ladeprogramm für MZ-700 - Modus und R - Option
;
;   (wird auf Adressen ab 0FF45H und dann nach  0CFF0H verschoben)
;
        OUT     (_KMODE),A      ; umschalten auf MZ-80 K -Modus
A729C:  LD      A,071H          ; Vordergrund- Hintergrundfarbe  (weiß/blau)
        LD      (DE),A          ; in Farbspeicher eintragen
        INC     DE              ; Zeiger auf Farbspeicher auf nächstes Byte
        LD      A,D             ; High - Byte Zeiger holen
        CP      0E0H            ; Ende Farbspeicher  ?
        JR      NZ,A729C        ; nein -->  Rest Farbspeicher initialisieren
        OUT     (_00RAM),A      ; Umschalten auf RAM von 00000H bis 07FFFH
        JP      (HL)            ; geladenes Maschinenprogramm starten
;
;
;   letzter Teil Ladeprogramm für MZ-800 - Modus und R - Option
;
;   (wird auf Adressen ab 0FF53H und dann nach  0CFF0H verschoben)
;
        OUT     (_00RAM),A      ; Umschalten auf RAM von 00000H bis 07FFFH
        OUT     (_E0ROM),A      ; Umschalten auf ROM von 0E000H bis 0FFFFH
        JP      (HL)            ; geladenes Maschinenprogramm starten
;
;
;   Initiate peripheral modules for MZ - 700 mode
;
;   (is moved to addresses starting at 01246H)
;
;
        PUSH    AF              ; Register - save value
        DI                      ; Disable interrupts
        IM      1               ; Specify MZ - 700 - Interrupt mode
        LD      HL,S1253        ; Pointer to table for initializing the peripherals - control blocks
        LD      B,17            ; Number of values in table
        RST     _DOCMD          ; Software - Execute command
        DEFB    36              ; Output code 36 table of values (HL) to ports
        POP     AF              ; saved register - retrieve value again
        RET
;
;
;   Table for initializing the control blocks in MZ-700 mode
;
;   (is shifted to addresses S1253)
;
        DEFB    00000000B       ; Interrupt - Vector
        DEFB    PIOA_C          ; Controll - Port  Z-80 PIO  Kanal A
        DEFB    11001111B       ; Mode 3 - Select
        DEFB    PIOA_C          ; Controll - Port  Z-80 PIO  Kanal A
        DEFB    00111111B       ; Bit 0 - 5 Input / Bit 6/7 Output
        DEFB    PIOA_C          ; Controll - Port  Z-80 PIO  Kanal A
        DEFB    00000111B       ; Interrupt-Controll-Wort  (kein Interrupt)
        DEFB    PIOA_C          ; Controll - Port  Z-80 PIO  Kanal A
;
        DEFB    00000000B       ; Interrupt - Vector
        DEFB    PIOB_C          ; Controll - Port  Z-80 PIO  Kanal B
        DEFB    11001111B       ; Mode 3 - Select
        DEFB    PIOB_C          ; Controll - Port  Z-80 PIO  Kanal B
        DEFB    00000000B       ; alle Bits auf Output
        DEFB    PIOB_C          ; Controll - Port  Z-80 PIO  Kanal B
        DEFB    00000111B       ; Interrupt-Controll-Wort  (kein Interrupt)
        DEFB    PIOB_C          ; Controll - Port  Z-80 PIO  Kanal B
;
        DEFB    01110100B       ; Zähler 1/Read'Load 2 Byte/Mode 2/Binary
        DEFB    CTC_53          ; Kontrollwortregister Zählerbaustein 8253
        DEFB    10110000B       ; Zähler 2/Read'Load 2 Byte/Mode 0/Binary
        DEFB    CTC_53          ; Kontrollwortregister Zählerbaustein 8253
;
        DEFB    (43200)%256     ; Low - Byte Anzahl Sekunden für 12 Stunden
        DEFB    CT2_53          ; Zähler zwei im Zählerbaustein 8253
        DEFB    (43200)/256     ; High - Byte Anzahl Sekunden für 12 Stunden
        DEFB    CT2_53          ; Zähler zwei im Zählerbaustein 8253
;
        DEFB    (15611)%256     ; Low - Byte Teilungsverhältnis für Sekunden
        DEFB    CT1_53          ; Zähler eins im Zählerbaustein 8253
        DEFB    (15611)/256     ; High - Byte Teilungsverhältnis für Sekunden
        DEFB    CT1_53          ; Zähler eins im Zählerbaustein 8253
;
        DEFB    00000101B       ; Code for 'Enable Timer Interrupt'
        DEFB    KEYP_F          ; Kontrollwortregister Ein- Ausgabebaustein 8255
;
        DEFB    00000001B       ; Code 'MZ-700 Bildschirm - Modus'
        DEFB    CRTCRF          ; Read-Format-Register des Bildschirm-Controllers
;
        DEFB    00000001B       ; Code 'MZ-700 Bildschirm - Modus'
        DEFB    CRTCWF          ; Write-Format-Register des Bildschirm-Controllers
;
;
;   BASIC - Arbeitsbereiche am Speicherende retten
;
A72DC:  LD      HL,(VARED)      ; Anfang Stringarbeitsbereich holen
        LD      (TMPEND),HL     ; als Ende Stringarbeitsbereich merken
        LD      DE,(POOL)       ; Zeiger auf I/O - Work Area holen
        LD      (S7339),DE      ; und merken
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Länge I/O - Work-Area und Basic-Variable errechnen
        LD      (S733B),HL      ; und merken
        LD      HL,-256         ; Vorgabe für Stackbereich
        ADD     HL,SP           ; minimale Stackadresse errechnen
        LD      (S733D),HL      ; und als Ende geretteter Bereich merken
        LD      DE,(VARED)      ; Anfang Stringarbeitsbereich holen
        PUSH    HL              ; Zeiger auf Ende Bereich merken
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Adressen vergleichen
        JP      C,A63A7         ; Adressen überschneiden sich -->  Fehler 6  Memory error
        EX      (SP),HL         ; Zeiger auf Ende Rettspeicher holen
        EX      DE,HL           ; Zeiger vertauschen
        LD      BC,(S733B)      ; Länge I/O-Work-Area / Basic-Variable holen
        INC     BC              ; corrigieren
        LDDR                    ; Daten in Rettspeicher übertragen
        POP     DE              ; Schiebeoffset holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    24              ; Code 24   Zeiger auf I/O-Work-Area,Basic-Var.,Strings corrigieren
        LD      A,1             ; Code for 'Variable gerettet'
        LD      (S733F),A       ; im Flag  'Variable gerettet'  merken
        RET
;
;
;   BASIC - Arbeitsbereiche retten und Datei eröffnen
;
A7314:  CALL    A72DC           ; BASIC-Arbeitsbereiche am Speicherende retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    47              ; Code 47   (Programm-) Datei eröffnen
        LD      A,(S1000)       ; Datei - Typ - Modus holen
        RET
;
;
;   Pseudo - Bereiche für die verschiedenen Arbeitsbereiche vorgeben
;
A731D:  LD      HL,(VARED)      ; Anfang Stringarbeitsbereich holen
        XOR     A               ; Accu auf Null
        DEC     HL
        LD      (HL),A          ;! Ende Stringtextbereich eintragen
        DEC     HL              ;!
        LD      (HL),A          ;!
        LD      (STRST),HL      ; Anfang Stringtextbereich merken
        DEC     HL
        LD      (HL),A          ; Ende  Basic - Variable  eintragen
        LD      (VARST),HL      ; Anfang Basic - Variable merken
        DEC     HL
        LD      (HL),A          ; Ende I/O - Work - Area eintragen
        LD      (POOL),HL       ; Zeiger auf I/O - Work Area merken
        LD      HL,4            ; Länge der Pseudo - Bereiche vorgeben
        LD      (S733B),HL      ; Länge I/O-Work-Area / Basic-Variable merken
        RET
;
S7339:  DEFS    2               ; Zeiger auf gerettete I/O - Work - Area
;
S733B:  DEFS    2               ; Länge I/O-Work-Area / Basic-Variable
;
S733D:  DEFS    2               ; Ende geretteter Bereich
;
S733F:  DEFS    1               ; Flag  'Variable gerettet'
;
;
;   wenn im Programm-Modus -->  Fehler 19  Instruction error
;
A7340:  PUSH    AF              ; Keep register value
        CALL    A596B           ; Abfrage, ob in direkter Programmierung
        JP      NZ,A638E        ; nein -->  Fehler 19  Instruction error
        POP     AF              ; geretteten Register - Wert holen
        RET
;
;
;   Speicher auf Platz überprüfen und Programm laden
;
A7349:  LD      BC,(S1014)      ; Programmlänge aus Dateikennung holen
        PUSH    BC              ; und merken
        LD      HL,(POOL)       ; Zeiger auf I/O - Work Area holen
        LD      DE,(TEXTST)     ; Anfang Basic - Programm holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Länge freier Arbeitsspeicher errechnen
        LD      L,0
        SBC     HL,BC           ; mit neuer Programmlänge vergleichen
        JP      C,A63A7         ; neues Programm länger -->  Fehler 6  Memory error
        LD      HL,0
        LD      (S7339),HL      ; als Zeiger auf gerettete I/O-Work-Area merken
        CALL    A6090           ; alle Flags auf Anfangsbedingungen setzen
        LD      HL,0            ; HL auf Null
        LD      (S9E51),HL      ; als Zeilennummer der aktuellen Programmzeile merken
        LD      HL,(TEXTST)     ; Anfang Basic - Programm holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    48              ; Code 48   Programm nach vorgegebener Kennung nach (HL) laden
        POP     BC              ; gerettete Programmlänge holen
        LD      HL,(TEXTST)     ; Anfang Basic - Programm holen
        ADD     HL,BC           ; Zeiger auf Ende Programm errechnen
        LD      (S7339),HL      ; als Zeiger auf I/O - Work - Area merken
        RET
;
;
;   Zwischenspeicher für Programmladeroutine löschen
;   und gerettete BASIC - Arbeitsbereiche wieder vorgeben
;
A737C:  LD      A,129           ; Datei - Nummer für Programm
        LD      B,0             ; Code for 'KILL'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    56              ; Code 56  Datei schliessen oder Dateidaten in Rechner löschen
        LD      HL,S733F        ; Zeiger auf Flag  'Variable gerettet'
        LD      A,(HL)          ; Flag  'Variable gerettet'  holen
        OR      A               ; gesetzt  ?
        RET     Z               ; nein
        LD      (HL),0          ; Flag zurücksetzen
        LD      HL,(S7339)      ; Zeiger auf I/O - Work - Area holen
        LD      A,H             ;! Zeiger vorhanden  ?
        OR      L               ;!
        JR      NZ,A7397        ; ja
        LD      HL,(TEXTST)     ; Anfang Basic - Programm holen
        CALL    A61C5           ; (HL) Bereichsende  (00 00)  eintragen
A7397:  EX      DE,HL           ; Zeiger auf Stelle für I/O - Work-Area nach DE
        LD      HL,(POOL)       ; Zeiger auf I/O - Work Area holen
        LD      BC,(S733B)      ; Länge I/O-Work-Area / Basic-Variable holen
        LDIR
        EX      DE,HL
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; 'um Anzahl verschobene Bytes' errechnen
        EX      DE,HL           ; nach DE
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    24              ; Code 24   Zeiger auf I/O-Work-Area,Basic-Var.,Strings corrigieren
        RET
;
;
;   Basic - Befehl   VERIFY     (Token code  254 165 / 0FEH 0A5H)
;
A73A9:  PUSH    HL              ; Programmzeiger retten
        CALL    A5F2F           ; Zeiger auf Zeilen im Programm in Zeilennummern umsetzen
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A6FA4           ; Text (HL) auf Geräte-Namen und Datei-Nummer auswerten
        PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    47              ; Code 47   (Programm-) Datei eröffnen
        CP      _BTX            ; Datei - Typ  BTX  ?
        JP      NZ,A63D1        ; nein -->  Fehler 61  Illegal filemode error
        LD      HL,(TEXTST)     ; Anfang Basic - Programm holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    50              ; Code 50   (Programm-) Datei vergleichen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   SAVE     (Token code  181 / 0B5H)
;
A73C0:  CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFB    ___ALL          ; ALL  (Zwischencode)  ?
        LD      A,1             ; Code for 'SAVE ALL'
        JP      Z,A7004         ; ja -->  RAM - Karteninhalt auf Quick - Disk schreiben
        PUSH    HL              ; Programmzeiger retten
        CALL    A5F2F           ; Zeiger auf Zeilen im Programm in Zeilennummern umsetzen
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A6FA4           ; Text (HL) auf Geräte-Namen und Datei-Nummer auswerten
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A73F6         ; ja -->  auf Sonderformat untersuchen
        PUSH    HL              ; Programmzeiger retten
        LD      A,_BTX          ; Code for 'Basic - Programm - Datei'
        LD      (S1000),A       ; als Datei - Typ - Kennung eintragen
        LD      HL,(POOL)       ; Zeiger auf I/O - Work Area holen
        LD      DE,(TEXTST)     ; Anfang Basic - Programm holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Länge des Basic - Programms errechnen
        LD      (S1014),HL      ; Programmlänge in Dateikennung eintragen
        LD      A,(S1001)       ; erstes Zeichen Datei - Name holen
        CP      CR              ; Textendezeichen  ?
        JP      Z,A63CE         ; ja -->  Fehler 60  Illegal filename error
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    49              ; Code 49   Programm abspeichern
        POP     HL              ; geretten Programmzeiger holen
        RET
;
;
;   Basic - Programm in ASCII abspeichern
;
A73F6:  CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    "A"             ; A   (ASCII)  ?
        PUSH    HL              ; Programmzeiger retten
        LD      A,2             ; Code for 'Datei zum Schreiben eröffnen'
        LD      (S1043),A       ; als Datei - Zugriffscode eintragen
        LD      A,129           ; Datei - Nummer für Programm
        LD      (S1042),A       ; als interne aktuelle Geräte-Nummer merken
        CALL    A6F79           ; sequentielle Datei eröffnen
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A6AC8           ; Zeilen aufbereiten in ASCII und an Datei ausgeben
        CALL    PRTCR           ; Zeilenvorschub ausgeben
        LD      B,1             ; Code for 'CLOSE'
        LD      A,129           ; Datei - Nummer für Programm
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    56              ; Code 56  Datei schliessen oder Dateidaten in Rechner löschen
        RET
;
;
;   Basic - Befehl   UNLOCK     (Token code  219 / 0DBH)
;
A7416:  XOR     A               ; Code for 'UNLOCK'
        DEFB    LD_BC
;
;
;   Basic - Befehl   LOCK     (Token code 218 / 0DAH)
;
A7418:  LD      A,1             ; Code for 'LOCK'
        PUSH    AF              ; Flag  'UNLOCK/LOCK'  merken
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    45              ; Code 45  Geräte- und Dateinamen (DE) auswerten und aufbereiten
        POP     AF              ; Flag  'UNLOCK/LOCK' holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    63              ; Code 63   (Programm-) Datei schützen oder freigeben
        RET
;
;
;   Basic - Befehl   DIR     (Token code 213 / 0D5H)
;
A7424:  CALL    GETLU           ; Datei- oder Gerätenummer bereitstellen
        PUSH    AF              ; Ausgabe - Datei (Geräte) - Nummer retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    46              ; Code 46   Datei-Verwaltungssatz nach Nr. bereitstellen
        JP      C,A6E2D         ; Datensatz nicht gefunden -->  Fehler 44  Not open error
        BIT     1,A             ; Datei oder Gerät zum Schreiben eröffnet  ?
        JP      Z,A6E30         ; nein -->  Fehler 59  Can't execute error
        CALL    A6F39           ; bei Datei auf Syntax 'Komma' untersuchen
        CALL    A6FB1           ; Geräte-Namen bereitstellen und Gerät anmelden
        LD      B,A             ; Geräte - Nummer merken
        XOR     A               ; Code for 'Inhaltsverzeichnis einlesen'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    57              ; Code 57  Inhaltsverzeichnis einlesen oder ausgeben
        LD      A,B             ; Geräte - Nummer holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    58              ; Code 58   Zeiger auf Geräte-Tabelle/Geräte-Nummer merken
        POP     AF              ; Ausgabe-Datei (Geräte) - Nummer holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    57              ; Code 57   Inhaltsverzeichnis einlesen oder ausgeben
        RET
;
;
;   DELETE   "Datei"
;
A7443:  CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    45              ; Code 45  Geräte- und Dateinamen (DE) auswerten und aufbereiten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    61              ; Code 61  (Programm-) Datei löschen
        RET
;
;
;   Basic - Befehl   RENAME     (Token code  216 / 0D8H)
;
A744B:  CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    45              ; Code 45  Geräte- und Dateinamen (DE) auswerten und aufbereiten
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    62              ; Code 62   Datei umbenennen
        RET
;
;
;   PRINT  auf  RANDOM - Datei
;
A7459:  CALL    A748F           ; RANDOM - Satz - Nummer auswerten und vorgeben
A745C:  CALL    A6C87           ; Ausdruck (HL) auswerten/Ergebnis als Zeichenkette bereitst.
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    66              ; Code 66  Datensatz in RANDOM - Datei schreiben
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        RET     Z               ; fertig
        CALL    A79B4           ; auf Syntax 'Komma' überprüfen
        JR      A745C           ; weitere Sätze in RANDOM - Datei schreiben
;
;
;   INPUT  aus  RANDOM - Datei
;
A746A:  CALL    A748F           ; RANDOM - Satz - Nummer auswerten und vorgeben
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        CALL    A8C08           ; überprüfen, ob Adresse in DE mit Stack kollidiert
A7474:  CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        PUSH    HL              ; Programmzeiger retten
        PUSH    AF              ; Variablentypcode retten
        PUSH    BC              ; Zeiger auf Variable retten
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    65              ; Code 65   Datensatz aus RANDOM - Datei lesen
        POP     DE              ; Zeiger auf Variable holen
        POP     AF              ; Variablentypcode holen
        CALL    A6E71           ; bereitgestellten String der Variable zuweisen
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        RET     Z               ; fertig
A748B:
        CALL    A79B4           ; auf Syntax 'Komma' überprüfen
        JR      A7474           ; weitere Werte aus RANDOM - Datei lesen
;
;
;   RANDOM - Satz - Nummer auswerten und vorgeben
;
A748F:  CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    "("             ; Klammer auf
        RET     NZ              ; nein -->  keine RANDOM - Satznummer angegeben
        CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        LD      A,D             ;! Satznummer gleich Null  ?
        OR      E               ;!
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    64              ; Code 64   RANDOM - Satznummer setzen
        CALL    A79AA           ; auf Syntax 'Klammer zu' überprüfen
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma
        RET
;
;
;   Basic - command SWAP (token code 191 / 0BFH)
;
A74A6:  LD      A,(S9E68)       ; SWAP - get flag
        OR      A               ; set  ?
        JP      NZ,A639D        ; already in the SWAP program --> error 25 SWAP error
        PUSH    HL              ; Save program pointer
        LD      B,0             ; Code 'length equals zero'
        RST     _DOCMD          ; Software - Execute command
        DEFB    44              ; Code 44 text (DE) on devices - evaluate names
        LD      (S755B),DE      ; Remember pointer to device table for SWAP main program
        LD      (S755D),A       ; Device - number SWAP - remember main program
        LD      HL,(POOL)       ; Get pointer to I/O - Work Area
        LD      DE,(TEXTST)     ; Start Basic - Get program
        XOR     A               ; reset carry flag (code 'write away')
        SBC     HL,DE           ; Length Basic - Calculate program
        LD      (S1014),HL      ; Enter the program length in the file identifier
        RST     _DOCMD          ; Software - Execute command
        DEFB    68              ; Code 68 SWAP - Write or load main program
        POP     HL              ; get saved program pointer
        CALL    A6FA4           ; Evaluate text (HL) for device name and file number
        CALL    A797A           ; check for syntax at the end of the command
        LD      A,(S1050)       ; Get Device - Type - Byte
        BIT     5,A             ; SWAP possible?
        JP      Z,A6E30         ; no --> Error 59 Can't execute error
        PUSH    HL              ; Save program pointer
        LD      HL,(W9E62)      ; Length of data set to be saved (2 CPL)
        ADD     HL,SP           ; Calculate pointer to position for record
        LD      SP,HL           ; Reset stack pointer
        EX      DE,HL           ; Pointer to memory after DE
        LD      HL,S9E4B        ; Pointer to next program line
        LD      BC,(W9E60)      ; Get length of data record to be saved
        LDIR                    ; Save data of the current program
        CALL    A7314           ; BASIC - Save workspace and open file
        CP      _BTX            ; File Type Basic Program ?
        JP      NZ,A63D1        ; no --> Error 61 Illegal filemode error
        LD      (A74F3 + 1),SP  ; Enter stack pointer in routine
;
;
;   CHAIN program if in SWAP program
;
A74F3:  LD      SP,0            ; Set stack pointer
        CALL    A7349           ; Check memory for space and load program
        CALL    A737C           ; Delete buffer for program load routine
        LD      HL,0FFFDH       ; Code 'Start SWAP - Stack'
        PUSH    HL              ; put on stack
        PUSH    HL
        LD      A,1             ; Code 'in the SWAP program'
        LD      (S9E68),A       ; note in the SWAP flag
        LD      HL,(TEXTST)     ; Start Basic - Get program
        JP      A5909           ; Process program from line (HL).
;
;
;   SWAP - program end --> reload main program
;
A750C:  XOR     A               ; Code 'not in SWAP program'
        LD      (S9E68),A       ; note in the SWAP flag
        POP     IX              ; Get return address
A7512:  POP     BC              ; Get value ID from stack
        LD      A,B             ; High - byte value identifier
        CP      0FFH            ; same value identifier ?
        JP      NZ,A639D        ; no --> error 25 SWAP error
        LD      A,C             ; Get low byte value identifier
        CP      0FDH            ; same identifier 'SWAP - Stack' ?
        JR      Z,A7531         ; yes -> start of stack found
        CP      0FEH            ; same identifier 'RETURN - data' ?
        LD      HL,4            ; The remainder of the data record is 4 bytes long
        JR      Z,A752D         ; yes --> Calculate pointer to next data set
        CP      18              ; same identifier 'NEXT - data set' ?
        LD      HL,16           ; The remainder of the data record is 16 bytes long
        JP      NZ,A639D        ; wrong identifier --> error 25 SWAP error
A752D:  ADD     HL,SP           ; Calculate pointer to next record
        LD      SP,HL           ; Reset stack pointer
        JR      A7512           ; check next record
;
A7531:  LD      DE,(S755B)      ; Get pointer to device table for SWAP main program
        LD      A,(S755D)       ; Device - Number SWAP - Get main program
        RST     _DOCMD          ; Software - Execute command
        DEFB    58              ; Code 58 Pointer to device table/remember device number
        LD      B,0             ; Code 'length zero characters'
        RST     _DOCMD          ; Software - Execute command
        DEFB    44              ; Code 44 text (DE) on devices - evaluate names
        CALL    A72DC           ; Save BASIC workspaces at end of memory
        OR      0FFH            ; Set code 'Load'
        RST     _DOCMD          ; Software - Execute command
        DEFB    68              ; Code 68 SWAP - Write or load main program
        CALL    A7349           ; Check memory for space and load program
        CALL    A737C           ; Delete buffer for program load routine
        LD      HL,0            ;! Get stack pointer to HL
        ADD     HL,SP           ;!
        LD      DE,S9E4B        ; Pointer to next program line
        LD      BC,(W9E60)      ; Get length of saved record
        LDIR                    ; restore saved data
        LD      SP,HL           ; Reset stack pointer
        POP     HL              ; get saved program pointer
        RET
;
S755B:  DEFS    2               ; Pointer to device table for SWAP main program
S755D:  DEFS    1               ; Device - number SWAP - main program

;
;
;   Cassettenroutinen und serielle Schnittstelle initialisieren
;
A755E:  POP     HL              ; Rücksprungadresse vom Stack holen
        PUSH    HL              ; und wieder merken
        LD      (ERRORP),HL     ; Rücksprungadresse als Fehleradresse eintragen
        LD      A,'1'           ; Code for 'serielle Schnittstelle eins'
        CALL    A7574           ; Nummer eintragen und Gerät initialisieren
        LD      A,'2'           ; Code for 'serielle Schnittstelle zwei'
        CALL    A7574           ; Nummer eintragen und Gerät initialisieren
        LD      DE,M758B        ; Text  'CMT:T'
        LD      B,5             ; Textlänge
        JR      A757C           ; Gerät nach Text (HL) initialisieren
;
A7574:  LD      (M7581),A       ; Nummer der Schnittstelle eintragen
        LD      DE,M757F        ; Text  'RSx:0,$8C,13'
        LD      B,12            ; Textlänge
A757C:  JP      A6F4F           ; Gerät nach Text (HL) initialisieren
;
;
;   Text zur Initialisierung der seriellen Schnittstellen
;   (keine Überwachungssignale, 8 Bit, 2 Stopbits, keine Parität, Endezeichen CR)
;
M757F:  DEFM    "RS"
M7581:  DEFM    "?:0,$8C,13"           ; auf ? wird Nummer der Schnittstelle eingetragen

;
;
;   Text zur Initialisierung der Cassettenroutinen
;
M758B:  DEFM    "CMT:T"         ; T = Fehler bei EOF ausgeben
;
M7590:  DEFB    0               ; Vorgabe für Übschreibmodus
;
B7591:  DEFB    3               ; Vorgabe für Palettencode der Punkte
;
;
;   Basic - Befehl   SET     (Token code 254 146 / 0FEH 092H)
;
B7592:  DEFB    OR_N            ; Code for 'SET'
;
;
;   Basic - Befehl   RESET     (Token code 254 147 / 0FEH 093H)
;
A7593:  XOR     A               ; Code for 'RESET'
        PUSH    AF              ; Flag  'RESET/SET' retten
        CALL    A75FB           ; auf Farbangabe untersuchen und X,Y-Graphic-Koord. bereitst.
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    71              ; Code 71   Graphic-Cursor auf Koordinate in DE',HL' setzen
        POP     AF              ; Flag  'RESET/SET'  holen
        PUSH    HL              ; Programmzeiger retten
        EXX                     ; Koordinaten in Erstregistersatz holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    72              ; Code 72   Punkt nach Koordinaten in DE,HL setzen/zurücksetzen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   LINE     (Token code 254 148 / 0FEH 094H)
;
B75A1:  DEFB    OR_N            ; Code for 'LINE'
;
;
;   Basic - Befehl   BLINE     (Token code 254 149 / 0FEH 095H)
;
A75A2:  XOR     A               ; Code for 'BLINE'
        LD      (D75B6 + 1),A   ; Flag  'BLINE/LINE'  in Routine eintragen
        CALL    A75FB           ; auf Farbangabe untersuchen und X,Y-Graphic-Koord. bereitst.
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
A75AC:  EXX                     ; Graphic - Koordinaten in Erstregistersatz holen
        PUSH    HL              ; Y - Koordinate des Punktes retten
        PUSH    DE              ; X - Koordinate des Punktes retten
        EXX
        CALL    A75FE           ; Ausdruck (HL) auswerten und X,Y - Graphic - Koordinate bereitstellen
        POP     DE              ; X - Koordinate Anfangspunkt holen
        EX      (SP),HL         ; Y - Koordinate Anfangspunkt holen / Programmzeiger retten
        EXX
D75B6:  LD      A,0             ; Flag  'BLINE/LINE'  holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    73              ; Code 73   Linie zeichnen von DE',HL' nach DE,HL
        POP     HL              ; geretteten Programmzeiger holen
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A75AC         ; ja -->  Koordinate bereitstellen und Linie zeichnen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    71              ; Code 71   Graphic-Cursor auf Koordinate in DE',HL' setzen
        RET
;
;
;   Basic - Befehl   PATTERN     (Token code 254 155 09BH)
;
A75C4:  CALL    A768A           ; auf Farbangabe untersuchen und auswerten
        CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        XOR     A               ; Accu auf Null  (Code for 'Lagen positiv')
        BIT     7,D             ; Anzahl Lagen positiv  ?
        JR      Z,A75D8         ; ja
        PUSH    HL              ; Programmzeiger retten
        LD      H,A             ; Null
        LD      L,A             ; Null
        SBC     HL,DE           ; positiven Wert für Anzahl Lagen errechnen
        EX      DE,HL           ; und nach DE
        POP     HL              ; geretteten Programmzeiger holen
        LD      A,1             ; Code for 'Lagen negativ'
A75D8:  EX      AF,AF           ; Flag  'Lagen positiv/negativ'  merken
        LD      A,D             ; High - Byte Anzahl Lagen holen
        OR      A               ; gleich Null  ?
        JR      NZ,A7616        ; Wert zu groß -->  Fehler 3  Illegal data error
        LD      A,E             ; Low - Byte Anzahl Lagen holen
        PUSH    AF              ; und retten
        EX      AF,AF           ; Flag  'Lagen positiv/negativ'  holen
        PUSH    AF              ; und retten
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        POP     AF              ; Flag  'Lagen positiv/negativ'  holen
        LD      C,A             ; und merken
        POP     AF              ; Anzahl Lagen holen
        PUSH    HL              ; Programmzeiger retten
        LD      H,C             ; Flag  'Lagen positiv/negativ'  vorgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    74              ; Code 74  Graphic-Muster ausgeben
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JR      NZ,A75C4        ; nein -->  weitere PATTERN - Teile ausführen
        RET
;
;
;   Basic - Befehl   POSITION     (Token code 254 154 / 0FEH 09AH)
;
A75F5:  CALL    A75FE           ; Ausdruck (HL) auswerten und X,Y - Graphic - Koordinate bereitstellen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    71              ; Code 71   Graphic-Cursor auf Koordinate in DE',HL' setzen
        RET
;
;
;   auf Farbangabe untersuchen und X,Y-Graphic-Koordinate bereitstellen
;
A75FB:  CALL    A768A           ; auf Farbangabe untersuchen und auswerten
;
;
;   Ausdruck (HL) auswerten und X,Y - Graphic - Koordinate bereitstellen
;
A75FE:  CALL    A760F           ; Ausdruck (HL) auswerten und Ergebnis auf Graphic-Koordinate testen
        PUSH    DE              ; X - Koordinate Graphic retten
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        CALL    A760F           ; Ausdruck (HL) auswerten und Ergebnis auf Graphic-Koordinate testen
        PUSH    DE              ; Y - Koordinate auf Stack
        EXX
        POP     HL              ; Y - Koordinate Graphic holen
        POP     DE              ; X - Koordinate Graphic holen
        EXX
        RET
;
;
;   Ausdruck (HL) auswerten und Ergebnis auf Graphic-Koordinate testen
;
A760F:  CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        LD      A,D             ; High - Byte Graphic - Koordinate holen
        ADD     A,040H          ; Koordinate im Bereich  -16384 / + 16384  ?
        RET     P               ; ja
A7616:  JP      A636A           ; Fehler 3   Illegal data error
;
;
;   Basic - Befehl   PAL     (Token code 254 150 / 0FEH 096H)
;
A7619:  CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A6364         ; ja -->  Fehler 1  Syntax error
        CALL    A7640           ; ein Byte - Wert zwischen 0 und 15 bereitstellen
        CALL    A76DE           ; Wert auf maximal zulässigen Palettenwert untersuchen
        AND     00000011B       ; Palettenwert im Palettenblock maskieren
        PUSH    AF              ; Palettencodewert retten
        LD      A,(S137E)       ; Palettenblocknummer holen
        LD      D,E             ; Palettencodewert nach D duplizieren
        SRL     D               ;! durch vier teilen
        SRL     D               ;!
        CP      D               ; Palettenblockcode mit aktueller Blocknummer  vergleichen
        JP      NZ,A6397        ; nicht gleich -->  Fehler  22   PAL error
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        CALL    A7640           ; ein Byte - Wert zwischen 0 und 15 bereitstellen
        LD      B,A             ; Farbwert merken
        POP     AF              ; Palettencodewert holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    82              ; Code 82   Farbcode in B der Palettencode-Nummer im Accu zuordnen
        RET
;
;
;   ein Byte - Wert zwischen 0 und 15 bereitstellen
;
A7640:  CALL    IBYTE           ; ein - Byte - Wert nach DE/Accu bereitstellen
        CP      15 + 1          ; größer 15  ?
        JR      NC,A7616        ; ja -->  Fehler 3  Illegal data error
        RET
;
;
;   Basic - Befehl   BOX     (Token code 254 152 / 0FEH 098H)
;
A7648:  CALL    A75FB           ; auf Farbangabe untersuchen und X,Y-Graphic-Koord. bereitst.
        EXX
        PUSH    HL              ; Y - Koordinate erste Ecke retten
        PUSH    DE              ; X - Koordinate erste Ecke retten
        EXX
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A75FE           ; Ausdruck (HL) auswerten und X,Y - Graphic - Koordinate bereitstellen
        EXX
        PUSH    HL              ; Y - Koordinate zweite Ecke retten
        PUSH    DE              ; X - Koordinate zweite Ecke retten
        EXX
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JR      Z,A766B         ; keine Ausmalfarbe angegeben
        CALL    A79B4           ; auf Syntax 'Komma' überprüfen
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        LD      A,(B7591)       ; Vorgabe für Palettencode der Punkte holen
        CALL    NZ,A76D9        ; Ausdruck (HL) auswerten und auf maximalen Palettencode unters.
        SCF                     ; Code for 'Rechteck ausmalen'
A766B:  EXX
        POP     DE              ; X - Koordinate der zweiten Ecke holen
        POP     HL              ; Y - Koordinate der zweiten Ecke holen
        EXX
        POP     DE              ; X - Koordinate der ersten Ecke holen
        EX      (SP),HL         ; Y - Koordinate holen / Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    75              ; Code 75   Rechteck zeichnen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   COLOR     (Token code 254 144 / 0FEH 090H)
;
A7675:  CALL    A76B4           ; Palettencodewert und Überschreibmodus bereitstellen
        LD      A,(B7591)       ; Vorgabe für Palettencode der Punkte holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    84              ; Code 84  aktuell benutzte Farbebenen merken
        LD      (S137B),A       ; maximaler Palettenwert / aktuelle Zeichenfarbe merken
        LD      A,(PWMODE)      ; aktuellen Überschreibmodus holen
        LD      (M7590),A       ; Vorgabe für Übschreibmodus merken
        CALL    A797A           ; auf Syntax Befehlsende überprüfen
        RET
;
;
;   auf Farbangabe untersuchen und auswerten
;
A768A:  CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    "["             ; Eckige Klammer auf  ?
        JR      NZ,A76A5        ; nein -->  kein Farbwert angegeben
        CALL    A76B4           ; Palettencodewert und Überschreibmodus bereitstellen
        LD      A,(B7591)       ; Vorgabe für Palettencode der Punkte holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    85              ; Code 85   Graphic - Palettenwert merken
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    "]"             ; Eckige Klammer zu   ?
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        RET
;
;
;   Standart-Palettencodewert und Überschreib-Modus vorgeben
;
A76A5:  LD      A,(S137B)       ; maximaler Palettenwert / aktuelle Zeichenfarbe holen
        LD      (B7591),A       ; als Vorgabe für Palettencode des Zeichens merken
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    85              ; Code 85   Graphic - Palettenwert merken
A76AD:  LD      A,(M7590)       ; Vorgabe für Übschreibmodus holen
        LD      (PWMODE),A      ; als aktuelle Überschreibmodus merken
        RET
;
;
;   Palettencodewert und Überschreibmodus bereitstellen
;
A76B4:  CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A76D1         ; ja -->  nur auf Überschreibmodus untersuchen
        CALL    A76D9           ; Ausdruck (HL) auswerten und auf maximalen Palettencode unters.
        LD      (B7591),A       ; als Vorgabe für Palettencode der Punkte merken
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      NZ,A76AD        ; nein -->  Überschreibmodus vorgeben
A76C6:  CALL    IBYTE           ; ein - Byte - Wert nach DE/Accu bereitstellen
        CP      1 + 1           ; Null oder Eins  ?
        JR      NC,A76FA        ; nein -->  Fehler 3  Illegal data error
        LD      (PWMODE),A      ; aktuellen Überschreibmodus merken
        RET
;
A76D1:  LD      A,(S137B)       ; maximaler Palettenwert / aktuelle Zeichenfarbe holen
        LD      (B7591),A       ; als Vorgabe für Palettencode der Punkte merken
        JR      A76C6           ; auf Überschreibmodus untersuchen
;
;
;   Ausdruck (HL) auswerten und Ergebnis auf maximal zulässigen Palettencodewert untersuchen
;
A76D9:  PUSH    BC              ; Keep register value
        CALL    IBYTE           ; ein - Byte - Wert nach DE/Accu bereitstellen
        POP     BC              ; geretteten Register - Wert holen
A76DE:  LD      A,(S1379)       ; Bildschirm - Modus - Bit holen
        RRA                     ; um eine Stelle nach rechts schieben
        JR      C,A76EA         ; Mode 0 -->  auf Palettencodewert zwischen 0 und 3 untersuchen
        RRA                     ; um eine Stelle nach rechts schieben
        JR      C,A76F0         ; Mode 1 -->  auf Palettencodewert zwischen 0 und 15 untersuchen
        RRA                     ; um eine Stelle nach rechts schieben
        JR      C,A76F6         ; Mode 2 -->  auf Palettencodewert 0 oder 1 untersuchen
A76EA:  LD      A,E             ; Palettencodewert holen
        CP      3 + 1           ; Null bis Drei  ?
        JR      NC,A76FA        ; nein -->  Fehler 3  Illegal data error
        RET
;
A76F0:  LD      A,E             ; Palettencodewert holen
        CP      15 + 1          ; zwischen Null und 15  ?
        JR      NC,A76FA        ; nein -->  Fehler 3  Illegal data error
        RET
;
A76F6:  LD      A,E             ; Palettencodewert holen
        CP      1 + 1           ; Null oder Eins  ?
        RET     C               ; ja
A76FA:  JP      A636A           ; Fehler 3   Illegal data error
;
;
;   Basic - Befehl   PAINT     (Token code 254 153 / 0FEH 099H)
;
A76FD:  CALL    A768A           ; auf Farbangabe untersuchen und auswerten
        CALL    A75F5           ; X,Y-Koordinate bereitstellen und Graphic-Cursor setzen
        LD      B,0             ; Zähler 'Anzahl Palettenwerte' auf Null
        LD      DE,S773C        ; Zeiger auf Speicher für Palettenwerte
        PUSH    DE              ; Zeiger auf Anfang Speicher retten
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JR      Z,A7735         ; kein Palettenwert angegeben -->  ausmalen
A770E:  CALL    A79B4           ; auf Syntax 'Komma' überprüfen
        PUSH    DE              ; Zeiger auf Speicher für Palettenwerte retten
        CALL    A76D9           ; Ausdruck (HL) auswerten und auf maximalen Palettencode unters.
        POP     DE              ; Zeiger auf Speicher für Palettenwerte holen
        LD      (DE),A          ; Palettencodewert merken
        INC     DE              ; Zeiger auf Speicher auf nächste Speicherzelle
        INC     B               ; Anzahl Palettencodewerte plus eins
        LD      A,B             ; Anzahl Palettencodewerte holen
        CP      16              ; schon 16 Werte bereitgestellt  ?
        JP      Z,A6364         ; ja -->  Fehler 1  Syntax error
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JR      NZ,A770E        ; nein -->  weitere Werte bereitstellen
A7724:  EX      (SP),HL         ; Programmzeiger retten / Zeiger auf Anfang Speicher holen
        PUSH    HL              ; Zeiger auf Speicher für Palettenwerte retten
        LD      HL,-527         ;! Speicher für Stack reservieren
        ADD     HL,SP           ;!
        LD      (S137C),HL      ; maximale RAM - Adresse für PAINT - Routine eintragen
        POP     HL              ; Zeiger auf Speicher für Palettenwerte holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    76              ; Code 76   Fläche ausmalen
        JP      C,A6373         ; Fehler aufgetreten -->  Fehler 6  Memory error
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
A7735:  LD      A,(B7591)       ; Vorgabe für Palettencode der Punkte holen
        LD      (DE),A          ; im Speicher für Palettencodewerte merken
        INC     B               ; Anzahl Palettencodewerte auf eins
        JR      A7724           ; Fläche ausmalen
;
S773C:  DEFS    16              ; Speicher für Palettencodewerte bei PAINT
;
;
;   Basic - Befehl   CIRCLE     (Token code 254 151 / 0FEH 097H)
;
A774C:  PUSH    HL              ; Programmzeiger retten
        LD      HL,0
        LD      (D782E + 1),HL  ; Verhältnisflag / Verhältnis löschen
        LD      (D7828 + 1),HL  ; X - Offset auf Startpunkt zurücksetzen
        LD      (D782B + 1),HL  ; Y - Offset auf Startpunkt zurücksetzen
        LD      (D7832 + 1),HL  ; X - Offset auf Endpunkt zurücksetzen
        LD      (D7835 + 1),HL  ; Y - Offset auf Endpunkt zurücksetzen
        LD      HL,S7905        ; Zeiger auf Speicher für Startwinkel
        CALL    A909E           ; Null im Real - Format nach (HL) eintragen
        LD      HL,B98C1        ; Zeiger auf 2 * Pi   (Real - Konstante)
        LD      DE,S790A        ; Zeiger auf Speicher für Endwinkel
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A75FB           ; auf Farbangabe untersuchen und X,Y-Graphic-Koord. bereitst.
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    71              ; Code 71   Graphic-Cursor auf Koordinate in DE',HL' setzen
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        PUSH    HL              ; Programmzeiger retten
        LD      A,D             ; High - Byte Wert holen
        AND     11000000B       ; Wert größer 16384  ?
        JP      NZ,A636A        ; ja -->  Fehler 3   Illegal data error
        EX      DE,HL           ; Radius nach HL
        LD      (D7838 + 2),HL  ; Radius in Routine eintragen
        LD      (D7828 + 1),HL  ; Radius als X - Offset auf Startpunkt eintragen
        LD      (D7832 + 1),HL  ; Radius als X - Offset auf Endpunkt eintragen
        LD      HL,(INTFAC)     ; Zeiger auf Anfang Rechenspeicher holen
        LD      DE,S78F1        ; Zeiger auf Speicher für Real-Radius
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A77EB         ; keine weiteren Parameter angegeben
        CALL    A79B4           ; auf Syntax 'Komma' überprüfen
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A77B0         ; kein Aspekt angegeben
        CALL    A7841           ; Aspekt - Wert für Circle auswerten
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A77EB         ; keine weiteren Parameter angegeben
        CALL    A79B4           ; auf Syntax 'Komma' überprüfen
A77B0:  CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A77CA         ; kein Startwinkel angegeben
        LD      IX,D7828 + 1    ; Zeiger auf Speicher für Offsets des Startpunktes
        LD      IY,S7905        ; Zeiger auf Speicher für Startwinkel
        CALL    A788E           ; X- und Y- Offset auf Punkt aus Radius, Aspekt und Winkel errechnen
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A77EB         ; keine weiteren Parameter
        CALL    A79B4           ; auf Syntax 'Komma' überprüfen
A77CA:  CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A77E4         ; kein Endwinkel angegeben
        LD      IX,D7832 + 1    ; Zeiger auf Speicher für Offsets des Endpunktes
        LD      IY,S790A        ; Zeiger auf Speicher für Endwinkel
        CALL    A788E           ; X- und Y- Offset auf Punkt aus Radius, Aspekt und Winkel errechnen
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A77EB         ; ja -->  Tortenflag nicht angegeben
        CALL    A79B4           ; auf Syntax 'Komma' überprüfen
A77E4:  CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    "O"             ; Code for 'Anfangspunkt über Mittelpunkt mit Endpunkt verbinden'
        SCF                     ; Code 'Verbindungslinie Zeichen'
        JR      A77EC           ; Parameter laden und Zeichenroutine aufrufen
;
A77EB:  XOR     A               ; Code for 'keine Verbindungslinie Zeichnen'
A77EC:  PUSH    HL              ; Programmzeiger retten
        PUSH    AF              ; Flag  'Verbindungslinie Zeichnen/nicht Zeichnen'
        LD      HL,S7905        ; Zeiger auf Speicher für Startwinkel
        LD      DE,S790A        ; Zeiger auf Speicher für Endwinkel
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        LD      A,(S7905)       ; Exponent der Differenz holen
        OR      A               ; gleich Null  ?
        LD      B,0             ; Code for 'Startwinkel gleich Endwinkel'
        JR      Z,A781E         ; Differenz gleich Null
        LD      HL,S7906        ; Zeiger auf MSByte Mantisse der Differenz
        RES     7,(HL)          ; Differenz auf 'Plus'
        DEC     HL              ; Zeiger wieder auf Exponenten
        LD      DE,B98C6        ; Zeiger auf Pi im Real - Format
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        LD      B,1             ; Code for '0 < Startwinkel - Endwinkel < Pi'
        JR      C,A781E         ; bereitgestellte Parameter laden
        LD      DE,B98C1        ; Zeiger auf 2 * Pi   (Real - Konstante)
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        LD      B,2             ; Code for 'Pi < Startwinkel - Endwinkel < 2 * Pi'
        JR      C,A781E         ; bereitgestellte Parameter laden
        LD      B,3             ; Code for '2 * Pi < Startwinkel - Endwinkel
A781E:  LD      A,(S790B)       ; Mantisse Winkeldifferenz holen
        AND     10000000B       ; Vorzeichen maskieren
        OR      B               ; plus Winkelgrößenflag
        LD      B,A             ; Winkelflag merken
        POP     AF              ; Tortengraphic - Flag holen
        LD      A,B             ; Winkelflag wieder holen
        EXX
D7828:  LD      DE,0            ; X - Offset auf Startpunkt    (wird eingetragen)
D782B:  LD      HL,0            ; Y - Offset auf Startpunkt    (wird eingetragen)
D782E:  LD      BC,0            ; C = Verhältnisflag  /  B = Verhältniswert
        EXX
D7832:  LD      DE,0            ; X - Offset auf Endpunkt    (wird eingetragen)
D7835:  LD      HL,0            ; Y - Offset auf Endpunkt    (wird eingetragen)
D7838:  LD      IX,0            ; Integer - Radius           (wird eingetragen)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    77              ; Code 77   Kreis zeichnen
        POP     HL              ; geretteten Programmzeiger holen
        OR      A               ; Carry - Flag zurücksetzen
        RET
;
;
;   Aspekt - Wert für CIRCLE bereitstellen und auswerten
;
A7841:  CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      HL,(INTFAC)     ; Zeiger auf Anfang Rechenspeicher holen
        INC     HL              ; Zeiger auf Mantisse des Aspekts
        BIT     7,(HL)          ; Aspekt negativ  ?
        JP      NZ,A636A        ; ja -->  Fehler 3   Illegal data error
        DEC     HL              ; Zeiger wieder auf Exponent der Zahl
        LD      DE,B7C45        ; Zeiger auf +1  (Real - Format)
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        RET     Z               ; Aspekt gleich 1
        LD      A,1             ; Code for 'Aspekt < 1'  (X-Achse als Hauptachse)
        JR      C,A7870         ; Aspekt kleiner eins
        LD      HL,B7C45        ; Zeiger auf +1  (Real - Format)
        LD      DE,S78F6        ; Zeiger auf Rechenspeicher für CIRCLE - Routine
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf +1 im Speicher
        LD      DE,(INTFAC)     ; Zeiger auf Anfang Rechenspeicher holen
        CALL    A93D5           ; /  - Routine   ( (HL) = (HL) / (DE) )
        LD      A,2             ; Code for 'Aspekt > 1' (Y-Achse als Hauptachse)
A7870:  LD      (D782E + 1),A   ; Verhältnisflag eintragen
        LD      DE,B78FB        ; Zeiger auf 256   (Real - Konstante)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,B7900        ; Zeiger auf  0.50001   (Real - Konstante)
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        CALL    HLFLT           ; Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
        LD      A,L             ; Low - Byte Aspekt - Wert holen
        LD      (D782E + 2),A   ; und in Parameterroutine eintragen
        BIT     0,H             ; High - Byte Aspekt - Wert gleich Null  ?
        RET     Z               ; ja
        XOR     A               ; Code 'Kreis zeichnen'
        LD      (D782E + 1),A   ; Verhältnisflag wieder löschen   (Aspekt zu groß)
        RET
;
;
;   X- und Y- Offset auf Punkt aus Radius, Aspekt und Winkel errechnen
;
A788E:  PUSH    IX              ; Zeiger auf Speicher für Offsets auf Punkt merken
        PUSH    IY              ; Zeiger auf Speicher für Winkel merken
        CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
        POP     DE              ; Zeiger auf Speicher für Winkel holen
        POP     IX              ; Zeiger auf Speicher für Offsets auf Punkt holen
        PUSH    HL              ; Programmzeiger retten
        PUSH    IX              ; Zeiger auf Speicher für Offset auf Punkt wieder merken
        LD      HL,(INTFAC)     ; Zeiger auf Anfang Rechenspeicher holen
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        LD      HL,(INTFAC)     ; Zeiger auf Anfang Rechenspeicher holen
        LD      D,H             ;! nach DE übertragen
        LD      E,L             ;!
        INC     DE              ;! Zeiger auf nächsten Rechenspeicher
        INC     DE              ;! bereitstellen
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        CALL    A96F9           ; COS - Funktion aufrufen   ( COS( (HL) ) )
        LD      DE,S78F1        ; Zeiger auf Speicher mit Real-Radius
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        CALL    A78D0           ; Ergebnis umsetzen in Integer und in Parameterroutine eintr.
        LD      HL,(INTFAC)     ; Zeiger auf Anfang Rechenspeicher holen
        CALL    A9709           ; SIN - Funktion aufrufen   ( SIN( (HL) ) )
        LD      DE,S78F1        ; Zeiger auf Speicher für Real-Radius
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        CALL    A90A6           ; Vorzeichen des Wertes (HL) umkehren
        CALL    A78D0           ; Ergebnis umsetzen in Integer und in Parameterroutine eintr.
        POP     IX              ; Zeiger auf Speicher für Offset verwerfen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   bereitgestelltes Ergebnis umsetzen in Integer und in Parameterroutine eintr.
;
A78D0:  INC     HL              ; Zeiger auf MSByte Mantisse stellen
        BIT     7,(HL)          ; Vorzeichen des Wertes abfragen
        PUSH    AF              ; Vorzeichen retten
        RES     7,(HL)          ; Wert auf plus
        DEC     HL              ; Zeiger wieder auf Exponenten
        LD      DE,B7900        ; Zeiger auf  0.50001   (Real - Konstante)
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        POP     AF              ; Vorzeichen des Wertes holen
        INC     HL              ; Zeiger auf MSByte Mantisse
        JR      Z,A78E3         ; alter Wert war positiv
        SET     7,(HL)          ; Vorzeichen auf Minus
A78E3:  DEC     HL              ; Zeiger wieder auf Exponenten
        CALL    HLFLT           ; Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
        EX      DE,HL           ; bereitgestellten Zahlwert nach DE
        POP     HL              ; Rücksprungadresse holen
        EX      (SP),HL         ; mit Zeiger auf Stelle für Offsett vertauschen
        LD      (HL),E          ;! Offset in Parameterroutine eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL              ;! Zeiger auf Stelle für nächsten Offset
        INC     HL              ;!
        EX      (SP),HL         ; Zeiger für Offset retten / Rücksprungadresse holen
        JP      (HL)            ; RETurn ausführen
;
;
;   Speicher unf Konstanten für CIRCLE - Routine
;
S78F1:  DEFS    5                       ; Speicher für Real-Radius
;
S78F6:  DEFS    5                       ; Zwischenspeicher für Routine
;
B78FB:  DEFB    089H                    ; Exponent   256
        DEFB    000H,000H,000H,000H     ; Mantisse   256
;
B7900:  DEFB    080H                    ; Exponent   0.50001
        DEFB    000H,000H,0A7H,0C6H     ; Mantisse   0.50001
;
S7905:  DEFS    1                       ; Exponent Startwinkel
S7906:  DEFS    4                       ; Mantisse Startwinkel
;
S790A:  DEFS    1                       ; Exponent Endwinkel
S790B:  DEFS    4                       ; Mantisse Endwinkel
;
;
;   Basic - Befehl   SYMBOL     (Token code 254 160 / 0FEH 0A0H)
;
A790F:  CALL    A75FB           ; auf Farbangabe untersuchen und X,Y-Graphic-Koord. bereitst.
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    71              ; Code 71   Graphic-Cursor auf Koordinate in DE',HL' setzen
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        LD      A,B             ; Anzahl Zeichen String holen
        OR      A               ; gleich Null  ?
        PUSH    BC              ; Anzahl Zeichen retten
        PUSH    HL              ; Programmzeiger retten
        LD      C,B             ; Anzahl Zeichen
        LD      B,0             ; High - Byte Anzahl auf Null
        LD      HL,S27D0        ; Zeiger auf Speicher für String
        EX      DE,HL           ; Zeiger vertauschen
        JR      Z,A7929         ; Stringlänge gleich Null
        LDIR                    ; String im Speicher retten
A7929:  POP     HL              ; geretteten Programmzeiger holen
A792A:
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    IBYTE           ; ein - Byte - Wert nach DE/Accu bereitstellen
        LD      A,D             ;! Vergrößerung in X - Achse gleich Null  ?
        OR      E               ;!
        JR      Z,A793D         ; ja -->  Fehler 3   Illegal data error
        PUSH    DE              ; Vergrößerung in X - Achse retten  (horizontale Vergrößerung)
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    IBYTE           ; ein - Byte - Wert nach DE/Accu bereitstellen
        LD      A,D             ;! Vergrößerung in Y - Achse gleich Null  ?
        OR      E               ;!
A793D:  JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        LD      A,E             ; Vergrößerung in Y-Achse  (steht schon im Accu)
        POP     DE              ; gerettete X - Vergrößerung holen
        LD      D,A             ; Y - Vergrößerung eintragen  (vertikale Vergrößerung)
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        PUSH    DE              ; Vergrößerungen retten
        JR      Z,A7957         ; keine Richtung angegeben
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    IBYTE           ; ein - Byte - Wert nach DE/Accu bereitstellen
        LD      A,3             ; maximalen Richtungswert vorgeben
        CP      E               ; mit angegebenem Richtungswert vergleichen
        JP      C,A636A         ; zu groß -->  Fehler 3   Illegal data error
        LD      A,E             ; Richtungswert holen
        DEFB    LD_B            ; Vorgabe für 'Keine Richtung angegeben' überspringen
A7957:  XOR     A               ; Richtung in X-Achse vorgeben
        POP     DE              ; Vergrößerung in X- und Y-Achse holen
        POP     BC              ; Anzahl Zeichen der Zeichenkette holen
        LD      C,A             ; Richtung merken
        LD      A,B             ; Anzahl Zeichen holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  fertig
        LD      A,C             ; Richtung holen
        PUSH    HL              ; Programmzeiger retten
        EX      DE,HL           ; Vergrößerungen nach HL
        LD      DE,S27D0        ; Zeiger auf Speicher mit Text vorgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    87              ; Code 87  Text mit Vergrößerung ausgeben
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   HCOPY     (Token code 254 156 / 0FEH 09CH)
;
A7968:  CALL    A797A           ; auf Syntax Befehlsende überprüfen
        PUSH    HL              ; Programmzeiger retten
        LD      A,0             ; Code for 'Bildschirm null'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    79              ; Code 79   Bildschirminhalt auf Graphic-Drucker ausgeben
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   CLS     (Token code 155 / 09BH
;
A7972:  CALL    A797A           ; auf Syntax Befehlsende überprüfen
        PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    69              ; Code 69   Bildschirm löschen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Programm (HL) auf Syntax Befehlsende überprüfen
;
A797A:  CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        RET     Z               ; Befehlsende -->  Syntax ist OK
        JP      A6364           ; Fehler 1  Syntax error
;
;
;   auf /P untersuchen und Ausgaberoutinen entsprechend umstellen
;
A7981:  XOR     A               ; Code for 'Ausgabe auf Bildschirm'
        LD      (FILOUT),A      ; Ausgabeflag  CRT/LPT  setzen
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFB    ___DIV          ; /   (Zwischencode)  ?
        RET     NZ              ; nein
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    "P"             ; P   (Printer)  ?
        ;CALL    AA007           ; Drucker auf Textmodus überprüfen
		CALL    AA009           ; Drucker auf Textmodus überprüfen
        LD      A,'P'           ; Code for 'Ausgabe auf Drucker'
        LD      (FILOUT),A      ; Ausgabeflag  CRT/LPT  setzen
        CP      A               ; Zero - Flag setzen
        RET
;
;
;   Hex - Wert in HL umsetzen in Dezimal - ASCII nach Zwischenspeicher
;
A7998:  LD      DE,S9E6A        ; Zeiger auf Zwischenspeicher vorgeben
        LD      B,0             ; Code for 'Vornullen unterdrücken'
        PUSH    DE              ; Zeiger auf Anfang Zwischenspeicher retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    22              ; Code 22   Hex-Wert in HL umsetzen in Dezimal-ASCII nach (DE)
        POP     DE              ; Zeiger auf aufbreiteten Text holen
        RET
;
;
;   auf Syntax  'Klammer auf'  überprüfen
;
A79A2:  INC     HL              ; ausgewertetes Zeichen überspringen
A79A3:  CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
A79A6:  CP      '('             ; nächstes Zeichen gleich 'Klammer auf'  ?
        JR      A79B6           ; Syntaxüberprüfung auswerten
;
;
;   auf Syntax 'Klammer zu' überprüfen
;
A79AA:  CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
A79AD:  CP      ')'             ; nächstes Zeichen gleich 'Klammer zu'  ?
        JR      A79B6           ; Syntaxüberprüfung auswerten
;
;
;   auf Syntax  'Komma'  untersuchen
;
A79B1:  CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
A79B4:  CP      ','             ; nächstes Zeichen gleich Komma  ?
A79B6:  INC     HL              ; Syntax - Zeichen überspringen
        RET     Z               ; Syntax ist OK
        JP      A6364           ; Fehler 1  Syntax error
;
;
;   Zeiger in DE auf nächstes relevantes Zeichen setzen
;
A79BB:  INC     DE              ; Textzeichen überspringen
A79BC:  LD      A,(DE)          ; ein Zeichen Text holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A79BB         ; ja -->  relevantes Zeichen suchen
        RET
;
;
;   +1 im Real - Format nach (DE) übertragen
;
A79C2:  LD      HL,B7C45        ; Zeiger auf +1  (Real - Format)
;
;
;   Real - Zahlwert von (HL) nach (DE) übertragen
;
A79C5:  LD      BC,5            ; Länge der Zahl im internen Real - Format
        LDIR                    ; Zahlwert von (HL) nach (DE) übertragen
        RET
;
;
;   Integer - Wert in (DE) umsetzen in Real - Wert nach (HL)
;
A79CB:  CALL    A909E           ; Null im Real - Format nach (HL) eintragen
        LD      A,E             ;! Wert gleich NUll  ?
        OR      D               ;!
        RET     Z               ; ja -->  fertig
        BIT     7,D             ; Wert negativ  ?
        LD      A,01111111B     ; Maske für MSB positive Zahl vorgeben
        JR      Z,A79E0         ; Zahl  positiv
        LD      A,D             ;! Wert in DE negieren
        CPL                     ;!
        LD      D,A             ;!
        LD      A,E             ;!
        CPL                     ;!
        LD      E,A             ;!
        INC     DE              ;!
        LD      A,11111111B     ; Maske für MSB negative Zahl vorgeben
A79E0:  LD      B,091H          ; Vorgabe für Exponent
A79E2:  DEC     B               ; Exponent minus eins
        BIT     7,D             ; 1tes Bit Mantisse gesetzt  ?
        JR      NZ,A79ED        ; ja -->  internes Format stimmt
        RL      E               ;! Mantisse mal zwei
        RL      D               ;!
        JR      A79E2           ; überprüfen, ob internes Format stimmt
;
A79ED:  LD      (HL),B          ; Exponenten eintragen
        INC     HL              ; eingetragenen Exponenten überspringen
        AND     D               ; Vorzeichen setzen
        LD      (HL),A          ; MSByte Mantisse eintragen
        INC     HL              ; Byte überspringen
        LD      (HL),E          ; zweites Byte Mantisse eintragen
        DEC     HL              ;! Zeiger wieder auf Exponenten
        DEC     HL              ;!
        RET
;
;
;   testen, ob ASCII - Zeichen im Accu gleic Ziffer ist   (nein -->  Carry)
;
A79F6:  CP      '0'             ; Anfang Ziffern
        RET     C               ; keine Ziffer
        CP      '9' + 1         ; Ende Ziffern
        CCF                     ; Ergebnisflag umkehren
        RET
;
;
;  untersuchen, ob Zeichen im Accu gleich Variablennamenzeichen ist
;
A79FD:  CP      '_'             ; Pfeil links im Sharp - Zeichensatz  ?
        RET     Z               ; ja -->  OK
        CP      '0'             ; Anfang Ziffern
        RET     C               ; kein gültiges Zeichen
        CP      'Z' + 1         ; Ende Buchstaben
        CCF                     ; ergebnisflag umkehren
        RET     C               ; kein gültiges Zeichen
        CP      '9' + 1         ; Ende Ziffern
        CCF                     ; Ergebnis umkehren
        RET     NC              ; Zeichen ist gültig
        CP      'A'             ; Anfang Buchstaben
        RET
;
;
;   ASCII - Text (DE) umsetzen in Real - Wert nach (HL)
;
A7A0E:  CALL    A909E           ; Null im Real - Format nach (HL) eintragen
        LD      (S7E34),A       ; Anzahl Stellen zurücksetzen
        LD      (S7E35),A       ; Flag 'Stellen angegeben' zurücksetzen
        LD      (S7E36),A       ; Flag  'Real - Wert' zurücksetzen
        LD      (D7AB5 + 1),A   ; Dezimalpunkt - Flag zurücksetzen
        LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
A7A22:  CALL    A79BC           ; Zeiger in DE auf nächstes relevantes Zeichen
        INC     DE              ; Zeichen überspringen
        CP      '+'             ; Vorzeichen plus  ?
        JR      Z,A7A22         ; ja -->  vergessen
        CP      '-'             ; Vorzeichen minus  ?
        JR      NZ,A7A34        ; nein -->  weiter untersuchen
        CALL    A7A22           ; ASCII-Text (DE) umsetzen in Real - Wert
        JP      A90A9           ; Vorzeichen des Wertes (HL) umkehren
;
A7A34:  CP      '$'             ; Kennung  Hex - Wert  ?
        JR      NZ,A7A44        ; nein -->  weiter untersuchen
        PUSH    HL              ; Zeiger auf Stelle für Zahl merken
        EX      DE,HL           ; Zeiger auf Text nach HL
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    20              ; Code 20   Sedezimal-Wert  (HL) umsetzen in Hex-Wert nach DE
        EX      (SP),HL         ; Programmzeiger retten / Zeiger für Zahlwert holen
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        POP     DE              ; geretteten Programmzeiger holen
        LD      A,5             ; Code for 'Real - Wert'
        RET
;
A7A44:  CP      '0'             ; Vornull  ?
        JR      NZ,A7A4E        ; nein -->  weiter untersuchen
        LD      A,(DE)          ; nächstes Zeichen holen
        INC     DE              ; Zeichen überspringen
        JR      A7A44           ; untersuchen, ob Vornull
;
A7A4C:  LD      A,(DE)          ; nächstes Textzeichen holen
        INC     DE              ; Zeichen überspringen
A7A4E:  CP      ' '             ; Leerzeichen  ?
        JR      Z,A7A4C         ; ja -->  nächstes Zeichen holen
        CP      '.'             ; Dezimalpunkt  ?
        JR      Z,A7A71         ; ja -->  'Dezimalpunkt gefunden'  merken
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        JR      C,A7AAB         ; keine Ziffer -->  testen, ob Exponent
        SUB     '0'             ; ASCII - Zeichen umsetzen in Dezimal-Ziffer
        CALL    A7BDD           ; altes Teilergebnis mal 10
        CALL    A7B47           ; Wert der neuen Stelle addieren   (Wert im Accu)
        LD      A,1             ; Code 'Stelle angegeben'
        LD      (S7E35),A       ; im Flag 'Stellen angegeben' merken
        LD      A,(S7E34)       ; Anzahl Stellen holen
        INC     A               ; plus eins
        LD      (S7E34),A       ; und wieder merken
        JR      A7A4C           ; nächstes Zeichen untersuchen
;
A7A71:  LD      A,1             ; Code for 'Dezimalpunkt angegeben'
        LD      (D7AB5 + 1),A   ; im Dezimalpunkt - Flag merken
        LD      C,A             ; Vorgabe für Zähler  'Anzahl Nachkommastellen'
A7A77:  LD      A,(DE)          ; ein Textzeichen holen
        INC     DE              ; Zeiger auf Text nächstes Zeichen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A7A77         ; ja -->  nächstes relevantes Zeichen suchen
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        JR      C,A7AA3         ; nein -->  Exponent für Nachkommastellen corrigieren
        INC     C               ; Anzahl Nachkommastellen plus eins
        SUB     '0'             ; ASCII - Zeichen umsetzen in Dezimal - Ziifer
        JR      Z,A7A8E         ; Null -->  Stelle nicht als angegebene Stelle merken
        PUSH    AF              ; Wert der Stelle retten
        LD      A,1             ; Code for 'Stellen angegeben'
        LD      (S7E35),A       ; im Flag 'Stellen angegeben' merken
        POP     AF              ; Wert der Stelle holen
A7A8E:  PUSH    AF              ; Wert der Stelle retten
        LD      A,(S7E35)       ; Flag 'Stellen angegeben' holen
        LD      B,A             ; und merken
        LD      A,(S7E34)       ; Anzahl Stellen holen
        ADD     A,B             ; plus Flag  `Stellen angegeben'   (0 oder 1)
        LD      (S7E34),A       ; neue Anzahl Stellen merken
        POP     AF              ; geretteten Wert der Stelle holen
        CALL    A7BDD           ; altes Teilergebnis mal 10
        CALL    A7B47           ; Wert der neuen Stelle addieren   (Wert im Accu)
        JR      A7A77           ; nächstes Textzeichen untersuchen
;
A7AA3:  DEC     C               ; Zähler 'Anzahl Nachkommastellen' minus iens
        JR      Z,A7AAB         ; Exponent corrigiert   (Zahlwert stimmt)
        CALL    A7B31           ; Real - Zahlwert (HL) durch zehn
        JR      A7AA3           ; überprüfen, ob Zahlwert stimmt
;
A7AAB:  CP      'E'             ; Exponenten - Kennung  ?
        JR      Z,A7ABC         ; ja -->  angegebenen Exponenten auswerten
A7AAF:  DEC     DE              ; Zeiger auf ASCII - Text wieder corrigieren
        LD      A,(S7E36)       ; Flag  'Real - Wert' holen
        OR      A               ; Real - Wert  ?
        RET     NZ              ; ja
D7AB5:  LD      A,0             ; Dezimalpunkt - Flag holen   (wird eingetragen)
        OR      A               ; Dezimalpunkt angegeben  ?
        RET     NZ              ; ja
        LD      A,5             ; Code for 'Real - Wert'
        RET
;
;
;   angegebenen Dezimal - Exponenten des Zahlwertes auswerten
;
A7ABC:  LD      A,(DE)          ; nächstes Textzeichen holen
        CP      '-'             ; Vorzeichen minus  ?
        JR      Z,A7ACA         ; ja -->  Vorzeichen für Exponenten angegeben
        CP      '+'             ; Vorzeichen plus  ?
        JR      Z,A7ACA         ; ja -->  Vorzeichen für Exponenten angegeben
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        JR      C,A7AAF         ; keine Ziffer -->  kein Exponent -->  Zahl umgesetzt
A7ACA:  LD      A,1             ; Code for 'Real - Wert'
        LD      (D7AB5 + 1),A   ; im Dezimalpunkt - Flag merken
        PUSH    HL              ; Zeiegr auf bisher bereitgestellten Zahlwert merken
        LD      HL,A92EA        ; Adresse  der  *  - Routine
        LD      (D7B29 + 1),HL  ; in Routine eintragen
        LD      HL,0            ; Vorgabe für Zähler Exponent
        LD      A,(DE)          ; Textzeichen holen
        INC     DE              ; Textzeichen überspringen
        CP      '+'             ; Vorzeichen plus  ?
        JR      Z,A7AEB         ; ja -->  vergessen
        CP      '-'             ; Vorzeichen minus  ?
        JR      NZ,A7AED        ; nein -->  Ziffer auswerten
A7AE4:
        PUSH    HL              ; Exponentenzähler retten
        LD      HL,A93D5        ; Adresse der / - Routine
        LD      (D7B29 + 1),HL  ; in Routine eintragen
        POP     HL              ; geretteten Zähler wieder holen
A7AEB:  LD      A,(DE)          ; ein Textzeichen holen
        INC     DE              ; Textzeichen überspringen
A7AED:  SUB     '0'             ; ASCII-Zeichen umsetzen in Dezimal - Wert
        JR      C,A7B0D         ; keine Ziffer -->  Exponent ausgewertet
        CP      10              ; mit Anzahl Ziffern vergleichen
        JR      NC,A7B0D        ; keine Ziffer -->  Exponent ausgewertet
        PUSH    DE              ; Zeiger auf Resttext retten
        CALL    A7B42           ; HL * 2 mit Untersuchung auf Übertrag   (Exp. * 2)
        LD      E,L             ;! Zwischenergebnis duplizieren
        LD      D,H             ;!
        CALL    A7B42           ; HL * 2 mit Untersuchung auf Übertrag   (Exp. * 4)
        CALL    A7B42           ; HL * 2 mit Untersuchung auf Übertrag   (Exp. * 8)
        CALL    A7B3E           ; HL + DE mit Untersuchung auf Übertrag  (Exp. * 10)
        LD      E,A             ; Wert der neuen Stelle
        LD      D,0             ; High - Byte Wert auf Null
        CALL    A7B3E           ; HL + DE mit Untersuchung auf Übertrag
        POP     DE              ; Zeiger auf Resttext wieder holen
        JR      A7AEB           ; Rest des angegebenen Exponenten auswerten
;
A7B0D:  LD      A,H             ; High - Byte Exponent holen
        OR      A               ; gleich Null  ?
        JR      NZ,A7B44        ; nein -->  zu groß -->  Fehler 2  Overflow error
        LD      A,L             ; Low - Byte Exponent holen
        POP     HL              ; Zeiger auf bereitgestellte Mantisse holen
        PUSH    DE              ; Zeiger auf Resttext retten
        PUSH    BC              ; Keep register value
        PUSH    HL              ; Zeiger auf bereitgestellte Mantisse retten
        LD      DE,S9E9D        ; Zeiger auf Zwischenspeicher für Berechnung
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        CALL    A79C2           ; +1 im Real - Format nach (DE) übertragen
        POP     HL              ; Zeiger auf Zahlwert +1 im Speicher
        LD      B,A             ; angegebenen Exponenten merken
        INC     B               ; für Schleife corrigieren
        JR      A7B25           ; Correcturfaktor für Mantissenwert errechnen
;
A7B22:  CALL    A7BDD           ; altes Teilergebnis mal 10
A7B25:  DJNZ    A7B22           ; richtigen Correcturfaktor errechnen
        EX      DE,HL           ; Zeiger auf Correcturfaktor nach DE
        POP     HL              ; Zeiger auf ZAhlwert der Mantisse holen
D7B29:  CALL    0               ; Wert corrigieren  (* oder /  Correcturfaktor)
        POP     BC              ; geretteten Register - Wert holen
        POP     DE              ; Zeiger auf Resttext holen
        JP      A7AAF           ; Typ des bereitgestellten Zahlwertes auswerten
;
;
;   Real - Zahlwert (HL) durch zehn
;
A7B31:  PUSH    AF              ;! Register - Werte retten
        PUSH    BC              ;!
        PUSH    DE              ;!
        LD      DE,B7C40        ; Zeiger auf  + 10  (Real - Format)
        CALL    A93D5           ; /  - Routine   ( (HL) = (HL) / (DE) )
        POP     DE              ;! gerettete Register - Werte holen
        POP     BC              ;!
        POP     AF              ;!
        RET
;
;
;   HL = HL + DE  mit Untersuchung auf Überlauf
;
A7B3E:  ADD     HL,DE           ; Zahlen addieren
        RET     NC              ; Ergebnis ist OK
        JR      A7B44           ; zu groß -->  Fehler 2  Overflow error
;
;
;   HL = HL + HL  mit Untersuchung auf Überlauf
;
A7B42:  ADD     HL,HL           ; Zahlen addieren
        RET     NC              ; Ergebnis ist OK
A7B44:  JP      A6367           ; zu groß -->  Fehler 2  Overflow error
;
;
;   Wert der neuen Stelle addieren   (Wert im Accu)
;
A7B47:  PUSH    DE              ; Keep register value
        PUSH    HL              ; Zeiger auf Real - Zahlwert merken
        LD      HL,S9E9D        ; Zeiger auf Zwischenspeicher für Berechnung
        LD      E,A             ; Dezimal - Ziffer
        LD      D,0             ; High - Byte Wert auf Null
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        EX      DE,HL           ; Zeiger auf umgesetzten Real-Wert nach DE
        POP     HL              ; Zeiger auf Zahl holen
        PUSH    BC              ; Keep register value
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        POP     BC              ;! gerettete Register - Werte wieder holen
        POP     DE              ;!
        RET
;
;
;   Real - Zahlwert  (HL)  umsetzen in ASCII nach Zwischenspeicher
;
A7B5B:  LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        LD      A,(HL)          ; Exponenten der Zahl holen
        OR      A               ; gleich Null  ?
        JR      Z,A7B68         ; ja -->  Zahl gleich Null
        INC     HL              ; Zeiger auf MSByte der Mantisse
        LD      A,(HL)          ; MSByte der Mantisse holen
        DEC     HL              ; Zeiger auf Zahl wieder auf Exponenten
        RLCA                    ; Vorzeichen nach Carry - Flag schieben
A7B68:  LD      A,' '           ; Leerzeichen  (Space) bei positiver Zahl
        JR      NC,A7B71        ; Zahl ist positiv
        CALL    A90A9           ; Vorzeichen des Wertes (HL) umkehren
        LD      A,'-'           ; Vorzeichen minus für negative Zahl
A7B71:  PUSH    AF              ; Vorzeichen retten
        CALL    A7CE0           ; Zahl aufbereiten in ASCII, wenn ohne Exponent möglich
        CALL    A7D6D           ; Rest der Zahl aufbereiten in ASCII
        POP     AF              ; Vorzeichen holen
        DEC     DE              ; Zeiger auf ASCII-Text auf Stelle für Vorzeichen
        LD      (DE),A          ; Vorzeichen eintragen
        RET
;
;
;   Real - Zahlen (HL) und (DE) vergleichen    (BC - Keep register value)
;
A7B7C:  PUSH    BC              ; Keep register value
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Nachkommastellen des Real - Zahlwertes (HL) vergessen
;
A7B82:  CALL    PUSHR           ; Save registers IX, HL, BC and DE
        LD      A,(HL)          ; Exponenten der Zahl holen
        CP      081H            ; Zahl mit Vorkommastellen
        JP      C,A909E         ; nein -->  Null im Real - Format nach (HL) eintragen
        LD      A,(HL)          ; Exponenten der Zahl holen
        CP      0A0H            ; Zahl mit Nachkommastellen
        RET     NC              ; nein -->  fertig
        INC     HL              ; Zeiger auf Mantisse stellen
        CALL    A7BB9           ; drei Byte der Mantisse aus Speicher (HL) nach Register laden
        PUSH    HL              ; Zeiger auf Ende der Mantissen merken
        LD      L,(HL)          ; letztes Byte der Mantisse laden
        LD      B,0             ; Zähler 'wie oft geschoben' auf Null
A7B97:  SRL     E               ;! Mantisse um ein Bit schieben
        RR      D               ;! (ein Bit vergessen)
        RR      C               ;!
        RR      L               ;!
        INC     A               ; Exponenten plus eins
        INC     B               ; Zähler 'wie oft geschoben' plus eins
        CP      0A0H            ; Exponent für Zahl ohne Nachkommastellen  ?
        JR      NZ,A7B97        ; nein -->  weiter schieben und vergessen
A7BA5:  SLA     L               ;! Mantisse wieder auf richtige Wertigkeit
        RL      C               ;! schieben
        RL      D               ;!
        RL      E               ;!
        DJNZ    A7BA5           ;!   weiter schieben
        LD      A,L             ; letztes Byte der Mantisse holen
        POP     HL              ; Zeiger auf Stelle für letztes Byte Mantisse holen
        LD      (HL),A          ;! Mantisse wieder in Speicher eintragen
        DEC     HL              ;!
        LD      (HL),C          ;!
        DEC     HL              ;!
        LD      (HL),D          ;!
        DEC     HL              ;!
        LD      (HL),E          ;!
        RET
;
;
;   drei Byte aus Speicher (HL) nach Register laden
;
A7BB9:  LD      E,(HL)          ;! Bytes aus Speicher nach Register laden
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL              ;!
        LD      C,(HL)          ;!
        INC     HL              ;!
        RET
;
;
;   Basic - Funktion   FRAC     (Token code  255 141 / 0FFH 08DH)
;   (Nachkommastellen des Real - Zahlwertes (HL) errechnen)
;
A7BC0:  LD      A,(HL)          ; Exponenten der Zahl holen
        CP      081H            ; Betrag der Zahl größer eins  ?
        RET     C               ; nein -->  Zahl hat keine Vorkommastellen -->  fertig
        PUSH    DE              ; Keep register value
        PUSH    HL              ; Zeiger auf Zahlwert retten
        LD      DE,S7BD8        ; Zeiger auf Zwischenspeicher für Routine
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf Anfang Speicher holen
        CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        EX      DE,HL           ; Zeiger auf Zahl ohne Nachkommastellen nach DE
        POP     HL              ; Zeiger auf Originalwert holen
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     DE              ; geretteten Register - Wert holen
        RET
;
S7BD8:  DEFS    5               ; Zwischenspeicher für FRAC - Routine
;
;
;   Real - Zahlwert (HL) mal zehn
;
A7BDD:  PUSH    AF              ;! Register - Werte retten
        PUSH    BC              ;!
        PUSH    DE              ;!
        LD      DE,B7C40        ; Zeiger auf  + 10  (Real - Format)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     DE              ;! gerettete Register - Werte holen
        POP     BC              ;!
        POP     AF              ;!
        RET
;
;
;   vorzeichenbehafteten Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
;
HLFLT:  INC     HL              ; Zeiger auf umzusetzende Zahl auf Mantisse stellen
        BIT     7,(HL)          ; Zahl positiv  ?
        JR      Z,A7BFA         ; ja -->  Zahl umsetzen in Integer - Wert
        CALL    A7BFA           ; Betrag der Zahl (HL) umsetzen in Integer nach HL
        LD      A,H             ;! 2er Complement des Zahlwertes in HL bilden
        CPL                     ;!
        LD      H,A             ;!
        LD      A,L             ;!
        CPL                     ;!
        LD      L,A             ;!
        INC     HL              ;!
        RET
;
A7BFA:  DEC     HL              ; Zeiger wieder auf Exponent
        LD      A,(HL)          ; Exponenten der Zahl holen
        CP      091H            ; mit größtem umsetzbarem Exponenten vergleichen
        JP      NC,A6367        ; Zahl zu groß -->  Fehler 2  Overflow error
        CP      081H            ; kleinster Exponent mit Vorkommastellen  ?
        JR      C,A7C18         ; Zahl hat keine Vorkommastellen -->  Ergebnis gleich 0
        PUSH    AF              ; Exponenten retten
        INC     HL              ; Zeiger auf Zahl auf Mantisse
        LD      A,(HL)          ;! die zwei höchstwertigen Bytes der
        INC     HL              ;! Mantisse laden
        LD      L,(HL)          ;!
        LD      H,A             ;!
        POP     AF              ; geretteten Exponenten wieder holen
        SET     7,H             ; erstes Bit der Mantisse setzen   (Vorzeichen - Bit)
A7C0E:  CP      090H            ; normierter Exponent  ?
        RET     Z               ; ja -->  Wert in HL stimmt
        INC     A               ; Zähler für Exponenten plus eins
        SRL     H               ;! Mantisse durch zwei
        RR      L               ;!
        JR      A7C0E           ; testen, ob Wert stimmt
;
A7C18:  CCF                     ; Carry - Flag zurücksetzen   (Code 'kein Fehler'
        LD      HL,0            ; Null als Ergebnis vorgeben
        RET
;
;
;   Konstanten für die Zahlumsetzroutinen
;
B7C1D:  DEFB    09BH                    ; Exponent   .1E+09
        DEFB    03EH,0BCH,020H,000H     ; Mantisse   .1E+09
;
B7C22:  DEFB    098H                    ; Exponent   10000000
        DEFB    018H,096H,080H,000H     ; Mantisse   10000000
;
        DEFB    094H                    ; Exponent   1000000
        DEFB    074H,024H,000H,000H     ; Mantisse   1000000
;
        DEFB    091H                    ; Exponent   100000
        DEFB    043H,050H,000H,000H     ; Mantisse   100000
;
        DEFB    08EH                    ; Exponent   10000
        DEFB    01CH,040H,000H,000H     ; Mantisse   10000
;
        DEFB    08AH                    ; Exponent   1000
        DEFB    07AH,000H,000H,000H     ; Mantisse   1000
;
        DEFB    087H                    ; Exponent   100
        DEFB    048H,000H,000H,000H     ; Mantisse   100
;
B7C40:  DEFB    084H                    ; Exponent   10
        DEFB    020H,000H,000H,000H     ; Mantisse   10
;
B7C45:  DEFB    081H                    ; Exponent   1
        DEFB    000H,000H,000H,000H     ; Mantisse   1
;
        DEFB    07DH                    ; Exponent   .1
        DEFB    04CH,0CCH,0CCH,0CDH     ; Mantisse   .1
;
B7C4F:  DEFB    066H                    ; Exponent   .1E-07
        DEFB    02BH,0CCH,077H,012H     ; Mantisse   .1E-07
;
;
;   Real - Zahlwert umsetzen in ASCII mit Exponentialdarstellung
;
A7C54:  LD      HL,(S7E37)      ; Zeiger auf Real - Zahlwert holen
        LD      B,0             ; Vorgabe für Exponenten
A7C59:  LD      DE,B7C40        ; Zeiger auf  + 10  (Real - Format)
        CALL    A7B7C           ; Real-Zahlen (HL) und (DE) vergleichen (BC-Register retten)
        JR      C,A7C67         ; Zahl (HL) ist kleiner als 10
        CALL    A7B31           ; Real - Zahlwert (HL) durch zehn
        INC     B               ; Exponentenzähler plus eins
        JR      A7C59           ; überprüfen, ob Zahl (HL) kleiner 10 ist
;
A7C67:  LD      DE,B7C45        ; Zeiger auf +1  (Real - Format)
        CALL    A7B7C           ; Real-Zahlen (HL) und (DE) vergleichen (BC-Register retten)
        JR      NC,A7C75        ; Zahl (HL) ist größer gleich +1
        CALL    A7BDD           ; Real - Zahlwert (HL) mal 10
        DEC     B               ; Exponentenzähler minus eins
        JR      A7C67           ; überprüfen, ob Zahl (HL) größer gleich eins ist
;
A7C75:  PUSH    BC              ; Exponentenzähler retten
        CALL    A7CE0           ; Zahl aufbereiten in ASCII, wenn ohne Exponent möglich
        CALL    A7D6D           ; Rest der Zahl aufbereiten in ASCII
        POP     BC              ; geretteten Exponentenzähler holen
        PUSH    DE              ; Zeiger auf Anfang ASCII-Zahlwert retten
        EX      DE,HL           ; Zeiger auf Zahl nach HL
A7C7F:  LD      A,(HL)          ; ein Zeichen Zahl holen
        OR      A               ; Ende Zahlwert  ?
        JR      Z,A7C86         ; ja
        INC     HL              ; Zeiger auf Zahltext auf nächste Stelle
        JR      A7C7F           ; Ende Zahltext suchen
;
A7C86:  DEC     HL              ; Zeiger auf letzte Stelle der Zahl
        LD      A,(HL)          ; ASCII - Stelle holen
        INC     HL              ; Zeiger wieder auf Ende Zahl
        CP      '0'             ; Null  ?
        JR      NZ,A7C8F        ; nein -->  relevante Stelle
        INC     B               ; Exponentenzähler plus eins
        DEC     HL              ; Zeiger wieder auf Null
A7C8F:  LD      A,'E'           ; Code for 'Exponent'
        LD      (HL),A          ; hinter Zahlwert Mantisse eintragen
        INC     HL              ; Exponentenzeichen überspringen
        LD      A,B             ; Exponentenzähler holen
        LD      B,'+'           ; Vorgabe für Vorzeichen Exponent
        BIT     7,A             ; Zähler positiv  ?
        JR      Z,A7C9E         ; Exponent positiv
        NEG                     ; 2er Complement des Zählers bilden
        LD      B,'-'           ; richtiges Vorzeichen vorgeben
A7C9E:  LD      (HL),B          ; Vorzeichen des Exponenten eintragen
        INC     HL              ; Vorzeichen überspringen
        LD      (HL),'0'        ; erste Stelle Exponent vorgeben
A7CA2:  SUB     10              ; ein mal Wertigkeit der Stelle abziehen
        JR      C,A7CA9         ; schon zu klein
        INC     (HL)            ; 10er Stelle plus eins
        JR      A7CA2           ; weiter untersuchen
;
A7CA9:  ADD     A,'9' + 1       ; 1er Stelle Exponent umsetzen in ASCII
        INC     HL              ; 10er Stelle überspringen
        LD      (HL),A          ; 1er Stelle des Exponenten eintragen
        INC     HL              ; 1er Stelle des Exponenten überspringen
        LD      (HL),NUL        ; Code for 'Textende'  eintragen
        POP     DE              ; Zeiger auf Anfang Zahltext holen
        RET
;
;
;   Real - Zahlwert im Integer - Zahlbereich aufbereiten in ASCII
;
A7CB2:  PUSH    HL              ; Zeiger auf Real - Zahlwert retten
        CALL    HLFLT           ; Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
        LD      DE,S9E75        ; Zeiger auf Speicher für ASCII - Zahl vorgeben
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        LD      B,1             ; Code for 'auch Vornullen aufbereiten'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    22              ; Code 22   Hex-Wert in HL umsetzen in Dezimal-ASCII nach (DE)
        POP     HL              ; Zeiger auf Anfang aufbereitete Zahl holen
        LD      A,'0'           ; Null
        LD      B,5             ; maximal 5 Stellen vergleichen
A7CC3:  CP      (HL)            ; eine Stelle auf Vornull vergleichen
        JR      NZ,A7CCB        ; nicht Vornull -->  Vorkommastellen merken
        INC     HL              ; Vornull überspringen
        DJNZ    A7CC3           ; weitere Stellen überprüfen
        JR      A7CD4           ; Zahl hat keine Vorkommastellen
;
A7CCB:  LD      A,B             ; Anzahl Vorkommastellen holen
        LD      (S7E34),A       ; Anzahl Stellen merken
        LD      A,1             ; Code for 'Vorkommastellen'
        LD      (S7E35),A       ; im Flag 'Stellen angegeben' merken
A7CD4:  LD      A,'.'           ; Dezimalpunkt
        LD      (S9E7A),A       ; in Speicher eintragen
        POP     HL              ; Zeiger auf Real - Zahlwert holen
        CALL    A7BC0           ; Nachkommastellen des Real-Zahlwertes (HL) errechnen
        JP      A7D30           ; Nachkommastellen aufbereiten in ASCII
;
;
;   Zahl aufbereiten in ASCII, wenn ohne Exponent möglich
;
A7CE0:  LD      (S7E37),HL      ; Zeiger auf Real - Zahlwert merken
        XOR     A               ; Accu auf Null
        LD      (S7E34),A       ; Anzahl Stellen zurücksetzen
        LD      (S7E35),A       ; Flag 'Stellen angegeben' zurücksetzen
        PUSH    HL              ; Zeiger auf Real - Zahlwert merken
        LD      HL,S9E71        ; Zeiger auf Speicher zur Zahlaufbereitung in ASCII
        LD      (HL),-1         ; Code for 'Zahlanfang'  eintragen
        LD      B,33            ; 33 Zeichen Länge
        LD      A,'0'           ; Null
A7CF4:  INC     HL              ;! Speicher mit Null initialisieren
        LD      (HL),A          ;!
        DJNZ    A7CF4           ;!
        LD      A,'.'           ; Dezimalpunkt
        LD      (S9E7A),A       ; in Speicher eintragen
        POP     HL              ; Zeiger auf Real - Zahlwert holen
        LD      A,(HL)          ; Exponenten der Zahl holen
        OR      A               ; gleich Null  ?
        RET     Z               ; Zahl gleich Null -->  fertig
        LD      DE,B7C1D        ; Zeiger auf .1E+09 im Real - Format
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        CCF                     ; Ergebnis umkehren
        RET     C               ; Zahlwert zu groß für Ansgabe ohne Exponent
        LD      DE,B7C4F        ; Zeiger auf .1E-07 im Real - Format
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        RET     C               ; Zahl zu klein für Ausgabe ohne Exponent
        LD      DE,ZFAC1        ; Zeiger auf Speicher für Real - Zahl
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf Speicher mit Real-Zahlwert holen
        LD      A,(HL)          ; Exponenten der Zahl holen
        CP      081H            ; Exponent für Zahlwert  +/- 1
        JR      C,A7D30         ; Nachkommastellen aufbereiten in ASCII
        CP      090H            ; Zahl kleiner 32728  ?
        JP      C,A7CB2         ; Zahl im Integer-Wert-Bereich -->  aufbereiten in ASCII
        LD      IX,S9E72        ; Zeiger auf Anfang Speicher für ASCII-Zahl
        LD      DE,B7C22        ; Zeiger auf  +10000000
        CALL    A7DF7           ; Vorkommastellen der Zahl (HL) aufbereiten in ASCII
        CALL    A7E2B           ; überprüfen, ob Rest gleich Null oder weitere Stellen
        RET     NC              ; keine Nachkommastellen
;
;
;   Nachkommastellen aufbereiten in ASCII
;
A7D30:  LD      IX,S9E7B        ; Zeiger auf Speicher für Nachkommastellen
A7D34:  LD      DE,B7C1D        ; Zeiger auf .1E+09 im Real - Format
        PUSH    BC              ; Keep register value
        PUSH    IX              ; Zeiger für Nachkommastellen retten
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     IX              ; Zeiger für Nachkommastellen holen
        POP     BC              ; geretteten Register - Wert holen
        INC     DE              ;! Zeiger in DE auf nächste Zahl in Tabelle
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        CALL    A7DF7           ; Vorkommastellen der Zahl (HL) aufbereiten in ASCII
        CALL    A7E2B           ; überprüfen, ob Rest gleich Null oder weitere Stellen
        JR      C,A7D34
        RET
;
;
;   Real - Zahlwert (HL) aufbereiten in ASCII nach Zwischenspeicher
;
A7D4E:  LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        PUSH    HL              ; Zeiger auf Real - Zahlwert retten
        LD      DE,S9EAD        ; Zeiger auf Speicher für Real-Zahlwert  (ASCII)
        PUSH    DE              ; Zeiger auf Speicher merken
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf Speicher mit aufbereiteter Zahl
        CALL    A7CE0           ; Zahl aufbereiten in ASCII, wenn ohne Exponent möglich
        CALL    A7D6A           ; Rest Zahl aufbereiten in ASCII
        POP     HL              ; Zeiger auf geretteten Real-Zahl-Wert holen
        RET
;
A7D64:  LD      DE,S9E7A        ; Zeiger auf Stelle für Dezimalpunkt
        LD      (DE),A          ; Textendezeichen eintragen
        DEC     DE              ; Zeiger auf Null  (0)
        RET
;
;
;   Rest des Zahlwertes aufbereiten in ASCII
;
A7D6A:  JP      C,A7C54         ; Real-Zahl aufbereiten in ASCII mit Exponenten
A7D6D:  LD      HL,(S7E37)      ; Zeiger auf Real - Zahlwert holen
        LD      A,(HL)          ; Exponenten der Zahl holen
        OR      A               ; Exponent gleich Null  ?
        JR      Z,A7D64         ; ja -->  Textende auf Dezimalwert eintragen  (0)
        LD      DE,S9E72        ; Zeiger auf Anfang Speicher für ASCII-Zahl
        DEC     DE              ; Zeiger für Schleife corrigieren
        EX      DE,HL           ; Zeiger für ASCII-Zahl nach HL
        LD      DE,1            ; Code for 'Dezimalpunkt'
A7D7C:  INC     HL              ; Zeiger auf ASCII-Zahlwert auf nächstes Zeichen
        LD      A,(HL)          ; eine Ziffernstelle holen
        CP      '.'             ; Dezimalpunkt  ?
        JR      NZ,A7D87        ; nein -->  weiter untersuchen
        LD      DE,0            ; Code for 'kein Dezimalpunkt'
        JR      A7D7C           ; weiter untersuchen
;
A7D87:  CP      '0'             ; Null  ?
        JR      Z,A7D7C         ; ja -->  weiter untersuchen
        ADD     HL,DE           ; eventuell Dezimalpunkt überspringen
        LD      DE,8            ; maximale Länge Mantisse
        ADD     HL,DE           ; Zeiger auf Ende Zahlwert errechnen
        LD      A,(HL)          ; letzte Stelle der Zahl holen
A7D91:  LD      (HL),'0'        ; und Null eintragen
        CP      '5'             ; Stelle runden  (4/5tel Rundung)  ?
        JR      C,A7DA6         ; kleiner 5 -->  nicht runden
A7D97:  DEC     HL              ; Zeiger auf Stelle davor
        LD      A,(HL)          ; ASCII - Stelle holen
        CP      '.'             ; Dezimalpunkt  ?
        JR      Z,A7D97         ; ja -->  nächste Ziffernstelle suchen
        INC     A               ; Zahlanfang  ?
        JR      Z,A7DE0         ; ja -->  Text  '1E+08'  vorgeben
        LD      (HL),A          ; aufgerundeten Zahlwert wieder eintragen
        CP      '9' + 1         ; Übertrag auf vorige Stelle  ?
        JR      Z,A7D91         ; ja -->  weiter runden
        INC     HL              ; Zeiger wieder auf letzte aufbereitete Stelle
A7DA6:  LD      DE,S9E7A        ; Zeiger auf Stelle für Dezimalpunkt
        EX      DE,HL
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE
        EX      DE,HL
        JR      C,A7DB5         ; Zeiger steht auf Nachkommastelle
        LD      HL,S9E7A        ; Zeiger auf Stelle für Dezimalpunkt
        JR      A7DCC           ; aufbereitete Nachkommastelle  (jetzt 0)  abnippeln
;
A7DB5:  DEC     HL              ; Zeiger auf ASCII- Zahl
        LD      A,(HL)          ; eine Ziffernstelle holen
        CP      '.'             ; Dezimalpunkt  ?
        DEC     HL              ; Zeiger wieder corrigieren
        JR      Z,A7DCB         ; ja -->  Zahl ohne Dezimalpunkt ausgeben
        INC     HL
        CP      '0'             ; Stelle gleich Null  ?
        JR      Z,A7DA6         ; ja -->  letzte relevante Stelle suchen
        PUSH    HL              ; Zeiger auf letzte relevante Stelle retten
        LD      DE,S9E83        ; Zeiger auf maximales Ende Mantisse ohne Exponent
        SBC     HL,DE           ; überprüfen, ob Zahl nach ohne Exponent geht
        POP     HL              ; Zeiger auf letzte relevante Stelle holen
        JP      NC,A7C54        ; zu groß -->  Zahl mit Exponenten aufbereiten
A7DCB:  INC     HL              ; Zeiger auf ASCII - Zahl
A7DCC:  LD      (HL),NUL        ; Textendezeichen hinter Zahlwert eintragen
        LD      DE,S9E72        ; Zeiger auf Anfang Speicher für ASCII - Zahl
A7DD1:  LD      A,(DE)          ; eine Ziffernstelle holen
        CP      '0'             ; Null  ?
        JR      NZ,A7DD9        ; nein -->  testen, ob Ende Zahl
        INC     DE              ; Zeiger auf Zahl auf nächste Stelle
        JR      A7DD1           ; erste relevante Stelle suchen
;
A7DD9:  OR      A               ; Textendezeichen  ?
        RET     NZ              ; nein -->  Zahlwert  OK
        DEC     DE              ; Zeiger wieder auf Stelle davor
        LD      A,'0'           ; Null
        LD      (DE),A          ; eintragen
        RET
;
A7DE0:  LD      HL,S9E6A        ; Zeiger auf Speicher für ASCII-Zahl
        LD      DE,M7DF1        ; Text  '1E+08'
        PUSH    BC              ; Keep register value
        LD      BC,6            ; Textlänge
        LDIR                    ; Text nach Speicher für ASCII-Zahl übertragen
        POP     BC              ; geretteten Register - Wert holen
        LD      DE,S9E6A        ; Zeiger auf Speicher mit ASCII - Zahl vorgeben
        RET
;
M7DF1:  DEFM    "1E+08"
        DEFB    NUL
;
;
;   Vorkommastellen des Real - Zahlwertes (HL) aufbereiten in ASCII
;
A7DF7:  LD      A,(DE)          ; Exponenten aus Tabelle holen
        CP      07DH            ; letzter Tabellenwert  ?
        RET     Z               ; ja -->  fertig
A7DFB:  CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A7E13         ; Zahl ist kleiner als Stellenwertigkeit in Tabelle
        INC     (IX+0)          ; ASCII - Stelle plus eins
        PUSH    IX              ; Zeiger auf ASCII - Stelle merken
        PUSH    BC              ; Keep register value
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     BC              ; geretteten Register - Wert holen
        POP     IX              ; Zeiger auf ASCII - Stelle holen
        LD      A,1             ; Code for 'Ziffer aufbereitet'
        LD      (S7E35),A       ; im Flag 'Ziffer aufbereitet' merken
        JR      A7DFB           ; weiter untersuchen
;
A7E13:  INC     IX              ; Zeiger auf nächste ASCII-Ziffern-Stelle
        INC     DE              ;! Zeiger auf Tabelle auf nächsten Wert
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        LD      A,(S7E35)       ; Flag 'Ziffer aufbereitet' holen  (0 oder 1)
        LD      B,A             ; und merken
        LD      A,(S7E34)       ; Anzahl Stellen holen
        ADD     A,B             ; neue Anzahl Stellen errechnen
        LD      (S7E34),A       ; neuen Anzahl Stellen merken
        CALL    A7E2B           ; überprüfen, ob Rest gleich Null oder weitere Stellen
        RET     NC              ; fertig
        JR      A7DF7           ; Vorkommastellen der Zahl (HL) aufbereiten in ASCII
;
;
;   überprüfen, ob Rest gleich Null oder weitere Stellen
;
A7E2B:  LD      A,(HL)          ; Exponenten des Restes des Real - Wertes holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  fertig
        LD      A,(S7E34)       ; Anzahl aufbereitete Stellen holen
        CP      9               ; mit maximaler Anzahl Stellen vergleichen
        RET
;
;
;   Speicher für Zahlaufbereitungsroutinen
;
S7E34:  DEFS    1               ; Speicher für Anzahl aufbereitete Stellen
;
S7E35:  DEFS    1               ; Flag 'Stellen angegeben/Ziffer aufbereitet'
;
S7E36:  DEFS    1               ; Flag  'Real - Wert'
;
S7E37:  DEFS    2               ; Zeiger auf Real - Zahlwert
;
S7E39:  DEFS    2               ; Zeiger auf Anfang USING - Format
;
S7E3B:  DEFS    2               ; Zeiger auf aktuelle Stelle USING - Format
;
;
;   bereitgestellten Wert entsprechend USING - Format aufbereiten
;   (DE = Zeiger auf Wertdescriptor / BC = Zeiger auf Speicher für aufbereiteten Wert)
;
A7E3D:  LD      HL,(S7E3B)      ; Zeiger auf aktuelle Stelle USING - Format holen
        PUSH    DE              ; Zeiger auf Wertdescriptor retten
A7E41:  LD      A,(HL)          ; nächstes Textzeichen aus USING - Format holen
        OR      A               ; Textendezeichen  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        CALL    USGCD           ; überprüfen, ob Zeichen im Accu USING-Format-Zeichen ist
        JR      Z,A7E50         ; Formatzeichen -->  Format auswerten und Wert aufbereiten
        LD      (BC),A          ; Textzeichen aus USING-Format für Ausgabe merken
        INC     BC              ; Textzeichen überspringen
        INC     HL              ; Zeiger auf USING-Format auf nächstes Zeichen
        JR      A7E41           ; nächstes Zeichen USING-Format auswerten
;
A7E50:  EX      AF,AF           ; USING - Formatzeichen retten
        LD      A,(S9E9C)       ; Wertart - Flag holen
        CP      3               ; Code for 'Zeichenkettenwert'  ?
        JP      NZ,A7F08        ; nein -->  Zahlwert nach USING - Format aufbereiten
        EX      AF,AF           ; gerettetes USING - Formatzeichen wieder holen
        CP      '!'             ; Code for 'ein Zeichen Text'  ?
        JP      Z,CHOUT1        ; ja -->  ein Zeichen Text der Zeichenkette aufbereiten
        CP      '&'             ; Code for 'mehrere Zeichen Text'  ?
        JP      Z,CHOUT2        ; ja -->  Länge auszählen und Text aufbereiten
        JP      A636D           ; Fehler 4   Type mismatch error
;
;
;   ein Zeichen Text nach USING - Format aufbereiten
;
CHOUT1: EX      (SP),HL         ; Zeiger auf USING-Format merken / Wertdescriptor holen
        PUSH    BC              ; Zeiger für aufbereitete Zeichen retten
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
        OR      A               ; Länge auszugebender Text gleich Null ?
        LD      A,' '           ; Leerzeichen  (Space)  vorgeben
        JR      Z,A7E72         ; Länge gleich Null -->  Leerzeichen vorgeben
        LD      A,(DE)          ; erstes Zeichen der Zeichenkette holen
A7E72:  POP     BC              ; Zeiger auf aufbereitete Zeichen holen
        LD      (BC),A          ; neues Zeichen merken
        INC     BC              ; neues Zeichen überspringen
;
;
;   eventuell vorhandene Textkonstante im USING - Format aufbereiten zur Ausgabe
;
A7E75:  POP     HL              ; Zeiger auf USING - Format holen
        INC     HL              ; ausgewertetes Zeichen überspringen
A7E77:  LD      A,(HL)          ; nächstes Zeichen USING - Format holen
        OR      A               ; gleich Textendezeichen  ?
        JR      Z,A7E85         ; ja -->  wieder Anfang USING - Format vorgeben
        CALL    USGCD           ; überprüfen, ob Zeichen im Accu USING-Format-Zeichen ist
        JR      Z,A7E88         ; Formatzeichen -->  Zeiger auf Rest USING-Format merken
        LD      (BC),A          ; Textzeichen zur Ausgabe merken
        INC     BC              ; Textzeichen überspringen
        INC     HL              ; Zeiger auf USING-Format auf nächstes Zeichen
        JR      A7E77           ; nächstes Zeichen USING - Format auswerten
;
A7E85:  LD      HL,(S7E39)      ; Zeiger auf Anfang USING - Format holen
A7E88:  LD      (S7E3B),HL      ; Zeiger auf aktuelle Stelle USING - Format merken
        XOR     A               ; Code for 'Textende'
        LD      (BC),A          ; hinter bereitgestellte Zeichenfolge eintragen
        RET
;
;
;   Formatlänge für Zeichenkette auszählen und Text nach USING - Format aufbereiten
;
CHOUT2: LD      D,2             ; Vorgabe zwei Zeichen
A7E90:  INC     HL              ; Textanfangszeichen in USING - Format überspringen
        LD      A,(HL)          ; nächstes Zeichen im USING - Format holen
        CP      '&'             ; Code for 'Formatende'  ?
        JR      Z,A7E9E         ; ja -->  Text nach Format ausgeben
        INC     D               ; Zähler 'Anzahl Zeichen Text' plus eins
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A7E90         ; ja -->  Formatlänge auszählen
        JP      A636A           ; ja -->  Fehler 3   Illegal data error
;
A7E9E:  EX      (SP),HL         ; Zeiger auf USING-Format merken / Wertdescriptor holen
        LD      A,(HL)          ; Länge der auszugebenden Zeichenkette holen
        CP      D               ; mit auszugebender Zeichenkette vergleichen
        JR      C,A7EB8         ; Zeichenkette ist kürzer als Format
        INC     HL              ; Zeiger auf 'Offset auf Zeichenkette'  stellen
        CALL    INDRCT          ; Offset aus Descriptor (HL) nach HL holen
        PUSH    BC              ; Zeiger für aufbereitete Zeichen retten
        LD      BC,(STRST)      ; Anfang Stringtextbereich holen
        ADD     HL,BC           ; Zeiger auf Stringtext errechnen
        POP     BC              ; Zeiger für aufbereitete Zeichen wieder holen
A7EAE:  LD      A,(HL)          ; ein Zeichen der Zeichenkette holen
        LD      (BC),A          ; und als auszugebendes Zeichen merken
        INC     BC              ; auszugebendes Zeichen überspringen
        INC     HL              ; Zeiger auf String auf nächstes Zeichen
        DEC     D               ; Restanzahl Zeichen minus eins
        JR      NZ,A7EAE        ; ungleich Null -->  weitere Zeichen übertragen
        JP      A7E75           ; Textkonstante im USING-Format für Ausgabe aufbereiten
;
;
;   Zeichenkette, die kürzer als USING - Format ist, aufbereiten zur Ausgabe
;
A7EB8:  LD      E,(HL)          ; Länge der auszugebenden Zeichenkette holen
        INC     HL              ; Zeiger auf 'Offset auf Zeichenkette'  stellen
        CALL    INDRCT          ; Adresse aus Tabelle (HL) nach HL holen
        LD      A,E             ; Länge der Zeichenkette holen
        OR      A               ; Länge gleich Null  ?
        JR      Z,A7ED5         ; ja -->  nur Leerzeichen ausgeben
        PUSH    BC              ; Zeiger für aufbereitete Zeichen retten
        LD      BC,(STRST)      ; Anfang Stringtextbereich holen
        ADD     HL,BC           ; Zeiger auf Stringtext errechnen
        POP     BC              ; Zeiger für aufbereitete Zeichen wieder holen
A7EC8:  LD      A,(HL)          ; ein Zeichen der Zeichenkette holen
        LD      (BC),A          ; und als auszugebendes Zeichen merken
        INC     BC              ; auszugebendes Zeichen überspringen
        INC     HL              ; Zeiger auf String auf nächstes Zeichen
        DEC     E               ; Restanzahl Zeichen in Zeichenkette minus eins
        JR      Z,A7ED9         ; gleich Null -->  Rest mit Leerzeichen auffüllen
        DEC     D               ; Restanzahl Zeichen für Format minus eins
        JR      NZ,A7EC8        ; weitere Zeichen der Zeichenkette bereitstellen
        JP      A7E75           ; Textkonstante im USING-Format für Ausgabe aufbereiten
;
;
;   nicht vorhandene Zeichen mit Leerzeichen auffüllen
;
A7ED5:  LD      A,' '           ; Leerzeichen  (Space)  vorgeben
        LD      (BC),A          ; und als auszugebendes Zeichen merken
        INC     BC              ; bereitgestelltes Zeichen überspringen
A7ED9:  DEC     D               ; Zähler 'Restanzahl Zeichen' minus eins
        JR      NZ,A7ED5        ; weitere Leerzeichen bereitstellen
        JP      A7E75           ; Textkonstante im USING-Format für Ausgabe aufbereiten
;
;
;   überprüfen, ob Zeichen im Accu USING - Format - Zeichen ist
;
USGCD:  CALL    CHKACC          ; Vergleich Accu mit hinter CALL angegebenen Bytes
        DEFB    4               ; vier Zeichen angegeben
        DEFM    "!&#+"          ; USING - Formatzeichen
        RET     Z               ; Zeichen im Accu ist Formatzeichen
        LD      E,A             ; Zeichen merken
        CP      '*'             ; Sternchen als Schecksperrzeichen  ?
        JR      Z,A7F02         ; ja -->  überprüfen, ob zwei Zeichen hintereinander
        CALL    POND            ; Überprüfen, ob Accu gleich Währungszeichen ist
        JR      Z,A7F02         ; ja -->  testen, ob zwei Zeichen hintereinander
        CP      '.'             ; Dezimalpunktkennzeichen  ?
        LD      E,'#'           ; Nummernfeld für nächstes Zeichen vorgeben
        JR      Z,A7F02         ; Dezimalpunkt -->  testen, ob nächstes Zeichen Nummernfeld
        CP      0C4H            ; Code for 'nächstes Zeichen ausgeben'  ?
        RET     NZ              ; nein
        INC     HL              ; Code überspringen
        LD      A,(HL)          ; nächstes Zeichen aus USING - Format holen
        OR      A               ; Textendezeichen  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        RET
;
A7F02:  INC     HL              ; erstes Formatzeichen überspringen
        LD      A,(HL)          ; zweites Formatzeichen holen
        CP      E               ; mit Zeichenvorgabe vergleichen
        DEC     HL              ; Zeiger wieder auf erstes Zeichen stellen
        LD      A,(HL)          ; erstes Zeichen wieder aus Format holen
        RET
;
;
;   bereitgestellten Zahlwert nach USING - Format aufbereiten
;
A7F08:  XOR     A               ; Accu auf Null
        LD      (D804E + 1),A   ; Flag  'Vorzeichen vorne angegeben'  zurücksetzen
        LD      (A809E + 1),A   ; Schecksperre - Flag zurücksetzen
        LD      (A8086 + 1),A   ; Währungszeichen - Flag zurücksetzen
        LD      (A8044 + 1),A   ; Flag  'Vorzeichen minus hinten angegeben'  zurücksetzen
        LD      (D7FFE + 1),A   ; Komma - Flag  zurücksetzen
        LD      (A802B + 1),A   ; Anzahl Vorkommastellen löschen
        LD      (D8049 + 1),A   ; FLag  'Vorzeichen plus hinten angegeben'  zurücksetzen
        LD      (D7FF7 + 1),A   ; Exponent - Flag zurücksetzen
        DEC     A               ; Code for 'keine Nachkommastellen'
        LD      (D7FF4 + 1),A   ; als Anzahl Nachkommastellen merken
        EX      AF,AF           ; Formatzeichen holen
        LD      D,0             ; Vorgabe für Anzahl Vorkommastellen
        CP      '#'             ; Nummernkreuz  ?
        JP      Z,A7F64         ; ja -->  Anzahl Vorkommastellen auszählen
        CP      '*'             ; Schecksperrzeichen  ?
        JP      Z,A7F45         ; ja -->  merken und Format auszählen
        CALL    POND            ; überprüfen, ob Accu gleich Währungszeichen ist
        JP      Z,A7F56         ; ja -->  merken und Format auszählen
        CP      '.'             ; Dezimalpunktzeichen  ?
        JP      Z,A7F66         ; ja -->  Nachkommastellen auszählen
        CP      '+'             ; Code for 'Vorzeichen vorne ausgeben'  ?
        JP      Z,A7F5F         ; ja -->  merken und Format auszählen
        JP      A636D           ; Fehler 4   Type mismatch error
;
A7F45:  LD      A,1             ; Code for 'Schecksperre angegeben'
        LD      (A809E + 1),A   ; im Schecksperre - Flag merken
        INC     HL              ; erstes Schecksperrzeichen überspringen
        INC     D               ; Anzahl Vorkommastellen plus eins
        INC     HL              ; zweites Schecksperrzeichen überspringen
        INC     D               ; Anzahl Vorkommastellen plus eins
        LD      A,(HL)          ; nächstes Formatzeichen holen
        CALL    POND            ; überprüfen, ob Accu gleich Währungszeichen ist
        JR      NZ,A7F66        ; nein -->  Vorkommastellen auszählen
        JR      A7F58           ; Code for 'Währungszeichen angegeben'  merken
;
;
;   Zahlformat mit Währungszeichen begonnen
;
A7F56:  INC     HL              ; Format - Zeichen im USING - String überspringen
        INC     D               ; Anzahl Vorkommastellen plus eins
A7F58:  INC     HL              ; Format-Zeichen im USING-String überspringen
        INC     D               ; Anzahl Vorkommastellen plus eins
        LD      (A8086 + 1),A   ; Währungszeichen im Währungszeichen - Flag merken
        JR      A7F66           ; Restliche Vorkommastellen auszählen
;
A7F5F:  LD      A,1             ; Code for 'Vorzeichen vorne angegeben'
        LD      (D804E + 1),A   ; Flag  'Vorzeichen vorne angegeben' setzen
;
;
;   Anzahl Vorkommastellen im USING - Format auszählen
;
A7F64:  INC     HL              ; Formatzeichen überspringen
        INC     D               ; Anzahl Vorkommastellen plus eins
A7F66:  EX      DE,HL           ; Zeiger auf Format nach DE / Zähler nach HL
        DEC     H               ; Zähler Anzahl Vorkommastellen für Schleife corrigieren
A7F68:  INC     H               ; Zähler Anzahl Vorkommastellen plus eins
        LD      A,(DE)          ; nächstes Zeichen aus USING - Format holen
        INC     DE              ; Formatzeichen überspringen
        CP      '#'             ; Nummernkreuz  ?
        JR      Z,A7F68         ; ja -->  nächstes Zeichen auswerten
        CP      ','             ; Tabulationskomma  ?
        JR      NZ,A7F7A        ; nein -->  weiter untersuchen
        LD      A,1             ; Code for 'mit Komma tabulieren'
        LD      (D7FFE + 1),A   ; Komma - Flag setzen
        JR      A7F68           ; restliche Vorkommastellen auszählen
;
A7F7A:  CP      '.'             ; Dezimalpunkt  ?
        JR      Z,A7FA1         ; ja -->  Nachkommastellen auszählen
        CP      '-'             ; Vorzeichen minus  ?
        JR      NZ,A7F8A        ; nein -->  weiter untersuchen
        LD      A,1             ; Code for 'Vorzeichen minus hinten angegeben'
        LD      (A8044 + 1),A   ; Flag  'Vorzeichen minus hinten angegeben' setzen
        INC     DE              ; Zeiger für Ende Schleife corrigieren
        JR      A7F9A           ; Anzahl Vorkommastellen merken und Zahl aufbereite
;
A7F8A:  CP      '+'             ; Vorzeichen plus  ?
        JR      NZ,A7F9A        ; nein -->  Anzahl Vorkommastelen merken und Zahl aufbereiten
        LD      A,(D804E + 1)   ; Flag  'Vorzeichen vorne angegeben' holen
        OR      A               ; gesetzt  ?
        JR      NZ,A7F9A        ; ja -->  Vorzeichen hinten vergessen
        LD      A,1             ; Code for 'Vorzeichen plus hinten angegeben'
        LD      (D8049 + 1),A   ; FLag  'Vorzeichen plus hinten angegeben' setzen
        INC     DE              ; Zeiger auf USING - Format
A7F9A:  DEC     DE              ; Zeiger auf USING - Format corrigiern
        LD      A,H             ; Anzahl Vorkommastellen holen
        LD      (A802B + 1),A   ; Anzahl Vorkommastellen merken
        JR      A7FD4           ; Format auf angegebenen Exponenten  untersuchen
;
;
;   Anzahl Nachkommastellen im USING - Format auszählen
;
A7FA1:  LD      A,H             ; Anzahl Vorkommastellen holen
        LD      (A802B + 1),A   ; Anzahl Vorkommastellen merken
        LD      H,-1            ; Vorgabe für Zähler 'Anzahl Nachkommastellen'
A7FA7:  INC     H               ; Zähler 'Anzahl Nachkommastellen' plus eins
        LD      A,(DE)          ; ein Format - Zeichen holen
        INC     DE              ; Formatzeichen überspringen
        CP      '#'             ; Nummernkreuz  ?
        JR      Z,A7FA7         ; ja -->  nächstes Zeichen auswerten
        CP      '-'             ; Vorzeichen minus  ?
        JR      NZ,A7FBA        ; nein -->  weiter untersuchen
        LD      A,1             ; Code for 'Vorzeichen minus hinten angegeben'
        LD      (A8044 + 1),A   ; Flag  'Vorzeichen minus hinten angegeben' setzen
        INC     DE              ; Zeiger auf Format für Einsprung corrigieren
        JR      A7FCA           ; Format auf angegebenen Exponenten untersuchen
;
A7FBA:  CP      '+'             ; Vorzeichen plus  ?
        JR      NZ,A7FCA        ; nein -->  Nachkommastellen merken
        LD      A,(D804E + 1)   ; Flag  'Vorzeichen vorne angegeben' holen
        OR      A               ; gesetzt  ?
        JR      NZ,A7FCA        ; ja -->  Vorzeichen hinten vergessen
        LD      A,1             ; Code for 'Vorzeichen plus hinten angegeben'
        LD      (D8049 + 1),A   ; FLag  'Vorzeichen plus hinten angegeben'  setzen
        INC     DE              ; Zeiger auf USING - Format
A7FCA:  DEC     DE              ; Zeiger auf USING - Format corrigieren
        LD      A,H             ; Anzahl Nachkommastellen holen
        LD      (D7FF4 + 1),A   ; Anzahl Nachkommastellen merken
        JR      A7FD4           ; Format auf Exponenten untersuchen
;
A7FD1:  POP     DE              ; Zeiger auf Formatstelle  'Anfang Exponent'  holen
        JR      A7FE6           ; Zahlwert entsprechend USING-Format aufbereiten
;
;
;   auf Exponenten im USING - Format untersuchen
;
A7FD4:  LD      H,4             ; auf vier Zeichen Exponent untersuchen
        PUSH    DE              ; Zeiger auf Anfang Exponenten im Format merken
A7FD7:  LD      A,(DE)          ; ein Zeichen Format holen
        INC     DE              ; Formatzeichen überspringen
        CP      '^'             ; Exponentenzeichen  ?
        JR      NZ,A7FD1        ; nein -->  kein Exponent angegeben
        DEC     H               ; Zähler minus eins
        JR      NZ,A7FD7        ; weitere Stellen untersuchen
        POP     AF              ; Zeiger auf Anfang Exponenten vergessen
        LD      A,1             ; Code for 'Exponent angegeben'
        LD      (D7FF7 + 1),A   ; Exponent - Flag setzen
A7FE6:  POP     HL              ; Zeiger auf Zahlwert holen
        PUSH    DE              ; Zeiger auf Rest USING - Format merken
        INC     HL              ; Zeiger auf MSByte Mantisse stellen
        LD      A,(HL)          ; MSByte Mantisse der Zahl holen
        RES     7,(HL)          ; Vorzeichen der Zahl auf plus
        DEC     HL              ; Zeiger auf Zahl wieder auf Exponenten
        LD      (A807B + 1),A   ; MSByte Mantisse aufzubereitende Zahl merken
        LD      A,(A802B + 1)   ; Anzahl Vorkommastellen holen
        LD      D,A             ; und merken
D7FF4:  LD      A,0             ; Anzahl Nachkommastellen holen   (wird eingetragen)
        LD      E,A             ; und merken
D7FF7:  LD      A,0             ; Exponent - Flag holen   (wird eingetragen)
        PUSH    BC              ; Zeiger auf Speicher für aufbereiteten Zahlwert retten
        CALL    USNGCV          ; Zahlwert nach USING - Format aufbereiten
        POP     BC              ; Zeiger auf Speicher für aufbereiteten Zahlwert holen
D7FFE:  LD      A,0             ; Komma - Flag holen   (wird eingetragen)
        OR      A               ; gesetzt  ?
        JR      Z,A8044         ; nein -->  ohne Komma ausgeben
        PUSH    BC              ; Zeiger auf Speicher für aufbereiteten Zahlwert retten
        PUSH    DE              ; Zeiger auf aufbereiteten Zahlwert retten
        LD      A,(A802B + 1)   ; Anzahl Vorkommastellen holen
        LD      L,A             ; und merken
        LD      H,0             ; High - Byte Offset auf Null
        ADD     HL,DE           ; Zeiger auf Dezimalpunkt errechnen
        LD      DE,S9E6A        ; Zeiger auf Zwischenspeicher  (bei USING-Routine)
        LD      C,0             ; Zähler 'Anzahl Stellen' auf null
        DEC     HL              ; Zeiger auf ASCII - Zahlwert
A8012:  LD      B,3             ; nach je drei Stellen ein Komma setzen
A8014:  LD      A,(HL)          ; ein Zeichen des ASCII - Zahlwertes holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A802B         ; ja -->  Zahlanfang gefunden
        INC     C               ; Zähler 'Anzahl Zeichen' plus eins
        LD      (DE),A          ; Zahlzeichen merken
        INC     DE              ; Zeiger auf Zwischenspeicher für Zahltext
        DEC     HL              ; Zeiger auf ASCII - Zahltext
        DJNZ    A8014           ; weitere Zeichen übertragen
        LD      A,(HL)          ; nächstes Zeichen ASCII - Zahlwert holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A802B         ; ja -->  kein Komma vor Zahlwert schreiben
        LD      A,','           ; Komma als Trennzeichen
        LD      (DE),A          ; in Text eintragen
        INC     DE              ; Komma überspringen
        INC     C               ; Zähler 'Anzahl Zeichen' plus eins
        JR      A8012           ; Rest der Vorkommazahl aufbereiten
;
A802B:  LD      A,0             ; Anzahl Vorkommastellen holen   (wird eingetragen)
        CP      C               ; mit jetziger Anzahl Vorkommastellen vergleichen
        JP      C,A6367         ; mit Komma zu viele Stellen -->  Fehler 2  Overflow error
        LD      B,C             ; Textlänge mit Komma
        LD      L,A             ; Anzahl Vorkommastellen
        LD      H,0             ; High - Byte Anzahl auf Null
        POP     DE              ; Zeiger auf Anfang ASCII - Zahl holen
        PUSH    DE              ; und wieder merken
        ADD     HL,DE           ; Zeiger auf Dezimalpunktstelle errechnen
        LD      DE,S9E6A        ; Zeiger auf Zwischenspeicher   (bei USING-Routine)
        DEC     HL              ; Zeiger auf Stelle für Zahl
A803C:  LD      A,(DE)          ; ein Zeichen Zahltext mit Komma
        LD      (HL),A          ; wieder vor Nachkommastellen setzen
        DEC     HL              ; Zeiger auf Stelle für Vorkommastellen
        INC     DE              ; Zeiger auf aufbereitete Vorkommastellen
        DJNZ    A803C           ; weitere Zeichen übertragen
        POP     DE              ; Zeiger auf Anfang aufbereitete ASCII - Zahl
        POP     BC              ; Zeiger auf Stelle für ASCII - Zahl
A8044:  LD      A,0             ; Flag  'Vorzeichen minus hinten angegeben' holen
        OR      A               ; gesetzt  ?
        JR      NZ,A8086        ; ja -->  Vorzeichen hinter Zahl eintragen
D8049:  LD      A,0             ; FLag  'Vorzeichen plus hinten angegeben' holen
        OR      A               ; gesetzt  ?
        JR      NZ,A8086        ; ja -->  Vorzeichen hinter Zahl eintragen
D804E:  LD      A,0             ; Flag  'Vorzeichen vorne angegeben'  holen
        OR      A               ; gesetzt  ?
        JR      NZ,A807B        ; ja -->  auf jeden Fall Vorzeichen vor Zahl schreiben
        LD      A,(A807B + 1)   ; MSByte Mantisse aufzubereitende Zahl holen
        RLCA                    ; Vorzeichenbit nach Carry schieben
        JR      NC,A8086        ; Zahl ist positiv -->  kein Vorzeichen vor Zahl schreiben
        LD      A,(DE)          ; erstes Zeichen der aufbereiteten Zahl holen
        CP      ' '             ; Leerzeichen  (Space) ?
        LD      H,'-'           ; Vorzeichen minus vorgeben
        JR      Z,A8065         ; Leerzeichen -->  Stelle für Vorzeichen suchen
        CP      '0'             ; führende Null  ?
        JP      NZ,A6367        ; nein -->  Fehler 2  Overflow error
A8065:  PUSH    DE              ; Zeiger auf Anfang ASCII - Zahlwert merken
A8066:  LD      A,(DE)          ; ein Zeichen ASCII - Zahl holen
        INC     DE              ; Zeiger auf Zahltext auf nächstes Zeichen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A8066         ; ja -->  relevantes Zeichen suchen
        CP      '0'             ; führende Null  ?
        JR      Z,A8066         ; ja -->  relevantes Zeichen suchen
        OR      A               ; Textendezeichen  ?
        JR      NZ,A8074        ; nein
        DEC     DE              ; Textendezeichen retten
A8074:  DEC     DE              ; letzte Stelle der Zahl retten
        DEC     DE              ; Zeiger auf Stelle für Vorzeichen
        LD      A,H             ; Vorzeichen holen
        LD      (DE),A          ; und vor Zahlwert eintragen
        POP     DE              ; Zeiger auf Anfang ASCII - Zahlwert holen
        JR      A8086           ; auf Währungszeichen untersuchen
;
A807B:  LD      A,0             ; MSByte Mantisse aufzubereitende Zahl holen
        RLCA                    ; Vorzeichen nach Carry schieben
        LD      H,'+'           ; Vorzeichen 'Plus' vorgeben
        JR      NC,A8065        ; Zahlwert ist positiv
        LD      H,'-'           ; Vorzeichen 'Minus' vorgeben
        JR      A8065           ; Vorzeichen vor Zahlwert eintragen
;
A8086:  LD      A,0             ; Währungszeichen - Flag holen   (wird eingetragen)
        OR      A               ; gesetzt  ?
        JR      Z,A809E         ; nein -->  auf Schecksperre untersuchen
        LD      A,(DE)          ; erstes Zeichen ASCII - Zahl holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      NZ,A809E        ; nein -->  Währungszeichen vergessen
        PUSH    DE              ; Zeiger auf Anfang Zahlwert merken
A8091:  LD      A,(DE)          ; ein Zeichen ASCII - Zahl holen
        INC     DE              ; Zeichen überspringen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A8091         ; ja -->  Anfang Zahlwert suchen
        DEC     DE              ;! Zeiger auf Freistelle für Währungszeichen stellen
        DEC     DE              ;!
        LD      A,(A8086 + 1)   ; Währungszeichen - Flag holen
        LD      (DE),A          ; Währungszeichen vor Zahlwert eintragen
        POP     DE              ; Zeiger auf Anfang Zahlwert holen
A809E:  LD      A,0             ; Schecksperre - Flag holen   (wird eingetragen)
        OR      A               ; gesetzt  ?
        JR      Z,A80B0         ; nein -->  auf Vorzeichen hinter Zahlwert untersuchen
        PUSH    DE              ; Zeiger auf Anfang Zahlwert retten
A80A4:  LD      A,(DE)          ; ein Zeichen ASCII - Zahlwert holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      NZ,A80AF        ; nein -->  Schecksperre vergessen
        LD      A,'*'           ; Schecksperrzeichen
        LD      (DE),A          ; eintragen
        INC     DE              ; Zeiger auf ASCII - Zahl auf nächstes Zeichen
        JR      A80A4           ; nächste Stelle untersuchen
;
A80AF:  POP     DE              ; Zeiger auf Anfang ASCII - Zahlwert holen
A80B0:  LD      A,(DE)          ; ein ASCII - Zahlzeichen holen
        OR      A               ; Textendezeichen  ?
        JR      Z,A80B9         ; ja -->  auf Vorzeichen hinten untersuchen
        LD      (BC),A          ; ein Zahlzeichen zur Ausgabe merken
        INC     BC              ; Zeiger auf Speicher für aufbereiteten Text
        INC     DE              ; Zeiger auf ASCII - Zahlwert
        JR      A80B0           ; weitere Zahlzeichen übertragen
;
;
;   auf 'Vorzeichen hinten angegeben' untersuchen und eventuell Vorzeichen eintragen
;
A80B9:  LD      A,(D8049 + 1)   ; FLag  'Vorzeichen plus hinten angegeben'  holen
        OR      A               ; gesetzt  ?
        JR      Z,A80CD         ; nein -->  auf 'Vorzeichen minus hinten angegeben' untersuchen
        LD      A,(A807B + 1)   ; MSByte Mantisse aufzubereitende Zahl holen
        RLCA                    ; Vorzeichenbit nach Carry schieben
        LD      A,'+'           ; Vorzeichen 'Plus' vorgeben
A80C5:  JR      NC,A80C9        ; Zahlwert ist positiv
        LD      A,'-'           ; Vorzeichen 'Minus' vorgeben
A80C9:  LD      (BC),A          ; Vorzeichen hinter Zahlwert eintragen
        INC     BC              ; Vorzeichen überspringen
        JR      A80DB           ; Textkonstante im USING-Format für Ausgabe aufbereiten
;
A80CD:  LD      A,(A8044 + 1)   ; Flag  'Vorzeichen minus hinten angegeben' holen
        OR      A               ; gesetzt  ?
        JR      Z,A80DB         ; nein -->  Textkonstante im USING-Format für Ausgabe aufb.
        LD      A,(A807B + 1)   ; MSByte Mantisse aufzubereitende Zahl holen
        RLCA                    ; Vorzeichenbit nach Carry schieben
        LD      A,' '           ; Vorgabe 'Leerzeichen' für positives Vorzeichen
        JR      A80C5           ; bei negativem Zahlwert minus eintragen
;
A80DB:  POP     HL              ; Zeiger auf Rest USING - Format holen
        JP      A7E77           ; Textkonstante im USING - Format für Ausgabe aufbereiten
;
;
;   testen, ob Zeichen im Accu gleich Währungszeichen ist
;
POND:   CP      0FBH            ; Pfund - Zeichen  ?
        RET     Z               ; ja
        CP      '$'             ; Dollar - Zeichen  ?
        RET
;
;
;   Zahlwert (HL) nach USING - Format aufbereiten
;   (D = Vorkommastellen / E = Nachkommastellen / A = Exponentenflag)
;
USNGCV: OR      A               ; mit Exponent aufbereiten  ?
        JP      Z,USGCV2        ; nein
        PUSH    DE              ; Vorkommastellen / Nachkommastellen retten
        LD      A,(HL)          ; Exponenten der Zahl holen
        OR      A               ; Zahlwert gleich Null  ?
        JR      Z,USCMOK        ; Zahl gleich Null -->  Text vorgeben
        PUSH    HL              ; Zeiger auf Zahlwert im Real - Format retten
        LD      A,D             ; Anzahl Vorkommastellen holen
        LD      DE,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        PUSH    AF              ; Anzahl Vorkommastellen merken
        CALL    A79C2           ; +1 im Real - Format nach (DE) übertragen
        POP     AF              ; Anzahl Vorkommastellen holen
        OR      A               ; gleich Null  ?
        JR      Z,BMULED        ; ja -->  Faktor stimmt
        LD      B,A             ; Anzahl Vorkommastellen für Schleife merken
        LD      HL,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        JR      A8104           ; Faktor errechnen
;
A8101:  CALL    A7BDD           ; Zahlwert (HL) mal 10
A8104:  DJNZ    A8101           ; richtigen Faktor errechnen

BMULED: POP     HL              ; Zeiger auf aufzubereitenden Zahlwert holen
        LD      B,0             ; Vorgabe für Exponentenzähler
USTNCM: LD      DE,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        CALL    A7B7C           ; Real-Zahlen (HL) und (DE) vergleichen (BC-Register retten)
        JR      C,USTOCM        ; Real - Zahlwert ist kleiner als Normierungsfaktor
        CALL    A7B31           ; Real - Zahlwert (HL) durch zehn
        INC     B               ; Exponentenzähler plus eins
        JR      USTNCM          ; weiter untersuchen
;
USTOCM: PUSH    HL              ; Zeiger normierter Wert merken
        LD      HL,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        CALL    A7B31           ; Real - Zahlwert (HL) durch zehn
        POP     HL              ; Zeiger auf normierten Wert holen
USONCM: LD      DE,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        CALL    A7B7C           ; Real-Zahlen (HL) und (DE) vergleichen (BC-Register retten)
        JR      NC,USCMOK       ; Real - Zahl ist größer als Normierungsfaktor
        CALL    A7BDD           ; altes Teilergebnis mal 10
        DEC     B               ; Exponentenzähler minus eins
        JR      USONCM          ; weiter untersuchen
;
USCMOK: POP     DE              ; Vorkommastellen / Nachkommastellen holen
        PUSH    BC              ; Exponentenzähler retten
        CALL    USGCV1          ; Zahlwert aufbereiten in ASCII
        POP     BC              ; Exponentenzähler holen
        PUSH    DE              ; Zeiger auf ASCII - Zahlwert retten
        LD      A,(DE)          ; erstes Zeichen ASCII - Zahlwert holen
        CP      '.'             ; Dezimalpunkt  ?
        JR      NZ,FLADSR       ; nein
        LD      DE,S9E7A        ; Zeiger auf Stelle für Dezimalpunkt
        DEC     DE              ; Zeiger auf Vorkommastelle
        LD      A,(DE)          ; erste Vorkommastelle holen
        CP      '1'             ; eins  ?
        POP     DE              ; Zeiger auf ASCII - Wert holen
        PUSH    DE              ; und wieder merken
        JR      NZ,A8167        ; Vorkommastellen vorhanden
        EX      DE,HL           ; Zeiger auf ASCII - Wert nach HL
        INC     HL
        LD      (HL),'1'
        DEC     HL
        JR      A8165
;
FLADSR: LD      A,(DE)          ; ASCII - Stelle holen
        CP      '1'             ; eins  ?
        JR      NZ,A8167        ; nein -->  Stelle für Exponenten suchen
        EX      DE,HL           ; Zeiger auf ASCII - Zahl nach HL
        INC     HL              ; Stelle überspringen
        LD      A,(HL)          ; nächste Stelle holen
        DEC     HL              ; Zeiger wieder auf vorige Stelle
        CP      '.'             ; Dezimalpunkt  ?
        LD      A,'0'           ; Null
        JR      Z,A815C         ; Dezimalpunkt -->  0.1
        LD      A,' '           ; Leerzeichen  (Space)
A815C:  LD      (HL),A          ; Zeichen eintragen
A815D:  INC     HL              ; Zeiger auf nächste ASCII - Stelle
        LD      A,(HL)          ; ASCII - Stelle holen
        CP      '.'             ; Dezimalpunkt  ?
        JR      Z,A815D         ; ja -->  Dezimalpunkt überspringen
        LD      (HL),'1'        ; 'Eins' eintragen
A8165:  EX      DE,HL           ; Zeiger auf ASCII - Zahlwert nach DE
        INC     B               ; Exponentenzähler plus eins
A8167:  LD      A,(DE)          ; eine ASCII - Stelle holen
        INC     DE              ; Stelle überspringen
        OR      A               ; Textendezeichen  ?
        JR      NZ,A8167        ; nein -->  Textende suchen
        DEC     DE              ; Zeiger wieder auf Textendezeichen
        JP      A7C8F           ; Exponenten aufbereiten in ASCII
;
;
;   Zahl im Real - Format ohne Exponenten aufbereiten
;
USGCV2: PUSH    DE              ; Vorkommastellen / Nachkommastellen retten
        CALL    USGCV1          ; Zahlwert aufbereiten in ASCII
        POP     AF              ; Vorkommastellen holen
        OR      A               ; Zahlwert mit Vorkommastellen  ?
        RET     NZ              ; ja -->  fertig
        PUSH    HL              ; Zeiger auf Anfang aufbereitete Zahl retten
        LD      HL,S9E7A        ; Zeiger auf Stelle für Dezimalpunkt
        DEC     HL              ; Zeiger auf erste Vorkommastelle
        LD      A,'0'           ; Null
        CP      (HL)            ; mit erster Vorkommastelle vergleichen
A817F:  JP      NZ,A6367        ; nicht Null -->  Fehler 2  Overflow error
        DEC     HL              ; Zeiger auf Stelle für Vorzeichen
        LD      A,' '           ; Leerzeichen  (Space)  vorgeben
        CP      (HL)            ; mit Stelle für Vorzeichen vergleichen
        JR      NZ,A817F        ; nicht gleich -->  Fehler 2  Overflow error
        POP     HL              ; Zeiger auf Anfang aufbereiteten Zahlwert
        RET
;
;
;   Zahlwert aufbereiten in ASCII
;
USGCV1: PUSH    DE              ; Vorkommastellen / Nachkommastellen retten
        CALL    A7CE0           ; Zahl aufbereiten in ASCII, wenn ohne Exponent möglich
        JP      C,A6367         ; nicht ohne Exponent möglich -->  Fehler 2  Overflow error
        POP     HL              ; Vorkommastellen / Nachkommastellen holen
        PUSH    HL              ; und wieder merken
        LD      H,0             ; High - Byte Offset auf Null
        INC     L               ; Nachkommastellen angegeben  ?
        JR      Z,A8199         ; nein
        DEC     L               ; Zähler wieder corrigieren
A8199:  LD      DE,S9E7B        ; Zeiger auf Speicher für Nachkommastellen
        ADD     HL,DE           ; Zeiger auf Rundungsstelle errechnen
        LD      A,(HL)          ; Stelle holen
        LD      (HL),NUL        ; Textendezeichen eintragen
        DEFB    LD_DE           ; nächsten Befehl überspringen
A81A1:  LD      (HL),'0'        ; Rundungsstelle löschen
        CP      '5'             ; aufrunden  ?
        JR      C,A81B6         ; nein
A81A7:  DEC     HL              ; Zeiger auf Stelle davor
        LD      A,(HL)          ; Zeichen an Stelle holen
        CP      '.'             ; Dezimalpunkt  ?
        JR      Z,A81A7         ; ja -->  nächste Ziffer suchen
        INC     A               ; Stelle plus eins
        JP      Z,A6367         ; Zahlanfang -->  Fehler 2  Overflow error
        LD      (HL),A          ; gerundete Stelle eintragen
        CP      '9' + 1         ; Überlauf in Ziffernstelle  ?
        JR      Z,A81A1         ; ja -->  weiter aufrunden
A81B6:  LD      HL,S11A3        ; Zeiger auf Speicher für Aufbereitung nach Format
        LD      DE,256*' ' + 0  ; ' ' =Leerzeichen  / 0 = 256 Zeichen
A81BC:  LD      (HL),D          ; ein Zeichen des Speichers löschen
        INC     HL              ; Zeiger auf Speicher auf nächste Stelle
        DEC     E               ; Zähler minus eins
        JR      NZ,A81BC        ; weitere Stellen löschen
        POP     HL              ; H = Vorkommastellen / L = Nachkommastellen
        PUSH    HL              ; Stellen wieder merken
        LD      E,H             ; Anzahl Vorkommastellen
        LD      D,0             ; High - Byte Offset auf Null
        LD      HL,S11A4        ; Zeiger auf Anfang Speicher
        ADD     HL,DE           ; Zeiger auf Stelle für Dezimalpunkt errechnen
        PUSH    HL              ; Dezimalpunktstelle retten
        LD      HL,S9E71        ; Zeiger auf Speicher zur Zahlaufbereitung in ASCII
        LD      (HL),' '        ; Leerzeichen  (Space) als Vorzeichen eintragen
        INC     HL              ; Zeiger auf ASCII - Zahlwert
        LD      D,7             ; maximal 7 Vorkommastellen
A81D3:  LD      A,(HL)          ; eine Vorkommastelle holen
        CP      '0'             ; Null  ?
        JR      NZ,A81DE        ; nein -->  relevante Ziffer
        LD      (HL),' '        ; Vornull gegen Leerzeichen  (Space) austauschen
        INC     HL              ; Zeiger auf ASCII - Zahlwert auf nächste Stelle
        DEC     D               ; Restanzahl zu überprüfender Stellen minus eins
        JR      NZ,A81D3        ; nächste Stelle überprüfen
A81DE:  POP     HL              ; Zeiger auf Stelle für Dazimalpunkt holen
        PUSH    HL              ; und wieder merken
        LD      B,E             ; Anzahl Vorkommastellen duplizieren
        LD      A,B             ; Anzahl Vorkommastellen holen
        OR      A               ; gleich Null  ?
        JR      Z,A81FC         ; ja -->  keine Vorkommastellen
        LD      DE,S9E7A        ; Zeiger auf Stelle für Dezimalpunkt
A81E8:  DEC     HL              ; Zeiger für Vorkommastelle
        DEC     DE              ; Zeiger auf Vorkommastelle
        LD      A,(DE)          ; eine aufbereitete Vorkommastelle holen
        LD      (HL),A          ; und im Speicher merken
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A81FC         ; ja -->  fertig
        DJNZ    A81E8           ; weitere Vorkommastellen übertragen
        DEC     DE              ; Zeiger auf ASCII - Zahlwert
        LD      A,(DE)          ; eine Stelle holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A81FC         ; ja -->  Format ist OK
        INC     A               ; Zahlanfangzeichen  ?
        JP      NZ,A6367        ; nein -->  Fehler 2  Overflow error
A81FC:  POP     HL              ; Zeiger auf Dezimalpunkt holen
        POP     DE              ; Vorkommastellen / Nachkommastellen holen
        INC     E               ; Anzahl Nachkommastellen
        JR      Z,EDSTRT        ; keine Nachkommastellen aufbereiten
        LD      B,E             ; Anzahl aufzubereitende Nachkommastellen
        LD      DE,S9E7B        ; Zeiger auf Speicher für Nachkommastellen
        LD      (HL),'.'        ; Dezimalpunkt eintragen
A8207:  INC     HL              ; Dezimalpunkt überspringen
        DEC     B               ; Restanzahl Nachkommastellen minus eins
        JR      Z,EDSTRT        ; fertig -->  Textendezeichen eintragen
        LD      A,(DE)          ;! eine Nachkommastelle übertragen
        INC     DE              ;!
        LD      (HL),A          ;!
        JR      A8207           ; untersuchen, ob weitere Nachkommastellen
;
EDSTRT: LD      (HL),NUL        ; Textendezeichen hinter Zahlwert eintragen
        LD      DE,S11A4        ; Zeiger auf Anfang aufbereiteten ASCII-Zahlwert
        RET
;
;
;   ASCII - Text - Zeile (DE) umsetzen in Zwischencodezeile nach (HL)
;
CVIMTX: PUSH    DE              ;! Register - Werte retten
        PUSH    BC              ;!
        LD      C,0             ; Vorgabe für Längenzähler der Zwischencodezeile
        DEC     DE              ; Zeiger auf ASCII-Text für Schleife corrigieren
A821B:  INC     DE              ; Zeiger auf ASCII-Text auf nächstes Zeichen
A821C:  CALL    A839C           ; Leerzeichen (DE) nach (HL) übertragen
        OR      A               ; Zeilenendezeichen  ?
        JR      Z,A8253         ; ja -->  merken und gerettete Register holen
        CP      0FFH            ; PI  ?
        JR      Z,A8257         ; ja -->  Zwischencode für PI vorgeben
        CP      080H            ; schon Zwischencodezeichen  ?
        JP      NC,A6364        ; ja -->  Fehler 1  Syntax error
        CP      ' '             ; Steuerzeichen  ?
        JR      C,A821B         ; ja -->  vergessen und nächstes Zeichen untersuchen
        LD      IX,A821C        ; Rücksprungadresse für Umsetzung des nächsten Zeichens
        PUSH    IX              ; auf Stack ablegen
        CP      '\"'            ; Textanfangzeichen  ?
        JR      Z,IMSTR         ; ja -->  Text bis Ende der Textkonstanten übertragen
        CP      '\''            ; Kommentarkennzeichen  ?
        JR      Z,IMREM         ; ja -->  Text bis Ende Kommentar übertragen
        CP      '?'             ; Fragezeichen als Abkürzung für PRINT  ?
        JR      Z,IMPRT         ; ja -->  Zwischencode für PRINT eintragen
        CP      '.'             ; Dezimalpunkt  ?
        JP      Z,IMFLT         ; ja -->  Zahlwert umsetzen in internes Format
        CP      '$'             ; Kennung Hex - Wert  ?
        JP      Z,IMHEX         ; ja -->  Zahlwert umsetzen
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        JR      C,A829A         ; nein -->  untersuchen, ob BASIC - Befehl
        JP      IMNUM           ; auf Zahlwert untersuchen; wenn ja -->  Zahl umsetzen
;
A8253:  LD      (HL),A          ; Textendezeichen eintragen
        POP     BC              ;! gerettete Register - Werte holen
        POP     DE              ;!
        RET
;
;
;   Zwischencode für Pi im Zwischencodetext merken
;
A8257:  LD      (HL),____PI     ; Zwischencode (Token) für Pi eintragen
        CALL    A827E           ; Zeiger für Zwischencode und Längenzähler corrigieren
        JR      A821C           ; Resttext untersuchen und umsetzen
;
;
;   Zwischencode für PRINT statt Fragezeichen merken
;
IMPRT:  LD      A,_PRINT        ; Zwischencode (Token)  PRINT
        CALL    A827D           ; Zwischencode merken und Zeiger corrigieren
        JR      A82D5           ; auf Befehle mit Sonderbehandlung untersuchen
;
;
;   Kommentartext bis Ende Kommentar übertragen
;
IMREM:  LD      (HL),':'        ; Doppelpunkt im Zwischencodetext eintragen
        CALL    A827E           ; Zeiger für Zwischencode und Längenzähler corrigieren
        LD      (HL),'\''       ; Code for 'Kommentar'  in Zwischencodetext eintragen
        CALL    A827F           ; Zwischencodezeiger und Längenzähler corrigieren
        JP      A833C           ; Text (DE) bis Befehlsende in Zwischencodetext übernehmen
;
;
;   Text bis Ende der Textkonstanten übertragen
;
IMSTR:  LD      (HL),A          ; ein Textzeichen merken
        CALL    A827E           ; Zeiger für Zwischencode und Längenzähler corrigieren
A8276:  LD      A,(DE)          ; ein Textzeichen holen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja -->  fertig
        CP      '\"'            ; Textendezeichen  ?
        JR      NZ,IMSTR        ; nein -->  Zeichen merken
A827D:  LD      (HL),A          ; Zeichen für Zwischencodetext merken
A827E:  INC     DE              ; Zeiger auf ASCII-Text auf nächstes Zeichen
A827F:  INC     HL              ; Zeiger für Zwischencodetext auf nächstes Zeichen
A8280:  INC     C               ; Zähler 'Anzahl umgesetzte Zeichen' plus eins
        RET     NZ              ; noch OK
        JP      A6379           ; Fehler 8   Line lenght error
;
A8285:  POP     BC              ; geretteten Zähler 'Anzahl umgesetzte Zeichen' holen
        LD      A,(DE)          ; nächstes ASCII-Text-Zeichen holen
        CALL    A79FD           ; Zeichen im Accu gleich Variablennamenzeichen  ?
        JR      C,A827D         ; nein -->  Zwischencode merken und Zeiger corrigieren
A828C:  CALL    A827D           ; Zwischencode merken und Zeiger corrigieren
        LD      A,(DE)          ; nächstes ASCII - Text - Zeichen holen
        CP      '$'             ; Kennung Zeichenkettenvariable  ?
        JR      Z,A827D         ; ja -->  Zwischencode merken und Zeiger corrigieren
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        RET     C               ; nein
        JR      A828C           ; Ziffer merken und weiter untersuchen
;
;
;   Examine text (DE) for BASIC command word
;   if so --> convert to correct token code
;
A829A:  PUSH    BC              ; Save line length
        LD      BC,M5973        ; Pointers to BASIC command words specify table one
        CALL    A834B           ; Find text (DE) in BASIC command word table (BC).
        JR      NC,A82D1        ; Command found --> remember token code
        LD      BC,M5B16        ; Pointers to BASIC command words provide table two
        CALL    A834B           ; Find text (DE) in BASIC command word table (BC).
        LD      C,0FEH          ; Prebyte for table two
        JR      NC,A82B7        ; Command found --> note prebyte and token code
        LD      BC,M5BAD        ; Pointers to BASIC Command Words Table Three
        CALL    A834B           ; Find text (DE) in BASIC command word table (BC).
        LD      C,0FFH          ; Prebyte for table three
        JR      C,A8285         ; Command not found --> remember text characters
A82B7:  LD      (HL),C          ; Remember prebyte of table in tokenized text
        INC     HL              ; Skip prebyte
        LD      (HL),A          ; Note the token code of the command
        POP     BC              ; Get saved counter 'Number of converted characters'
        CALL    A8280           ; Correct pointer for token code and counter
        CALL    A827F           ; Correct token code pointer and length counter
        CP      ___ERL          ; Function ERL (token code) ?
        RET     NZ              ; no
        CALL    A839C           ; Transfer spaces (DE) to (HL).
        CP      '='             ; Equal  ?
        RET     NZ              ; no
        LD      (HL),____EQ     ; Enter token code for =
        CALL    A827E           ; Correct pointer for token code and length counter
        JR      A8311           ; examine for label name or line number
;
A82D1:  POP     BC              ; Repeat saved counter 'Number of converted characters'
        CALL    A827F           ; Correct token code pointer and length counter
A82D5:  CP      ___REM          ; Basic command REM ?
        JR      Z,A833C         ; Yes --> Text (DE) to end of command in tokenized text.
        CP      __DATA          ; Basic command DATA ?
        JR      Z,A833C         ; Yes --> Text (DE) to end of command in tokenized text.
        CP      __ELSE          ; Basic command ELSE ?
        JR      Z,A8332         ; yes --> enter a colon in front of ELSE
        CP      __THEN          ; Basic command THEN ?
        JR      Z,A8311         ; examine for label name or line number
        CP      0E0H
        RET     NC              ; only arithmetic functions
        PUSH    AF              ; Note the token code of the command
        CALL    A839C           ; Transfer spaces (DE) to (HL).
        CP      '/'             ; dash (slash) ?
        JR      NZ,A82FD        ; no --> check for number cross
        LD      (HL),___DIV     ; Remember token code for /
        CALL    A827E           ; Correct pointer for token code and length counter
        CALL    A79BC           ; Pointer in DE to next relevant character
        CALL    A827D           ; Memorize token code and correct pointer
        JR      A830D           ; check for command with jump address
;
A82FD:  CP      '#'             ; number cross ?
        JR      NZ,A830D        ; no --> check for command with jump address
        CALL    A827D           ; Memorize token code and correct pointer
        CALL    A79BC           ; Pointer in DE to next relevant character
        CALL    A79F6           ; character in accu same digit ?
        CALL    NC,IMNUM        ; yes --> convert numerical value
A830D:  POP     AF              ; Get token code of command
        CP      08DH            ; Command with line number or label ?
        RET     NC              ; no
;
;
;   examine for label name or line number
;
A8311:  CALL    A839C           ; Transfer spaces (DE) to (HL).
        CP      '\"'            ; identifier label name ?
        JR      NZ,A831D        ; no --> investigate further
        CALL    IMSTR           ; Transfer text to the end of the text constant
        JR      A8311           ; examine whether additional jump addresses
;
A831D:  CP      ','
        RET     C               ; kein Trennungszeichen zwischen Sprungadressen
        CP      '/'
        JR      C,A832D         ; Trennungszeichen merken und weiter untersuchen
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        RET     C               ; nein -->  kein Sprungziel
        CALL    A83D0           ; ASCII - Zeilennummer umsetzen und mit Kennung merken
        JR      A8311           ; auf Labelnamen oder Zeilennummer untersuchen
;
A832D:  CALL    A827D           ; Zwischencode merken und Zeiger corrigieren
        JR      A8311           ; auf Labelnamen oder Zeilennummer untersuchen
;
;
;   Doppelpunkt vor ELSE eintragen
;
A8332:  DEC     HL              ; Zeiger auf Stelle mit Zwischencode ELSE
        LD      (HL),':'        ; hier Doppelpunkt eintragen
        INC     HL              ; Doppelpunkt überspringen
        LD      (HL),A          ; und wieder Zwischencode  ELSE  eintragen
        CALL    A827F           ; Zwischencodezeiger und Längenzähler corrigieren
        JR      A8311           ; auf Labelnamen oder Zeilennummer untersuchen
;
;
;   Text (DE) to end of command in tokenized text
;
A833C:  LD      A,(DE)          ; ein Zeichen ASCII - Text holen
        CALL    A5966           ; testen, ob Accu gleich Befehlsendezeichen
        RET     Z               ; Befehlsende -->  Text übertragen
        CALL    A827D           ; Zwischencode merken und Zeiger corrigieren
        CP      '\"'            ; Textanfangszeichen  ?
        CALL    Z,A8276         ; ja -->  Text bis Textende übertragen
        JR      A833C           ; Text bis Befehlsende übertragen
;
;
;   Find text (DE) in BASIC - command word table (BC).
;
A834B:  PUSH    HL              ; Save pointer to memory for tokenized text
        PUSH    DE              ; Pointer to start ASCII - save text
        LD      H,B             ;! Pointer to command word table after HL
        LD      L,C             ;!
        LD      B,07FH          ; Default for token code
A8351:  POP     DE              ; Pointer to beginning of ASCII - get text
        PUSH    DE              ; and remember again
        INC     B               ; token code counter plus one
        LD      A,(HL)          ; Get a character from the table
        CP      -1              ; end-of-table character ?
        JR      NZ,A835D        ; no --> compare text
        POP     DE              ; Pointer to beginning of ASCII - get text
        POP     HL              ; Get pointer to memory for tokenized text
        SCF                     ; Set command word not found code
        RET
;
A835D:  CP      '.'             ; Punkt  ?
        JR      NZ,A836A        ; nein
        INC     HL              ; Punkt in Tabelle überspringen
        DEC     DE              ; Zeiger auf ASCII - Text auf letztes Zeichen
        LD      A,(DE)          ; letztes ASCII - Zeichen holen
        INC     DE              ; Zeiger wieder auf aktuelles Zeichen stellen
        CALL    A79FD           ; Zeichen im Accu gleich Variablennamenzeichen  ?
        JR      NC,A8389        ; ja -->  nächstes Befehlswort in Tabelle suchen
A836A:  LD      A,(DE)          ; ein Zeichen ASCII - Text holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      NZ,A837B        ; nein -->  Zeichen vergleichen
        LD      A,(HL)          ; ein Zeichen aus Tabelle holen
        AND     01111111B       ; ASCII - Zeichen maskieren
        SUB     'A'             ;! Buchstabe  ?
        CP      26              ;!
        JR      C,A8389         ; ja -->  nächstes Befehlswort in Tabelle suchen
        CALL    A79BB           ; Leerzeichen im Text (DE) überspringen
A837B:  LD      C,(HL)          ; ein Zeichen aus Befehlsworttabelle holen
        INC     HL              ; Zeiger auf Tabelle auf nächstes Zeichen
        INC     DE              ; Zeiger auf ASCII-Text auf nächstes Zeichen
        CP      '.'             ; Punkt   (für Abkürzung)
        JR      Z,A8391         ; ja -->  untersuchen, ob Abkürzung erlaubt
        SUB     C               ; ASCII-Zeichen mit Tabellenzeichen vergleichen
        JR      Z,A836A         ; gleich -->  nächstes Zeichen vergleichen
        CP      080H            ; Tabellenendezeichen verglichen  ?
        JR      Z,A8397         ; ja -->  Befehlswort gefunden
A8389:  DEC     HL              ; Zeiger auf Tabelle auf letztes verglichenes Zeichen
A838A:  BIT     7,(HL)          ; Wortendezeichen  ?
        INC     HL              ; Zeiger auf Tabelle auf nächstes Zeichen
        JR      Z,A838A         ; nein -->  Ende Befehlswort suchen
        JR      A8351           ; ASCII - text mit nächstes Wort in Tabelle vergleichen
;
A8391:  LD      A,B             ; Zwischencodezähler holen
        CP      0E8H
        JR      NC,A8389        ; logischer Befehl -->  Abkürzung nicht erlaubt
        CCF                     ; Flag auf 'Wort gefunden' setzen
A8397:  POP     HL              ; Zeiger auf Anfang ASCII-Text verwerfen
        POP     HL              ; Zeiger für Zwischencodetext holen
        LD      (HL),B          ; gefundenen Zwischencode merken
        LD      A,B             ; Zwischencode des Befehls holen
        RET
;
;
;   Leerzeichen (DE) nach (HL) übertragen
;
A839C:  LD      A,(DE)          ; ein ASCII - Textzeichen holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        RET     NZ              ; nein
        LD      (HL),A          ; Leerzeichen merken
        CALL    A827E           ; Zeiger für Zwischencode und Längenzähler corrigieren
        JR      A839C           ; auf weitere Leerzeichen untersuchen
;
;
;   auf Zahlwert untersuchen; wenn ja -->  Zahl umsetzen
;
IMNUM:  EX      AF,AF           ; ASCII - Textzeichen retten
        PUSH    DE              ; Zeiger auf ASCII - Text retten
        CALL    A79BB           ; Leerzeichen im Text (DE) überspringen
        POP     DE              ; Zeiger auf ASCII - Text retten
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        JR      NC,IMFLT        ; ja -->  Zahlwert umsetzen in internes Format
        CP      '.'             ; Dezimalpunkt  ?
        JR      Z,IMFLT         ; ja -->  Zahlwert umsetzen in internes Format
        CP      'E'             ; Exponentenkennung  ?
        JR      Z,IMFLT         ; ja -->  Zahlwert umsetzen in internes Format
        EX      AF,AF           ; gerettetes Textzeichen holen
        SUB     '0'-1           ; einzelne Ziffer umsetzen in Zwischencode
        JP      IMFLT           ; Zahlwert umsetzen in internes Format
;
;
;   Zahlwert umsetzen in internes Format und im Zwischencodetext merken
;
IMFLT:  PUSH    BC              ; Zähler 'Anzahl umgesetzte Zeichen' retten
        LD      (HL),__REAL     ; Code for 'Real - Zahlwert'  eintragen
        INC     HL              ; Zwischencode überspringen
        PUSH    HL              ; Zeiger auf Stelle für Real - Zahlwert merken
        CALL    A7A0E           ; ASCII-Text (DE) umsetzen in Real - Wert nach (HL)
        POP     HL              ; Zeiger auf Real - Zahlwert holen
        LD      BC,5            ; Länge Real - Zahlwert
        ADD     HL,BC           ; Zeiger auf Ende Zahlwert errechnen
        LD      A,6             ; 6 Zeichen neu hinzugekommen
        JR      A83F3           ; Zähler 'Anzahl umgesetzte Zeichen' corrigieren
;
;
;   ASCII - Zeilennummer umsetzen und mit Kennung merken
;
A83D0:  PUSH    BC              ; Zähler  'Anzahl umgesetzte Zeichen'  retten
        CALL    CVBCAS          ; ASCII - Wert (DE) umsetzen in Hex-Wert nach BC
        LD      (HL),_LINNO     ; Code for 'Zeilennummer'  eintragen
        INC     HL              ; Code überspringen
        JR      A83ED           ; Zähler  'Anzahl umgesetzte Zeichen'  corrigieren
;
;
;   Sedezimalwert (DE) umsetzen in internes Format nach (HL)
;
IMHEX:  LD      (HL),A          ; $ - Zeichen erst einmal merken
        INC     DE              ; Zeiger auf ASCII-Text auf nächstes Zeichen
        LD      A,(DE)          ; nächstes ASCII - Textzeichen holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    21              ; Code 21  Sedezimal-Zeichen im Accu umsetzen in Hex-Wert
        JP      C,A827F         ; kein Hex-Wert -->  Zwischencodezeiger und Längenzähler corrigieren
        PUSH    BC              ; Zähler  'Anzahl umgesetzte Zeichen'  retten
        LD      (HL),_HEXNO     ; Kennung  'Sedezimalwert'  eintragen
        INC     HL              ; Wertkennung überspringen
        PUSH    HL              ; Zeiger auf Stelle für Hex - Wert merken
        EX      DE,HL           ; Zeiger auf ASCII - Text nach HL
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    20              ; Code 20   Sedezimal-Wert (HL) umsetzen in Hex-Wert nach DE
        LD      B,D             ;! bereitgestellten Wert nach BC
        LD      C,E             ;!
        EX      DE,HL           ; Zeiger auf Rest ASCII - Text nach DE
        POP     HL              ; Zeiger auf Stelle für Zahlwert holen
A83ED:  LD      A,3             ; Vorgabe 3 neue Zeichen im Zwischencodetext
        LD      (HL),C          ; Low - Byte Wert eintragen
        INC     HL              ; Low - Byte Wert überspringen
        LD      (HL),B          ; High - Byte Wert eintragen
        INC     HL              ; High - Byte Wert überspringen
A83F3:  POP     BC              ; Zähler  'Anzahl umgesetzte Zeichen'  holen
        ADD     A,C             ; neue Anzahl Zeichen addieren
        JP      C,A6379         ; Überlauf -->  Fehler 8  Line lenght error
        LD      C,A             ; neue Anzahl umgesetzter Zeichen merken
BCKSKP: DEC     DE              ; Zeiger auf ASCII-Text auf letztes Zeichen
        LD      A,(DE)          ; ASCII - Zeichen holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,BCKSKP        ; ja -->  letztes relevantes Zeichen suchen
        INC     DE              ; Zeiger auf nächstes abzuarbeitendes Zeichen
        RET
;
;
;   Convert tokenized line in (HL) to ASCII in (DE)
;
CVTXIM: PUSH    HL              ; Save tokenized line pointer
        PUSH    DE              ; Save pointer to memory for ASCII
        PUSH    BC              ; Keep register value
        EXX
        LD      B,0             ; Vorgabe für Zähler  'umgesetzte Zeichen'
        EXX
        LD      C,0             ; Vorgabe für Längezähler
T840A:  LD      A,(HL)          ; ein Zeichen Zwischencodetext holen
        OR      A               ; Zeilenendezeichen  ?
        JR      Z,TXEND         ; ja -->  merken und gerettete Register holen
        LD      BC,T840A        ; Rücksprungadresse für nächstes Zeichen
        PUSH    BC              ; auf Stack ablegen
        CP      '\''            ; Anfang Kommentar  ?
        JR      Z,TXDATA        ; ja -->  Text (HL) bis Befehlsende nach (DE) übertragen
        INC     HL              ; Zwischencodezeichen überspringen
        LD      BC,M5973        ; Zeiger auf BASIC-Befehlswörter Tabelle eins vorgeben
        CP      ' '             ; Steuerzeichen  ?
        JR      C,TXNUM         ; ja -->  in entsprechenden Zahlwert umsetzen
        CP      '\"'            ; Textanfangszeichen  ?
        JR      Z,TXSTR         ; ja -->  Text (HL) nach (DE) übertragen
        CP      ':'             ; Doppelpunkt  ?
        JR      Z,TX3AH         ; ja -->  bei Kommentar und ELSE vergessen
        CP      ___REM          ; Zwischencode  REM  ?
        JR      Z,A8454         ; ja -->  Text (HL) bis Ende Befehl nach (DE) übertragen
        CP      __DATA          ; Zwischencode  DATA  ?
        JR      Z,A8454         ; ja -->  Text (HL) bis Ende Befehl nach (DE) übertragen
        CP      ____PI          ; Zwischencode  Pi  ?
        JR      Z,TXPAI         ; ja -->  Zeichen für Pi nach (DE) eintragen
        CP      0FEH            ; Vorbyte für Befehlsworttabellen  ?
        JR      NC,A8448        ; ja -->  Basic - Befehlswort aufbereiten
        CP      080H            ; Zwischencode  ?
        JP      NC,TXRSV        ; ja -->  Zwischencode umsetzen in ASCII - Text
        JP      STRDE           ; ASCII-Zeichen im Accu merken, Zähler corrigieren
;
TXEND:  LD      (DE),A          ; Zeilenendezeichen merken
        POP     BC              ; geretteten Register - Wert holen
        POP     DE              ; Zeiger auf Anfang ASCII-Text holen
        POP     HL              ; Zeiger auf Zwischencodetext holen
        RET
;
TXPAI:  LD      A,0FFH          ; Pi   (Sharp - ASCII - Code)
        JP      STRDE           ; ASCII-Zeichen im Accu merken, Zähler corrigieren
;
A8448:  LD      BC,M5BAD        ; Zeiger auf BASIC-Befehlswörter Tabelle drei vorgeben
        JR      NZ,A8450        ; nicht Befehlsworttabelle zwei -->  Wort umsetzen
        LD      BC,M5B16        ; Zeiger auf BASIC-Befehlswörter Tabelle zwei vorgeben
A8450:  LD      A,(HL)          ; eigentlichen Zwischencode holen
        INC     HL              ; Zwischencode überspringen
        JR      TXRSV           ; Zwischencode umsetzen in ASCII - Text
;
;
;    Text (HL) bis Ende Befehl nach (DE) übertragen
;
A8454:  CALL    TXRSV           ; Zwischencode umsetzen in ASCII - Text
        RET     Z               ; Befehlsende
;
TXDATA: LD      A,(HL)          ; nächstes Zwischencodezeichen holen
        CALL    A5966           ; testen, ob Accu gleich Befehlsendezeichen
        RET     Z               ; ja -->  fertig
        CALL    STRDE           ; ASCII-Zeichen im Accu merken, Zähler corrigieren
        LD      A,(HL)          ; Zwischencodezeichen noch einmal holen
        INC     HL              ; und überspringen
        CP      '\"'            ; Textanfangzeichen  ?
        CALL    Z,A846C         ; ja -->  Text (HL) nach (DE) übertragen
        JR      TXDATA          ; ja -->  Text (HL) bis Befehlsende nach (DE) übertragen
;
;
;   Textkonstante (HL) nach (DE) übertragen
;
TXSTR:  CALL    STRDE           ; ASCII-Zeichen im Accu merken, Zähler corrigieren
A846C:  LD      A,(HL)          ; nächstes Zwischencodezeichen holen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja -->  fertig
        INC     HL              ; Zwischencodezeichen überspringen
        CP      '\"'            ; Textendezeichen  ?
        JR      NZ,TXSTR        ; nein -->  weitere Zeicehn übertragen
        JR      STRDE           ; ASCII-Zeichen im Accu merken, Zähler corrigieren
;
;
;   bei Doppelpunkt auf ELSE oder Kommentar untersuchen
;
TX3AH:  LD      (DE),A          ; Doppelpunkt für ASCII - Text merken
        LD      A,(HL)          ; nächstes Zwischencodezeichen holen
        CP      __ELSE          ; Zwischencode  ELSE  ?
        RET     Z               ; ja -->  Doppelpunkt vergessen
        CP      '\''            ; Kommentaranfang
        RET     Z               ; ja -->  Doppelpunkt vergessen
        JR      A84E4           ; Zeiger für ASCII-Text  und Zähler corrigieren
;
;
;   Zwischencodekennung in entsprechenden Zahlwert umsetzen
;
TXNUM:  CP      __REAL          ; Kennung Real - Zahlwert  ?
        JR      Z,TXFLT         ; ja -->  Real - Wert aufberieten in ASCII
        CP      _LINNO          ; Kennung  Zeilennummer / Hex - Wert etc  ?
        JR      NC,TXINT        ; ja -->  umsetzen in ASCII - Zeichen
        DEC     A               ; Steuerzeichen auf Dezimalwert corrigieren
        OR      '0'             ; und umsetzen in ASCII - Zeichen
        JR      STRDE           ; ASCII-Zeichen im Accu merken, Zähler corrigieren
;
TXINT:  PUSH    DE              ; Zeiger auf Speicher für ASCII - Wert retten
        LD      E,(HL)          ;! Wert aus Zwischencodetext holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL
        PUSH    HL              ; Zeiger auf Zwischencodetext retten
        CP      _INTNO          ; Code  `Integer - Wert'  ?
        JR      Z,A84A3         ; ja -->  Integer - Wert umsetzen in ASCII
        CP      _LIN_P          ; Zeiger auf Zeile  ?
        JR      C,A84A3         ; nein -->  Zeilennummer umsetzen in ASCII
        JR      NZ,TXHEX        ; nein -->  Hex - Wert umsetzen in ASCII
        EX      DE,HL           ; Zeiger auf Zeile nach HL
        INC     HL              ;! Offset auf nächste Zeile überspringen
        INC     HL              ;!
        LD      E,(HL)          ;! Zeilennummer der Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
A84A3:  EX      DE,HL           ; aufzubereitenden Wert nach HL
        CALL    A7998           ; Hex - Wert in HL umsetzen in Dezimal - ASCII nach Zwischenspeicher
        LD      B,D             ;! Zeiger auf aufbereiteten Zahlwert nach BC
        LD      C,E             ;!
        POP     HL              ; Zeiger auf Zwischencodetext holen
        POP     DE              ; Zeiger auf Speicher für ASCII - Text holen
A84AB:  LD      A,(BC)          ; auf aufbereitetes Textzeichen holen
        OR      A               ; Textendezeichen  ?
        RET     Z               ; ja -->  fertig
        CALL    STRDE           ; ASCII-Zeichen im Accu merken, Zähler corrigieren
        INC     BC              ; Zeiger auf aufbereiteten Text auf nächstes Zeichen
        JR      A84AB           ; weitere Zeichen Zahltext übertragen
;
;
;   Real - Zahlwert (HL) aufbereiten in ASCII - Text nach (DE)
;
TXFLT:  PUSH    HL              ; Zeiger auf Zwischencodetext retten
        PUSH    DE              ; Zeiger für ASCII - Text retten
        CALL    A7D4E           ; Real - Zahlwert (HL) aufbereiten in ASCII - Text
        LD      B,D             ;! Zeiger auf aufbereiteten Zahlwert nach
        LD      C,E             ;! BC kopieren
        POP     DE              ; Zeiger auf Speicher für ASCII - Text holen
        POP     HL              ; Zeiger auf Zwischencodetext holen
        INC     HL              ;! aufbereiteten Real - Zahlwert im
        INC     HL              ;! Zwischencodetext überspringen
        INC     HL              ;!
        INC     HL              ;!
        INC     HL              ;!
        JR      A84AB           ; aufbereiteten Zahlwert nach ASCII-Text-Speicher übertragen
;
;
;   Zwischencode im Accu nach Tabelle (BC) umsetzen in ASCII - Text
;
TXRSV:  CP      080H            ; Zwischencode
        JR      Z,A84D2         ; Zeiger steht auf richtigem Text
        EX      AF,AF           ; Rest Zwischencodezähler retten
A84C9:  LD      A,(BC)          ; ein Zeichen aus Tabelle holen
        RLCA                    ; Textendebit nach Carry schieben
        INC     BC              ; Zeiger auf Texttabelle auf nächstes Zeichen
        JR      NC,A84C9        ; nicht Textende -->  Ende des Wortes suchen
        EX      AF,AF           ; geretteten Zwischencodezähler wieder holen
        DEC     A               ; minus eins
        JR      TXRSV           ; und testen, ob Zeiger auf richtigem Wort steht
;
A84D2:  LD      A,(BC)          ; ein Textzeichen aus Tabelle holen
        BIT     7,A             ; Wortendebit gesetzt  ?
        JR      NZ,STRDES       ; ja -->  letztes Zeichen des Wortes eintragen
        CP      '.'             ; Punkt  ?
        CALL    NZ,STRDE        ; nein -->  ASCII-Zeichen im Accu merken, Zähler corrigieren
        INC     BC              ; Zeiger auf Texttabelle auf nächstes Zeichen
        JR      A84D2           ; nächstes Tabellenzeichen aufbereiten
;
;
;   ASCII-Zeichen im Accu merken und Zähler für Länge der ASCII - Text - Zeile corrigieren
;
STRDES: AND     01111111B       ; eigentliches ASCII - Zeichen maskieren
STRDE:  LD      (DE),A          ; ASCII - Text - Zeichen merken
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja -->  fertig
A84E4:  INC     DE              ; eingetragenes Zeichen überspringen
        EXX
        INC     B               ; Zähler  'Anzahl umgesetzte Zeichen' plus eins
        EXX
        RET     NZ              ; Zähler noch OK
        XOR     A               ; Code for 'Zeilenende'
        LD      (DE),A          ; hinter Text eintragen
        DEC     DE              ; und Zeiger für Text corrigieren
        EXX
        DEC     B               ; Zähler wieder auf 255
        EXX
        RET
;
;
;   Hex - Wert in DE  umsetzen in ASCII - Text
;
TXHEX:  LD      A,'$'           ; Kennung Hex - Wert
        EX      AF,AF           ; Kennung merken
        EX      DE,HL           ; Hex - Wert nach HL
        CALL    HEXHL           ; Hex - Wert in HL aufbereiten in ASCII nach Speicher
        LD      B,D             ;! Zeiger auf aufbereiteten Text nach BC
        LD      C,E             ;!
        POP     HL              ; Zeiger auf Zwischencodetext holen
        POP     DE              ; Zeiger auf Speicher für ASCII - Text holen
        EX      AF,AF           ; gerettete Zahlkennung wieder holen
        CALL    STRDE           ; ASCII - Zeichen im Accu merken, Zähler corrigieren
        JR      A84AB           ; aufbereiteten Zahlwert nach ASCII-Text-Speicher übertragen
;
;
;   Hex - Wert in HL aufbereiten in Hex - ASCII - Wert nach Zwischenspeicher
;
HEXHL:  LD      DE,S9E76        ; Zeiger auf Speicher für Aufbereitung  Hex - Wert
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        LD      A,H             ; High - Byte Wert holen
        CALL    HEXACC          ; Byte im Accu umsetzen in zwei ASCII-Hex-Zeichen
        LD      A,L             ; Low - Byte Wert holen
        CALL    HEXACC          ; Byte im Accu umsetzen in zwei ASCII-Hex-Zeichen
        XOR     A               ; Code for 'Textende'
        LD      (DE),A          ; hinter aufbereiteten Zahlwert eintragen
        POP     DE              ; Zeiger auf Anfang Speicher holen
        LD      B,3             ; maximal drei Stellen auf Null überprüfen
A8512:  LD      A,(DE)          ; eine Stelle holen
        CP      '0'             ; gleich Null  ?
        RET     NZ              ; nein
        INC     DE              ; führende Null vergessen
        DJNZ    A8512           ; weiteren Stellen überprüfen
        RET
;
;
;   Byte im Accu umsetzen in zwei ASCII - Hex - Zeichen nach (DE)
;
HEXACC: PUSH    AF              ; auszugebendes Byte retten
        RRCA                    ;! High - Nibble auf Low - Nibble schieben
        RRCA                    ;!
        RRCA                    ;!
        RRCA                    ;!
        AND     00001111B       ; Low - Nibble maskieren
        CALL    A8527           ; Nibble aufbereiten in ASCII und merken
        POP     AF              ; aufzugebenden Zahlwert holen
        AND     00001111B       ; Low - Nibble maskieren
A8527:  ADD     A,'0'           ; umsetzen in ASCII
        CP      '9' + 1         ; Ziffer  ?
        JR      C,A852F         ; ja -->  Zeichen merken
        ADD     A,7             ; für A - F corrigieren
A852F:  LD      (DE),A          ; Hex - ASCII - Zeichen merken
        INC     DE              ; eingetragenes Zeichen überspringen
        RET
;
;
;   ASCII - Wert (DE) umsetzen in Hex - Wert nach BC
;
CVBCAS: PUSH    HL              ; Zeiger für Zwischencodetext retten
        EX      DE,HL           ; Zeiger auf Dezimal - ASCII - Wert nach HL
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    19              ; Code 19   ASCII - Wert (HL) umsetzen in Hex-Wert nach DE
        LD      B,D             ;! bereitgestellten Wert nach BC kopieren
        LD      C,E             ;!
        EX      DE,HL           ; Zeiger auf Rest ASCII - Text wieder nach HL
        POP     HL              ; geretteten Zeiger für Zwischencodetext holen
        JP      BCKSKP          ; Zeiger auf letztes relevantes Zeichen stellen
;
;
;   Ausdruck (HL) auswerten und ein - Byte - Wert nach E/Accu bereitstellen
;
IBYTE:  CALL    IDEEXP          ; zwei - Byte - Wert nach DE bereitstellen
;
;
;   untersuchen, ob bereitgestellter Wert zwischen 0 und 255 liegt
;
DCHECK: LD      A,D             ; High - Byte Wert holen
        OR      A               ; gleich Null  ?
        JP      NZ,A636A        ; nein -->  Fehler 3   Illegal data error
        LD      A,E             ; Lwo -Byte Wert holen
        RET
;
;
;   Ausdruck (HL) auswerten und 2 - Byte - Wert nach DE
;   ohne vorherige Zwischenergebnisse zu vergessen
;
DEEXP:  CALL    EXPR8           ; Ausdruck (HL) auswerten
        DEC     DE              ;! Zeiger auf bereitgestellten Wert stellen
        DEC     DE              ;!
        DEC     DE              ;!
        DEC     DE              ;!
        DEC     DE              ;!
        JR      STDEFC          ; Real - Wert (DE) umsetzen in zwei - Byte - Wert
;
;
;   Ausdruck (HL) auswerten und zwei - Byte - Wert nach DE bereitstellen
;
IDEEXP: CALL    EXPR            ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitst.
STDEFC: PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        EX      DE,HL           ; Zeiger auf Wert nach HL
        CALL    STROMT          ; Syntaxuntersuchung auf Real - Wert - Ergebnis
        CALL    HLFLT           ; Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
        EX      DE,HL           ; Ergebnis nach DE
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; nächstes Programmbyte holen
        RET
;
;
;   Stringausdrucë (HL© auswerteî unä Zeigeò auæ Strinç nacè DE bereitstellen
;
A8561:  CALL    EXPR            ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitst.
        PUSH    AF              ; nächstes Programmbyte retten
        CALL    A9036           ; Syntaxuntersuchung auf Zeichenkettenergebnis
        PUSH    HL              ; Programmzeiger retten
        EX      DE,HL           ; Zeiger auf Stringdescriptor nach HL
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; nächstes Programmbyte holen
        RET
;
;
;   Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
;
A8570:  LD      B,(HL)          ; Länge der Zeichenkette holen
        INC     HL              ; Länge in Stringdescriptor überspringen
        LD      E,(HL)          ;! Offset auf String auf Descriptor holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      HL,(STRST)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf String errechnen
        EX      DE,HL           ; Zeiger auf String nach DE
        LD      A,B             ; Länge der Zeichenkette holen
        RET
;
;
;   Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
;
EXPR:   LD      DE,(VARED)      ; Anfang Stringarbeitsbereich holen
        LD      (TMPEND),DE     ; als Ende Stringarbeitsbereich merken
A8584:  LD      DE,(INTFAC)     ; Zeiger auf Anfang Rechenspeicher holen
        PUSH    DE              ; Zeiger für Ergebnis merken
        CALL    EXPR8           ; Ausdruck (HL) auswerten und Ergebnis bereitstellen
        POP     DE              ; Zeiger auf Ergebnis holen
        RET
;
;
;   Ausdruck (HL) mit allen Prioritäten auswerten
;
EXPR8:  PUSH    DE              ; Zeiger für Ergebnis retten
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        CALL    A8C08           ; überprüfen, ob Adresse in DE mit Stack kollidiert
        POP     DE              ; Zeiger für Ergebnis holen
        CALL    A85B2           ; Ausdruck mit Priorität acht und höher auswerten
A859A:  CP      ___XOR          ; Zwischencode  XOR  ?
        RET     NZ              ; nein
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode XOR überspringen
        CALL    A85B2           ; Ausdruck mit Priorität acht und höher auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A959C           ; XOR - Routine aufrufen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; nächstes Programmbyte holen
        JR      A859A           ; auf weitere Funktionen mit gleicher Priorität untersuchen
;
;
;   Ausdruck mit Priorität acht und höher auswerten
;
A85B2:  CALL    A85CD           ; Ausdruck mit Priorität sieben und höher auswerten
A85B5:  CP      ____OR          ; Zwischencode  OR  ?
        RET     NZ              ; nein
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode OR überspringen
        CALL    A85CD           ; Ausdruck mit Priorität sieben und höher auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A9599           ; OR - Routine aufrufen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; nächstes Programmbyte holen
        JR      A85B5           ; auf weitere Funktionen mit gleicher Priorität untersuchen
;
;
;   Ausdruck mit Priorität sieben und höher auswerten
;
A85CD:  CALL    A85E8           ; Ausdruck mit Priorität sechs und höher auswerten
A85D0:  CP      ___AND          ; Zwischencode  AND  ?
        RET     NZ              ; nein
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode  AND überspringen
        CALL    A85E8           ; Ausdruck mit Priorität sechs und höher auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A9596           ; AND - Routine aufrufen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; nächstes Programmbyte holen
        JR      A85D0           ; auf weitere Funktionen mit gleicher Priorität untersuchen
;
;
;   Ausdruck mit Priorität sechs und höher auswerten
;
A85E8:  CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFB    ___NOT          ; Zwischencode  NOT  ?
        JR      NZ,A85FD        ; nein -->  Ausdruck mit Priorität fünf und höher auswerten
        CALL    A85FD           ; Ausdruck mit Priorität fünf und höher auswerten
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        LD      HL,-5           ; Länge Real - Zahlwert
        ADD     HL,DE           ; Zeiger auf bereitgestellten Wert errechnen
        CALL    A9586           ; NOT - Routine aufrufen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; nächstes Programmbyte holen
        RET
;
;
;   Ausdruck mit Priorität fünf und höher auswerten
;
A85FD:  CALL    A8667           ; Ausdruck mit Priorität vier oder höher auswerten
A8600:  CP      0EEH            ; Vergleichsbefehl  ?
        RET     C               ; nein
        PUSH    AF              ; nächstes Programmbyte retten
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und retten
        INC     HL              ; Zwischencode der Funktion überspringen
        CALL    A8667           ; Ausdruck mit Priorität vier oder höher auswerten
        POP     BC              ; Wertart des erstes Wertes holen
        EX      (SP),HL         ; Programmzeiger retten / Vergleichsberfehl holen
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Vergleichsbefehl retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        EX      AF,AF           ; Ergebnis Vergleich retten
        POP     AF              ; Vergleichsbefehl holen
        CP      ____LT          ; Zwischencode  <  ?
        JR      NZ,A863A        ; nein -->  weiter untersuchen
;
;
;   Auswertung  Vergleich  <
;
        EX      AF,AF           ; Ergebnis Vergleich holen
        JR      C,A8635         ; Vergleich ist erfüllt
;
;
;   Ergebnis  'Vergleich nicht erfüllt'  vorgeben
;
A861F:  LD      BC,0            ; Vorgabe für Wert Null  (logisch FALSE)
A8622:  LD      (HL),C          ; Exponenten eintragen
        INC     HL              ; eingetragenen Exponenten überspringen
        LD      (HL),B          ; MSBYte Mantisse eintragen
        INC     HL              ; MSByte Mantisse überspringen
        XOR     A               ; Accu auf Null
        LD      (HL),A          ;! Rest Mantisse auf Null setzen
        INC     HL              ;!
        LD      (HL),A          ;!
        INC     HL              ;!
        LD      (HL),A          ;!
        LD      A,5             ; Code for 'Real - Wert'  vorgeben
        LD      (S9E9C),A       ; im Wertart - Flag merken
        POP     AF              ; nächstes Programmbyte holen
        POP     HL              ; geretteten Programmzeiger holen
        JR      A8600           ; auf weitere Funktionen mit gleicher Priorität untersuchen
;
;
;   Ergebnis  'Vergleich erfüllt'  vorgeben
;
A8635:  LD      BC,08081H       ; Vorgabe für -1  (logisch  TRUE)
        JR      A8622           ; Wert eintragen
;
A863A:  CP      ____GT          ; Zwischencode  >  ?
        JR      NZ,A8645        ; nein -->  weiter untersuchen
;
;
;   Auswertung  Vergleich  >
;
        EX      AF,AF           ; Ergebnis Vergleich holen
        JR      Z,A861F         ; Vergleich ist nicht erfüllt -->  0
        JR      C,A861F         ; Vergleich ist nicht erfüllt -->  0
        JR      A8635           ; Vergleich erfüllt -->  -1
;
A8645:  CP      ____EQ          ; Zwischencode  =  ?
        JR      NZ,A864E        ; nein -->  weiter untersuchen
;
;
;   Auswertung  Vergleich  =
;
        EX      AF,AF           ; Ergebnis Vergleich holen
        JR      Z,A8635         ; Vergleich erfüllt -->  -1
        JR      A861F           ; vergleich ist nicht erfüllt -->  0
;
A864E:  CP      ____GE          ; Zwischencode  =>  ?
        JR      C,A8657         ; nein -->  weiter untersuchen
;
;
;   Auswertung  Vergleich  =>  oder >=
;
        EX      AF,AF           ; Ergebnis Vergleich holen
        JR      NC,A8635        ; Vergleich ist erfüllt -->  -1
        JR      A861F           ; Vergleich ist nicht erfüllt -->  0
;
A8657:  CP      ____LE          ; Zwischencode  <  ?
        JR      C,A8662         ; nein
;
;
;   Asuwertung  Vergleich  =< oder <=
;
        EX      AF,AF           ; Ergebnis Vergleich holen
        JR      Z,A8635         ; Vergleich erfüllt -->  -1
        JR      C,A8635         ; Vergleich erfüllt -->  -1
        JR      A861F           ; Vergleich ist nicht erfüllt -->  0
;
;
;   Auswertung Vergleich  <> oder ><
;
A8662:  EX      AF,AF           ; Ergebnis Vergleich holen
        JR      Z,A861F         ; Vergleich ist nicht erfüllt -->  0
        JR      A8635           ; Vergleich ist erfüllt -->  -1
;
;
;   Ausdruck mit Priorität vier oder höher auswerten
;
A8667:  CALL    A8692           ; Ausdruck mit Priorität drei oder höher auswerten
A866A:  CP      __PLUS          ; Zwischencode  Plus/Minus  ?
        RET     C               ; nein
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode überspringen
        JR      Z,A8684         ; Funktion plus
;
;
;   zweiten Parameter für -  - Routine bereitstellen
;
        CALL    A8692           ; Ausdruck mit Priorität drei oder höher auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
A8680:  POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; nächstes Programmbyte holen
        JR      A866A           ; auf weitere Funktionen mit gleicher Priorität unersuchen
;
;
;   zweiten Parameter für +  - Routine bereitstellen
;
A8684:  CALL    A8692           ; Ausdruck mit Priorität drei oder höher auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        JR      A8680           ; auf weitere Funktionen mit gleicher Priorität untersuchen
;
;
;   Ausdruck mit Priorität drei oder höher auswerten
;
A8692:  CALL    A86BD           ; Ausdruck mit Priorität zwei oder höher auswerten
A8695:  CP      __IDIV          ; Zwischencode  Backslash / MOD  ?
        RET     C               ; nein
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode überspringen
        JR      Z,A86AF         ; Integer - Division
;
;
;   zweiten Parameter für MOD - Routine bereitstellen
;
        CALL    A86BD           ; Ausdruck mit Priorität zwei oder höher auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A95F2           ; MOD - Routine aufrufen
A86AB:  POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; nächstes Programmbyte holen
        JR      A8695           ; auf weitere Funktionen mit gleicher Priorität untersuchen
;
;
;   zweiten Parameter für Integer - Division bereitstellen
;
A86AF:  CALL    A86BD           ; Ausdruck mit Priorität zwei oder höher auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A9611           ; Integer - Divisions - Routine aufrufen
        JR      A86AB           ; auf weitere Funktionen mit gleicher Priorität untersuchen
;
;
;   Ausdruck mit Priorität zwei oder höher auswerten
;
A86BD:  CALL    A86E8           ; Ausdruck mit Priorität eins oder höher auswerten
A86C0:  CP      ___DIV          ; Zwischencode / oder *  ?
        RET     C               ; nein
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode überspringen
        JR      Z,A86DA         ; Funktion  /  (geteilt)
;
;
;   zweiten Parameter für *  - Routine bereitstellen
;
        CALL    A86E8           ; Ausdruck mit Priorität eins oder höher auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
A86D6:  POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; nächstes Programmbyte holen
        JR      A86C0           ; auf weitere Funktionen mit gleicher Priorität untersuchen
;
;
;   zweiten Parameter für /  - Routine bereitstellen
;
A86DA:  CALL    A86E8           ; Ausdruck mit Priorität eins oder höher auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A93D5           ; /  - Routine   ( (HL) = (HL) / (DE) )
        JR      A86D6           ; auf weitere Funktionen mit gleicher Priorität untersuchen
;
;
;   Ausdruck mit Priorität eins oder höher auswerten
;
A86E8:  CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFB    __PLUS          ; Zwischencode  PLUS  ?
        JR      Z,A86E8         ; ja -->  Vorzeichen vergessen
        CP      _MINUS          ; Zwischencode minus  ?
        JR      NZ,A86F8        ; nein -->  weiter untersuchen
        INC     HL              ; Vorzeichen überspringen
        CALL    A86F8           ; Ausdruck mit Priorität null oder höher auswerten
        JR      A8721           ; Vorzeichen des bereitgestellten Wertes umkehren
;
;
;   Ausdruck mit Priorität null oder höher auswerten
;
A86F8:  CALL    A872D           ; Konstante, Variable oder Funktion (HL) auswerten
A86FB:  CP      ___POT          ; Zwischencode  ^  ?
        RET     NZ              ; nein
        LD      A,(S9E9C)       ; Wertart des beritgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode ^ überspringen
        CALL    A8713           ; Konstante, Variable oder Funktion mit Vorzeichen auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A950A           ; ^  - Routine aufrufen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; nächstes Programmbyte holen
        JR      A86FB           ; auf weitere Funktionen mit gleicher Priorität untersuchen
;
;
;   Konstante, Variable oder Funktion (HL) mit Vorzeichen auswerten
;
A8713:  CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFB    __PLUS          ; Zwischencode PLUS  ?
        JR      Z,A8713         ; ja -->  positives Vorzeichen vergessen
        CP      _MINUS          ; Zwischencode MINUS  ?
        JR      NZ,A872D        ; Konstante, Variable oder Funktion (HL) auswerten
        INC     HL              ; Zwischencode MINUS überspringen
        CALL    A872D           ; Konstante, Variable oder Funktion (HL) auswerten
;
;
;   Vorzeichen des bereitgestellten Wertes umkehren
;
A8721:  PUSH    AF              ; nächstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        LD      HL,-5           ; Länge Real - Zahlwert
        ADD     HL,DE           ; Zeiger auf bereitgestellten Wert errechnen
        CALL    A90A6           ; Vorzeichen des Wertes (HL) umkehren
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; nächstes Programmbyte holen
        RET
;
;
;   Konstante, Variable oder Funktion (HL) auswerten
;
A872D:  CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A6364         ; Fehler 1  Syntax error
        CALL    A8739           ; Wert Funktion, Konstante, Variable bereitstellen
        JP      HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
;
;
;   Wert der eingebauten Funktion, Konstanten oder Variablen bereitstellen
;
A8739:  PUSH    HL              ; Programmzeiger retten
        LD      HL,(MEMLMT)     ; LIMIT - Adresse holen
        SCF                     ;! Adresse des Rechenspeichers überprüfen
        SBC     HL,DE           ;!
        JP      C,A6373         ; zu hoch -->  Fehler 6  Memory error
        POP     HL              ; geretteten Programmzeiger holen
        CP      ____PI          ; Zwischencode  Pi  ?
        JR      Z,A8756         ; ja -->  Wert für Pi vorgeben
        CP      ' '             ; Zahlwertcode  ?
        JR      NC,A8796        ; nein -->  weiter untersuchen
A874C:  INC     HL              ; Zahlwertcode überspringen
        CP      __REAL          ; Real - Zahlwert  ?
        JR      C,A8765         ; nein -->  weiter untersuchen
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        JR      A875F           ; Code for 'Ergebnis ist Real-Wert'  vorgeben
;
;
;   Wert für Konstante Pi vorgeben
;
A8756:  INC     HL              ; Zwischencode Pi überspringen
        PUSH    HL              ; Programmzeiger retten
        LD      HL,B98C6        ; Zeiger auf Pi im Real - Format
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; geretteten Programmzeiger holen
;
;
;   Code for 'Ergebnis ist Real - Wert' vorgeben
;
A875F:  LD      A,5             ; Code for 'Real - Wert'
A8761:  LD      (S9E9C),A       ; im Wertart - Flag merken
        RET
;
;
;   Wert der Zahlkonstante bereitstellen
;
A8765:  CP      _LINNO          ; ZwischenCode for 'Zeilennummer'  ?
        JR      NC,A8772        ; kein einziffrige Zahlkonstante
        DEC     A               ; Zwischencode in Zahlwert corrigieren
        JP      M,A6364         ; Zeilenende -->  Fehler 1  Syntax error
        LD      B,0             ; High - Byte Wert auf Null
        LD      C,A             ; Ziffer als Low - Byte Wert vorgeben
        JR      A8783           ; Integer - Wert in BC aufbereiten in Real - Wert
;
A8772:  LD      C,(HL)          ;! Zwei - Byte - Wert aus Programm holen
        INC     HL              ;!
        LD      B,(HL)          ;!
        INC     HL
        CP      _LIN_P          ; ZwischenCode for 'Zeiger auf Zeile'  ?
        JR      NZ,A8783        ; nein -->  Integer - Wert in BC aufbereiten in Real - Wert
        INC     BC              ;! Offset auf nächste Zeile überspringen
        INC     BC              ;!
        LD      A,(BC)          ;! Zeilennummer der Zeile holen
        INC     BC              ;!
        EX      AF,AF           ;!
        LD      A,(BC)          ;!
        LD      B,A             ;!
        EX      AF,AF           ;!
        LD      C,A             ;!
;
;
;   Integer - Wert in BC aufbereiten in Real - Wert
;
A8783:  PUSH    HL              ; Programmzeiger retten
        PUSH    DE              ; Zeiger für Zahlwert retten
        EX      DE,HL           ; Zeiger für Zahlwert nach HL
        LD      E,C             ;! aufzubereitenden Wert nach BC
        LD      D,B             ;!
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        POP     DE              ; Zeiger auf aufbereiteten Zahlwert holen
        POP     HL              ; geretteten Programmzeiger holen
        LD      A,5             ; Code for 'Real - Wert'
A878F:  INC     DE              ;! bereitgestellten Wert retten
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        JR      A8761           ; Wertcode des bereitgestellten Wertes merken
;
A8796:  CP      '\"'            ; Anführungszeichen  ?
        JR      NZ,A87C9        ; keine Zeichenkettenkonstante
;
;
;   angegebene Zeichenkettenkonstante als Ergebnis bereitstellen
;
        INC     HL              ; Anführungszeichen überspringen
        PUSH    HL              ; Zeiger auf Anfang String retten
        CALL    A8BF0           ; Länge der Zeichenkettenkonstante (HL) auszählen
        EX      (SP),HL         ; Zeiger auf Anfang holen / Zeiger auf Ende retten
        PUSH    HL              ; Zeiger auf Anfang String merken
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        PUSH    BC              ; Stringlänge retten
        LD      BC,(STRST)      ; Anfang Stringtextbereich holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; Offset auf String errechnen
        POP     BC              ; Stringlänge holen
        EX      DE,HL           ; Zeiger für Ergebnis nach HL
        LD      (HL),B          ; Stringlänge in Descriptor eintragen
        INC     HL              ; eingetragene Länge überspringen
        LD      (HL),E          ;! Offset auf Stringtext in Descriptor eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL
        INC     HL
        INC     HL
        POP     DE              ; Zeiger auf Anfang String holen
        PUSH    HL              ; Zeiger für nächstes Ergebnis retten
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich übertragen
        LD      (TMPEND),HL     ; Ende Stringarbeitsbereich merken
        POP     DE              ; Zeiger auf Speicher für Ergebnis holen
        POP     HL              ; geretteten Programmzeiger holen
        LD      A,3             ; Code for 'Zeichenkettenwert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        RET
;
A87C9:  CP      '('             ; Klammer auf  ?
        JR      NZ,A87D4        ; nein -->  weiter untersuchen
;
;
;   Vorrangzeichen  'Klammer auf'  abarbeiten
;
        INC     HL              ; 'Klammer auf'überspringen
        CALL    EXPR8           ; Ausdruck (HL) auswerten
        JP      A79AD           ; auf Syntax  'Klammer zu'  überprüfen
;
A87D4:  OR      A               ; Zwischencode  ?
        JP      P,A8E15         ; nein -->  Wert der Variablen bereitstellen
        CP      ___SPC          ; Zwischencode  SPC  ?
        INC     HL              ; Zwischencode überspringen
        JR      NZ,A87E4        ; nicht SPC -->  weiter untersuchen
        LD      B,5             ; Code for 'Zahlparameter'  vorgeben
        LD      A,_SPACE        ; Zwischencode SPACE$ vorgeben
        PUSH    AF              ; Zwischencode merken
        JR      A8813           ; Syntax  'Klammer auf'  und Parameter bereitstellen
;
A87E4:  CP      0FFH            ; Vorbyte  Tabelle drei  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
        LD      A,(HL)          ; eigentlichen Zwischencode holen
        INC     HL              ; Zwischencode überspringen
        CP      ___CHR          ; Zwischencode  CHR$  ?
        JP      Z,A889F         ; ja -->  CHR$ - Funktion aufrufen
        CP      0C8H
        JP      NC,A6364        ; Fehler 1  Syntax error
        CP      0BAH
        JR      NC,A8843        ; Funktion, die sich Parameter selbst bereitstellt
        CP      09CH            ; Zwischencode  STICK  ?
        JR      Z,A8843         ; ja -->  Funktionsroutine aufrufen
        CP      09DH            ; Zwischencode  STRIG  ?
        JP      Z,A8843         ; ja -->  Funktionsroutine aufrufen
        PUSH    AF              ; Zwischencode der Funktion retten
        CP      0B3H
        JR      NC,A8834        ; Funktion mit Real - Wert - Argument
        LD      B,3             ; Code for 'Zeichenkettenwert'
        CP      0ABH
        JR      NC,A8813        ; Funktionen mit Zeichenkettenargument
        LD      B,5             ; Code for 'Real - Wert'
        CP      ___RND          ; Zwischencode  RND  ?
        JR      Z,A882E         ; ja -->  Funktion braucht nicht unbedingt Argument
A8813:  CALL    A79A3           ; auf Syntax  'Klammer auf'  überprüfen
A8816:  PUSH    BC              ; Code der Ergebnisvorgabe retten
        CALL    EXPR8           ; Ausdruck (HL) auswerten
        CALL    A79AD           ; auf Syntax  'Klammer zu'  überprüfen
        POP     AF              ; Code der Ergebnisvorgabe holen
        CALL    A9032           ; auf Syntax 'zwei gleiche Ergebnistypen'  untersuchen
A8821:  POP     AF              ; Zwischencode der Funktion holen
        PUSH    DE              ; Zeiger auf Speicher für Ergebnis retten
        PUSH    HL              ; Programmzeiger retten
        LD      HL,-5           ; Länge Ergebnis - Wert  (Real oder Descriptor)
        ADD     HL,DE           ; Zeiger auf bereitgestellten Wert errechnen
        CALL    A8843           ; Funktionsroutine nach Zwischencode aufrufen
        POP     HL              ; geretteten Programmzeiger holen
        POP     DE              ; Zeiger auf Speicher für Ergebnis holen
        RET
;
;
;   Funktionsdecodierung  RND
;
A882E:  CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    "("             ; Klammer auf  ?
        JR      Z,A8816         ; ja -->  Parameter angegeben -->  Funktion aufrufen
A8834:  LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        PUSH    HL              ; Programmzeiger retten
        LD      HL,B7C45        ; Zeiger auf +1  (Real - Format)
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; geretteten Programmzeiger holen
        JR      A8821           ; RND - Funktion aufrufen
;
;
;   Funktionsroutine nach Zwischencode im Accu aufrufen
;
A8843:  PUSH    HL              ; Zeiger auf Parameter retten
        ADD     A,A             ; Zwischencode mal zwei  (zwei Byte je Adresse)
        LD      L,A             ; und als Low - Byte Offset merken
        LD      H,0             ; High - Byte Offset auf Null
        LD      BC,W5D79        ; Zeiger auf Tabelle mit Anfangsadresse der Routinen
        ADD     HL,BC           ; Zeiger auf richtige Adresse errechnen
        LD      A,(HL)          ;! Anfangsadresse der Routine aus Tabelle holen
        INC     HL              ;!
        LD      H,(HL)          ;!
        LD      L,A             ;!
        EX      (SP),HL         ; Adresse ablegen / Zeiger auf Argument holen
        RET
;
;
;   Basic - Funktion   SIZE   (Token code  255 181 / 0FFH 0B5H)
;
A8852:  EX      DE,HL           ; Programmzeiger nach DE retten
        LD      HL,-527         ; Vorgabe für freien Arbeitsbereich
        ADD     HL,SP           ; Stackpointer holen
        LD      BC,(TMPEND)     ; Ende Stringarbeitsbereich holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; freien Arbeitsspeicher errechnen
        EX      DE,HL           ; Wert nach DE / Programmzeiger nach HL
        JR      NC,A8880        ; Wert ist OK -->  aufbereiten
        XOR     A               ; Accu auf Null
        JR      A887D           ; Null als Ergebnis aufbereiten
;
;
;   Basic - Funktion   CSRH     (Token code 255 182 / 0FFH 0B6H)
;
A8864:  LD      A,(CURX)        ; aktuelle X - Koordinate Cursor holen
        JR      A887D           ; Wert im Accu umsetzen in Real - Wert
;
;
;   Basic - Funktion   CSRV     (Token code 255 183 / 0FFH 0B7H)
;
A8869:  LD      A,(CURY)        ; aktuelle Y - Koordinate Cursor holen
        JR      A887D           ; Wert im Accu umsetzen in Real - Wert
;
;
;   Basic - Funktion   POSH     (Token code 255 184 / 0FFH 0B8H)
;
A886E:  LD      DE,(POINTX)     ; X - Koordinate Graphic - Cursor holen
        JR      A8880           ; Wert in DE umsetzen in Real - Wert
;
;
;   Basic - Funktion   POSV     (Token code 255 185 / 0FEH 0B9H)
;
A8874:  LD      DE,(POINTY)     ; Y - Koordinate Graphic - Cursor holen
        JR      A8880           ; Wert in DE umsetzen in Real - Wert
;
;
;   Basic - Funktion   ERN     (Token code 255 179 / 0FFH 0B3H)
;
A887A:  LD      A,(S9E53)       ; Fehlernummer holen
;
;
;   Wert im Accu umsetzen in Real - Wert
;
A887D:  LD      E,A             ; Low - Byte Wert merken
        LD      D,0             ; High - Byte Wert auf Null
;
;
;   Wert in DE umsetzen in Real - Wert
;
A8880:  LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        JP      A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
;
;
;   Basic - Funktion  ERL     (Token code 255 180 / 0FFH 0B4H)
;
A8888:  LD      DE,(S9E55)      ; Fehler - Zeilennummer holen
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        INC     HL              ; Zeiger auf MSByte Mantisse aufbereitete Zahl
        BIT     7,(HL)          ; Wert Positiv  ?
        DEC     HL              ; Zeiger wieder auf Exponenten
        RET     Z               ; Wert ist Positiv
        LD      DE,B889A        ; Zeiger auf Real - Wert 65536
        JP      A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
;
B889A:  DEFB    091H                    ; Exponent  65536
        DEFB    000H,000H,000H,000H     ; Mantisse  65536
;
;
;   Basic - Funktion  CHR$     (Token code 255 160 / 0FFH 0A0H)
;
A889F:  CALL    A79A3           ; auf Syntax  'Klammer auf'  überprüfen
        LD      B,0             ; Vorgabe für Anzahl Zeichen
A88A4:  PUSH    BC              ; Zähler  'Anzahl Zeichen' retten
        PUSH    DE              ; Zeiger für Ergebnis retten
        CALL    DEEXP           ; Ausdruck auswerten und 2-Byte - Wert bereitstellen
        CALL    DCHECK          ; untersuchen, ob Wert in DE zwischen 0 und 255 liegt
        POP     DE              ; Zeiger für Ergebnis holen
        POP     BC              ; Zähler  'Anzahl Zeichen'  holen
        PUSH    AF              ; bereitgestellten Wert retten
        INC     B               ; Zähler  'Anzahl Zeichen'  plus eins
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A88A4         ; ja -->  weitere Werte angegeben
        CALL    A79AD           ; auf Syntax  'Klammer zu'  überprüfen
        LD      A,B             ; Zähler  'Anzahl Zeichen'  holen
        EXX
        LD      B,A             ; Zähler  'Anzahl Zeichen'  merken
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        CALL    ADDHLA          ; Wert im Accu zum HL-Register addieren
        LD      D,H             ;! Zeiger auf neues Ende benutzter String-
        LD      E,L             ;! arbeitsbereich nach DE
        CALL    A8C08           ; überprüfen, ob Adresse in DE mit Stack kollidiert
A88C7:  DEC     HL              ; Zeiger auf Stelle für String
        POP     AF              ; ein Zeichen String holen
        LD      (HL),A          ; Stringzeichen merken
        DJNZ    A88C7           ; weitere Zeichen String bereitstellen
        EXX
        LD      A,B             ; Zähler  'Anzahl Zeichen'  holen
        EXX
        LD      B,A             ; und merken
A88D0:  LD      (TMPEND),DE     ; Ende Stringarbeitsbereich merken
        LD      DE,(STRST)      ; Anfang Stringtextbereich holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offset auf String errechnen
        PUSH    HL              ; und merken
        LD      A,B             ; Stringlänge holen
        EXX
        EX      DE,HL           ; Zeiger auf Stringdescriptor nach HL
        LD      (HL),A          ; Stringlänge in Descriptor eintragen
        INC     HL              ; Zeiger auf Stelle für Offset im Descriptor
        POP     BC              ; Offset auf String holen
        LD      (HL),C          ;! Offset auf String in Descriptor eintragen
        INC     HL              ;!
        LD      (HL),B          ;!
        LD      BC,3            ; Code for 'Ergebnis vom Typ String'
        ADD     HL,BC           ; Zeiger auf nächstes Ergebnis corrigieren
A88E9:  EX      DE,HL           ; Programmzeiger nach HL / Ergebniszeiger nach DE
        LD      A,3             ; Code for 'Zeichenkettenwert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        RET
;
;
;   Basic - Funktion   HEX$     (Token code 255 162 / 0FFH 0A2H)
;
A88F0:  PUSH    HL              ; Zeiger auf Argumnet retten
        CALL    HLFLT           ; Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
        CALL    HEXHL           ; Hex-Wert in HL aufbereiten in Hex-ASCII nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    23              ; Code 23   Länge des Textes (DE) auszählen
;
;
;   Stringdescriptor aufbauen und String in Stringarbeitsspeicher übertragen
;
A88F9:  LD      A,B             ; Textlänge holen
        OR      A               ; gleich Null  ?
        JR      Z,A890D         ; ja -->  Leerstring vorgebe
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        PUSH    HL              ; Zeiger merken
        PUSH    BC              ; Stringlänge retten
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich übertragen
        POP     BC              ; gerettete Stringlänge holen
        EX      DE,HL
        POP     HL              ; Zeiger auf Anfang String holen
        EXX
        POP     DE              ; Zeiger auf Speicher für Ergebnis holen
        EXX
        JR      A88D0           ; Stringdescriptor für Ergebnis holen
;
A890D:  POP     HL              ; Zeiger auf Stelle für Ergebnis holen
        CALL    A909E           ; Null im Real - Format nach (HL) eintragen
        JR      A88E9           ; Code for 'Ergebnis ist Zeichenkette'  setzen
;
;
;   Basic - Funktion   SPACE$     (Token code 255 168 / 0FFH 0A8H)
;
A8913:  PUSH    HL              ; Zeiger für Ergebnis retten
        CALL    A8924           ; Real-Wert (HL) umsetzen in Integer mit Test auf < 256
        LD      B,A             ; Anzahl Spaces merken
        LD      C,A             ; Textlänge merken
        OR      A               ; Textlänge gleich Null ?
        LD      A,' '           ; Leerzeichen  (Space)  vorgeben
        PUSH    DE              ; Zeiger auf Speicher für String merken
        CALL    NZ,SETDE        ; Stringbereich (DE) mit Konstanten auffüllen
        POP     DE              ; Zeiger auf Speicher mit Zeichenkette holen
        LD      B,C             ; Textlänge vorgeben
        JR      A88F9           ; Stringdescriptor aufbauen und String merken
;
;
;   Real-Wert (HL) umsetzen in Integer mit Untersuchung, ob Wert kleiner 256 ist
;
A8924:  CALL    HLFLT           ; Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
        LD      DE,S11A4        ; Zeiger auf Speicher für String vorgeben
        LD      A,H             ; High - Byte Länge holen
        OR      A               ; gleich Null  ?
        JP      NZ,A636A        ; nein -->  Fehler 3   Illegal data error
        LD      A,L             ; Low - Byte Wert holen
        RET
;
;
;   Basic - Funktion   STR$     (Token code 255 161 / 0FFH 0A1H)
;
A8931:  PUSH    HL              ; Programmzeiger retten
        CALL    A7B5B           ; Real-Wert (HL) umsetzen in ASCII nach Z-Speicher
        LD      A,(DE)          ; erstes aufbereitetes Zeichen holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      NZ,A893B        ; nein -->  relevantes Zeichen
        INC     DE              ; Freistelle für Vorzeichen überspringen
A893B:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    23              ; Code 23   Länge des Textes (DE) auszählen
        JR      A88F9           ; Stringdescriptor aufbauen und String merken
;
;
;   Basic - Funktion   EOF     (Token code 255 198 / 0FFH 0C8H)
;
A893F:  CALL    A79A3           ; auf Syntax  'Klammer auf'  überprüfen
        CALL    GETLU           ; Datei- oder Gerätenummer bereitstellen
        LD      B,A             ; Datei - Nummer retten
        CALL    A79AA           ; auf Syntax 'Klammer zu' überprüfen
        LD      A,B             ; gerettete Datei - Nummer holen
        PUSH    HL              ; Programmzeiger retten
        PUSH    DE              ; Zeiger auf Speicher für Ergebnis retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    41              ; Code 41   Zeiger auf Datensatz nach Datensatznr bereitstellen
        LD      DE,-1           ; Vorgabe  'Dateiende'
        JR      C,A895B         ; Datei nicht geöffnet -->  Wert aufbereiten
        INC     HL              ; Zeiger auf Dateiendeflag
        BIT     7,(HL)          ; Dateiendeflag abfragen
        JR      NZ,A895B        ; gesetzt -->  -1 als 'logisch wahr' aufbereiten
        LD      DE,0            ; Code for 'nicht Dateiende'
A895B:  POP     HL              ; Zeiger auf Stelle für Ergebnis holen
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; Wertart - Flag merken
A8964:  INC     HL              ;! bereitgestellten Wert retten
        INC     HL              ;!
        INC     HL              ;!
        INC     HL              ;!
        INC     HL              ;!
        EX      DE,HL           ; Zeiger für Wert nach DE
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Funktion   POINT     (Token code 255 197 / 0FFH 0C5H)
;
A896C:  CALL    A79A3           ; auf Syntax  'Klammer auf'  überprüfen
        PUSH    DE              ; Zeiger für Ergebnis retten
        CALL    DEEXP           ; Ausdruck auswerten und 2-Byte - Wert bereitstellen
        LD      B,D             ;! X - Koordinate Graphic retten
        LD      C,E             ;!
        POP     DE              ; Zeiger auf Stelle für Ergebnis holen
        PUSH    DE              ; und wieder merken
        PUSH    BC              ; X - Koordinate Graphic - retten
        CALL    A79B4           ; auf Syntax 'Komma' überprüfen
        CALL    DEEXP           ; Ausdruck auswerten und 2-Byte - Wert bereitstellen
        CALL    A79AD           ; auf Syntax  'Klammer zu'  überprüfen
        EX      (SP),HL         ; Programmzeiger retten / X - Koordinate Graphic holen
        EX      DE,HL           ; X- und Y- Koordinate Graphic vertauschen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    78              ; Abfrage, ob Graphic - Punkt gesetzt ist
        INC     A               ; Ergebnis gleich minus eins
        JP      Z,A636A         ; ja -->  Fehler in Koordinate -->  Fehler 3   Illegal data error
        DEC     A               ; Ergebnis wieder corrigieren
        POP     DE              ; Programmzeiger holen
        POP     HL              ; Zeiger für Ergebnis holen
        PUSH    DE              ; Programmzeiger wieder retten
        CALL    A887D           ; Wert im Accu umsetzen in Real - Wert
        JR      A8964           ; bereitgestellten Wert retten und Programmzeiger holen
;
;
;   Basic - Funktion   ASC     (Token code 255 171 / 0FFH 0ABH)
;
A8992:  PUSH    HL              ; Zeiger für Ergebnis retten
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
        OR      A               ; Länge gleich Null  ?
        JR      Z,A899A         ; ja -->  Null als Ergebnis aufbereiten
        LD      A,(DE)          ; erstes Zeichen der Zeichenkette holen
A899A:  JR      A89A0           ; Zeiger für Ergebnis holen und Wert aufbereiten
;
;
;   Basic - Funktion   LEN     (Token code 255 172 / 0FFH 0ACH)
;
A899C:  PUSH    HL              ; Zeiger für Ergebnis retten
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
A89A0:  POP     HL              ; Zeiger für Ergebnis holen
        JP      A887D           ; Wert im Accu umsetzen in Real - Wert
;
;
;   Basic - Funktion   VAL     (Token code 255 173 / 0FFH 0ADH)
;
A89A4:  PUSH    HL              ; Zeiger für Ergebnis retten
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        PUSH    HL              ; und merken
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich übertragen
        LD      (HL),NUL        ; Code for 'Textende'  hinter String eintragen
        POP     DE              ; Zeiger auf Anfang String holen
        POP     HL              ; Zeiger für Ergebnis holen
        JP      A7A0E           ; ASCII-Text (DE) umsetzen in Real - Wert nach (HL)
;
;
;   Basic - Funktion  LEFT$     (Token code 255 186 / 0FFH 0BAH)
;
A89B6:  CALL    A8A32           ; String und 2-Byte-Wert bereitstellen
        CALL    A79AD           ; auf Syntax  'Klammer zu'  überprüfen
        CALL    A8A2B           ; überprüfen, ob Wert in BC kleiner 256 ist
        EX      DE,HL           ; Programmzeiger nach DE / Stringzeiger nach HL
        LD      A,(HL)          ; Stringlänge holen
        CP      C               ; mit LEFT$ - Wert vergleichen
        JR      NC,A89C5        ; String ist länger als Wert
        LD      C,A             ; LEFT$ - Wert als Stringlänge merken
A89C5:  LD      (HL),C          ; neue Stringlänge eintragen
        LD      BC,5            ; Länge Descriptoreintrag
A89C9:  LD      A,3             ; Code for 'Zeichenkettenwert'
        ADD     HL,BC           ; Springdescriptor retten
        EX      DE,HL           ; Zeiger für Wert nach DE / Programmzeiger nach HL
        LD      (S9E9C),A       ; Werttyp im Wertart - Flag merken
        JP      HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
;
;
;   Basic - Funktion   RIGHT$     (Token code 255 187 / 0FFH 0BBH)
;
A89D3:  CALL    A8A32           ; String und 2-Byte-Wert bereitstellen
        CALL    A79AD           ; auf Syntax  'Klammer zu'  überprüfen
        CALL    A8A2B           ; überprüfen, ob Wert in BC kleiner 256 ist
        EX      DE,HL           ; Programmzeiger nach DE / Stringzeiger nach HL
        LD      A,(HL)          ; Stringzeiger holen
        SUB     C               ; angegebene Länge RIGHT$ abziehen
        JR      NC,A89E3        ; String ist länger
        XOR     A               ; Offset auf neuen String vorgeben
        LD      C,(HL)          ; neue Stringlänge holen  (gleich alte)
A89E3:  LD      (HL),C          ; neue Stringlänge eintragen
        INC     HL              ; Zeiger auf 'Offset auf String'
        ADD     A,(HL)          ; Low - Byte Offset corrigieren
        LD      (HL),A          ; neues Low - Byte merken
        INC     HL              ; Zeiger auf Descriptor auf High - Byte
        JR      NC,A89EB        ; kein Übertrag
        INC     (HL)            ; High - Byte Offset corrigieren
A89EB:  LD      BC,3            ; Restlänge für Rettung Stringdescriptor
        JR      A89C9           ; Stringdescriptor retten und Wertcode vorgeben
;
;
;   Basic - Funktion   MID$     (Token code 255 188 / 0FFH 0BCH)
;
A89F0:  CALL    A8A32           ; String und 2-Byte-Wert bereitstellen
        CALL    A8A2B           ; überprüfen, ob Wert in BC kleiner 256 ist
        OR      A               ; Anfangsstelle gleich Null  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        PUSH    AF              ; Anfangsstelle retten
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ")"             ; Klammer zu  ?
        LD      A,255           ; Vorgabe für  'Anzahl Zeichen'
        JR      Z,A8A17         ; keine Anzahl angegeben -->  alle Zeichen ab Anfangsposition
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        PUSH    DE              ; Zeiger auf Stringdescriptor retten
        EX      DE,HL           ; Programmzeiger nach DE
        LD      BC,5            ; Vorgabe für Länge zu rettender Wert
        ADD     HL,BC           ; Stringdescriptor retten
        EX      DE,HL           ; Programmzeiger wieder nach HL
        CALL    DEEXP           ; Ausdruck auswerten und 2-Byte - Wert bereitstellen
        CALL    A79AD           ; auf Syntax  'Klammer zu'  überprüfen
        CALL    DCHECK          ; untersuchen, ob Wert in DE zwischen 0 und 255 liegt
        POP     DE              ; Zeiger auf Stringdescriptor holen
A8A17:  POP     BC              ; Anfangsstelle holen
        LD      C,A             ; Anzahl Zeichen merken
        EX      DE,HL           ; Zeiger auf Stringdescriptor nach HL
        LD      A,(HL)          ; Länge des vorgegebenen Strings holen
        SUB     B               ; Anfangsstelle abziehen
        JR      C,A8A27         ; zu kurz -->  Ergebnis ist Leerstring
        INC     A               ; Restlänge corrigieren
        CP      C               ; mit angegebener Länge vergleichen
        JR      NC,A8A23        ; String ist noch länger
        LD      C,A             ; Restlänge vorgeben
A8A23:  LD      A,B             ; Anfangsstelle holen
        DEC     A               ; für Offset corrigieren
        JR      A89E3           ; neue Länge merken und Offset auf String corrigieren
;
A8A27:  XOR     A               ; Accu auf Null
        LD      C,A             ; als neue Länge vorgeben
        JR      A89E3           ; Stringdescriptor corrigieren
;
;
;   überprüfen, ob Wert in BC kleiner 256 ist
;
A8A2B:  LD      A,B             ; High - Byte Wert holen
        OR      A               ; gleich Null  ?
        JP      NZ,A636A        ; nein -->  Fehler 3   Illegal data error
        LD      A,C             ; Low - Byte Wert holen
        RET
;
;
;   String und 2-Byte-Wert bereitstellen
;
A8A32:  CALL    A79A3           ; auf Syntax  'Klammer auf'  überprüfen
        PUSH    DE              ; Zeiger auf Stelle für Ergebnismerken
        CALL    EXPR8           ; Ausdruck (HL) auswerten
        CALL    A79B4           ; auf Syntax 'Komma' überprüfen
        CALL    A9036           ; Syntaxuntersuchung auf Zeichenkettenergebnis
        CALL    DEEXP           ; Ausdruck auswerten und 2-Byte - Wert bereitstellen
        LD      C,E             ;! Wert nach DE kopieren
        LD      B,D             ;!
        POP     DE              ; Zeiger auf Stringdescriptor holen
        RET
;
;
;   Basic - Funktion   TI$     (Token code 255 196 / 0FFH 0C4H)
;
A8A46:  PUSH    HL              ; Programmzeiger retten
        PUSH    DE              ; Zeiger auf Stelle für Ergebnis merken
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        PUSH    HL              ; und merken
        LD      A,'0'           ; Null
        LD      B,6             ; sechs Zeichen für Uhrzeit
        CALL    SETHL           ; Speicherbereich (HL) mit Konstante belegen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    37              ; Code 37   Uhrzeit lesen
        POP     HL              ; Zeiger auf Textvorgabe holen
        OR      A               ; Flag  Vormittag / Nachmittag
        JR      Z,A8A5E         ; Vormittag
        INC     (HL)            ;! 12 für Nachmittag  vorgeben
        INC     HL              ;!
        INC     (HL)            ;!
        INC     (HL)            ;!
        DEC     HL
A8A5E:  EX      DE,HL           ; Zeiger auf Textspeicher nach DE
        LD      BC,36000        ; 36000 Sekunden  (Wert 10er Stundenstelle)
        CALL    A8AD5           ; eine Stelle der Uhrzeit aufbereiten
        LD      BC,3600         ; 3600 Sekunden  (Wert 1er Stundenstelle)
        CALL    A8AD5           ; eine Stelle der Uhrzeit aufbereiten
        CP      '9' + 1         ; Stelle größer neun  ?
        JR      C,A8A79         ; kein Übertrag auf 10er Stelle
        SUB     10              ; 1er - Stelle corrigieren
        DEC     DE              ; Zeiger auf 1er - Stundenstelle
        LD      (DE),A          ; richtigen Stellenwert eintragen
        DEC     DE              ; Zeiger auf 10er - Stundenstelle
        LD      A,(DE)          ; 10er - Stundenstelle holen
        INC     A               ; corrigieren
        LD      (DE),A          ; und richtigen Stellenwert eintragen
        INC     DE              ; Zeiger auf 1er - Stundenstelle
        INC     DE              ; Zeiger auf 10er - Minutenstelle
A8A79:  DEC     DE              ; Zeiger auf 1er - Stundenstelle
        DEC     DE              ; Zeiger auf 10er - Stundenstelle
        LD      A,(DE)          ; 10er - Stundenstelle holen
        INC     DE              ; Zeiger auf 1er - Stundenstelle
        LD      B,A             ; 10er - Stundenstelle merken
        LD      A,(DE)          ; 1er - Stundenstelle holen
        INC     DE              ; Zeiger wieder auf 10er - Minutenstelle
        LD      C,A             ; 1er - Stundenstelle merken
        LD      A,B             ; 10er - Stundenstelle holen
        CP      '2'             ; gleich 2  (24)  ?
        JR      NZ,A8A97        ; nein -->  Rest Uhrzeit aufbereiten
        LD      A,C             ; 1er - Stundenstelle holen
        CP      '4'             ; gleich 4  (24)  ?
        JR      NZ,A8A97        ; nein -->  Rest Uhrzeit aufbereiten
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        LD      A,'0'           ; Null
        LD      B,6             ; 6 Stellen Stringlänge TI$
        CALL    SETHL           ; Speicherbereich (HL) mit Konstante belegen
        JR      A8AAD           ; Stringdescriptor aufbereiten
;
A8A97:  LD      BC,600          ; 600 Sekunden  (Wert 10er - Minutenstelle)
        CALL    A8AD5           ; eine Stelle der Uhrzeit aufbereiten
        LD      BC,60           ; 60 Sekunden  (Wert 1er - Minutenstelle)
        CALL    A8AD5           ; eine Stelle der Uhrzeit aufbereiten
        LD      BC,10           ; 10 Sekunden  (Wert 10er Sekundenstelle)
        CALL    A8AD5           ; eine Stelle der Uhrzeit aufbereiten
        LD      A,'0'           ; Vorgabe für ASCII - Wert
        ADD     A,L             ; ASCII - Ziffer errechnen
        LD      (DE),A          ; Wert 1er - Sekundenstelle eintragen
A8AAD:  LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        LD      DE,6            ; Länge aufbereiteter String vorgeben
        EX      DE,HL
        ADD     HL,DE           ; neuen String retten
        LD      (TMPEND),HL     ; neues Ende Stringarbeitsbereich merken
        EX      DE,HL
        LD      DE,(STRST)      ; Anfang Stringtextbereich holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offset auf String errechnen
        EX      DE,HL           ; Offset nach DE
        POP     HL              ; Zeiger auf Stelle für Ergebnis holen
        LD      (HL),6          ; Stringlänge in Descriptor eintragen
        INC     HL
        LD      (HL),E          ;! Offset auf String in Descriptor eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL
        INC     HL
        INC     HL
        EX      DE,HL           ; Zeiger auf Stelle für nächstes Ergebnis nach DE
        POP     HL              ; geretteten Programmzeiger holen
        LD      A,3             ; Code for 'Zeichenkettenwert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        JP      HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
;
;
;   eine Stelle der Uhrzeit aufbereiten
;
A8AD5:  OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; ein mal Stellenwertigkeit abziehen
        JR      C,A8ADF         ; ging schon nicht mehr
        LD      A,(DE)          ; Stelle holen
        INC     A               ; plus eins
        LD      (DE),A          ; und wieder merken
        JR      A8AD5           ; untersuchen, ob Wert größer Stellenwert
;
A8ADF:  ADD     HL,BC           ; Restwert wieder corrigieren
        INC     DE              ; Zeiger auf nächste Stelle
        RET
;
;
;   Uhrzeit zuweisen   (TI$=___)
;
A8AE2:  CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFB    ____EQ          ; Zwischencode  =
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        LD      A,B             ; Stringlänge holen
        CP      6               ; gleich sechs  ?
        JP      NZ,A636A        ; nein -->  Fehler 3   Illegal data error
        PUSH    HL              ; Programmzeiger retten
        PUSH    DE              ; Zeiger auf String retten
        LD      HL,0            ; Vorgabe für Anzahl Sekunden
        CALL    A8B23           ; zwei Ziffernstellen auswerten
        CP      23 + 1          ; größer als 23  ?
        JP      NC,A636A        ; ja -->  Fehler 3   Illegal data error
        CP      11 + 1          ; größer als 11  ?
        LD      A,0             ; Vorgabe  'Vormittag'
        JR      C,A8B0B         ; nein -->  Uhrzeit ist Vormittags
        PUSH    DE              ; Zeiger auf Text merken
        LD      DE,12           ; 12 Stunden
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; bisher bereitgestellten Wert corrigieren
        POP     DE              ; Zeiger auf Resttext holen
        INC     A               ; Flag auf Nachmittag
A8B0B:  PUSH    AF              ; Flag  Vormittag / Nachmittag  merken
        CALL    A8B23           ; zwei Ziffernstellen auswerten
        CP      59 + 1          ; größer 59  ?
        JP      NC,A636A        ; ja -->  Fehler 3   Illegal data error
        CALL    A8B23           ; zwei Ziffernstellen auswerten
        CP      59 + 1          ; größer 59  ?
        JP      NC,A636A        ; ja -->  Fehler 3   Illegal data error
        POP     AF              ; Flag  Vormittag / Nachmittag  holen
        EX      DE,HL           ; ausgewertete Anzahl Sekunden nach DE
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    38              ; Code 38   Uhrzeit setzen
        POP     DE              ; Zeiger auf String holen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   bisher vorhandene Anzahl Sekunden * 60 plus Wert für zwei neue
;   auszuwertende Stellen
;
A8B23:  PUSH    DE              ; Zeiger auf Text retten
        LD      D,H             ;! alten Wert duplizieren
        LD      E,L             ;!
        ADD     HL,HL           ;! alten Wert mal   2
        ADD     HL,HL           ;!            mal   4
        ADD     HL,DE           ;!            mal   5
        LD      D,H             ;! Zwischenergebnis duplizieren
        LD      E,L             ;!
        ADD     HL,HL           ;!            mal  10
        ADD     HL,DE           ;!            mal  15
        ADD     HL,HL           ;!            mal  30
        ADD     HL,HL           ;!            mal  60
        POP     DE              ; Zeiger auf Rest Zeittext holen
        LD      A,(DE)          ; nächstes Textzeichen holen
        INC     DE              ; Zeiger auf nächste Stellen
        SUB     '0'             ; ASCII - Stelle umsetzen in Dezimalwert
        JP      C,A636A         ; keine Ziffer -->  Fehler 3   Illegal data error
        CP      10              ; mit Anzahl Ziffern vergleichen
        JP      NC,A636A        ; keine Ziffer -->  Fehler 3   Illegal data error
        PUSH    BC              ; Register retten
        LD      C,A             ; erste Ziffer merken
        ADD     A,A             ;! Wert neue Stelle mal  2
        ADD     A,A             ;!                  mal  4
        ADD     A,C             ;!                  mal  5
        ADD     A,A             ;!                  mal 10
        LD      C,A             ; Wert erste neue Stelle
        LD      A,(DE)          ; nächstes Textzeichen holen
        INC     DE              ; Zeiger auf Text auf nächste Stelle
        SUB     '0'             ; ASCII - Stelle umsetzen in Dezimalwert
        JP      C,A636A         ; keine Ziffer -->  Fehler 3   Illegal data error
        CP      10              ; mit Anzahl Ziffern vergleichen
        JP      NC,A636A        ; keine Ziffer -->  Fehler 3   Illegal data error
        ADD     A,C             ; plus erste Stelle
        LD      C,A             ; neuen Stellenwert merken
        LD      B,0             ; High - Byte Wert auf Null
        ADD     HL,BC           ; plus altes Ergebnis
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Variablennamen (HL) auswerten und Zeiger auf Variable nach BC,
;   Variablenartcode nach Accu bereitstellen
;
A8B56:  LD      DE,(VARED)      ; Anfang Stringarbeitsbereich holen
        LD      (TMPEND),DE     ; als Ende Stringarbeitsbereich merken
        LD      DE,(INTFAC)     ; Zeiger auf Anfang Rechenspeicher holen
A8B62:  PUSH    DE              ; Zeiger für Ergebnis merken
        CALL    A8BB5           ; Variablennamen (HL) im Zwischenspeicher bereitstellen
A8B66:  LD      A,(HL)          ; nächstes Programmbyte holen
        CP      '('             ; Klammer auf   ?
        JP      Z,A8C1B         ; ja -->  indizierte Variable
        PUSH    HL              ; Programmzeiger retten
        CALL    A8ED6           ; Variable nach bereitgestelltem Namen suchen
        JR      NC,A8B78        ; Variable nicht gefunden -->  anlegen
        LD      A,C             ; Variablentyp nach Accu holen
        LD      C,L             ;! Zeiger auf Variable nach BC
        LD      B,H             ;!
        POP     HL              ; geretteten Programmzeiger holen
        POP     DE              ; geretteten Register - Wert holen
        RET
;
;
;   neue Variable einfügen
;
A8B78:  LD      A,(DE)          ; Länge des Variablennamens holen
        ADD     A,C             ; plus Variablentyplänge
        ADD     A,2             ; plus Stellen für Verwaltungsflags
        PUSH    BC              ; Typlänge merken
        EX      DE,HL           ; Zeiger für Variable nach DE
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        PUSH    HL              ; und merken
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ;! zu verschiebende Anzahl Bytes errechnen
        INC     HL              ;!
        LD      C,L             ;! und nach BC übertragen
        LD      B,H             ;!
        POP     HL              ; Ende Stringarbeitsbereich holen
        PUSH    DE              ; Zeiger auf Stelle für Variable merken
        EX      DE,HL
        LD      L,A             ;! Zeiger auf neues Ende errechnen
        LD      H,0             ;!
        ADD     HL,DE           ;!
        EX      DE,HL
        CALL    A8C08           ; überprüfen, ob Adresse in DE mit Stack kollidiert
        LDDR                    ; vorhandene Werte verschieben
        LD      E,A             ; Länge neue Variable
        LD      D,0             ; High - Byte Länge auf Null
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    26              ; Code 26   Zeiger auf Stringbereiche corrigieren
        POP     HL              ; Zeiger auf Stelle für Variable holen
        POP     BC              ; Variablentypflag holen
        LD      DE,S11A4        ; Zeiger auf Speicher mit Variablennamen vorgeben
        LD      (HL),C          ; Variablentyp eintragen
        INC     HL              ; Variablentyp überspringen
        SCF                     ; eins für Typflag
        SBC     A,C             ; Länge Variablennamen errechnen
        LD      B,A             ; Länge Variablenname
A8BA4:  LD      A,(DE)          ;! Länge Variablenname udn Variablennamen
        LD      (HL),A          ;! merken
        INC     DE              ;!
        INC     HL              ;!
        DJNZ    A8BA4           ;!   weitere Zeichen übertragen
        PUSH    HL              ; Zeiger auf Variable merken
        LD      B,C             ; Variablentypflag holen
        CALL    CLRHL           ; Speicherbereich (HL) löschen
        LD      (HL),A          ; Code for 'Ende Bereich'  eintragen
        LD      A,C             ; Variablentypflag holen
        POP     BC              ; Zeiger auf Variable holen
        POP     HL              ; geretteten Programmzeiger holen
        POP     DE              ; geretteten Register - Wert holen
        RET
;
;
;   Variablennamen (HL) im Zwischenspeicher bereitstellen
;
A8BB5:  CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
        SUB     'A'             ;! Accu gleich Buchstabe  ?
        CP      26              ;!
        JP      NC,A6364        ; nein -->  Fehler 1  Syntax error
        LD      DE,S11A4        ; Zeiger auf Zwischenspeicher vorgeben
        LD      B,0             ; Zähler  'Anzahl Zeichen Variablenname'  vorgeben
A8BC4:  INC     DE              ; Zeiger auf Speicher auf nächste Stelle
        LD      A,(HL)          ; nächstes Programmbyte holen
        CALL    A79FD           ; Zeichen im Accu gleich Variablennamenzeichen  ?
        JR      C,A8BD6         ; kein Variablennamenzeichen -->  Länge merken
        LD      (DE),A          ; ein Zeichen Variablenname merken
        INC     B               ; Zähler  'Anzahl Zeichen Variablenname'  plus eins
        LD      A,B             ; Zähler holen
        CP      2 + 1           ; maximale Länge erreicht  ?
        JR      C,A8BD3         ; nein -->  noch OK
        DEC     B               ; Zähler minus eins
A8BD3:  INC     HL              ; Programmzeiger auf nächstes Zeichen
        JR      A8BC4           ; weitere Zeichen Variablenname auswerten
;
A8BD6:  LD      DE,S11A4        ; Zeiger auf Speicher mit Variablennamen
        EX      DE,HL           ; nach HL / Programmzeiger nach DE
        LD      (HL),B          ; Länge Variablenname eintragen
        EX      DE,HL           ; Programmzeiger nach HL / Zeiger  V.-Name nach DE
        LD      C,5             ; Code for 'Real - Wert'
        CP      '$'             ; Kennung Zeichenkette  ?
        RET     NZ              ; nein
        LD      C,3             ; Code for 'Zeichenkettenwert'
        INC     HL              ; Zeichenkettenkennung überspringen
        RET
;
;
;   Zeiger auf letzte zwei Werte bereitstellen
;
A8BE5:  LD      HL,-5           ; Länge bereitgestellter Wert
        EX      DE,HL
        ADD     HL,DE           ; Zeiger auf zweites Argument bereitstellen
        EX      DE,HL
        ADD     HL,DE           ; Zeiger auf erstes Argument bereitstellen
        LD      A,B             ; Typ des zweiten Arguments holen
        JP      A9032           ; auf Syntax 'zwei gleiche Ergebnistypen'  untersuchen
;
;
;   Länge der Zeichenkettenkonstante (HL) auszählen
;
A8BF0:  LD      B,-1            ; Vorgabe für Längenzähler
A8BF2:  INC     B               ; Länge plus eins
        LD      A,(HL)          ; ein Zeichen holen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja -->  fertig
        INC     HL              ; Textzeichen überspringen
        CP      '\"'            ; Textendezeichen  ?
        RET     Z               ; ja -->  fertig
        JR      A8BF2           ; Textende suchen
;
;
;   Zeichenkette mit Länge in B von (DE) nach (HL) übertragen
;   (Zeichenkette in Stringarbeitsbereich übertragen)
;
A8BFC:  LD      A,B             ; Länge holen
        OR      A               ; gleich Null ?
        RET     Z               ; ja -->  fertig
        CALL    LDHLDE          ; Speicherbereich von (DE) nach (HL) verschieben
        EX      DE,HL           ; Zeiger auf Arbeitsbereich nach DE
        CALL    A8C08           ; überprüfen, ob Adresse in DE mit Stack kollidiert
        EX      DE,HL           ; Zeiger auf Arbeitsbereich nach HL
        RET
;
;
;   überprüfen, ob Adresse in DE mit Stackbereich collidiert
;
A8C08:  PUSH    HL              ; Keep register value
        LD      HL,-512         ; Vorgabe für Arbeitsbereich
        ADD     HL,SP           ; Stackpointer holen
        SBC     HL,DE           ; Adresse in DE prüfen
        POP     HL              ; geretteten Register - Wert holen
        RET     NC              ; Adresse ist OK
        JP      A63A7           ; Fehler 6  Memory error
;
;
;   Dimensionierung bereitstellen und Variable dimensionieren
;
A8C14:  LD      DE,(INTFAC)     ; Zeiger auf Anfang Rechenspeicher holen
        PUSH    DE              ; Zeiger auf Rechenspeicher merken
        JR      A8C23           ; Einsprung in Routine
;
;
;   Wert einer dimensionierten Variable bereitstellen
;
A8C1B:  XOR     A               ; Code for 'Aufruf'
        LD      (S8E14),A       ; im Flag  'DIM - Aufruf' merken
        INC     HL              ; 'Klammer auf' überspringen
        LD      (S8E12),HL      ; Programmzeiger bei Anfang Dimensionierung merken
A8C23:  LD      B,0             ; Zähler  'Anzahl Dimensionen'  auf Null
        EXX
        POP     HL              ; Zeiger auf Rechenspeicher holen
        PUSH    HL              ;! und wieder merken
        PUSH    HL              ;!
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        LD      DE,S11A4        ; Zeiger auf Speicher für Variablennamen
        PUSH    HL              ; Zeiger für Variablennamen merken
        LD      A,(DE)          ;! Länge Variablennamen nach String-
        LD      (HL),A          ;! arbeitsbereich übertragen
        INC     DE              ; Zeiger auf Variablennamen
        INC     HL              ; Zeiger auf Stringarbeitsbereich
        LD      B,A             ; Länge Variablenname
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich übertragen
        POP     DE              ; Zeiger auf Variablennamen holen
        LD      (TMPEND),HL     ; neues Ende Stringarbeitsbereich merken
        LD      HL,(STRST)      ; Anfang Stringtextbereich holen
        EX      DE,HL           ; Zeiger vertauschen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offset auf Variablennamen errechnen
        EX      (SP),HL         ; Offset merken / Zeiger Rechenspeicher holen
        PUSH    HL              ; Zeiger auf Rechenspeicher wieder merken
        EXX
A8C46:  POP     DE              ; Zeiger auf Rechenspeicher holen
        PUSH    DE              ; und wieder merken
        PUSH    BC              ; Zähler  'Anzahl Dimensionen'  merken
        LD      BC,(S8E12)      ; Programmzeiger bei Anfang Dimensionierung holen
        LD      A,(S8E14)       ; Flag  'DIM - Aufruf' holen
        PUSH    BC              ; Programmzeiger merken
        PUSH    AF              ; Flag  'DIM - Aufruf'  merken
        LD      BC,(S9E6A)      ; Programmzeiger aus Zwischenspeicher holen
        PUSH    BC              ; und merken
        CALL    DEEXP           ; Ausdruck auswerten und 2-Byte - Wert bereitstellen
        BIT     7,D             ; Wert größer 32767  ?
        JP      NZ,A636A        ; ja -->  Fehler 3   Illegal data error
        EX      AF,AF           ; nächstes Programmbyte retten
        POP     BC              ; geretteten Programmzeiger holen
        LD      (S9E6A),BC      ; und wieder in Zwischenspeicher merken
        POP     AF              ; gerettetes Flag  'DIM - Aufruf'  holen
        LD      (S8E14),A       ; Flag  'DIM - Aufruf' merken
        POP     BC              ; Programmzeiger auf Anfang Index holen
        LD      (S8E12),BC      ; Programmzeiger bei Anfang Dimensionierung merken
        EX      AF,AF           ; nächstes Programmbyte holen
        INC     HL              ; Programmzeiger auf nächstes Programmbyte
        CP      ')'             ; Klammer zu  ?
        JR      Z,A8C8C         ; ja -->  Ende Index
        CP      ','             ; Komma als Trennzeichen  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
        POP     BC              ; Zähler  'Anzahl Dimensionen'  holen
        INC     B               ; Anzahl Dimensionen plus eins
        LD      A,B             ; Anzahl holen
        CP      3 + 1           ; mit maximaler Anzahl Dimensionen vergleichen
        JP      NC,A636A        ; zu viele Dimensionen -->  Fehler 3   Illegal data error
        EXX
        POP     HL              ; Zeiger für Ergebnis holen
        POP     DE              ; Offset auf Variablennamen holen
        EXX
        PUSH    DE              ; Index / Dimension merken
        EXX
        PUSH    DE              ; Offset auf Variablennamen wieder merken
        PUSH    HL              ; Zeiger für Ergebnis wieder merken
        EXX
        JR      A8C46           ; nächsten Index / Dimension bereitstellen
;
A8C8C:  POP     BC              ; Zähler  'Anzahl Dimensionen'  holen
        EXX
        POP     HL              ; Zeiger für Ergebnis holen
        POP     DE              ; Offset auf Variablennamen holen
        EXX
        INC     B               ; Anzahl Dimensionen plus eins
        PUSH    DE              ; Index / Dimension merken
        PUSH    HL              ; Programmzeiger merken
        EXX
        LD      HL,(STRST)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf Variablennamen errechnen
        LD      B,(HL)          ; Länge Name holen
        INC     B               ; für Länge corrigieren
        LD      DE,S11A4        ; Zeiger auf Speicher für Variablennamen
        CALL    LDDEHL          ; Speicherbereich von (HL) nach (DE) verschieben
        EXX
        SET     7,C             ; Code for 'indizierte Variable'
        CALL    A8ED6           ; Variable nach bereitgestelltem Namen suchen
        RES     7,C             ; Code wieder zurücksetzen
        JR      NC,A8D01        ; Variable nicht gefunden
        LD      A,B             ; jetzige Anzahl Dimensionen holen
        CP      (HL)            ; mit vorhandener Anzahl Dimensionen vergleichen
        JP      NZ,A6376        ; nicht gleich -->  Fehler 7  Array def. error
        INC     HL              ; Dimensionszähler überspringen
        EX      DE,HL           ; Zeiger auf Variabe nach DE
        POP     HL              ; Programmzeiger holen
        LD      (S9E6A),HL      ; und im Speicher merken
        EXX
        LD      HL,0            ; Vorgabe für Berechnung, welches Feldelement
        EXX
        EX      DE,HL
A8CBC:  LD      E,(HL)          ;! bei Dimensionierung angegebene Dimension holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL
        EX      (SP),HL         ; Zeiger auf Feld merken / Index holen
        PUSH    DE              ; vorhandene Dimensionen auf Stack ablegen
        EXX
        POP     DE              ; vorhandene Dimensionen holen
        CALL    A8DE8           ; HL = HL * DE   (Integer)
        EXX
        PUSH    HL              ; angegebenen Index merken
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; überprüfen, ob Index größer Dimensionierung
        JP      NC,A636A        ; ja -->  Fehler 3   Illegal data error
        EXX
        POP     DE              ; angegebenen Index holen
        CALL    A8DE4           ; HL und DE addieren mit Untersuchung auf Übertrag
        EXX
        POP     HL              ; Zeiger auf Feld holen
        DJNZ    A8CBC           ; weitere Dimensionen auswerten
        PUSH    HL              ; Zeiger auf Feld merken
        EXX
        LD      A,C             ; Variablentypflag holen
        LD      D,B             ; Null
        BIT     6,A             ; Code  FN  ?
        JR      NZ,A8CF4        ; ja
        AND     00001111B       ; Variablentyplänge maskieren
        LD      E,A             ; DE enthält Typlänge
        PUSH    AF              ; Variablentypflag retten
        CALL    A8DE8           ; HL = HL * DE   (Integer)
        PUSH    HL              ; Offset auf Wert merken
        EXX
        POP     BC              ; Offset auf Wert holen
        POP     AF              ; Variablentypflag holen
        POP     HL              ; Zeiger auf Anfang Feld holen
        ADD     HL,BC           ; Zeiger auf Wert  (Feldelement)  errechnen
        LD      C,L             ;! Zeiger auf Feldelement nach BC kopieren
        LD      B,H             ;!
A8CEF:  LD      HL,(S9E6A)      ; geretteten Programmzeiger holen
        POP     DE              ; Zeiger für Ergebnis holen
        RET
;
A8CF4:  LD      E,(HL)          ;! Länge FN holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        POP     HL              ; Zeiger auf Feld holen
        LD      C,L             ;! Zeiger auf FN nach BC kopieren
        LD      B,H             ;!
        LD      (HL),E
        INC     HL
        LD      (HL),D
        AND     00001111B       ; Variablentyp maskieren
        JR      A8CEF           ; Porgrammzeiger holen
;
;
;   Dimensionierte Variable noch nicht vorhanden
;
A8D01:  EXX
        LD      A,(S8E14)       ; Flag  'DIM - Aufruf' holen
        OR      A               ; Aufruf  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
                                ; wenn hier NOP's eingesetzt werden, wird beim ersten
                                ; Aufruf automatisch bis auf Index 10 dimensioniert
        POP     HL              ; Programmzeiger holen
        LD      (S9E6A),HL      ; und merken
        EXX
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        LD      L,B             ; Anzahl Dimensionen
        LD      H,0             ; High - Byte Anzahl auf Null
        ADD     HL,HL           ; Anzahl mal zwei
        ADD     HL,DE           ; plus Anfang Stringarbeitsbereich
        EX      DE,HL           ; nach DE
        INC     DE              ; für Zähler corrigieren
        CALL    A8C08           ; überprüfen, ob Adresse in DE mit Stack kollidiert
        LD      (HL),B          ; Anzahl Dimensionen eintragen
        INC     HL              ; Zeiger auf Stelle für Dimensionen
        EXX
        LD      HL,1            ; Vorgabe für Feldlängenerrechnung
        EXX
A8D23:  POP     DE              ; eine Dimension holen
        LD      A,(S8E14)       ; Flag  'DIM - Aufruf' holen
        OR      A               ; Aufruf  ?
        JR      NZ,A8D36        ; nein -->  Dimensionierung
        PUSH    HL              ; Zeiger auf Feld retten
        EX      DE,HL           ; Dimension nach DE
        LD      DE,10           ; Vorgabe Index bis 10 für nicht dimensionierte Variable
        SCF                     ;! überprüfen, ob angegebener Index größer ist
        SBC     HL,DE           ;!
        JP      NC,A636A        ; ja -->  Fehler 3   Illegal data error
        POP     HL              ; Zeiger auf Feld wieder holen
A8D36:  INC     DE              ; für Index Null corrigieren
        LD      (HL),E          ;! Anzahl Elemente dieser Dimension merken
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL              ; Zeiger für Felddaten
        PUSH    DE              ; Anzahl Elemente Dimension
        EXX
        POP     DE              ; Anzahl Elemente Dimension
        CALL    A8DE8           ; HL = HL * DE   (Integer)
        EXX
        DJNZ    A8D23           ; weitere Dimensionen
        LD      E,C             ; Variablentyplänge
        LD      D,0             ; High - Byte Länge auf Null
        PUSH    BC              ; Variablentyp - Länge merken
        PUSH    DE              ; Typ - Länge
        EXX
        POP     DE              ; Typ - Länge holen
        CALL    A8DE8           ; HL = HL * DE   (Speicherplatz für Feld errechnen)
        PUSH    HL              ; Gesamtfeldlänge
        EXX
        POP     BC              ; Gesamtfeldlänge holen
        PUSH    BC              ; und wieder merken
        EX      DE,HL
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        LD      L,(HL)          ; Anzahl Dimensionen holen
        LD      H,0             ; High - Byte Anzahl auf Null
        ADD     HL,HL           ; mal zwei
        LD      A,(S11A4)       ; Länge Feldname holen
        ADD     A,5             ; plus Stammdatenlänge
        ADD     A,L             ; plus Low - Byte Länge für Dimension
        LD      L,A             ; Low - Byte Feldlänge merken
        LD      A,0             ; Vorgabe Null
        ADC     A,H             ; High - Byte Länge corrigieren
        LD      H,A             ; High - Byte Feldlänge merken
        JR      C,A8D6C         ; Überlauf -->  Fehler 6  Memory error
        ADD     HL,BC           ; plus Länge für Felddaten
        JR      C,A8D6C         ; Überlauf -->  Fehler 6  Memory error
        PUSH    HL              ; Gesamtfeldlänge retten
        ADD     HL,DE           ; Zeiger auf Ende Feld errechnen
A8D6C:  JP      C,A63A7         ; Überlauf -->  Fehler 6  Memory error
        EX      DE,HL           ; Zeiger auf Ende Feld nach DE
        CALL    A8C08           ; überprüfen, ob Adresse in DE mit Stack kollidiert
        PUSH    HL              ; Zeiger auf Anfang Feld
        EXX
        POP     HL              ; Zeiger auf Anfang Feld
        LD      BC,(STRST)      ; Anfang Stringtextbereich holen
        DEC     BC              ; corrigieren
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; Länge der gespeicherten Strings errechnen
        PUSH    HL              ; und merken
        EXX
        POP     BC              ; Länge der gespeicherten Strings
        LDDR                    ; Stringtextbereich verschieben  (Platz für Feld schaffen)
        POP     DE              ; Gesamtfeldlänge holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    26              ; Code 26   Zeiger auf Stringbereiche corrigieren
        POP     BC              ; Länge Felddaten holen
        PUSH    DE              ; Gesamtfeldlänge auf Stack ablegen
        EXX
        POP     DE              ; Gesamtfeldlänge
        LD      H,B             ;! Zeiger auf Feldanfang
        LD      L,C             ;!
        POP     BC              ; Variablentypflag holen
        LD      A,C             ; Variablentypflag
        OR      10000000B       ; plus Code for 'dimensionierte Variable'
        LD      (HL),A          ; Variablentyp eintragen
        INC     HL              ; Zeiger auf Feld
        DEC     DE              ; Feldlänge corrigieren
        LD      (HL),E          ;! Offset auf Ende Feld eintragen
        INC     HL              ;!   Gesamtfeldlänge)
        LD      (HL),D          ;!
        INC     HL
        LD      DE,S11A4        ; Zeiger auf Variablennamen vorgeben
        LD      A,(DE)          ; Länge Variablenname holen
        INC     A               ; für Länge Variablenname corrigieren
        LD      B,A             ; Anzahl Zeichen merken
        CALL    LDHLDE          ; Speicherbereich von (DE) nach (HL) verschieben
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        LD      A,(DE)          ;! Anzahl Dimensionen übertragen
        LD      (HL),A          ;!
        INC     HL              ; Zeiger für Dimensionen
        INC     DE              ; Zeiger auf Dimensionen
        ADD     A,A             ; mal zwei   (zwei Byte je Dimension)
        LD      B,A             ; Anzahl zu übertragende Zeichen merken
        CALL    LDHLDE          ; Speicherbereich von (DE) nach (HL) verschieben
        PUSH    HL              ; Zeiger auf Felddatenbereich merken
        EXX
        POP     HL              ; Zeiger auf Felddatenbereich holen
A8DB0:  XOR     A               ; Accu auf Null
        LD      (HL),A          ; ein Byte Felddaten auf Null
        INC     HL              ; Zeiger auf Felddatenbereich
        DEC     BC              ; Restanzahl Bytes minus eins
        LD      A,B             ;! Restlänge gleich Null  ?
        OR      C               ;!
        JR      NZ,A8DB0        ; nein -->  weitere Bytes löschen
        LD      (HL),A          ; Code for 'Ende Bereich'  eintragen
        EXX
        POP     DE              ; Zeiger für Ergebnis holen
        LD      A,(S8E14)       ; Flag  'DIM - Aufruf' holen
        OR      A               ; Aufruf  ?
        JR      Z,A8DC5         ; ja -->  Wert bereitstellen
        LD      HL,(S9E6A)      ; Programmzeiger aus Speicher holen
        RET
;
A8DC5:  LD      HL,(S8E12)      ; Programmzeiger bei Anfang Dimensionierung holen
        PUSH    DE              ; Zeiger für Ergebnis retten
        JP      A8C23           ; Index auswerten und Wert Variable bereitstellen
;
;
;   Basic - Befehl   DIM     (Token code 150 / 096H)
;
A8DCC:  LD      A,-1            ; Code for 'DIM'
        LD      (S8E14),A       ; im Flag  'DIM - Aufruf' merken
A8DD1:  CALL    A8BB5           ; Variablennamen (HL) im Zwischenspeicher bereitstellen
        LD      A,(HL)          ; nächstes Programmbyte holen
        CALL    A79A6           ; Accu auf Syntax 'Klammer auf' überprüfen
        CALL    A8C14           ; angegebene Dimensionen auswerten und dimensionieren
        CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
        CP      ','             ; Komma  ?
        RET     NZ              ; nein -->  fertig
        INC     HL              ; Komma überspringen
        JR      A8DD1           ; weitere Variable dimensionieren
;
;
;   HL und DE addieren mit Untersuchung auf Übertrag
;
A8DE4:  ADD     HL,DE           ; Werte addieren
        RET     NC              ; Ergebnis ist OK
        JR      A8E0F           ; Übertrag -->  Fehler 6  Memory error
;
;
;   HL = HL * DE   mit Untersuchung auf Übertrag
;
A8DE8:  PUSH    BC              ; Keep register value
        EX      DE,HL           ; Faktoren vertauschen
        LD      C,L             ; Low - Byte Faktor
        LD      A,H             ; High - Byte Faktor
        LD      HL,0            ; Vorgabe für Ergebnis
        CALL    A8DF8           ; HL = HL * 256 + A * DE
        LD      A,C             ; Low - Byte Faktor holen
        CALL    A8DF8           ; HL = HL * 256 + A * DE
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   HL = HL * 256 + A * DE   mit Untersuchung auf Übertrag
;
A8DF8:  OR      A               ; Faktor gleich Null  ?
        JR      Z,A8E09         ; ja -->  nur altes Teilergebnis mal 256
        LD      B,8             ; 8 Bit multiplizieren
A8DFD:  ADD     HL,HL           ; altes Teilergebnis mal zwei
        JR      C,A8E0F         ; Übertrag -->  Fehler 6  Memory error
        RLCA                    ; ein Bit nach Carry schieben
        JR      NC,A8E06        ; nicht gesetzt -->  Stelle nicht addieren
        ADD     HL,DE           ; zweiten Faktor addieren
        JR      C,A8E0F         ; Übertrag -->  Fehler 6  Memory error
A8E06:  DJNZ    A8DFD           ; weitere Bits auswerten
        RET
;
A8E09:  LD      A,H             ; altes High - Byte holen
        LD      H,L             ; Low - Byte auf High - Byte schieben
        LD      L,0             ; Low - Byte auf Null
        OR      A               ; altes High - Byte gleich Null  ?
        RET     Z               ; ja -->  OK
A8E0F:  JP      A6373           ; zu hoch -->  Fehler 6  Memory error
;
S8E12:  DEFS    2               ; Programmzeiger bei Anfang Dimensionierung
S8E14:  DEFS    1               ; Flag  'DIM - Aufruf'
;
;
;   Wert der Variablen mit Namen (HL) bereitstellen
;
A8E15:  SUB     'A'             ;! Buchstabe im Accu  ?
        CP      26              ;!
        JP      NC,A6364        ; nein -->  Fehler 1  Syntax error
        LD      BC,(S9048)      ; Zeiger auf Parameter aktuelle FN  holen
        LD      A,B             ;! Zeiger vorhanden  ?
        OR      C               ;!
        JR      NZ,A8E36        ; ja -->  in selbstdefinierter Funktion
        CALL    A8B62           ; Variablennamen ausweten und Zeiger auf Variable liefern
A8E27:  PUSH    DE              ; Zeiger für Ergebnis merken
        PUSH    HL              ; Programmzeiger retten
        LD      L,C             ;! Zeiger auf Variablenwert / -descriptor
        LD      H,B             ;!
        LD      B,A             ; Variablentypflag merken
        LD      C,A             ; Variablentypflag
        CALL    LDDEHL          ; Speicherbereich von (HL) nach (DE) verschieben
        POP     HL              ; geretteten Programmzeiger holen
        LD      A,C             ; Variablentypflag holen
        POP     DE              ; Zeiger auf Ergebnis holen
        JP      A878F           ; bereitgestellten Wert retten
;
;
;   da in FN -->  überprüfen, ob Variable Parameter der Funktion ist
;
A8E36:  PUSH    DE              ; Zeiger für Ergebnis retten
        CALL    A8BB5           ; Variablennamen (HL) im Zwischenspeicher bereitstellen
        PUSH    HL              ; Programmzeiger retten
        INC     B               ; Länge Variablenname für Länge corrigieren
        LD      DE,S11A4        ; Zeiger auf bereitgestellten Variablennamen
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich übertragen
        LD      B,0             ; Zähler  'Anzahl Parameter'  auf Null
        LD      HL,(S9048)      ; Zeiger auf Parameter aktuelle FN  holen
        CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
        CP      ____EQ          ; Zwischencode  =  ?
        JR      Z,A8E80         ; ja -->  Funktion hat keine Parameter
        CP      '('             ; Klammer auf  ?
        JR      NZ,A8E7D        ; nein -->  Fehler 1  Syntax error
A8E55:  INC     HL              ; Programmzeiger auf nächstes Byte
        INC     B               ; Zähler  'Anzahl Dimensionen'  plus eins
        PUSH    BC              ; Zähler  'Anzahl Dimensionen'  retten
        CALL    A8BB5           ; Variablennamen (HL) im Zwischenspeicher bereitstellen
        LD      A,C             ; Variablentyp holen
        POP     DE              ; Funktions-Parameter-Typ / Anzahl Parameter
        CP      E               ; mit Typ Variablenname vergleichen
        LD      C,E             ; letzten Typ merken
        JR      NZ,A8E72        ; Typen nicht gleich
        PUSH    DE              ; FN - Parameter - Typ retten
        LD      C,B             ; Länge Variablenname
        INC     C               ; für Länge corrigieren
        PUSH    HL              ; Zeiger auf Parameter retten
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        LD      DE,S11A4        ; Zeiger auf Variablennamen bei FN - Aufruf
        CALL    A904C           ; Namen vergleichen
        POP     HL              ; Zeiger auf FN - Parameter holen
        POP     BC              ; FN - Parameter - Typ / Zähler  'Anzahl Parameter'
        JR      Z,A8E96         ; Variable ist FN - Parameter
A8E72:  CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
        CP      ')'             ; Klammer zu  ?
        JR      Z,A8E80         ; ja -->  Ende Parameterangabe
        CP      ','             ; Komma  ?
        JR      Z,A8E55         ; ja -->  weitere Parameter überprüfen
A8E7D:  JP      A6364           ; Fehler 1  Syntax error
;
;
;   Variablenname ist nicht FN - Parameter
;
A8E80:  LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        LD      DE,S11A4        ; Zeiger auf Speicher für Variablennamen
        LD      A,(HL)          ;! Länge Variablenname übertragen
        LD      (DE),A          ;!
        LD      B,A             ; Anzahl Zeichen Variablenname
A8E89:  INC     HL              ; Zeiger auf Variablennamen
        INC     DE              ; Zeiger für Variablennamen
        LD      A,(HL)          ;! ein Zeichen Variablenname übertragen
        LD      (DE),A          ;!
        DJNZ    A8E89           ; weitere Zeichen Variablenname übertragen
        POP     HL              ; Programmzeiger holen
        POP     DE              ; Zeiger für Ergebnis holen
        CALL    A8ED2           ; Zeiger auf Wert Variable bereitstellen
        JR      A8E27           ; Wert der Variablen bereitstellen
;
;
;   Variable als FN - Parameter gefunden
;
A8E96:  LD      HL,(S904A)      ; Programmzeiger bei FN - Aufruf holen
        CALL    A79A3           ; auf Syntax  'Klammer auf'  überprüfen
        DEC     B               ; Parameter - Zähler
        JR      Z,A8EB7         ; steht auf richtigem Parameter
        DEC     HL              ; Programmzeiger corrigieren
A8EA0:  PUSH    BC              ; Parameter - Zähler retten
A8EA1:  CALL    A6A0A           ; Zeiger in HL auf nächstes Befehlsbyte stellen
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A6364         ; Fehler 1  Syntax error
        CP      ')'             ; Klammer zu  ?
        JP      Z,A6364         ; Fehler 1  Syntax error
        CP      ','             ; Komma  ?
        JR      NZ,A8EA1        ; nein -->  Ende Parameter suchen
        POP     BC              ; Parameter - Zähler holen
        DJNZ    A8EA0           ; richtigen Parameter suchen
        INC     HL              ; Komma überspringen
A8EB7:  EX      DE,HL           ; Zeiger nach DE
        POP     HL              ; Programmzeiger holen
        EX      (SP),HL         ; Programmzeiger retten / Zeiger für Ergebnis holen
        EX      DE,HL           ; Zeiger Ergebnis nach DE / Zeiger Parameter nach HL
        LD      BC,(S9048)      ; Zeiger auf Parameter aktuelle FN  holen
        PUSH    BC              ; und retten
        LD      BC,0            ; Code for 'nicht in FN'
        LD      (S9048),BC      ; als Zeiger auf Parameter aktuelle FN  merken
        CALL    EXPR8           ; Ausdruck (HL) auswerten
        POP     HL              ; geretteten Zeiger auf Parameter aktuelle FN holen
        LD      (S9048),HL      ; als Zeiger auf Parameter aktuelle FN  merken
        POP     HL              ; Programmzeiger holen
        JP      HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
;
A8ED2:  PUSH    DE              ; Zeiger für Ergebnis retten
        JP      A8B66           ; Zeiger auf Wert Variable nach Namen (HL) bereitstellen
;
;
;   Variable nach bereitgestelltem Namen in vorhandenen Datensätzen suchen
;
A8ED6:  LD      HL,(VARST)      ; Anfang Basic - Variable holen
A8ED9:  LD      DE,S11A4        ; Zeiger auf bereitgestellten Namen
        LD      A,(HL)          ; Typflag der gespeicherten Variablen holen
        OR      A               ; Bereichsendezeichen  ?
        RET     Z               ; ja -->  Namen nicht gefunden
        CP      01000000B       ; Feld oder Funktion  ?
        JR      NC,A8F0A        ; ja
        CP      C               ; mit Namenwertcode vergleichen
        JR      NZ,A8EFF        ; falscher Typ
        INC     HL              ; Variablentypcode überspringen
        LD      A,(DE)          ;! Namenlänge vergleichen
        CP      (HL)            ;!
        JR      NZ,A8EFD        ; Längen stimmen nicht überein
        LD      B,A             ; Länge Name
A8EEC:  INC     DE              ; Zeiger auf vorgegebenen Namen
        INC     HL              ; Zeiger auf gespeicherten Namen
        LD      A,(DE)          ;! ein Zeichen Name vergleichen
        CP      (HL)            ;!
        JR      NZ,A8EF7        ; Namen nicht gleich
        DJNZ    A8EEC           ; weitere Zeichen Namen vergleichen
        INC     HL              ; Zeiger auf Wert stellen
        SCF                     ; Code for 'Variable gefunden'  setzen
        RET
;
;
;   Zeiger in HL auf Ende Variablenwert bereitstellen
;
A8EF7:  INC     HL              ; Zeiger auf Namen
        DJNZ    A8EF7           ; Zeiger auf Ende Namen stellen
        LD      A,C             ; Typflag holen
        JR      A8F04           ; Zeiger auf Ende Wert stellen
;
;
;   Zeiger in HL auf nächste Variable stellen
;
A8EFD:  LD      A,C             ; Typflag holen
        DEC     HL              ; Zeiger auf Anfang Datensatz
A8EFF:  AND     00001111B       ; Wertlänge maskieren
        INC     HL              ; Zeiger auf Namenlänge
        ADD     A,(HL)          ; Namenlänge addieren
        INC     HL              ; Zeiger auf Variablennamen
A8F04:  LD      E,A             ; Offset auf Ende Datensatz
        LD      D,0             ; High - Byte Offset auf Null
        ADD     HL,DE           ; Zeiger auf Ende Datensatz
        JR      A8ED9           ; nächsten Datensatz überprüfen
;
;
;   Typ bei dimensionierter Variable oder Funktion überprüfen
;
A8F0A:  CP      C               ; Typen vergleichen
        JR      Z,A8F21         ; richtiger Typ
        INC     HL              ; Zeiger auf Felddaten
A8F0E:  LD      E,(HL)          ;! Offset auf Ende Datensatz holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        DEC     HL              ;! Zeiger auf Ende Datensatz errechnen
        ADD     HL,DE           ;!
        JR      A8ED9           ; nächsten Datensatz überprüfen
;
;
;   Zeiger in HL auf Ende Feld / Funktion stellen
;
A8F15:  LD      A,C             ; Länge Name holen
        SUB     B               ; schon verglichene Zeichen abziehen
        CPL                     ; 2er Complement bilden
        LD      C,A             ; und merken
        LD      B,-1            ; BC enthält Offset auf Anfang in 2er CPL
        ADD     HL,BC           ; Zeiger auf Anfang Felddaten errechnen
        POP     BC
A8F1D:  DEC     HL
        DEC     HL
        JR      A8F0E           ; Offset auf Ende Feld holen und Zeiger richten
;
;
;   Feld- / Funktionsnamen vergleichen
;
A8F21:  LD      A,(HL)          ; Länge Name im Datensatz holen
        EXX
        LD      C,A             ; Länge Name
        LD      B,0             ; Zähler  'Anzahl verglichene Zeichen'
        EXX
        INC     HL              ; Zeiger auf Dimensionen
        PUSH    DE              ; Zeiger auf Namen
        LD      E,(HL)          ;! Offset auf Feldende holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL              ; Zeiger auf Feldnamen
        EX      DE,HL
        ADD     HL,DE           ; Zeiger auf Feldende errechnen
        EX      DE,HL
        POP     DE              ; Zeiger auf Namen holen
        LD      A,(DE)          ;! Namenlänge vergleichen
        CP      (HL)            ;!
        JR      NZ,A8F1D        ; Längen nicht gleich -->  nächsten Datensatz vergleichen
        PUSH    BC              ; Anzahl Dimensionen merken
        LD      B,A             ; Länge Name merken
        LD      C,A             ; Länge Name
A8F38:  INC     HL              ; Zeiger auf gespeicherten Namen
        INC     DE              ; Zeiger auf vorgegebenem Namen
        LD      A,(DE)          ;! ein Zeichen Name vergleichen
        CP      (HL)            ;!
        JR      NZ,A8F15        ; nicht gleich -->  nächsten Datensatz vergleichen
        DJNZ    A8F38           ; weitere Zeichen Name vergleichen
        INC     HL              ; Zeiger auf Dimensionierung stellen
        POP     BC              ; Anzahl Dimensionen holen
        SCF                     ; Code for 'Feld / Funktion gefunden'  setzen
        RET
;
;
;   Basic - Befehl   DEF FN
;
A8F44:  CALL    A8BB5           ; Variablennamen (HL) im Zwischenspeicher bereitstellen
        SET     6,C             ; Code for 'Funktion'  setzen
        PUSH    HL              ; Programmzeiger auf Anfang Funktion retten
        CALL    A8ED6           ; Variable nach bereitgestelltem Namen suchen
        JP      C,A6376         ; schon vorhanden -->  Fehler 7  Array def. error
        LD      (HL),C          ; Code for 'FN'  eintragen
        EX      (SP),HL         ; Programmzeiger holen / Zeiger für Funktion merken
        PUSH    HL              ; Programmzeiger auf Anfang Funktion merken
        DEC     HL              ; für Schleife corrigieren
A8F54:  CALL    A6A0A           ; Zeiger in HL auf nächstes Befehlsbyte stellen
        OR      A               ; Zeilenendezeichen  ?
        JR      Z,A8F5E         ; ja
        CP      ':'             ; Befehlsendezeichen  ?
        JR      NZ,A8F54        ; nein -->  Ende Befehl suchen
A8F5E:  POP     DE              ; Zeiger auf Anfang Funktionstext holen
        PUSH    HL              ; Zeiger auf Ende Funktionstext merken
        INC     HL              ;! Länge des Funktionstextes errechnen
        SBC     HL,DE           ;!
        LD      A,(S11A4)       ; Länge Funktionsname holen
        ADD     A,4             ; Stammdatenlänge für Funktion addieren
        LD      C,A             ; und merken
        LD      B,0             ; High - Byte auf Null
        LD      A,L             ; Länge Funktionstext holen
        ADD     HL,BC           ; Speicherplatzlänge für Funktion errechnen
        LD      B,A             ; Länge Funktionstext
        PUSH    HL              ; Speicherplatzlänge für Funktion
        EXX
        POP     BC              ; Speicherplatzlänge für Funktion holen
        PUSH    BC              ; und wieder merken
        PUSH    HL              ;! Register - Werte retten
        PUSH    DE              ;!
        PUSH    BC              ;!
        LD      HL,0            ;! Stackpointer holen
        ADD     HL,SP           ;!
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        DEC     H               ; mindestens 256 Byte Arbeitsbereich
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; freien Speicherplatz errechnen
        LD      A,12            ; Fehler 12  DEF FN nesting error
        JP      C,A63A9         ; Speicher zu klein -->  Fehler behandeln
        POP     BC              ;! gerettete Register - Werte wieder holen
        POP     DE              ;!
        POP     HL              ;!
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        PUSH    HL              ; und merken
        ADD     HL,BC           ; neues Ende errechnen
        EX      (SP),HL         ; neues Ende merken / altes Ende holen
        PUSH    HL              ; und merken
        LD      DE,(STRST)      ; Anfang Stringtextbereich holen
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; zu verschiebende Anzahl Bytes errechnen
        LD      C,L             ;! Anzahl zu verschiebende Bytes nach BC
        LD      B,H             ;!
        POP     HL              ; altes Ende holen
        POP     DE              ; neues Ende holen
        LDDR                    ; Platz für neue Funktion schaffen
        POP     DE              ; Speicherplatzlänge der Funktion holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    26              ; Code 26   Zeiger auf Stringbereiche corrigieren
        DEC     DE              ; Länge Funktion für Offset corrigieren
        POP     HL              ; Programmzeiger auf Ende Funktion holen
        EX      (SP),HL         ; Zeiger merken / Zeiger auf Stelle für Funktion
        INC     HL
        LD      (HL),E          ;! Offset auf Ende Funktion eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL
        LD      DE,S11A4        ; Zeiger auf bereitgestellten Funktionsnamen
        LD      A,(DE)          ;! Länge Funktionsname übertragen
        LD      (HL),A          ;!
        LD      B,A             ; Länge Funktionsname
A8FAE:  INC     DE              ; Zeiger auf Funktionsnamen
        INC     HL              ; Zeiger auf Speicher für Funktion
        LD      A,(DE)          ;! ein Zeichen Funktionsname übertragen
        LD      (HL),A          ;!
        DJNZ    A8FAE           ; weitere Zeichen Funktionsname übertragen
        INC     HL              ; letztes Zeichen Funktionsname überspringen
        PUSH    HL              ; Zeiger auf Speicher für Funktion
        EXX
        POP     HL              ; Zeiger auf Speicher für Funktion
        CALL    LDHLDE          ; Speicherbereich von (DE) nach (HL) verschieben
        LD      (HL),0          ; Code for 'Bereichsende'  eintragen
        POP     HL              ; Programmzeiger holen
        RET
;
;
;   Basic - Funktion   FN     (Token code 255 199 / 0FFH 0C7H)
;
A8FBF:  PUSH    DE              ; Zeiger für Ergebnis merken
        CALL    A8BB5           ; Variablennamen (HL) im Zwischenspeicher bereitstellen
        POP     IX              ; Zeiger für Ergebnis holen
        PUSH    BC              ; Länge Funktionsname retten
        SET     6,C             ; Code for 'Funktionsname'  setzen
        LD      DE,(S904A)      ; alten Programmzeiger bei FN - Aufruf holen
        LD      (S904A),HL      ; neuen Programmzeiger bei FN - Aufruf merken
        PUSH    DE              ; alten Programmzeiger retten
        CALL    A8ED6           ; Variable nach bereitgestelltem Namen suchen
        JP      NC,A6382        ; Funktion nicht gefunden -->  Fehler 15  Un def. function error
        LD      DE,(S9048)      ; Zeiger auf Parameter aktuelle FN  holen
        LD      (S9048),HL      ; Zeiger auf Parameter aktuelle FN  merken
        PUSH    DE              ; alten Zeiger auf Funktionsparameter retten
        PUSH    IX              ; Zeiger auf Speicher für Ergebnis retten
        DEC     HL              ; Zeiger auf Funktion corrigieren
A8FE1:  CALL    A6A0A           ; Zeiger in HL auf nächstes Befehlsbyte stellen
        CALL    A5963           ; überprüfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A6364         ; Zeilenende -->  Fehler 1  Syntax error
        CP      ____EQ          ; Zwischencode  =  ?
        JR      NZ,A8FE1        ; nein -->  Anfang Funktionstext suchen
        INC     HL              ; Zwischencode = überspringen
        POP     DE              ; Zeiger für Ergebnis holen
        PUSH    DE              ; und wieder merken
        CALL    EXPR8           ; Ausdruck (HL) mit allen Prioritäten auswerten
        POP     DE              ; Zeiger auf Ergebnis holen
        LD      HL,(S904A)      ; Programmzeiger bei FN - Aufruf holen
        POP     BC              ; alten Zeiger auf Funktionsparameter holen
        LD      (S9048),BC      ; Zeiger auf Parameter aktuelle FN  merken
        POP     BC              ; alten Programmzeiger bei FN - Aufruf holen
        LD      (S904A),BC      ; Programmzeiger bei FN - Aufruf merken
        EX      DE,HL           ; Zeiger auf bereitgestellten Wert nach HL
        POP     BC
        LD      A,C             ; Funktionstyp holen
        CALL    A9032           ; auf Syntax 'zwei gleiche Ergebnistypen'  untersuchen
        LD      BC,5            ; Länge bereitgestellter Wert
        ADD     HL,BC           ; bereitgestellten Wert retten
        EX      DE,HL           ; Zeiger für Wert nach DE / Programmzeiger nach HL
        CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
        CP      '('             ; Klammer auf  ?
        RET     NZ              ; nein -->  Funktion hat keine Parameter
        PUSH    DE              ; Zeiger für Ergebnis merken
        LD      B,1             ; Code for 'eine Klammer suchen'
A9016:  PUSH    BC              ; Zähler retten
        CALL    A6A0A           ; Zeiger in HL auf nächstes Befehlsbyte stellen
        POP     BC              ; Parameterzähler holen
        CALL    A5966           ; testen, ob Accu gleich Befehlsendezeichen
        JP      Z,A6364         ; Fehler 1  Syntax error
        CP      '('             ; Klammer auf  ?
        JR      NZ,A9026        ; nein
        INC     B               ; Klammerzähler plus eins
A9026:  CP      ')'             ; Klammer zu  ?
        JR      NZ,A9016        ; nein -->  Ende Parameter suchen
        DJNZ    A9016           ; richtige Anzahl  'Klammer zu'  suchen
        INC     HL              ; Klammer zu überspringen
        CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
        POP     DE              ; Zeiger für Ergebnis holen
        RET
;
;
;   auf Syntax 'zwei gleiche Ergebnistypen'  untersuchen
;
A9032:  CP      3               ; erster Wert vom Typ String  ?
        JR      NZ,STROMT       ; nein -->  Syntaxuntersuchung auf Real - Wert - Ergebnis
;
;
;   Syntaxuntersuchung auf Zeichenkettenergebnis
;
A9036:  LD      A,(S9E9C)       ; Wertart - Flag des bereitgestellten Wertes holen
        CP      3               ; Stringwert  ?
        RET     Z               ; ja -->  OK
        JP      A636D           ; Fehler 4   Type mismatch error
;
;
;   Syntaxuntersuchung auf Real - Wert - Ergebnis
;
STROMT: LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        CP      3               ; Stringwert  ?
        RET     NZ              ; nein -->  OK
        JP      A636D           ; Fehler 4   Type mismatch error
;
S9048:  DEFS    2               ; Zeiger auf Parameter der aktuellen Funktion
S904A:  DEFS    2               ; Programmzeiger bei Funktionsaufruf

;
;   Variablennamen vergleichen
;
A904C:  LD      A,(DE)          ;! Länge Variablennamen vergleichen
        CP      (HL)            ;!
        RET     NZ              ; Namenlängen nicht gleich
        PUSH    BC              ;! Register - Werte retten
        PUSH    DE              ;!
        PUSH    HL              ;!
        LD      B,C             ; Anzahl zu vergleichende Zeichen
A9053:  LD      A,(DE)          ;! ein Zeichen Variablennamen vergleichen
        CP      (HL)            ;!
        JR      NZ,A905C        ; Namen nicht gleich
        INC     DE              ;! Zeiger auf Namen auf nächstes Zeichen
        INC     HL              ;!
        DJNZ    A9053           ; weitere Zeichen Variablenname vergleichen
        XOR     A               ; Code for 'Variablenname gleich'
A905C:  POP     HL              ;! gerettete Register - Werte holen
        POP     DE              ;!
        POP     BC              ;!
        RET
;
;
;   Basic - Funktion   STICK     (Token code 255 156 / 0FFH 09CH)
;
A9060:  CALL    A79A3           ; auf Syntax 'Klammer auf' untersuchen
        PUSH    DE              ; Zeiger für Ergebnis retten
        CALL    DEEXP           ; Ausdruck (HL) auswerten und 2-Byte Wert nach DE
        CALL    DCHECK          ; untersuchen, ob Wert in DE zwischen 0 und 255 liegt
        CP      2 + 1           ; bekannte Joy - Stick - Nummer  ?
        JP      NC,A636A        ; nein -->  Fehler 3  Illegal data error
        POP     DE              ; Zeiger auf Stelle für Ergebnis holen
        PUSH    AF              ; Joy - Stick - Nummer retten
        CALL    A79AA           ; auf Syntax 'Klammer zu' untersuchen
        POP     AF              ; gerettete Joy - Stick - Nummer holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    30              ; Code 30   Joy - Stick nach Richtung abfragen
        EX      DE,HL           ; Programmzeiger nach DE/Zeiger für Ergebnis nach HL
        PUSH    DE              ; Programmzeiger retten
        CALL    A887D           ; Wert im Accu umsetzen in Real - Wert nach (HL)
        JP      A8964           ; bereitgestellten Wert retten und Programmzeiger holen
;
;
;   Basic - Funktion   STRIG     (Token code 255 157 / 0FFH 09DH)
;
A907F:  CALL    A79A3           ; auf Syntax 'Klammer auf' untersuchen
        PUSH    DE              ; Zeiger für Ergebnis retten
        CALL    DEEXP           ; Ausdruck (HL) auswerten und 2-Byte Wert nach DE
        CALL    DCHECK          ; untersuchen, ob Wert in DE zwischen 0 und 255 liegt
        CP      4 + 1           ; mit maximaler Feuerknopf - Nummer vergleichen
        JP      NC,A636A        ; zu groß -->  Fehler 3  Illegal data error
        POP     DE              ; Zeiger für Ergebnis holen
        PUSH    AF              ; Feuerknopf - Nummer merken
        CALL    A79AA           ; auf Syntax 'Klammer zu' untersuchen
        POP     AF              ; gerettete Feuerknopf - Nummer abfragen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    31              ; Code 31   Feuerknopf des Joy - Sticks abfragen
        EX      DE,HL           ; Programmzeiger nach DE / Zeiger für Ergebnis nach HL
        PUSH    DE              ; Programmzeiger retten
        CALL    A887D           ; Wert im Accu umsetzen in Real - Wert nach (HL)
        JP      A8964           ; bereitgestellten Wert retten und Programmzeiger holen
;
;
;   Null im Real - Format nach (HL) eintragen
;
A909E:  PUSH    HL              ; Zeiger auf Speicher für Zahl retten
        LD      B,5             ; Länge Real - Zahlwert
        CALL    CLRHL           ; Speicherbereich (HL) löschen
        POP     HL              ; Zeiger auf Speicher für Zahl holen
        RET
;
;
;   Vorzeichen des Wertes (HL) umkehren
;
A90A6:  CALL    STROMT          ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
A90A9:  LD      A,(HL)          ; Exponenten des Zahlwertes holen
        OR      A               ; gleich Null  ?
        RET     Z               ; Wert gleich Null -->  fertig
        INC     HL              ; Zeiger auf MSByte Mantisse Zahl
        LD      A,(HL)          ; MSByte Mantisse holen
        XOR     10000000B       ; Vorzeichenflag umkehren
        LD      (HL),A          ; neues MSByte eintragen
        DEC     HL              ; Zeiger wieder auf Exponent
        RET
;
;
;   Basic - Funktion   -
;
A90B3:  CALL    STROMT          ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
        LD      C,A             ; Länge Real - Wert merken
        LD      A,10000000B     ; Code for 'Minus'
        JP      A90C6           ; Einsprung in Routine
;
;
;   Basic - Funktion   +
;
A90BC:  LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        CP      3               ; Stringwert  ?
        JP      Z,A9110         ; ja -->  zwei Strings addieren
        LD      C,A             ; Wertlänge merken
        XOR     A               ; Code for 'Plus'
A90C6:  LD      (S94C0),HL      ; Zeiger auf Speicher für Ergebnis merken
        PUSH    DE              ;! Zeiger auf Argumente retten
        PUSH    HL              ;!
        LD      (S94C3),SP      ; Stackpointer merken
        INC     HL              ;! Zeiger auf Vorzeichen der Argumente
        INC     DE              ;! stellen
        LD      B,(HL)          ;! Vorzeichen des Ergebnisses errechnen
        XOR     (HL)            ;!
        EX      DE,HL           ;!
        XOR     (HL)            ;!
        DEC     HL              ;! Zeiger wieder auf Exponenten
        DEC     DE              ;!
        EX      DE,HL
        RLCA                    ; Rechenbit nach Carry schieben
        LD      A,B             ; Vorzeichen holen
        LD      (S94C2),A       ; Vorzeichen Ergebnis merken
        JP      C,A91D1         ; Zahlen voneinander subtrahieren
        XOR     A               ; Accu auf Null
        CP      (HL)            ; mit Exponent erstes Argument vergleichen
        JP      Z,A9105         ; 1. Wert = 0 -->  Ergebnis ist zweites Argument
        LD      A,(DE)          ; Exponent zweites Argument holen
        OR      A               ; gleich Null  ?
        JR      Z,A90ED         ; ja -->  Ergebnis ist erstes Argument
        SUB     (HL)            ; Exponentendifferenz errechnen
        JP      A9214           ; Mantissen angleichen und Zahlen addieren
;
;
;   erstes Argument plus errechnetes Vorzeichen als Ergebnis vorgeben
;
A90ED:  LD      SP,(S94C3)      ; Stackpointer holen
        POP     HL              ;! gerettete Zeiger auf Argumente holen
        POP     DE              ;!
        EI                      ; Interrupt freigeben
        LD      A,(HL)          ; Exponenten holen
        OR      A               ; gleich Null ?
        JP      Z,A95BD         ; ja -->  Absolut - Wert bilden
        LD      A,(S94C2)       ; Vorzeichen Ergebnis holen
        AND     10000000B       ; Vorzeichenbit maskieren
        INC     HL              ; Zeiger auf MSByte Mantisse
        RES     7,(HL)          ; Wert auf positives Vorzeichen
        OR      (HL)            ; plus neues Vorzeichen
        LD      (HL),A          ; MSByte Mantisse wieder merken
        DEC     HL              ; Zeiger auf Exponent Ergebnis
        RET
;
;
;   zweites Argument und errechnetes Vorzeichen als Ergebnis vorgeben
;
A9105:  LD      B,0             ; High - Byte Anzahl auf Null
        LD      A,5             ; Länge  Real - Wert
        LD      C,A             ; vorgeben
        EX      DE,HL           ; Zeiger vertauschen
        LDIR                    ; zweites Argument auf erstes Argument übertragen
        JP      A90ED           ; Vorzeichen Ergebnis richten
;
;
;   zwei Zeichenketten addieren
;
A9110:  LD      B,(HL)          ; Länge erste Zeichenkette holen
        LD      A,(DE)          ; Länge zweite Zeichenkette holen
        ADD     A,B             ; neue Zeichenkettenlänge errechnen
        JP      C,A6370         ; Übertrag -->  Fehler 5  String length error
        LD      C,A             ; Länge der neuen Zeichenkette merken
        PUSH    DE              ; Zeiger auf zweiten Zeichenkettendescriptor
        PUSH    HL              ; Zeiger auf ersten Zeichenkettendescriptor
        PUSH    DE              ; Zeiger auf zweiten Zeichenkettendescriptor
        INC     HL              ; Länge der ersten Zeichenkette überspringen
        LD      E,(HL)          ;! Offset auf Zeichenkette aus Descriptor holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      HL,(STRST)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf Zeichenkette errechnen
        EX      DE,HL           ; und in DE merken
        LD      HL,(TMPEND)     ; Ende Stringarbeitsbereich holen
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich übertragen
        EX      (SP),HL         ; Zeiger auf zweiten Descriptor holen
        LD      B,(HL)          ; Länge zweite Zeichenkette holen
        INC     HL
        LD      E,(HL)          ;! Offset auf Zeichenkette aus Descriptor holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      HL,(STRST)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf String errechnen
        EX      DE,HL           ; und nach DE
        POP     HL              ; Zeiger auf Ende des ersten Strings holen
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich übertragen
        LD      A,C             ; Länge neuer String holen
        LD      DE,(TMPEND)     ; Ende Stringarbeitsbereich holen
        LD      BC,(STRST)      ; Anfang Stringtextbereich holen
        EX      DE,HL
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,BC           ; Offset auf neuen String errechnen
        EX      DE,HL           ; Zeiger auf Ende String nach HL
        LD      (TMPEND),HL     ; Ende Stringarbeitsbereich merken
        POP     HL              ; Zeiger für Ergebnis holen
        LD      (HL),A          ; Länge des neuen Strings eintragen
        INC     HL
        LD      (HL),E          ;! Offset auf String in Descriptor eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        DEC     HL              ;! Zeiger wieder auf Anfang Descriptor setzen
        DEC     HL              ;!
        POP     DE              ; geretteten Register - Wert holen
        RET
;
;
;   zwei Zahlen oder Zeichenketten vergleichen
;
A9153:  LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        CP      3               ; Strings  ?
        JR      NZ,A918E        ; nein -->  Zahlwerte vergleichen
;
;
;   Zeichenketten mit Descriptoren (HL) und (DE) vergleichen
;
        PUSH    DE              ; Zeiger auf zweiten Stringdescriptor
        PUSH    HL              ; Zeiger auf ersten Stringdescriptor
        LD      A,(DE)          ;! Stringlängen gleich Null  ?
        OR      (HL)            ;!
        JR      Z,A918B         ; ja -->  Strings gleich
        LD      A,(DE)          ;! Stringlängen vergleichen
        CP      (HL)            ;!
        JR      C,A9165         ; zweiter String ist länger
        LD      A,(HL)          ; kleinere Länge holen
A9165:  OR      A               ; gleich Null  ?
        JR      Z,A9185         ; ja
        INC     HL              ; Stringlänge überspringen
        LD      C,(HL)          ;! Offset auf ersten String aus Descriptor
        INC     HL              ;! holen
        LD      B,(HL)          ;!
        EX      DE,HL           ; Zeiger auf zweiten Descriptor nach HL
        INC     HL              ; Stringlänge überspringen
        LD      E,(HL)          ;! Offset auf zweiten String aus Descriptor
        INC     HL              ;! holen
        LD      D,(HL)          ;!
        LD      HL,(STRST)      ; Anfang Stringtextbereich holen
        EX      DE,HL
        ADD     HL,DE           ; Zeiger auf zweiten String errechnen
        EX      DE,HL
        ADD     HL,BC           ; Zeiger auf ersten String errechnen
        EX      DE,HL
        LD      B,A             ; zu vergleichende Anzahl merken
        OR      A               ; zu vergleichende Anzahl gleich Null ?
        JR      Z,A918B         ; ja
A917D:  LD      A,(DE)          ;! ein Zeichen vergleichen
        CP      (HL)            ;!
        JR      NZ,A918B        ; nicht gleich -->  Vergleich entschieden
        INC     DE              ;! Zeiger auf Strings auf nächstes Zeichen
        INC     HL              ;!
        DJNZ    A917D           ; weitere Zeichen vergleichen
A9185:  POP     DE              ;! Zeiger auf Descriptoren holen
        POP     HL              ;!
        LD      A,(DE)          ;! Stringlängen vergleichen
        CP      (HL)            ;!
        EX      DE,HL
        RET
;
A918B:  POP     HL              ;! Zeiger auf Stringdescriptoren holen
        POP     DE              ;!
        RET
;
;
;   zwei Real - Zahlwerte vergleichen
;
A918E:  INC     DE              ;! Zeiger auf Mantissen der Zahlen
        INC     HL              ;!
        LD      A,(DE)          ; Vorzeichen zweiter Wert holen
        DEC     DE              ; Zeiger wieder auf Exponent
        XOR     (HL)            ; Vorzeichen erster Wert
        RLCA                    ; Vorzeichen nach Carry schieben
        JR      NC,A919A        ; Vorzeichen der Werte gleich
        LD      A,(HL)          ; Vorzeichen erster Wert holen
        DEC     HL              ; Zeiger wieder auf Exponenten
        RLCA                    ; Vorzeichen nach Carry schieben
        RET
;
A919A:  LD      A,(HL)          ; Vorzeichen erster Wert holen
        DEC     HL              ; Zeiger wieder auf Exponenten
        RLCA                    ; Vorzeichen nach Carry schieben
        JR      NC,A91A5        ; Werte sind positiv
        CALL    A91A5           ; Real-Zahlen (HL) ohne Vorzeichen vergleichen
        RET     Z               ; Zahlen sind gleich
        CCF                     ; Ergebnis umkehren
        RET
;
;
;   Real - Zahlen  (HL) und (DE)  ohne Vorzeichen vergleichen
;
A91A5:  PUSH    DE              ;! Zeiger auf Zahlwerte retten
        PUSH    HL              ;!
        EX      DE,HL
        LD      A,(DE)          ;! Exponenten der Zahlen vergleichen
        CP      (HL)            ;!
        JR      NZ,A91C6        ; Exponenten nicht gleich
        INC     DE              ;! Zeiger auf Mantissen der Zahlen
        INC     HL              ;!
        LD      A,(HL)          ; Mantisse erster Wert holen
        OR      10000000B       ; Vorzeichen auf 'minus'
        LD      B,A             ; und Byte merken
        LD      A,(DE)          ; Mantissen zweiter Wert holen
        OR      10000000B       ; Vorzeichen auf 'minus'
        CP      B               ; MSBytes der Mantissen vergleichen
        JR      NZ,A91C6        ; Werte nicht gleich
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        LD      B,A             ; als Länge Zahl merken
        DEC     B               ; für Exponenten corrigieren
        DEC     B               ; für MSByte corrigieren
A91BE:  INC     DE              ;! Zeiger auf Mantissen auf nächstes Byte
        INC     HL              ;!
        LD      A,(DE)          ;! ein Byte der Mantissen vergleichen
        CP      (HL)            ;!
        JR      NZ,A91C6        ; Zahlen nicht gleich
        DJNZ    A91BE           ; weitere Bytes vergleichen
A91C6:  POP     HL              ;! gerettete Zeiger auf Werte holen
        POP     DE              ;!
        RET
;
;
;   Ergebnis gleich  'Null'  vorgeben
;
A91C9:  POP     HL              ; Zeiger für Ergebnis holen
        PUSH    HL              ; und wieder merken
        CALL    A909E           ; Null im Real - Format nach (HL) eintragen
        JP      A90ED           ; Stackpointer corrigieren
;
;
;   Zahlen (HL) und (DE) subtrahieren
;
A91D1:  CALL    A91A5           ; Real-Zahlen (HL) und (DE) ohne Vorzeichen vergleichen
        JR      Z,A91C9         ; Zahlen gleich -->  Ergebnis gleich Null
        JR      NC,A91E1        ; erster Wert ist größer zweiter Wert
        LD      A,(S94C2)       ; Vorzeichen Ergebnis holen
        XOR     10000000B       ; Vorzeichen umkehren
        LD      (S94C2),A       ; und wieder merken
        SCF                     ; Code for '2tes Argument größer'
A91E1:  EX      AF,AF           ; merken
        LD      A,(HL)          ; Exponent erstes Artgument holen
        OR      A               ; gleich Null  ?
        JP      Z,A9105         ; ja -->  zweites Argument als Ergebnis vorgeben
        LD      A,(DE)          ; Exponent zweites Argument holen
        OR      A               ; gleich Null  ?
        JP      Z,A90ED         ; ja -->  erstes Argument als Ergebnis vorgeben
        SUB     (HL)            ; Exponentendifferenz errechnen
        JR      C,A91F6         ; erstes Argument ist größer
        CP      4 * 8           ; erlaubte Exponentendifferenz maximal
        JP      NC,A9105        ; erstes Argument zu klein -->  Eregbnis 2tes Argument
        JR      A91FD           ; Exponenten angleichen
;
A91F6:  NEG                     ; 2er Complement der Exponentendifferenz bilden
        CP      4 * 8           ; erlaubte Exponentendifferenz maximal
        JP      NC,A90ED        ; 2tes Argument zu klein -->  Ergebnis ist 1tes Argument
A91FD:  EX      AF,AF           ; Flag  '2tes Argument größer'  holen
        JR      C,A9201         ; 2tes Argument ist größer
        EX      DE,HL           ; Zeiger auf Argumente vertauschen
A9201:  EX      AF,AF           ; Exponentendifferenz holen
        JP      A929B           ; Zahlen voneinander subrahieren
;
A9205:  LD      SP,(S94C3)      ; Stackpointer holen
        EI                      ; Interrupt freigeben
        POP     HL              ;! Zeiger auf Argumente holen
        POP     DE              ;!
        LD      A,(S94CA)
        OR      A
        JP      Z,A6367         ; Fehler 2   Overflow error
        RET
;
;
;   Zahlen (HL) und (DE) addieren
;
A9214:  JR      NC,A9220        ; 2tes Argument ist größer
        NEG                     ; 2er Complement der Exponentendifferenz bilden
        CP      4 * 8           ; erlaubte Exponentendifferenz maximal
        JP      NC,A90ED        ; Ergebnis ist 2tes Argument
        EX      DE,HL           ; Zeiger vertauschen
        JR      A9225           ; Mantissen angleichen und Zahlen addieren
;
A9220:  CP      4 * 8           ; erlaubte Exponentendifferenz maximal
        JP      NC,A9105        ; 2tes Argument zu klein -->  1tes Argument als Ergebnis
A9225:  CALL    A925B           ; Mantissen angleichen und Werte in Register laden
        LD      A,H             ;! 4tes Byte Mantisse addieren
        EXX                     ;!
        ADC     A,H             ;!
        EXX
        LD      H,A             ; Ergebnis merken
        LD      A,L             ;! 3tes Byte Mantisse addieren
        EXX                     ;!
        ADC     A,L             ;!
        EXX
        LD      L,A             ; Ergebnis merken
        LD      A,D             ;! 2tes Byte Mantisse addieren
        EXX                     ;!
        ADC     A,D             ;!
        EXX
        LD      D,A             ; Ergebnis merken
        LD      A,E             ;! 1tes Byte Mantisse addieren
        EXX                     ;!
        ADC     A,E             ;!
        EXX
        JR      NC,A9248        ; kein Übertrag
        RRA                     ;! Mantisse entsprechend Übertrag
        RR      D               ;! corrigieren
        RR      L               ;!
        RR      H               ;!
        INC     C               ; Exponent plus eins
        JP      Z,A9205         ; Exponent zu groß
A9248:  LD      E,A             ; MSByte Mantisse merken
        LD      A,C             ; Exponent Ergebnis holen
        EXX
        LD      BC,5            ; Länge Real - Wert
        LD      HL,(S94C0)      ; Zeiger auf Speicher für Ergebnis holen
        LD      (HL),A          ; Exponenten eintragen
        ADD     HL,BC           ; Zeiger auf Ende Mantisse
        DI                      ; Interrupt sperren
        LD      SP,HL           ; Stackpointer auf Ende Mantisse setzen
        EXX
        PUSH    HL              ; LSBytes Mantisse ablegen
        PUSH    DE              ; MSBytes Mantisse ablegen
        JP      A90ED           ; Stackpointer richten und Vorzeichen eintragen
;
;
;   Mantissen entsprechend Exponentendifferenz angleichen
;   und Werte in Register laden
;
A925B:  DI                      ; Interrupt sperren
        LD      (S94C5),SP      ; Stackpointer bei Interruptsperrung merken
        EX      AF,AF           ; Exponentenzähler retten
        INC     HL              ; Zeiger auf Mantisse
        LD      SP,HL           ; Stackpointer setzen
        EXX
        POP     DE              ; zwei MSBytes Mantisse holen
        SET     7,E             ; erstes Bit der Mantisse setzen
        POP     HL              ; zwei LSBytes Mantisse holen
        OR      A               ; Carry - Flag zurücksetzen
A9269:  EX      AF,AF           ; Exponentendifferenz holen
        CP      8               ; größer oder gleich acht  ?
        JR      C,A927A         ; nein -->  einzeln schieben
        SUB     8               ; Differenz minus acht
        EX      AF,AF           ; Rest Exponentendifferenz retten
        RL      H               ; Rundungsbit nach Carry schieben
        LD      H,L             ;! Mantisse um acht Bit  (1 Byte) schieben
        LD      L,D             ;!
        LD      D,E             ;!
        LD      E,0             ;!
        JR      A9269           ; überprüfen, ob Mantissen angeglichen
;
A927A:  OR      A               ; Differenz gleich Null  ?
        JR      Z,A928B         ; ja -->  zweites Argument laden
A927D:  EX      AF,AF           ; Restdifferenz retten
        OR      A               ; Carry - Flag zurücksetzen
        RR      E               ;! Mantissen um ein Bit schieben
        RR      D               ;!
        RR      L               ;!
        RR      H               ;!
        EX      AF,AF           ; Rest Exponentendifferenz holen
        DEC     A               ; Zähler minus eins
        JR      NZ,A927D        ; weiter angleichen
A928B:  EXX
        EX      DE,HL           ; Zeiger auf 2tes Argument nach HL
        LD      C,(HL)          ; Exponenten holen
        INC     HL              ; Zeiger auf MSByte Mantisse
        LD      SP,HL           ; Stackpointer setzen
        POP     DE              ; MSBytes Mantisse holen
        SET     7,E             ; erstes Bit der Mantisse setzen
        POP     HL              ; LSBytes Mantisse holen
        EX      AF,AF           ; Bit für Rundung holen
        LD      SP,(S94C5)      ; Stackpointer bei Interruptsperrung holen
        EI                      ; Interrupt wieder freigeben
        RET
;
;
;   Zahl (DE) von Zahl (HL) subtrahieren
;
A929B:  CP      4 * 8           ; Exponentendifferenz maximal
        JP      NC,A90ED        ; zu groß -->  Ergebnis ist 1tes Argument
        CALL    A925B           ; Mantissen angleichen und Werte in Register laden
        LD      A,H             ;! 4tes Byte subtrahieren
        EXX                     ;!
        SBC     A,H             ;!
        EXX
        LD      H,A             ; Ergebnis merken
        LD      A,L             ;! 3tes Byte subtrahieren
        EXX                     ;!
        SBC     A,L             ;!
        EXX
        LD      L,A             ; Ergebnis merken
        LD      A,D             ;! 2tes Byte subtrahieren
        EXX                     ;!
        SBC     A,D             ;!
        EXX
        LD      D,A             ; Ergebnis merken
        LD      A,E             ;! 1tes Byte subtrahieren
        EXX                     ;!
        SBC     A,E             ;!
        EXX
A92B6:  OR      A               ; MSByte Ergebnis gleich Null  ?
        JR      Z,A92CF         ; ja -->  Ergebnis um 8 Bit schieben
A92B9:  BIT     7,A             ; MSBit Ergebnis Mantisse gesetzt  ?
        JR      NZ,A92CB        ; ja -->  Mantisse hat internes Format
        RL      H               ;! Mantisse Ergebnis um ein Bit schieben
        RL      L               ;!
        RL      D               ;!
        RLA                     ;!
        DEC     C               ; Exponenten corrigieren
        JP      NZ,A92B9        ; weiter für internes Format corrigieren
        JP      A91C9           ; Ergebnis gleich Null
;
A92CB:  LD      E,A             ; MSByte Mantisse Ergebnis
        JP      A9248           ; Ergebnis in Speicher ablegen
;
;
;   Ergebnis für internes Format um mehr als 8 Bit corrigieren
;
A92CF:  LD      A,C             ; Exponenten holen
        SUB     8               ; minus acht
        LD      C,A             ; neuen Exponenten merken
        LD      A,D             ;! Mantisse um acht Bit schieben
        LD      D,L             ;!
        LD      L,H             ;!
        LD      H,0             ;!
        JR      Z,A92DC         ; Exponent gleich Null -->  Ergebnis gleich Null
        JR      NC,A92B6        ; überprüfen, ob internes Format stimmt
A92DC:  JP      A91C9           ; Ergebnis gleich Null vorgeben
;
;
;   Vorzeichen Ergebnis für Division oder Multiplikation errechnen
;
A92DF:  LD      C,A             ; Länge Zahl merken
        INC     HL              ;! Zeiger auf Mantisse stellen
        INC     DE              ;!
        LD      A,(DE)          ; MSByte Mantisse 1ter Wert
        XOR     (HL)            ; MSByte Mantisse 2ter Wert
        LD      (S94C2),A       ; Vorzeichen Ergebnis merken
        DEC     HL              ;! Zeiger auf Werte wieder auf Exponent
        DEC     DE              ;!
        RET
;
;
;   Basic - Funktion   *
;
A92EA:  CALL    STROMT          ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
        CALL    A92DF           ; Vorzeichen Ergebnis errechnen
        PUSH    DE              ;! Zeiger auf Argumente retten
        PUSH    HL              ;!
        LD      (S94C3),SP      ; Stackpointer merken
        LD      A,(HL)          ; Exponent 1tes Argument holen
        OR      A               ; gleich Null  ?
        JP      Z,A91C9         ; ein Faktor gleich Null -->  Ergebnis gleich Null
        LD      A,(DE)          ; Exponent 2tes Argument holen
        OR      A               ; gleich Null  ?
        JP      Z,A91C9         ; ein Faktor gleich Null -->  Ergebnis gleich Null
        INC     DE              ; Zeiger auf Mantisse
        PUSH    DE              ;! nach IX
        POP     IX              ;!
        ADD     A,(HL)          ; plus Exponent 1ter Wert
        LD      E,A             ; Low - Byte Exponentenzähler
        LD      A,0             ;! eventuellen Übertrag erfassen
        ADC     A,A             ;!
        LD      D,A             ; High - Byte Exponentenzähler
        LD      (S94C8),DE      ; Exponentenzähler für Ergebnis merken
        INC     HL              ; Zeiger auf Mantisse
        XOR     A               ; Accu auf Null
        LD      (S94C7),A       ; Flag  'Übertrag aufgetreten'  zurücksetzen
        LD      D,(HL)          ; MSByte Mantisse 1te Zahl holen
        SET     7,D             ; MSBit setzen
        INC     HL              ; Zeiger auf Wert auf nächstes Byte
        LD      E,(HL)          ; 2tes Byte Mantisse holen
        INC     HL
        PUSH    HL              ; Zeiger auf Mantisse
        LD      H,A             ; Null
        LD      L,A             ; Null
        EXX
        POP     HL              ; Zeiger auf Mantisse
        LD      D,(HL)          ;! zwei niederwertigen Bytes der Mantisse holen
        INC     HL              ;!
        LD      E,(HL)          ;!
        LD      B,A             ; Null
        LD      C,A             ; Null
        LD      H,A             ; Null
        LD      L,A             ; Null
        EXX
        LD      A,(IX+0)        ; MSByte 2ter Faktor holen
        OR      10000000B       ; MSBit setzen
        LD      C,4             ; 4 Byte multiplizieren
A932D:  LD      B,8             ; 8 Bit je Byte
        OR      A               ; Byte Faktor gleich Null  ?
        JP      Z,A93C2         ; ja -->  nächstes Byte multiplizieren
A9333:  RLCA                    ; ein Bit nach Carry schieben
        JR      NC,A9348        ; nicht gesetzt -->  Wertigkeit nicht addieren
        EX      AF,AF           ; Restbits retten
        EXX
        LD      A,C             ;! Byte fünf addieren
        ADD     A,B             ;!
        LD      C,A             ;!
        ADC     HL,DE           ; Byte 3/4 addieren
        EXX                     ; höherwertigen Bytes holen
        ADC     HL,DE           ; Byte 1/2 addieren
        JR      NC,A9347        ; kein Übertrag
        LD      A,1             ; Code 'Übertrag aufgetreten'
        LD      (S94C7),A       ; Flag  'Übertrag aufgetreten' setzen
A9347:  EX      AF,AF           ; Restbits holen
A9348:  SRL     D               ;! Multiplikator um ein Bit schieben
        RR      E               ;!
        EXX                     ;!
        RR      D               ;!
        RR      E               ;!
        RR      B               ;!
        EXX
        DJNZ    A9333           ; weitere Bits in diesem Byte
A9356:  INC     IX              ; Zeiger auf Multiplikant auf nächstes Byte
        LD      A,(IX+0)        ; Byte holen
        DEC     C               ; Zähler Restanzahl Bytes minus eins
        JR      NZ,A932D        ; ungleich Null -->  weitere Bytes
        EXX
        LD      A,(S94C7)       ; Flag  'Übertrag aufgetreten'  holen
        OR      A               ; gesetzt  ?
        JR      Z,A937B         ; nein
        LD      DE,(S94C8)      ; Exponentenzähler für Ergebnis holen
        INC     DE              ; plus eins
        LD      (S94C8),DE      ; und wieder merken
        EXX
        SCF                     ;! Mantisse entsprechend Übertrag
        RR      H               ;! corrigieren
        RR      L               ;!
        EXX                     ;!
        RR      H               ;!
        RR      L               ;!
        RR      C               ;!
A937B:  BIT     7,C             ; MSBit Byte fünf abfragen  (Rundungsbit)
        JR      Z,A9399         ; nicht aufrunden
        LD      DE,1            ;! Ergebnis aufrunden
        ADD     HL,DE           ;!
        EXX                     ;!
        LD      DE,0            ;!
        ADC     HL,DE           ;!
        EXX
        JR      NC,A9399        ; kein Übertrag
        LD      DE,(S94C8)      ; Exponentenzähler für Ergebnis holen
        INC     DE              ; plus eins
        LD      (S94C8),DE      ; und wieder merken
        EXX
        LD      H,10000000B     ; Mantisse vorgeben
        EXX
A9399:  POP     IX              ; Zeiger für Ergebnis holen
        PUSH    IX              ; und wieder merken
        LD      (IX+4),L        ;! Mantisse Ergebnis im Speicher ablegen
        LD      (IX+3),H        ;!
        EXX                     ;!
        LD      (IX+2),L        ;!
        LD      (IX+1),H        ;!
        LD      HL,(S94C8)      ; Exponentenzähler für Ergebnis holen
        OR      A               ; Carry - Flag zurücksetzen
        LD      DE,00081H       ; Correkturfaktor vorgeben
        SBC     HL,DE           ; Exponenten corrigieren
        LD      A,H
        ADD     A,0
        JP      M,A93CE         ; Ergebnis gleich Null
        JP      NZ,A9205        ; Ergebnis zu groß
        LD      (IX+0),L        ; Exponenten eintragen
        JP      A90ED           ; Vorzeichen Ergebnis eintragen
;
A93C2:  LD      A,E             ;! Multiplikator um ein Byte schieben
        EXX                     ;!
        LD      B,E             ;!
        LD      E,D             ;!
        LD      D,A             ;!
        EXX                     ;!
        LD      E,D             ;!
        LD      D,0             ;!
        JP      A9356           ; weitere Bytes multiplizieren
;
A93CE:  LD      SP,(S94C3)      ; Stackpointer holen
        JP      A91C9           ; Ergebnis 'Null' vorgeben
;
;
;   Basic - Funktion  /
;
A93D5:  CALL    STROMT          ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
        CALL    A92DF           ; Vorzeichen Ergebnis errechnen
        PUSH    DE              ;! Zeiger auf Argumente retten
        PUSH    HL              ;!
        LD      (S94C3),SP      ; Stackpointer merken
        LD      A,(DE)          ; Exponent Divisor holen
        OR      A               ; gleich Null  ?
        JP      Z,A6367         ; ja -->  Fehler 2   Overflow error
        EX      AF,AF           ; Exponenten merken
        LD      A,(HL)          ; Exponent Dividend holen
        OR      A               ; gleich Null  ?
        JP      Z,A91C9         ; ja -->  Ergebnis gleich Null
        EXX
        ADD     A,081H          ;! Exponenten Ergebnis errechnen
        LD      B,A             ;!
        LD      A,0             ;!
        ADC     A,A             ;!
        EX      AF,AF           ;!
        LD      C,A             ;!
        LD      A,B             ;!
        SUB     C               ;!
        LD      C,A             ;!
        EX      AF,AF           ;!
        LD      B,A             ;!
        EX      AF,AF           ;!
        LD      A,B             ;!
        SBC     A,0             ;!
        JP      C,A93CE         ; Ergebnis gleich Null
        JP      NZ,A9205        ; Ergebnis zu groß
        LD      A,C             ; Exponent Ergebnis
        PUSH    AF              ;merken
        EXX
        INC     DE              ;! Zeiger auf Mantissen der Argumente stellen
        INC     HL              ;!
        LD      B,(HL)          ;! höherwertige Bytes der beiden Mantissen laden
        SET     7,B             ;!
        INC     HL              ;!
        LD      C,(HL)          ;!
        INC     HL              ;!
        PUSH    HL              ;!     Zeiger auf Mantisse
        EX      DE,HL           ;!
        LD      D,(HL)          ;!
        SET     7,D             ;!     MSBit setzen
        INC     HL              ;!
        LD      E,(HL)          ;!
        INC     HL              ;!
        PUSH    HL              ;!     Zeiger auf Mantisse
        LD      H,B             ;!
        LD      L,C             ;!
        EXX
        POP     HL              ; Zeiger auf Restmantisse
        LD      D,(HL)          ;! niederwertigen Bytes der beiden Mantissen laden
        INC     HL              ;!
        LD      E,(HL)          ;!
        POP     HL              ;!
        LD      A,(HL)          ;!
        INC     HL              ;!
        LD      L,(HL)          ;!
        LD      H,A             ;!
        EXX
        LD      C,5             ; 5 Byte Ergebnis bilden
A9427:  LD      B,8             ; 8 Bit je Byte
        XOR     A               ; Vorgabe für Byte Ergebnis
A942A:  BIT     7,H             ; Bit gesetzt  ?
        JR      NZ,A943E        ; ja -->  subtrahieren
        OR      A               ;! ein Bit Ergebnis merken
A942F:  RLA                     ;!
        EXX
        ADD     HL,HL           ;! Dividend um ein Bit schieben
        EXX                     ;!
        ADC     HL,HL           ;!
        DJNZ    A942A           ; weitere Bits dieses Byte
        PUSH    AF              ; Ein Byte Ergebnis merken
        DEC     C               ; Restanzahl Bytes minus eins
        JR      NZ,A9427        ; weitere Bytes errechnen
        JP      A9478           ; Ergebnis aufbereiten
;
A943E:  OR      A               ; Carry Flag zurücksetzen
        EXX
        SBC     HL,DE           ;! Divisor ein mal Subtrahieren
        EXX                     ;!
        SBC     HL,DE           ;!
        CCF
        JR      C,A942F         ; ein Bit Ergebnis merken
        EXX
        ADD     HL,DE           ;! Restdividend corrigieren
        EXX                     ;!
        ADC     HL,DE           ;!
        OR      A               ; Carry - Flag zurücksetzen
        RLA                     ; ein Bit Ergebnis merken
        EXX
        ADD     HL,HL           ;! Dividend um eine Stelle schieben
        EXX                     ;!
        ADC     HL,HL           ;!
        DJNZ    A945D           ; weitere Bits in diesem Byte
        PUSH    AF              ; ein Byte Ergebnis merken
        LD      B,8             ; 8 Bit je Byte
        DEC     C               ; Restanzahl Bytes minus eins
        JP      Z,A9478         ; Division durchgeführt
A945D:  EXX
        OR      A               ; Carry - Flag zurücksetzen
        SBC     HL,DE
        EXX
        SBC     HL,DE
        SCF                     ; Carry - Flag setzen
        RLA                     ; ein Bit Ergebnis merken
        DJNZ    A946E           ; weitere Bits dieses Byte
        PUSH    AF              ; ein Byte Ergebnis merken
        LD      B,8             ; 8 Bit je Byte
        DEC     C               ; Restanzahl Bytes minus eins
        JR      Z,A9478         ; Division durchgeführt
A946E:  EXX
        ADD     HL,HL           ;! Dividend um eine Stelle schieben
        EXX                     ;!
        ADC     HL,HL           ;!
        JR      C,A945D
        JP      A942A
;
;
;   Ergebnis der Division aufbereiten
;
A9478:  POP     AF              ; 5tes Byte Mantisse holen
        LD      H,A             ; Byte für Rundung merken
        EXX
        POP     AF              ;! Mantisse Ergebnis holen
        LD      E,A             ;!
        POP     AF              ;!
        LD      D,A             ;!
        POP     AF              ;!
        LD      C,A             ;!
        POP     AF              ;!
        LD      B,A             ;!
        POP     AF              ; Exponent Ergebnis holen
A9484:  BIT     7,B             ; 1tes Mit Mantisse gesetzt  ?
        JR      NZ,A949B        ; ja -->  Mantisse hat internes Format
        EXX
        SLA     H               ;! Mantisse um ein Bit schieben
        EXX                     ;!
        RL      E               ;!
        RL      D               ;!
        RL      C               ;!
        RL      B               ;!
        DEC     A               ; Exponenten corrigieren
        JP      NZ,A9484        ; überprüfen, ob internes Format stimmt
        JP      A91C9           ; Ergebnis  'Null'  vorgeben
;
;
;   Ergebnis der Division eventuell runden
;
A949B:  EXX
        RL      H               ; MSBit Rundungsbyte nach Carry
        EXX
        JR      NC,A94B2        ; nicht aufrunden
        LD      HL,1            ;! Ergebnis aufrunfen
        ADD     HL,DE           ;!
        EX      DE,HL           ;!
        LD      HL,0            ;!
        ADC     HL,BC           ;!
        LD      B,H             ;!
        LD      C,L             ;!
        JR      NC,A94B2        ; kein Übertrag
        LD      B,10000000B     ; Mantisse vorgeben
        INC     A               ; Exponent plus eins
A94B2:  POP     HL              ; Zeiger für Ergebnis holen
        PUSH    HL              ; und wieder merken
        LD      (HL),A          ; Exponenten eintragen
        INC     HL
        LD      (HL),B          ;! Mantisse Ergebnis im Speicher ablegen
        INC     HL              ;!
        LD      (HL),C          ;!
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL              ;!
        LD      (HL),E          ;!
        JP      A90ED           ; Vorzeichen Ergebnis eintragen
;
;
;   verschiedene Speicher für Grundrechenarten
;
S94C0:  DEFS    2               ; Zeiger auf Speicher für Ergebnis
S94C2:  DEFS    1               ; Vorzeichen Ergebnis
S94C3:  DEFS    2               ; Stackpointer
S94C5:  DEFS    2               ; Stackpointer bei Interruptsperrung
S94C7:  DEFS    1               ; Flag  'Übertrag aufgetreten'
S94C8:  DEFS    2               ; Exponentenzähler für Ergebnis
S94CA:  DEFS    1
;
;
;   Vorzeichen des Zahlwertes (HL) abfragen
;
A94CB:  INC     HL              ; Zeiger auf MSByte Mantisse
        BIT     7,(HL)          ; Vorzeichen abfragen
        DEC     HL              ; Zeiger wieder auf Exponenten
        RET
;
;
;   Zahlwert (HL) mal zwei
;
A94D0:  INC     (HL)            ; Exponenten plus eins
        RET     NZ              ; Ergebnis ist OK
        JP      A6367           ; Fehler 2   Overflow error
;
;
;   Zahlwert (HL) durch zwei
;
A94D5:  LD      A,(HL)          ; Exponenten holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  Wert ist gleich Null
        DEC     (HL)            ; Exponenten minus eins
        RET     NZ              ; Ergebnis ist OK
        JP      A909E           ; Null im Real - Format nach (HL) eintragen
;
;
;   einen Rechenspeicher für Rechenroutine reservieren
;
A94DD:  PUSH    HL              ; Zeiger auf Rechenspeicher retten
        INC     HL              ;! um Länge Real - Zahlwert hochzählen
        INC     HL              ;!
        INC     HL              ;!
        INC     HL              ;!
        INC     HL              ;!
        EX      DE,HL           ; Adresse nach DE
        LD      HL,(MEMMAX)     ; maximal erlaubte RAM - Adresse holen
        DEC     HL
        SBC     HL,DE           ; Rechenspeicheradresse überprüfen
        JP      C,A6373         ; zu hoch -->  Fehler 6  Memory error
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;   vier Rechenspeicher für Routinen bereitstellen
;
A94EF:  PUSH    HL              ; Zeiger auf Rechenspeicher merken
        LD      (S9BA0),HL      ; Zeiger auf Rechenspeicher vier
        CALL    A94DD           ; einen Rechenspeicher reservieren
        EX      DE,HL           ; Zeiger nach HL
        LD      (S9BA2),HL      ; Zeiger auf Rechenspeicher drei
        CALL    A94DD           ; einen Rechenspeicher reservieren
        EX      DE,HL           ; Zeiger nach HL
        LD      (S9BA4),HL      ; Zeiger auf Rechenspeicher zwei
        CALL    A94DD           ; einen Rechenspeicher reservieren
        LD      (S9BA6),DE      ; Zeiger auf Rechenspeicher eins
        POP     HL              ; geretteten Zeiger auf Rechenspeicher wieder holen
        RET
;
;
;   Basic - Funktion   ^
;
A950A:  CALL    STROMT          ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
        EX      DE,HL           ; Zeiger auf 2tes Argument nach HL
        LD      A,(HL)          ; Exponent der Hochzahl holen
        OR      A               ; gleich Null  ?
        JP      Z,A956C         ; ja -->  Ergebnis gleich +1
        EX      DE,HL
        LD      A,(HL)          ; Exponent der Basis holen
        OR      A               ; gleich Null  ?
        JP      Z,A909E         ; ja -->  Null im Real - Format nach (HL) eintragen
        CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        JR      Z,A9546         ; Zahl positiv
;
;
;   Basis negativ -->  untersuchen, ob Hochzahl ganze Zahl ist
;
        CALL    A90A9           ; Vorzeichen des Wertes (HL) umkehren
        EX      DE,HL
        PUSH    DE              ; Zeiger auf Basis
        PUSH    HL              ; Zeiger auf Hochzahl
        LD      DE,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        LD      HL,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        CALL    A7BC0           ; Nachkommastellen des Real-Zahlwertes (HL) errechnen
        LD      A,(HL)          ; Exponent Ergebnis holen
        OR      A               ; gleich Null ?
        JP      NZ,A636A        ; nein -->  Fehler 3  Illegal data error
        POP     HL              ; Zeiger auf Hochzahl holen
        PUSH    HL              ; und wieder merken
        CALL    HLFLT           ; Real - Wert (HL) umsetzen in Integer - Wert nach HL
        BIT     0,L             ; Wert gerade  ?
        POP     DE              ; Zeiger auf Hochzahl holen
        POP     HL              ; Zeiger auf Basis holen
        JR      Z,A9546         ; Wert gerade -->  (HL) ^ (DE) errechnen
        CALL    A9546           ; (HL) ^ (DE) errechnen
        JP      A90A9           ; Vorzeichen des Wertes (HL) umkehren
;
A9546:  EX      DE,HL
        LD      A,(HL)          ; Exponenten der Hochzahl holen
        OR      A               ; gleich Null  ?
        JR      Z,A956C         ; ja -->  Ergebnis ist gleich +1
        CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        JR      Z,A9572         ; Hochzahl positiv
;
;
;   Hochzahl negativ
;
        CALL    A90A9           ; Vorzeichen des Wertes (HL) umkehren
        CALL    A9572           ; EXP( LN(DE) * (HL) ) errechnen
        PUSH    DE              ; Keep register value
        PUSH    HL              ; Zeiger auf Zwischenergebnis retten
        LD      DE,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        CALL    A79C2           ; +1 im Real - Format nach (DE) übertragen
        LD      HL,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        POP     DE              ; Zeiger auf Zwischenergebnis holen
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        PUSH    DE              ; Zeiger auf Ergebnis merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf Ergebnis holen
        POP     DE              ; geretteten Register - Wert holen
        RET
;
;
;   +1  als Ergebnis vorgeben
;
A956C:  PUSH    DE              ; Zeiger für Ergebnis retten
        CALL    A79C2           ; +1 im Real - Format nach (DE) übertragen
        POP     HL              ; Zeiger auf Ergebnis holen
        RET
;
;
;   Basis hoch Hochzahl über Logarithmus errechnen
;
A9572:  PUSH    DE              ; Zeiger auf Basis retten
        LD      DE,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf Basis holen
        CALL    A9A4F           ; LN - Routine   ( LN(HL) )
        LD      DE,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        JP      A992B           ; EXP - Routine   ( EXP(HL) )
;
;
;   Basic - Funktion   NOT     (Token code 237 / 0EDH)
;
A9586:  CALL    STROMT          ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
        PUSH    DE              ; Keep register value
        PUSH    HL              ; Zeiger für Ergebnis retten
        CALL    HLFLT           ; Real - Wert (HL) umsetzen in Integer - Wert nach HL
        LD      A,L             ;! Wert complementieren
        CPL                     ;!
        LD      E,A             ;!
        LD      A,H             ;!
        CPL                     ;!
        LD      D,A             ;!
        JR      A95B7           ; Integer - Wert für Ergebnis umsetzen in Real - Wert
;
;
;   Basic - Funktion   AND     (Token code  236 / 0ECH)
;
A9596:  LD      A,AND_D         ; Vorgabe für Z-80 - Befehl
        DEFB    LD_BC
;
;
;   Basic - Funktion   OR     (Token code 235 / 0EBH)
;
A9599:  LD      A,OR_D          ; Vorgabe für Z-80 - Befehl
        DEFB    LD_BC
;
;
;   Basic - Funktion   XOR     (Token code 234 / 0EAH)
;
A959C:  LD      A,XOR_D         ; Vorgabe für Z-80 - Befehl
        LD      (D95B2),A       ; richtigen Befehl in Routine eintragen
        INC     A               ; auf Befehl mit E - Register corrigieren
        LD      (D95B5),A       ; richtigen Befehl in Routine eintragen
        CALL    STROMT          ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
        PUSH    DE              ;! Zeiger auf Werte retten
        PUSH    HL              ;!
        CALL    HLFLT           ; Real - Wert (HL) umsetzen in Integer - Wert nach HL
        EX      DE,HL           ; Zeiger 2ter Wert nach HL / 1ter Wert nach DE
        CALL    HLFLT           ; Real - Wert (HL) umsetzen in Integer - Wert nach HL
        LD      A,H             ; High - Byte 2ter Wert holen
D95B2:  AND     D               ; mit 1tem Wert verknüpfen   (Befehl wird eingetragen)
        LD      D,A             ; Ergebnis merken
        LD      A,L             ; Low - Byte 2ter Wert holen
D95B5:  AND     E               ; mit 1tem Wert verknüpfen   (Befehl wird eingetragen)
        LD      E,A             ; Ergebnis merken
A95B7:  POP     HL              ; Zeiger für Ergebnis holen
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        POP     DE              ; geretteten Register - Wert holen
        RET
;
;
;   Basic - Funktion   ABS     (Token code 255 129 / 0FFH 081H)
;
A95BD:  INC     HL              ; Zeiger auf MSByte Mantisse
        RES     7,(HL)          ; Vorzeichen auf plus
        DEC     HL              ; Zeiger wieder auf Exponenten
        RET
;
;
;   Basic - Funktion   INT     (Token code 255 128 / 0FFH 080H)
;
A95C2:  CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        JP      Z,A7B82         ; Zahl positiv -->  Nachkommastellen der Zahl (HL) vergessen
        CALL    A95E7           ; Zahl (HL) im Zwischenspeicher merken
        CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        LD      DE,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        RET     Z               ; Argument hatte keine Nachkommastellen
A95D5:  LD      DE,B7C45        ; Zeiger auf  +1   (Real - Format)
        JP      A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
;
;
;   +1 zur Zahl (HL) addieren
;
A95DB:  LD      DE,B7C45        ; Zeiger auf  +1   (Real - Format)
        JP      A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
;
;
;   Zahl (HL) mit +1 vergleichen
;
A95E1:  LD      DE,B7C45        ; Zeiger auf  +1   (Real - Format)
        JP      A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
;
;
;   Zahl (HL) im Zwischenspeicher merken
;
A95E7:  PUSH    HL              ;! Register - Werte retten
        PUSH    DE              ;!
        LD      DE,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     DE              ;! gerettete Register - Werte wieder holen
        POP     HL              ;!
        RET
;
;
;   Basic - Funktion   MOD     (Token code 250 / 0FAH)
;
A95F2:  CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        EX      DE,HL           ; Zeiger auf Argumente vertauschen
        CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        EX      DE,HL           ; Zeiger auf Argumente vertauschen
        CALL    A95E7           ; Zahl (HL) im Zwischenspeicher merken
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        PUSH    DE              ; Keep register value
        LD      DE,ZFAC1        ; Zeiger auf Speicher für Real - Zahlwert
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     DE              ; geretteten Register - Wert wieder holen
        JP      A90A9           ; Vorzeichen des Wertes (HL) umkehren
;
;
;   Basic - Funktion   Integer-Division   (Backslash)     (Token code 249 / 0F9H)
;
A9611:  CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        EX      DE,HL           ; Zeiger auf Argumente vertauschen
        CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        EX      DE,HL           ; Zeiger auf Argumente vertauschen
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        JP      A7B82           ; Nachkommastellen der Zahl (HL) vergessen
;
;
;   Basic - Funktion   SQR     (Token code 255 135 / 0FFH 087H)
;
A961F:  LD      A,(HL)          ; Exponent Argument holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  Ergebnis gleich Null
        CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        JP      NZ,A636A        ; negativ -->  Fehler 3  Illegal data error
        CALL    A9A4F           ; LN - Routine   ( LN(HL) )
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        JP      A992B           ; EXP - Routine   ( EXP(HL) )
;
;
;   Ergebnis  '+1'  vorgeben und Stack corrigieren
;
A9631:  PUSH    HL              ; Zeiger auf Ergebnis merken
        EX      DE,HL           ; Zeiger für Ergebnis nach DE
        CALL    A79C2           ; +1 im Real - Format nach (DE) übertragen
        POP     HL              ; Zeiger auf Ergebnis holen
        POP     BC              ; geretteten Register - Wert wieder holen
        RET
;
B9639:  DEFB    07EH            ; Exponent  0.19970768
        DEFB    04CH            ; Mantisse  0.19970768
;
B963B:  DEFB    080H            ; Exponent  0.67097684
        DEFB    02BH            ; Mantisse  0.67097684
;
;
;   Basic - Funktion   ATN     (Token code 255 138 / 0FFH 08AH)
;
A963D:  PUSH    BC              ; Keep register value
        INC     HL              ; Zeiger auf Mantisse
        LD      A,(HL)          ; MSByte Mantisse holen
        RES     7,(HL)          ; Vorzeichen auf plus
        DEC     HL              ; Zeiger wieder auf Exponenten
        PUSH    AF              ; Vorzeichen Argument merken
        CALL    A964E           ; ATN - Wert errechnen
        POP     AF              ; Vorzeichen Argument holen
        POP     BC              ; geretteten Register - Wert wieder holen
        RLCA                    ; Vorzeichen nach Carry schieben
        RET     NC              ; Argument war positiv
        JP      A90A9           ; Vorzeichen des Wertes (HL) umkehren
;
;
;   überprüfen, ob Betrag Argument kleiner eins ist, wenn nein
;   ATN über 1/Argument errechnen und Pi/2 vom Ergebnis abziehen
;
A964E:  CALL    A95E1           ; Zahl (HL) mit +1 vergleichen
        JR      C,A9671         ; Argument < +1 -->  ATN direkt errechnen
        CALL    A94DD           ; einen Rechenspeicher reservieren
        PUSH    DE              ; Zeiger auf Rechenspeicher merken
        PUSH    HL              ; Zeiger auf Argument merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     DE              ;! Zeiger auf ursprüngliche Stelle
        PUSH    DE              ;! mit Argument
        CALL    A79C2           ; +1 im Real - Format nach (DE) übertragen
        POP     HL              ; Zeiger auf +1
        POP     DE              ; Zeiger auf Argument
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        CALL    A9671           ; ATN von 1/Argument errechnen
        LD      DE,B98CB        ; Zeiger auf Pi/2  (Real - Konstante)
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        JP      A95BD           ; ABS - Wert der Zahl (HL) bilden
;
;
;   ATN der Zahl (HL) iterieren
;
A9671:  LD      A,11111111B     ; Code for 'Vorzeichen Ergebnis stimmt'
        LD      (S97E7),A       ; Flag  'Vorzeichen Ergebnis Iteration'
        LD      DE,B9639        ; ca.  1/5  (Real)
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A96CD         ; Argument kleiner 1/5 -->  direkt iterieren
        LD      DE,B963B        ; ca.  3/5  (Real)
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        PUSH    AF              ; Ergebnis Vergleich retten
        CALL    A94DD           ; einen Rechenspeicher reservieren
        POP     AF              ; Ergebnis Vergleich holen
        PUSH    HL              ; Zeiger auf Argument retten
        PUSH    DE              ; Zeiger auf Rechenspeicher retten
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf Rechenspeicher holen
        JR      C,A96A5         ; Wert ist kleiner 3/5
        CALL    A95DB           ; +1 zur Zahl (HL) addieren
        EX      (SP),HL
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     DE
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        CALL    A96CD           ; ATN - Wert errechnen
        LD      DE,B98D0        ; Zeiger auf  Pi/4   (Real - Konstante)
        JP      A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
;
A96A5:  LD      DE,B96C8        ; Zeiger auf SQR(2) - 1   (Real - Konstante)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        CALL    A95DB           ; +1 zur Zahl (HL) addieren
        EX      (SP),HL
        LD      DE,B96C8        ; Zeiger auf SQR(2) - 1   (Real - Konstante)
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     DE
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        CALL    A96CD           ; ATN - Wert errechnen
        CALL    A94D0           ; Real - Zahl (HL) mal zwei
        LD      DE,B98D0        ; Zeiger auf  Pi/4   (Real - Konstante)
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        JP      A94D5           ; Real - Zahl (HL) durch zwei
;
B96C8:  DEFB    07FH                    ; Exponent  0.41421356   ( SQR(2)-1 )
        DEFB    054H,013H,0CCH,0D0H     ; Mantisse  0.41421356   ( SQR(2)-1 )
;
;
;
;
A96CD:  PUSH    BC              ; Keep register value
        PUSH    HL              ; Zeiger auf Argument retten
        CALL    A94EF           ; 4 Rechenspeicher für Routine bereitstellen
        POP     HL              ; Zeiger auf Argument holen
        PUSH    HL              ; und wieder retten
        PUSH    DE              ; Zeiger auf Rechenspeicher eins
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf Rechenspeicher eins  (Argument)
        LD      E,L             ;! nach DE
        LD      D,H             ;!
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,(S9BA4)      ; Zeiger auf Rechenspeicher zwei
        POP     HL              ; Zeiger auf Argument holen
        PUSH    HL              ; und wieder merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        DEC     A               ; Länge Zahl minus eins
        CP      4               ; Real - Wert  ?
        LD      B,A             ; 4  Iterationsschritte
        LD      HL,B986E        ; Zeiger auf Tabelle mit Konstanten für Iteration
        JP      Z,A9774         ; Real - Wert -->  Iteration ausführen
        LD      B,10            ; 10 Iterationsschritte bei Double - Precision
        JP      A9774           ; Iteration ausführen
;
;
;   Basic - Funktion   COS     (Token code  255 131 / 0FFH 083H)
;
A96F9:  PUSH    BC              ; Keep register value
        LD      A,(HL)          ; Exponent Argument holen
        OR      A               ; gleich Null  ?
        JP      Z,A9631         ; ja -->  Ergebnis gleich Null
        LD      DE,B98CB        ; Zeiger auf Pi/2  (Real - Konstante)
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        CALL    A90A9           ; Vorzeichen des Wertes (HL) umkehren
        POP     BC              ; geretteten Register - Wert holen
;
;
;   Basic - Funktion   SIN     (Token code 255 130 / 0FFH 082H)
;
A9709:  PUSH    BC              ; Keep register value
        INC     HL              ; Zeiger auf Mantisse Argument
        LD      A,(HL)          ; MSByte Mantisse holen
        RES     7,(HL)          ; Vorzeichen auf plus
        AND     10000000B       ; Vorzeichen Argument maskieren
        CPL                     ; Maske für Vorzeichen bilden
        LD      (S97E7),A       ; Flag  'Vorzeichen Ergebnis Iteration'
        DEC     HL              ; Zeiger wieder auf Exponent
        LD      DE,B98C1        ; Zeiger auf 2 * Pi   (Real - Konstante)
        PUSH    HL              ; Zeiger auf Argument merken
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A9727         ; Zahl ist kleiner 2 * Pi
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        CALL    A7BC0           ; Nachkommastellen des Real-Zahlwertes (HL) errechnen
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
A9727:  LD      DE,B98C6        ; Zeiger auf Pi im Real - Format
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A973A         ; Zahl ist kleiner Pi
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        LD      A,(S97E7)       ; Flag  'Vorzeichen Ergebnis Iteration'
        XOR     10000000B       ; Vorzeichen umkehren
        LD      (S97E7),A       ; Flag  'Vorzeichen Ergebnis Iteration'
A973A:  LD      DE,B98CB        ; Zeiger auf Pi/2  (Real - Konstante)
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A974B         ; Zahl ist kleiner Pi/2
        LD      DE,B98C6        ; Zeiger auf Pi im Real - Format
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        CALL    A95BD           ; ABS - Wert der Zahl (HL) bilden
A974B:  CALL    A94EF           ; 4 Rechenspeicher für Routine bereitstellen
        POP     HL              ; Zeiger auf Argument retten
        PUSH    DE              ; Zeiger auf Rechenspeicher eins
        LD      DE,B98D0        ; Zeiger auf  Pi/4   (Real - Konstante)
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      NC,A97BD        ; Argument größer Pi/4 -->  über COS - Reihe iterieren
        POP     DE              ; Zeiger auf Rechenspeicher eins
        PUSH    HL              ; Zeiger auf Argument
        PUSH    DE              ; Zeiger auf Rechenspeicher eins
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf Rechenspeicher eins
        LD      E,L             ;! nach DE
        LD      D,H             ;!
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,(S9BA4)      ; Zeiger auf Rechenspeicher zwei
        POP     HL              ; Zeiger auf Argument holen
        PUSH    HL              ; und wieder merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        LD      B,A             ; als Anzahl Iterationsschritte merken
        LD      HL,B981E        ; Zeiger auf Konstanten für Iteration  SIN - Reihe
;
;
;   Iterationsroutine für  SIN - COS - ATN
;
A9774:  PUSH    BC              ; Anzahl Iterationsschritte retten
        PUSH    HL              ; Zeiger auf Konstantentabelle
        LD      HL,(S9BA4)      ; Zeiger auf Rechenspeicher zwei
        LD      DE,(S9BA6)      ; Zeiger auf Rechenspeicher eins
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     HL              ; Zeiger auf Konstantentabelle holen
        PUSH    HL              ; und wieder merken
        LD      DE,(S9BA2)      ; Zeiger auf Rechenspeicher drei
        PUSH    DE              ; merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf Rechenspeicher drei
        LD      DE,(S9BA4)      ; Zeiger auf Rechenspeicher zwei
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        EX      DE,HL
        LD      HL,(S9BA0)      ; Zeiger auf Rechenspeicher vier
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        POP     HL              ; Zeiger auf Konstantentabelle
        LD      DE,5            ; Länge  Real - Zahlwert
        ADD     HL,DE           ; Zeiger auf nächste Konstante in Tabelle
        POP     BC              ; Restanzahl Iterationsschritte holen
        DJNZ    A9774           ; weitere Iterationsschritte ausführen
        POP     HL              ; Zeiger auf Ergebnis holen
        POP     BC
        LD      A,(S97E7)       ; Flag  'Vorzeichen Ergebnis Iteration'
        INC     HL              ; Zeiger auf Mantisse Ergebnis
        XOR     (HL)            ;! Vorzeichen Ergebnis richten
        CPL                     ;!
        LD      (HL),A          ; Vorzeichen Ergebnis merken
        DEC     HL              ; Zeiger wieder auf Exponenten
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        CP      8               ; Double - Precision - Wert  ?
        LD      A,(HL)          ; Exponenten Ergebnis holen
        JR      Z,A97B9         ; Double Precision
        CP      05CH
A97B5:  RET     NC              ; Ergebnis ist OK
        JP      A909E           ; Null im Real - Format nach (HL) eintragen
;
A97B9:  CP      04DH
        JR      A97B5           ; untersuchen, ob Ergebnis groß genug ist
;
;
;   Werte für Iteration nach COS - Reihe vorgeben
;
A97BD:  LD      DE,B98CB        ; Zeiger auf Pi/2  (Real - Konstante)
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        CALL    A95BD           ; ABS - Wert der Zahl (HL) bilden
        POP     DE              ; Zeiger auf Rechenspeicher eins
        PUSH    HL              ; Zeiger auf Argument
        PUSH    DE              ; Zeiger auf Rechenspeicher eins
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf Rechenspeicher eins
        LD      E,L             ;! nach DE
        LD      D,H             ;!
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,(S9BA4)      ; Zeiger auf Rechenspeicher zwei
        CALL    A79C2           ; +1 im Real - Format nach (DE) übertragen
        POP     DE              ; Zeiger auf Argument holen
        PUSH    DE              ; und wieder merken
        CALL    A79C2           ; +1 im Real - Format nach (DE) übertragen
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        LD      B,A             ; Anzahl Iterationsschritte merken
        LD      HL,B9846        ; Zeiger auf Konstante für  COS - Reihe
        JR      A9774           ; Einsprung in Iterationsschleife
;
S97E7:  DEFS    1               ; Flag  'Vorzeichen Ergebnis Iteration'
;
;
;   Basic - Funktion   TAN     (Token code 255 132 / 0FFH 084H)
;
A97E8:  PUSH    BC              ; Keep register value
        PUSH    HL              ; Zeiger auf Argument retten
        CALL    A94DD           ; einen Rechenspeicher reservieren
        EX      DE,HL           ; Zeiger auf Rechenspeicher nach HL
        LD      (S9BA8),HL      ; Zeiger auf Speicher für COS(Argument)
        CALL    A94DD           ; einen Rechenspeicher reservieren
        LD      (S9BAA),DE      ; Zeiger auf Speicher für SIN(Argument)
        POP     HL              ; Zeiger auf Argument holen
        PUSH    HL              ; und wieder merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        LD      HL,(S9BA8)      ; Zeiger auf Speicher für COS(Argument)
        EX      DE,HL           ; nach DE
        POP     HL              ; Zeiger auf Argument holen
        PUSH    HL              ; und wieder merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        LD      HL,(S9BAA)      ; Zeiger auf Speicher für SIN(Argument)
        CALL    A9709           ; SIN - Routine aufrufen   ( SIN( (HL) ) )
        POP     DE              ; Zeiger auf Stelle für Ergebnis holen
        PUSH    DE              ; und wieder merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        LD      HL,(S9BA8)      ; Zeiger auf Speicher für COS(Argument)
        CALL    A96F9           ; COS - Routine aufrufen   ( COS( (HL) ) )
        EX      DE,HL           ; Zeiger auf COS(Argument) nach DE
        POP     HL              ; Zeiger auf SIN(Argument) holen
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Zeiger auf Konstanten für Iteration nach SIN - Reihe
;
B981E:  DEFB    07EH                    ; Exponent  -0.16666667      (-1/3!)
        DEFB    0AAH,0AAH,0AAH,0ABH     ; Mantisse  -0.16666667      (-1/3!)
;
        DEFB    07AH                    ; Exponent   .83333333E-02   (1/5!)
        DEFB    008H,088H,088H,089H     ; Mantisse   .83333333E-02   (1/5!)
;
        DEFB    074H                    ; Exponent  -.1984127E-03    (-1/7!)
        DEFB    0D0H,00DH,000H,0D0H     ; Mantisse  -.1984127E-03    (-1/7!)
;
        DEFB    06EH                    ; Exponent   .27557319E-05   (1/9!)
        DEFB    038H,0EFH,01DH,02BH     ; Mantisse   .27557319E-05   (1/9!)
;
        DEFB    067H                    ; Exponent  -.25052108E-07   (-1/11!)
        DEFB    0D7H,032H,02BH,040H     ; Mantisse  -.25052108E-07   (-1/11!)
;
        DEFB    060H                    ; Exponent   .16059043E-09   (1/13!)
        DEFB    030H,092H,030H,09DH     ; Mantisse   .16059043E-09   (1/13!)
;
        DEFB    058H                    ; Exponent  -.76471635E-12   (-1/15!)
        DEFB    0D7H,03FH,09FH,03AH     ; Mantisse  -.76471635E-12   (-1/15!)
;
        DEFB    050H                    ; Exponent   .28114571E-14   (1/17!)
        DEFB    04AH,096H,03BH,082H     ; Mantisse   .28114571E-14   (1/17!)
;
;
;   Konstanten für Iteration nach COS - Reihe
;
B9846:  DEFB    080H                    ; Exponent  -0.5             (-1/2!)
        DEFB    080H,000H,000H,000H     ; Mantisse  -0.5             (-1/2!)
;
        DEFB    07CH                    ; Exponent   0.041666666     (1/4!)
        DEFB    02AH,0AAH,0AAH,0ABH     ; Mantisse   0.041666666     (1/4!)
;
        DEFB    077H                    ; Exponent  -.13888889E-02   (-1/6!)
        DEFB    0B6H,00BH,060H,0B6H     ; Mantisse  -.13888889E-02   (-1/6!)
;
        DEFB    071H                    ; Exponent   .24801587E-04   (1/8!)
        DEFB    050H,00DH,000H,0D0H     ; Mantisse   .24801587E-04   (1/8!)
;
        DEFB    06BH                    ; Exponent  -.27557319E-06   (-1/10!)
        DEFB    093H,0F2H,07DH,0BCH     ; Mantisse  -.27557319E-06   (-1/10!)
;
        DEFB    064H                    ; Exponent   .20876756E-10   (1/12!)
        DEFB    00FH,076H,0C7H,080H     ; Mantisse   .20876756E-10   (1/12!)
;
        DEFB    05CH                    ; Exponent  -.11470745E-10   (-1/14!)
        DEFB    0C9H,0CBH,0A5H,046H     ; Mantisse  -.11470745E-10   (-1/14!)
;
        DEFB    054H                    ; Exponent   .47794773E-13   (1/16!)
        DEFB    057H,03FH,09FH,03AH     ; Mantisse   .47794773E-13   (1/16!)
;
;
;   Konstanten für Iteration nach ATN - Reihe
;
B986E:  DEFB    07FH                    ; Exponent  -0.33333333      (-1/3)
        DEFB    0AAH,0AAH,0AAH,0ABH     ; Mantisse  -0.33333333      (-1/3)
;
        DEFB    07EH                    ; Exponent   0.2             (1/5)
        DEFB    04CH,0CCH,0CCH,0CDH     ; Mantisse   0.2             (1/5)
;
        DEFB    07EH                    ; Exponent  -0.14285714      (-1/7)
        DEFB    092H,049H,024H,092H     ; Mantisse  -0.14285714      (-1/7)
;
        DEFB    07DH                    ; Exponent   0.11111111      (1/9)
        DEFB    063H,08EH,038H,0E4H     ; Mantisse   0.11111111      (1/9)
;
        DEFB    07DH                    ; Exponent  -0.09090909      (-1/11)
        DEFB    0BAH,02EH,08BH,0A3H     ; Mantisse  -0.09090909      (-1/11)
;
        DEFB    07DH                    ; Exponent   0.076923076     (1/13)
        DEFB    01DH,089H,0D8H,09EH     ; Mantisse   0.076923076     (1/13)
;
        DEFB    07DH                    ; Exponent  -0.066666666     (-1/15)
        DEFB    088H,088H,088H,089H     ; Mantisse  -0.066666666     (-1/15)
;
        DEFB    07CH                    ; Exponent   0.058823529     (1/17)
        DEFB    070H,0F0H,0F0H,0F1H     ; Mantisse   0.058823529     (1/17)
;
        DEFB    07CH                    ; Exponent  -0.052631579     (-1/19)
        DEFB    0D7H,094H,035H,0E5H     ; Mantisse  -0.052631579     (-1/19)
;
        DEFB    07CH                    ; Exponent   0.047619047     (1/21)
        DEFB    043H,00CH,030H,0C3H     ; Mantisse   0.047619047     (1/21)
;
;
;   Basic - Funktion   SGN     (Token code 255 139 / 0FFH 08BH)
;
A98A0:  LD      DE,0            ; Vorgabe  'Null'
        LD      A,(HL)          ; Exponent Argument holen
        OR      A               ; gleich Null  ?
        JR      Z,A98AF         ; ja -->  Ergebnis gleich Null
        CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        INC     DE              ; Wert auf +1
        JR      Z,A98AF         ; Zahl ist positiv
        DEC     DE              ;! Wert auf -1
        DEC     DE              ;!
A98AF:  CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        RET
;
;
;   Basic - Funktion   RAD     (Token code 255 143 / 0FFH 08FH)
;
A98B3:  LD      DE,B98D5        ; Zeiger auf Pi/180
        JR      A98BB           ; Konstante mit Argument multiplizieren
;
;
;   Basic - Funktion   PAI     (Token code 255 142 / 0FFH 08EH)
;
A98B8:  LD      DE,B98C6        ; Zeiger auf Pi im Real - Format
A98BB:  PUSH    BC              ; Keep register value
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Tabelle mit PI - Konstanten
;
B98C1:  DEFB    083H                    ; Exponent  2 * Pi
        DEFB    049H,00FH,0DAH,0A2H     ; Mantisse  2 * Pi
;
B98C6:  DEFB    082H                    ; Exponent  Pi
        DEFB    049H,00FH,0DAH,0A2H     ; Mantisse  Pi
;
B98CB:  DEFB    081H                    ; Exponent  Pi/2
        DEFB    049H,00FH,0DAH,0A2H     ; Mantisse  Pi/2
;
B98D0:  DEFB    080H                    ; Exponent  Pi/4
        DEFB    049H,00FH,0DAH,0A2H     ; Mantisse  Pi/4
;
B98D5:  DEFB    07BH                    ; Exponent  Pi/180
        DEFB    00EH,0FAH,035H,013H     ; Mantisse  Pi/180
;
;
;   Basic - Funktion   PEEK     (Token code 255 137 / 0FFH 089H)
;
A98DA:  PUSH    HL              ; Zeiger für Ergebnis retten
        CALL    HLFLT           ; Real - Wert (HL) umsetzen in Integer - Wert nach HL
        LD      E,(HL)          ; Wert aus Speicher holen
        LD      D,0             ; High - Byte Wert auf Null
        POP     HL              ; Zeiger für Ergebnis holen
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        RET
;
;
;   Basic - Funktion   RND     (Token code 255 136 / 0FFH 088H)
;
A98E6:  LD      A,(HL)          ; Exponent Argument holen
        OR      A               ; gleich Null  ?
        JR      Z,A98EF         ; ja -->  Argument gleich Null
        CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        JR      Z,A98FA         ; Wert positiv
A98EF:  PUSH    HL              ; Zeiger auf Argument retten
        LD      HL,04193H       ; Vorgabe für Anfangswert
        LD      (W9929),HL      ; als Zwischenwert RND merken
        POP     HL              ; Zeiger auf Argument holen
        XOR     A               ; Accu auf Null
        LD      R,A             ; ins Refresh - Register eintragen
A98FA:  PUSH    BC              ; Register - Wert  RND  holen
        LD      DE,(W9929)      ; Zwischenwert RND holen
        LD      A,R             ;! neuen Zwischenwert errechnen
        XOR     D               ;!
        RRC     A               ;!
        RRC     A               ;!
        RRC     A               ;!
        LD      D,A             ;!
        LD      A,R             ;!
        XOR     E               ;!
        RLC     A               ;!
        RLC     A               ;!
        LD      E,D             ;!
        LD      D,A             ;!
        LD      (W9929),DE      ; Zwischenwert RND merken
        PUSH    HL              ; Zeiger auf Argument retten
        INC     HL              ; Zeiger auf MSByte Mantisse
        RES     7,D             ; Vorzeichen auf plus
        LD      (HL),D          ;! Zwischenwert als Bytes der Mantisse eintragen
        INC     HL              ;!
        LD      (HL),E          ;!
        INC     HL
        LD      A,R             ; drittes Byte holen
        LD      (HL),A          ; und eintragen
        POP     HL              ; Zeiger auf Exponenten holen
        LD      (HL),081H       ; Exponent für Wert zwischen eins und zwei eintragen
        CALL    A95D5           ; eins vom Real - Wert (HL) abziehen
        POP     BC              ; geretteten Register - Wert holen
        RET
;
W9929:  DEFW    04193H          ; Zwischenwert RND
;
;
;   Basic - Funktion   EXP     (Token code 255 134 / 0FFH 086H)
;
A992B:  PUSH    BC              ; Keep register value
        LD      A,(HL)          ; Exponent Argument holen
        OR      A               ; gleich Null  ?
        JP      Z,A9631         ; ja -->  Ergebnis gleich '+1'
        INC     HL              ; Zeiger auf MSByte Mantisse
        LD      A,(HL)          ; Vorzeichen Argument holen
        LD      (S9A41),A       ; und merken
        RES     7,(HL)          ; Vorzeichen auf plus
        DEC     HL              ; Zeiger wieder auf Exponent
        LD      DE,B9B96        ; Zeiger auf 1/LN(2)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        PUSH    HL              ; Zeiger auf Argument / LN(2)
        CALL    A94DD           ; einen Rechenspeicher reservieren
        PUSH    DE              ; Zeiger auf Rechenspeicher merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; Zeiger auf Rechenspeicher holen
        CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        PUSH    HL              ; Zeiger auf INT(Argument/LN(2))
        CALL    HLFLT           ; Real - Wert (HL) umsetzen in Integer - Wert nach HL
        XOR     A               ; Accu auf Null
        CP      H               ; High - Byte gleich Null  ?
        JP      NZ,A6367        ; nein -->  Fehler 2   Overflow error
        LD      A,L             ; Low - Byte holen
        LD      (S9A40),A       ; als Wert - Zähler EXP - Routine merken
        POP     DE              ; Zeiger auf INT(Argument/LN(2))
        POP     HL              ; Zeiger auf Argument/LN(2) holen
        PUSH    HL              ; und wieder merken
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        PUSH    DE              ; Zeiger auf INT(Argument/LN(2))
        PUSH    HL              ; Zeiger auf FRAC(Argument/LN(2))
        CALL    A79C2           ; +1 im Real - Format nach (DE) übertragen
        POP     DE              ; Zeiger auf FRAC(Argument/LN(2))
        POP     HL              ; Zeiger auf +1
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        EX      DE,HL           ; Zeiger vertauschen
        XOR     A               ; Accu auf Null
        LD      B,8             ; acht Iterationsschritte
A996C:  PUSH    BC              ; Restanzahl Iterationsschritte merken
        PUSH    AF
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A997A         ; Zahl (DE) größer
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     AF
        SET     7,A
        PUSH    AF
A997A:  POP     AF
        RLC     A
        EX      DE,HL
        PUSH    AF
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        POP     AF
        EX      DE,HL
        POP     BC              ; Restanzahl Iterationsschritte holen
        DJNZ    A996C           ; Argument weiter angleichen
        LD      (S9A42),A
        PUSH    DE
        LD      DE,B9B8C        ; Zeiger auf LN(2)   (Real - Konstante)
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        BIT     3,A             ; Double - Precision  ?
        JR      NZ,A9998        ; ja
        LD      DE,B9B91        ; Zeiger auf LN(2)   (Real - Konstante)
A9998:  CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     DE
        PUSH    DE
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     HL
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        BIT     3,A             ; Double - Precision  ?
        JP      Z,A9A30         ; nein -->  Real - Wert
        CALL    A94D0           ; Real - Zahl (HL) mal zwei
        LD      DE,B7C40        ; Zeiger auf +10   (Real - Format)
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        POP     DE
        PUSH    DE
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,B7C40        ; Zeiger auf +10   (Real - Format)
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        CALL    A94D0           ; Real - Zahl (HL) mal zwei
        POP     DE
        PUSH    DE
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,B9B87        ; Zeiger auf  1/120   (Real - Konstante)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        CALL    A94D0           ; Real - Zahl (HL) mal zwei
        CALL    A95DB           ; +1 zur Zahl (HL) addieren
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        POP     DE
        PUSH    DE
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        CALL    A95DB           ; +1 zur Zahl (HL) addieren
        POP     DE
        PUSH    DE
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
A99E7:  CALL    A95DB           ; +1 zur Zahl (HL) addieren
        EX      (SP),HL
        EX      DE,HL
        PUSH    DE
        CALL    A79C2           ; +1 im Real - Format nach (DE) übertragen
        POP     HL
        LD      DE,B9B37        ; Zeiger auf Konstanten für EXP - Iteration
        LD      A,(S9A42)
        LD      B,8
A99F9:  RLC     A
        JR      NC,A9A04
        PUSH    AF
        PUSH    BC
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     BC
        POP     AF
A9A04:  INC     DE              ;! Zeiger auf nächstes Wert in Konstantentabelle
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        DJNZ    A99F9
        LD      A,(S9A40)       ; Wert - Zähler EXP - Routine holen
        ADD     A,(HL)
        JP      C,A6367         ; Fehler 2   Overflow error
        LD      (HL),A          ; Exponenten eintragen
        POP     DE
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     BC
        LD      A,(S9A41)       ; Vorzeichen Argument EXP
        RLC     A               ; nach Carry schieben
        RET     NC              ; Argument war positiv
        PUSH    BC              ;! Register - Werte retten
        PUSH    DE              ;!
        PUSH    HL              ; Zeiger für Ergebnis retten
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     DE              ; Zeiger auf Stelle für Ergebnis holen
        PUSH    DE              ; und wieder merken
        CALL    A79C2           ; +1 im Real - Format nach (DE) übertragen
        POP     HL              ; Zeiger auf +1
        POP     DE              ; Zeiger auf bisheriges Ergebnis
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        POP     BC              ; geretteten Register - Wert holen
        RET
;
A9A30:  POP     DE
        PUSH    DE
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      A,(HL)
        OR      A
        CALL    NZ,A94D5        ; Real - Zahl (HL) durch zwei
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        JP      A99E7           ; Wiedereinsprung in Routine
;
S9A40:  DEFS    1               ; Wert - Zähler  EXP - Routine
S9A41:  DEFS    1               ; Vorzeichen Argument EXP
S9A42:  DEFS    1
;
;
;   Basic - Funktion   LOG     (Token code 255 140 / 0FFH 08CH)
;
A9A43:  PUSH    BC              ; Keep register value
        CALL    A9A4F           ; LN - Routine   ( LN(HL) )
        LD      DE,B9B28        ; Zeiger auf  LOG(e)   (Real - Konstante)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Basic - Funktion   LN     (Token code 255 133 / 0FFH 085H)
;
A9A4F:  PUSH    BC              ; Keep register value
        CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        JP      NZ,A636A        ; negativ -->  Fehler 3  Illegal data error
        LD      A,(HL)          ; Exponent Argument holen
        OR      A               ; gleich Null  ?
        JP      Z,A636A         ; Argument = 0 -->  Fehler 3  Illegal data error
        SUB     081H            ; Exponentenzähler für Ergebnis errechnen
        LD      (S9B27),A       ; Exponentenzähler  LN - Routine
        LD      (HL),081H       ; neuen Exponenten vorgeben
        XOR     A               ; Accu auf Null
        LD      B,8             ; 8 Vergleichswerte
        LD      DE,B9B37        ; Zeiger auf Konstanten für LN - Routine
A9A68:  PUSH    BC              ; Zähler retten
        PUSH    AF
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A9A7E         ; Restwert kleiner Vergleichswert
        PUSH    HL              ; Zeiger auf Restwert retten
        LD      HL,8 * 5        ; Offset zur entsprechenden N.ten Wurzel aus 1/2
        ADD     HL,DE           ; Zeiger auf Tabelle errechnen
        EX      DE,HL           ; und nach DE
        EX      (SP),HL
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     DE
        POP     AF
        SET     7,A
        PUSH    AF
A9A7E:  POP     AF
        RLC     A
        INC     DE              ;! Zeiger auf Konstantentabelle auf nächsten
        INC     DE              ;! Wert in Tabelle
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        POP     BC              ; Zähler holen
        DJNZ    A9A68           ; weitere Durchläufe
        LD      (S9BA0),HL      ; Zeiger auf Rechenspeicher vier
        CALL    A94DD           ; einen Rechenspeicher reservieren
        EX      DE,HL           ; Zeiger auf Rechenspeicher nach HL
        LD      E,A
        LD      D,0             ; High - Byte Wert auf Null
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        LD      A,(HL)          ; Exponenten holen
        OR      A               ; gleich Null  ?
        JR      Z,A9A9D         ; ja -->  Wert gleich Null
        SUB     8
        LD      (HL),A
A9A9D:  LD      A,(S9B27)       ; Exponentenzähler  LN - Routine
        CP      080H
        JR      C,A9AA6
        NEG
A9AA6:  PUSH    HL
        CALL    A94DD           ; einen Rechenspeicher reservieren
        EX      DE,HL           ; Zeiger auf Rechenspeicher nach DE
        LD      (S9BA2),HL      ; Zeiger auf Rechenspeicher drei
        LD      E,A
        LD      D,0
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        LD      A,(S9B27)       ; Exponentenzähler  LN - Routine
        AND     10000000B
        INC     HL
        OR      (HL)
        LD      (HL),A
        DEC     HL
        EX      DE,HL
        POP     HL
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        LD      DE,B9B9B        ; Zeiger auf LN(2)  (Real - Konstante)
        CP      5               ; Real - Wert ?
        JR      Z,A9ACF         ; ja
        LD      DE,B9B8C        ; Zeiger auf LN(2)  (Real - Konstante)
A9ACF:  CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        PUSH    HL
        LD      DE,(S9BA2)      ; Zeiger auf Rechenspeicher drei
        LD      HL,(S9BA0)      ; Zeiger auf Rechenspeicher vier
        PUSH    HL              ; merken
        PUSH    DE              ; Zeiger auf Rechenspeicher drei merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     HL
        CALL    A95DB           ; +1 zur Zahl (HL) addieren
        EX      (SP),HL
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     DE
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        PUSH    DE
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     HL
        PUSH    DE
        LD      E,L
        LD      D,H
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     DE
        PUSH    HL
        PUSH    DE
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) übertragen
        POP     HL
        LD      DE,B9B32        ; Zeiger auf 5/3  (Real - Konstante)
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        EX      DE,HL
        POP     HL
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,B7C40        ; Zeiger auf  +10   (Real - Format)
        CALL    A94D0           ; Real - Zahl (HL) mal zwei
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        EX      DE,HL
        LD      HL,(S9BA0)      ; Zeiger auf Rechenspeicher vier
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,B9B2D        ; Zeiger auf 2/5  (Real - Konstante)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     DE
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        POP     BC              ; geretteten Register - Wert holen
        RET
;
S9B27:  DEFS    1               ; Exponentenzähler  LN - Routine
;
;
;   diverse Konstanten für Rechenroutinen
;
B9B28:  DEFB    07FH                    ; Exponent   0.43429448    LOG(e)
        DEFB    05EH,05BH,0D8H,0A9H     ; Mantisse   0.43429448    LOG(e)
;
B9B2D:  DEFB    07FH                    ; Exponent   0.4           2/5
        DEFB    04CH,0CCH,0CCH,0CDH     ; Mantisse   0.4           2/5
;
B9B32:  DEFB    081H                    ; Exponent   1.6666667     5/3
        DEFB    055H,055H,055H,056H     ; Mantisse   1.6666667     5/3
;
;
;   Konstanten für EXP - Routine
;
B9B37:  DEFB    081H                    ; Exponent   1.4142136       2te Wurzel (2)
        DEFB    035H,004H,0F3H,034H     ; Mantisse   1.4142136       2te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.1892071       4te Wurzel (2)
        DEFB    018H,037H,0F0H,052H     ; Mantisse   1.1892071       4te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.0905077       6te Wurzel (2)
        DEFB    00BH,095H,0C1H,0E4H     ; Mantisse   1.0905077       6te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.0442738       8te Wurzel (2)
        DEFB    005H,0AAH,0C3H,068H     ; Mantisse   1.0442738       8te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.0218972      10te Wurzel (2)
        DEFB    002H,0CDH,086H,099H     ; Mantisse   1.0218972      10te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.0108893      12te Wurzel (2)
        DEFB    001H,064H,0D1H,0F4H     ; Mantisse   1.0108893      12te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.0054299      14te Wurzel (2)
        DEFB    000H,0B1H,0EDH,050H     ; Mantisse   1.0054299      14te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.0027113      16te Wurzel (2)
        DEFB    000H,058H,0D7H,0D3H     ; Mantisse   1.0027133      16te Wurzel (2)
;
        DEFB    080H                    ; Exponent   0.70710078      2te Wurzel (1/2)
        DEFB    035H,004H,0F3H,034H     ; Mantisse   0.70710078      2te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.84089641      4te Wurzel (1/2)
        DEFB    057H,044H,0FCH,0CBH     ; Mantisse   0.84089641      4te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.91700404      6te Wurzel (1/2)
        DEFB    06AH,0C0H,0C6H,0E8H     ; Mantisse   0.91700404      6te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.95760328      8te Wurzel (1/2)
        DEFB    075H,025H,07DH,016H     ; Mantisse   0.95760328      8te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.97857206     10te Wurzel (1/2)
        DEFB    07AH,083H,0B2H,0DCH     ; Mantisse   0.97857206     10te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.98922801     12te Wurzel (1/2)
        DEFB    07DH,03EH,00CH,00DH     ; Mantisse   0.98922801     12te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.99459942     14te Wurzel (1/2)
        DEFB    07EH,09EH,011H,05DH     ; Mantisse   0.99459942     14te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.99729605     16te Wurzel (1/2)
        DEFB    07FH,04EH,0CBH,05AH     ; Mantisse   0.99729605     16te Wurzel (1/2)
;
B9B87:  DEFB    07AH                    ; Exponent   .83333333E-02     1/120
        DEFB    008H,088H,088H,089H     ; Mantisse   .83333333E-02     1/120
;
B9B8C:  DEFB    080H                    ; Exponent   0.69314718        LN(2)
        DEFB    031H,072H,017H,0F8H     ; Mantisse   0.69314718        LN(2)
;
B9B91:  DEFB    080H                    ; Exponent   0.69314718        LN(2)
        DEFB    031H,072H,017H,0F8H     ; Mantisse   0.69314718        LN(2)
;
B9B96:  DEFB    081H                    ; Exponent   1.442695          1/LN(2)
        DEFB    038H,0AAH,03BH,02AH     ; Mantisse   1,442695          1/LN(2)
;
B9B9B:  DEFB    080H                    ; Exponent   0.69314718        LN(2)
        DEFB    031H,072H,017H,0F8H     ; Mantisse   0.69314718        LN(2)
;
;
;   Speicher für Zeiger auf dynamische Zwischenspeicher für Rechenroutinen
;
S9BA0:  DEFS    2       ; Zeiger auf Rechenspeicher vier
S9BA2:  DEFS    2       ; Zeiger auf Rechenspeicher drei
S9BA4:  DEFS    2       ; Zeiger auf Rechenspeicher zwei
S9BA6:  DEFS    2       ; Zeiger auf Rechenspeicher eins
S9BA8:  DEFS    2       ; Zeiger auf Speicher für COS(Argument)
S9BAA:  DEFS    2       ; Zeiger auf Speicher für SIN(Argument)
;
;
;   Basic - Befehl   SOUND     (Token code 254 138 / 0FEH 08AH)
;
A9BAC:  CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFB    ____EQ          ; Zwischencode  =  ?
        JR      NZ,A9BBE        ; nicht SOUND =
        CALL    A79A3           ; auf Syntax 'Klammer auf' überprüfen
        CALL    IBYTE           ; 1-Byte - Wert nach E/Accu bereitstellen
        CP      15 + 1          ; größer als maximale Generatornummer  ?
        SET     7,A             ; Code for 'SOUND =' für Syntaxüberprüfung
        JR      A9BC3           ; überprüfen und Frequenz bereitstellen
;
A9BBE:  CALL    IBYTE           ; 1-Byte - Wert nach E/Accu bereitstellen
        CP      83 + 1          ; größer als maximale Notennummer  ?
A9BC3:  JP      NC,A636A        ; ja -->  Fehler 3  Illegal data error
        PUSH    AF              ; Generatornummer / Note retten
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    IDEEXP          ; Ausdruck (HL) auswerten und 2-Byte-Wert nach DE bereitst.
        POP     AF              ; Generatornummer / Note holen
        PUSH    AF              ; und wieder retten
        OR      A               ; SOUND =  ?
        CALL    M,A79AA         ; ja -->  auf Syntax 'Klammer zu' untersuchen
        POP     AF              ; Generatornummer / Note holen
        PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    34              ; Code 34  Ton nach Generatornr./Frequenz oder Note/Länge
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   TEMPO     (Token code 254 163 / 0FE 0A3H)
;
A9BD9:  CALL    IBYTE           ; 1-Byte - Wert nach E/Accu bereitstellen
        DEC     A               ;! auf Tempo von 1 bis 7 untersuchen
        CP      7               ;! (hier fehlt aber irgendwie der Sprung
        INC     A               ;!  bei fehlerhaften Wert)
        JP      _TEMPO          ; Tempo setzen
;
;
;   Basic - Befehl   NOISE     (Token code 254 140 / 0FEH 08CH)
;
A9BE3:  LD      A,00001000B     ; Code for 'Tongenerator 4'
        DEFB    LD_BC
;
;
;   Basic - Befehl   MUSIC     (Token code 254 163 / 0FEH 0A0H)
;
A9BE6:  LD      A,00000111B     ; Code for 'Tongenerator 1 - 3'
        LD      (S9CEB),A       ; Flag  'NOISE/MUSIC'
        CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
        LD      B,3             ; Code for 'MUSIC WAIT'
        CP      __WAIT          ; Zwischencode  WAIT  ?
        JR      Z,A9C07         ; ja -->  MUSIC WAIT
        DEC     B               ; Code auf  'MUSIC STOP'
        CP      __STOP          ; Zwischencode  STOP  ?
        JR      Z,A9C07         ; ja -->  MUSIC STOP
        CP      __INIT          ; Zwischencode INIT  ?
        JR      NZ,A9C0D        ; nein -->  normaler MUSIC - Befehl
        LD      DE,B9CDF        ; Zeiger auf Speicher für aktuelle Oktave
        LD      B,4             ; Vier Generatorwerte
        LD      A,2             ; Oktave vorgeben
        CALL    SETDE           ; Speicherbereich (DE) mit Konstante im Accu füllen
A9C07:  PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    35              ; Code 35   MUSIC nach Status in B behandeln
        POP     HL              ; geretteten Programmzeiger holen
        INC     HL              ; Zwischencode überspringen
        RET
;
;
;   Zeichenketten für MUSIC bereitstellen und auswerten
;
A9C0D:  CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        RET     Z               ; ja -->  fertig
        XOR     A               ; Accu auf Null
        LD      (S9CE7),A       ; Zähler 'bereitgestellte Zeichenkettenlänge' zurücksetzen
        LD      (S9CE8),A       ; Zähler 'Stringnummer für parallele Ausgabe' zurücksetzen
        LD      B,A             ; Null
        LD      A,CR            ; Textendezeichen
        LD      DE,S27D0        ; Zeiger auf Anfang Speicher für MUSIC - Text
        LD      (S9CE9),DE      ; Zeiger auf aktuelle Speicherstelle für MUSIC - Text
        LD      (DE),A          ; Textendezeichen eintragen
        CALL    SETDE           ; Speicherbereich (DE) mit Konstante im Accu füllen
        LD      A,(S9CEB)       ; Flag  'NOISE/MUSIC'
        LD      (S9CEC),A       ; als Flag 'welcher Tongenerator'  merken
A9C2C:  LD      DE,S9CEC        ; Zeiger auf Flag 'welcher Tongenerator'
        LD      A,(DE)          ; Flag 'welcher Tongenerator' holen
        RRC     A               ; ein Bit nach Carry schieben
        LD      (DE),A          ; Restbits merken
        PUSH    AF              ; Tongenerator-Status merken
        LD      B,0             ; Vorgabe für Zeichenkettenlänge
        JR      NC,A9C42        ; Bit nicht gesetzt -->  Tongegerator wird nicht angesprochen
        CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
        CP      ';'             ; Strichpunkt  ?
        JR      Z,A9C42         ; ja -->  keine Zeichenkette für Tongenerator angegeben
        CALL    A8561           ; Stringausdruck (HL) auswerten / Zeiger auf String nach DE
A9C42:  PUSH    HL              ; Programmzeiger retten
        LD      A,(S9CE8)       ; Zähler 'Stringnummer für parallele Ausgabe'
        CP      4               ; schon vierter paralleler String  ?
        JP      Z,A6364         ; ja -->  Fehler 1  Syntax error
        INC     A               ; Zähler plus eins
        LD      (S9CE8),A       ; Zähler 'Stringnummer für parallele Ausgabe' merken
        INC     B               ; Stringlänge plus eins   (für Textendezeichen)
        JP      Z,A6370         ; zu groß -->  Fehler 5   String length error
        LD      A,(S9CE7)       ; Zähler 'bereitgestellte Zeichenkettenlänge'  holen
        ADD     A,B             ; plus neue Länge
        JP      C,A6370         ; zu groß -->  Fehler 5   String lenght error
        LD      (S9CE7),A       ; Zähler 'bereitgestellte Zeichenkettenlänge' merken
        LD      HL,(S9CE9)      ; Zeiger auf aktuelle Speicherstelle für MUSIC - Text holen
        CALL    LDHLDE          ; Speicherbereich von (DE) nach (HL) verschieben
        LD      (S9CE9),HL      ; Zeiger auf aktuelle Speicherstelle für MUSIC - Text
        DEC     HL              ; Zeiger auf Stelle für Textendezeichen
        LD      (HL),CR         ; Textende eintragen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; geretteten Tongeneratorstatus holen
        JR      NC,A9C2C        ; Tongenerator nicht angesprochen -->  weiter untersuchen
        CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        JR      Z,A9C7E         ; ja -->  bereitgestellte Texte auswerten
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A9C7E         ; wieder von vorne -->  bereitgestellte Texte auswerten
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    ";"             ; Strichpunkt als Trennzeichen überspringen
        JR      A9C2C           ; weitere MUSIC - Teile auswerten
;
A9C7E:  PUSH    HL              ; Programmzeiger retten
        LD      HL,S27D0        ; Zeiger auf Speicher mit MUSIC - Texten
        PUSH    HL              ;! nach IX
        POP     IX              ;!
        LD      IY,B9CDF        ; Zeiger auf Speicher für aktuelle Oktave des Tongenerators
        LD      B,4             ; Texte für vier Tongeneratoren auswerten
A9C8B:  PUSH    BC              ; Zähler 'Restanzahl Texte' retten
        PUSH    HL              ; Zeiger auf MUSIC - Texte retten
        PUSH    IX              ;! Zeiger auf Stelle für Tongeneratorwerte
        POP     HL              ;! nach HL
        LD      DE,S27D0        ; Zeiger auf Anfang Speicher für Tongeneratorwerte
        XOR     A               ; Carry - Flag zurücksetzen
        SBC     HL,DE           ; Offset auf Werte für Tongenerator errechnen
        LD      (IY+4),L        ; und merken
        POP     HL              ; Zeiger auf MUSIC - Texte merken
        LD      (A9CA1 + 1),SP  ; Stackpointer in Routine eintragen
        CALL    A9CED           ; MUSIC-Text (HL) auswerten und Werte für Tongenerator nach (IX)
A9CA1:  LD      SP,0            ; Stackpointer neu setzen
        POP     BC              ; Zähler 'Restanzahl Texte' holen
        INC     HL              ; Endezeichen MUSIC-Text überspringen
        INC     IY              ; Endezeichen Tongeneratorwert überspringen
        DJNZ    A9C8B           ; weitere Texte auswerten
        LD      B,3             ; Code 'MUSIC WAIT'  (Ende der letzten Melodie abwarten)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    35              ; Code 35   MUSIC nach Status in B behandeln
        LD      BC,256          ; maximal 256 Byte bereitgestellt
        LD      HL,S27D0        ; Zeiger auf bereitgestellte Werte für Tongenerator
        LD      DE,S2ED0        ; Zeiger auf Speicher für Generatorwerte
        LDIR                    ; Werte im Speicher retten
        LD      B,4             ; Werte für vier Tongeneratoren übergeben
        LD      HL,S9CE3        ; Zeiger auf Speicher mit Offsets auf Werte
A9CBE:  LD      E,(HL)          ; einen Offset aus Speicher holen
        LD      D,0             ; High - Byte Offset auf Null
        INC     HL              ; Zeiger auf nächsten Offset
        PUSH    HL              ; Zeiger merken
        LD      HL,S2ED0        ; Zeiger auf Anfang Speicher mit Werten für Tongeneratoren
        ADD     HL,DE           ; Zeiger auf aktuellen Speicher errechnen
        LD      A,(HL)          ; ersten Wert aus Tabelle holen
        CP      -1              ; End of table  ?
        JR      Z,A9CD4         ; ja -->  keine Werte für diesen Tongenerator
        LD      A,4             ;! Tongeneratornummer aus Zähler errechnen
        SUB     B               ;!
        PUSH    BC              ; Tongeneratorzähler merken
        EX      DE,HL           ; Zeiger auf Tongeneratorwerte nach DE
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    33              ; Code 33  Werte (DE) nach Tongenerator im Accu
        POP     BC              ; Tongeneratorzähler holen
A9CD4:  POP     HL              ; Zeiger auf Offsets holen
        DJNZ    A9CBE           ; Werte für weitere Tongeneratoren auswerten
        LD      B,1
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    35              ; Code 35   MUSIC nach Status in B behandeln
        POP     HL              ; geretteten Programmzeiger holen
        JP      A9C0D           ; untersuchen, ob weitere MUSIC - Teile
;
;
;   Zeiger auf Speicher für aktuelle Oktave des Tongenerators
;
B9CDF:  DEFB    2               ; Tongenerator  1
        DEFB    2               ; Tongenerator  2
        DEFB    2               ; Tongenerator  3
        DEFB    2               ; Rauschgenerator
;
S9CE3:  DEFS    4               ; Speicher für Offset auf Tongeneratorwerte
S9CE7:  DEFS    1               ; Zähler 'bereitgestellte Zeichenkettenlänge'
S9CE8:  DEFS    1               ; Zähler 'Stringnummer für parallele Ausgabe'
S9CE9:  DEFS    2               ; Zeiger auf aktuelle Speicherstelle für MUSIC - Text
S9CEB:  DEFS    1               ; Flag  'NOISE/MUSIC'
S9CEC:  DEFS    1               ; Flag 'welcher Tongenerator'
;
;
;   Music - String (HL) auswerten und Werte für Tongenerator nach (IX) bereitstellen
;
A9CED:  CALL    A9E36           ; Speicher für Steuerparameter löschen
A9CF0:  CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
        CALL    A9E0C           ; testen, ob Zeichen im Accu gleich Notenbuchstabe ist
        JR      C,A9CFF         ; kein Notenbuchstabe -->  auf Sonderzeichen untersuchen
        LD      C,0             ; Vorgabe für Offset auf Notennummer
        CALL    A9D60           ; Notenbuchstaben auswerten
        JR      A9D1F           ; untersuchen, ob Fehler aufgetreten ist
;
A9CFF:  CALL    A9E16           ; testen, ob Accu gleich Melodieendezeichen ist
        JP      Z,A9E1E         ; ja -->  Endezeichen eintragen
        LD      B,12            ; 12 Sonderzeichen in Tabelle
        EX      DE,HL           ; Zeiger auf Notentext nach DE
        LD      HL,M9D26        ; Zeiger auf Tabelle mit Sonderzeichen
A9D0B:  CP      (HL)            ; Accu mit Zeichen in Tabelle vergleichen
        INC     HL              ; Tabellenzeichen überspringen
        JR      Z,A9D17         ; Zeichen gefunden -->  Routine aufrufen
        DEC     B               ; Restanzahl Zeichen minus eins
        JP      Z,A636A         ; Zeichen nicht gefunden -->  Fehler 3  Illegal data error
        INC     HL              ;! Anfangsadresse in Tabelle überspringen
        INC     HL              ;!
        JR      A9D0B           ; nächstes Zeichen in Tabelle vergleichen
;
A9D17:  LD      C,(HL)          ;! Anfangsadresse der Routine aus
        INC     HL              ;! Tabelle holen
        LD      B,(HL)          ;!
        EX      DE,HL           ; Zeiger auf Music - Text nach HL
        INC     HL              ; ausgewertetes Zeichen überspringen
        CALL    A9D24           ; Routine (BC) aufrufen
A9D1F:  JP      C,A636A         ; Fehler in Routine -->  Fehler 3  Illegal data error
        JR      A9CF0           ; Rest Notentext untersuchen
;
A9D24:  PUSH    BC              ; Anfangsadresse auf Stack ablegen
        RET                     ; Routine aufrufen
;
;
;   Tabelle mit Anfangsadresse der Sonderfunktionen im Music - Text
;
M9D26:  DEFM    "#"             ; erhöhte Note
        DEFW    A9D57           ; Anfangsadresse der Routine
        DEFM    "+"             ; obere Oktave
        DEFW    A9D4D           ; Anfangsadresse der Routine
        DEFB    0D7H            ; obere Oktave   (Balken oben)
        DEFW    A9D4D           ; Anfangsadresse der Routine
        DEFM    "-"             ; untere Oktave
        DEFW    A9D4A           ; Anfangsadresse der Routine
        DEFB    0CFH            ; untere Oktave  (Balken unten)
        DEFW    A9D4A           ; Anfangsadresse der Routine
        DEFM    "O"             ; Oktave setzen
        DEFW    A9D91           ; Anfangsadresse der Routine
        DEFM    "N"             ; Note angegeben
        DEFW    A9DA0           ; Anfangsadresse der Routine
        DEFM    "T"             ; Tempo angegeben
        DEFW    A9DAA           ; Anfangsadresse der Routine
        DEFM    "V"             ; Lautstärke angegeben
        DEFW    A9DBC           ; Anfangsadresse der Routine
        DEFM    "S"             ; Wellenform angegeben
        DEFW    A9DDE           ; Anfangsadresse der Routine
        DEFM    "M"             ; Wiederholungsfaktor angegeben
        DEFW    A9DEC           ; Anfangsadresse der Routine
        DEFM    "L"             ; Tonlänge angegeben
        DEFW    A9DCD           ; Anfangsadresse der Routine
;
;
;   Note in unterer Oktave auswerten
;
A9D4A:  LD      C,-12           ; Offset für Notennummer in unterer Oktave
        DEFB    LD_DE
;
;
;   Note in oberer Oktave auswerten
;
A9D4D:  LD      C,12            ; Offset für Notennummer in oberer Oktave
        CALL    TEST1           ; Vergleich auf Byte hinter CALL
        DEFM    "#"             ; erhöhte Note  ?
        JR      NZ,B9D56        ; nein
        INC     C               ; Offset für Notennummer plus eins
B9D56:  DEFB    LD_DE
;
;
;   erhöhte Note auswerten
;
A9D57:  LD      C,1             ; Offset für erhöhte Note vorgeben
        CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
        CALL    A9E0C           ; testen, ob Zeichen im Accu gleich Notenbuchstabe ist
        RET     C               ; kein Notenbuchstabe -->  Abbruch
A9D60:  LD      B,A             ; Notenbuchstaben merken
        INC     HL              ; Notenbuchstaben im Text überspringen
        CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        CCF                     ; Ergebnisflag umkehren
        CALL    C,A9DD4         ; Nummer angegeben -->  Tonlänge auswerten
        RET     C               ; Fehler aufgetreten -->  Abbruch
        LD      A,B             ; Notenbuchstaben holen
        CP      'R'             ; Pause  ?
        JR      Z,A9D85         ; ja -->  merken
        PUSH    HL              ; Zeiger auf Resttext retten
        LD      HL,B9E3E + -'A' ; Zeiger auf Notenoffset für Notennummer
        CALL    ADDHLA          ; Wert im Accu zum HL-Register addieren
        LD      B,(IY+0)        ; aktuelle Oktave holen
        INC     B               ; für Schleife corrigieren
        LD      A,(HL)          ; Offset der Note aus Tabelle holen
        POP     HL              ; Zeiger auf Rest Notentext holen
        ADD     A,C             ; eventuellen Offset aus Oktave oder erhöhter Note addieren
        SUB     12              ; Wert für Schleife corrigieren
A9D7F:  ADD     A,12            ;! Notennummer der Note aus Notenoffset und aktueller
        DJNZ    A9D7F           ;! Oktave errechnen  (12 Töne je Oktave)
        JR      A9DA4           ; Notennummer überprüfen und merken
;
A9D85:  XOR     A               ; Code for 'Pause'
A9D86:  PUSH    AF              ; neuen Wert retten
        CALL    A9E29           ; untersuchen, ob sich Steuerparameter geändert hat
        POP     AF              ; geretteten neuen Wert holen
A9D8B:  LD      (IX+0),A        ; neuen Wert merken
        INC     IX              ; Zeiger auf Speicher auf nächste Stelle
        RET
;
;
;   Oktave setzen
;
A9D91:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        JR      NC,A9D98        ; Zahlwert angegeben
        LD      A,2             ; Vorgabe für Oktave - Nummer
A9D98:  CP      6 + 1           ; Oktave 0 bis 6  ?
        CCF                     ; Ergebnis umkehren
        RET     C               ; Oktave zu groß -->  Abbruch
        LD      (IY+0),A        ; aktuelle Oktave des Tongenerators merken
        RET
;
;
;   Notennummer auswerten
;
A9DA0:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        RET     C               ; keine Notennummer angegeben -->  Abbruch
A9DA4:  CP      83 + 1          ; Notennummer 0 - 83  ?
        CCF                     ; Ergebnis umkehren
        RET     C               ; Notennummer zu groß -->  Abbruch
        JR      A9D86           ; Notennummer merken
;
;
;   Tempo auswerten
;
A9DAA:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        JR      NC,A9DB1        ; Tempo angegeben
        LD      A,4             ; Vorgabe für Tempo
A9DB1:  DEC     A               ;! Tempo zwischen 1 und 7  ?
        CP      7               ;!
        CCF                             ; Ergebnis umkehren
        RET     C               ; falsches Tempo -->  Abbruch
        ADD     A,06AH          ; plus Code for 'Tempo'
        LD      (S9E45),A       ; aktuelles Tempo merken
        RET
;
;
;   Lautstärke auswerten
;
A9DBC:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        JR      NC,A9DC3        ; Lautstärke angegeben
        LD      A,15            ; Vorgabe für Lautstärke
A9DC3:  CP      15 + 1          ; mit maximaler Lautstärke vergleichen
        CCF                     ; Ergebnis umkehren
        RET     C               ; Lautstärke zu groß -->  Abbruch
        ADD     A,080H          ; plus Code for 'Lautstärke'
        LD      (S9E46),A       ; aktuelle Lautstärke merken
        RET
;
;
;   Tonlänge auswerten
;
A9DCD:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        JR      NC,A9DD4        ; Tonlänge angegeben
        LD      A,5             ; Vorgabe für Tonlänge
A9DD4:  CP      9 + 1           ; mit maximaler Tonlänge vergleichen
        CCF                     ; Ergebnis umkehren
        RET     C               ; Tonlänge zu groß -->  Abbruch
        ADD     A,060H          ; plus Code for 'Tonlänge'
        LD      (S9E47),A       ; aktuelle Tonlänge merken
        RET
;
;
;   Wellenform auswerten
;
A9DDE:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        RET     C               ; keine Wellenform angegeben
        CP      8 + 1           ; mit maximaler Wellenform vergleichen
        CCF                     ; Ergebnis umkehren
        RET     C               ; Wellenform zu groß -->  Abbruch
        ADD     A,090H          ; plus Code 'Wellenform'
        LD      (S9E48),A       ; aktuelle Wellenform merken
        RET
;
;
;   Wiederholungsfaktor auswerten
;
A9DEC:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        RET     C               ; kein Wiederholungsfaktor angegeben -->  Abbruch
        OR      A               ; gleich Null  ?
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET     Z               ; gleich Null -->  Abbruch
        LD      B,A             ; Wiederholungsfaktor merke
        LD      C,0A0H          ; Code for 'Wiederholungsfaktor'
        LD      (S9E49),BC      ; Code und Wiederholungsfaktor merken
        OR      A
        RET
;
;
;   testen, ob (HL) Zahlwert, wenn ja -->  Zahlwert nach E/Accu bereitstellen
;
A9DFC:  CALL    HLFTCH          ; Leerzeichen (Spaces)   (HL) überspringen
        CALL    A9E16           ; testen, ob Accu gleich Melodieendezeichen ist
        SCF                     ; Code for 'kein Zahlwert'
        CALL    NZ,A79F6        ; nicht Ende -->  testen, ob Accu gleich Ziffer ist
        RET     C               ; kein Zahlwert angegeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    19              ; Code 19   ASCII - Wert (HL) umsetzen in Hex-Wert nach DE
        JP      DCHECK          ; untersuchen, ob Wert in DE zwischen 0 und 255 liegt
;
;
;   testen, ob Zeichen im Accu gleich Notenbuchstabe ist
;
A9E0C:  CP      'R'             ; Pause  ?
        RET     Z               ; ja
        CP      'A'             ; Notenbuchstabe  ?
        RET     C               ; nein
        CP      'G' + 1         ; Notenbuchstabe  ?
        CCF                     ; Ergebnisflag umkehren
        RET
;
;
;   testen, ob Accu gleich Melodieendezeichen ist
;
A9E16:  OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja
        CP      CR              ; Textendezeichen  ?
        RET     Z               ; ja
        CP      0C8H            ; Melodieendezeichen  ?
        RET
;
;
;   Ende der Wertetabelle eintragen
;
A9E1E:  CALL    A9E29           ; untersuchen, ob sich Steuerparameter geändert hat
        LD      A,-1            ; 'End of table' code
        CALL    A9D8B           ; Wert im Accu merken
A9E26:
        JP      A9CA1           ; Text für nächsten Tongenerator auswerten
;
;
;   untersuchen, ob sich Steuerparameter geändert hat, wenn ja -->  merken
;
A9E29:  LD      DE,S9E45        ; Zeiger auf Speicher für Steuerparameter
        LD      B,6             ; sechs Speicher
A9E2E:  LD      A,(DE)          ; ein Wert aus Speicher holen
        OR      A               ; gleich Null  ?
        CALL    NZ,A9D8B        ; nein -->  merken
        INC     DE              ; Zeiger auf nächsten Speicher
        DJNZ    A9E2E           ; weitere Speicherzellen überprüfen
;
;
;   Speicher für Steuerparameter löschen
;
A9E36:  LD      DE,S9E45        ; Zeiger auf Speicher für Steuerparameter
        LD      B,6             ; Anzahl Zeichen
        JP      CLRDE           ; Speicherbereich (DE) löschen
;
;
;   Tabelle mit Offsets der Noten innerhalb der Oktave
;
B9E3E:  DEFB    9               ; A
        DEFB    11              ; B
        DEFB    0               ; C
        DEFB    2               ; D
        DEFB    4               ; E
        DEFB    5               ; F
        DEFB    7               ; G
;
;
;   Speicher für Steuerparameter   (MUSIC)
;
S9E45:  DEFS    1               ; Tempo
S9E46:  DEFS    1               ; Lautstärke
S9E47:  DEFS    1               ; Tonlänge
S9E48:  DEFS    1               ; Wellenform
S9E49:  DEFS    2               ; Wiederholungsfaktor
;
;
;   Statusdatensatz des aktuellen Programms  (wird bei SWAP gerettet)
;
S9E4B:  DEFS    2               ; Zeiger auf nächste Zeile
S9E4D:  DEFS    2               ; Editor - Zeilennummer
S9E4F:  DEFS    2               ; Offset für AUTO
S9E51:  DEFS    2               ; Zeilennummer der aktuellen Zeile
S9E53:  DEFS    1               ; Fehlernummer
S9E54:  DEFS    1               ; ON ERROR GOTO - Status
S9E55:  DEFS    2               ; Fehler - Zeilennummer
S9E57:  DEFS    2               ; Zeiger auf nächste Zeile bei Fehler
S9E59:  DEFS    2               ; Programmzeiger bei Fehler
S9E5B:  DEFS    2               ; Zeiger auf Fehlerbehandlungsroutine
S9E5D:  DEFS    1               ; DATA - Flag
S9E5E:  DEFS    2               ; DATA - Zeiger
;
W9E60:  DEFW    21              ; Rettlänge für SWAP
W9E62:  DEFW    -21             ; Rettlänge für SWAP  (Complement)
;
;
;
S9E64:  DEFS    2               ; Stackpointer bei Anfang Befehl
S9E66:  DEFS    2               ; Programmzeiger bei Anfang Befehl
S9E68:  DEFS    2
;
S9E6A:  DEFS    7               ; Zeiger auf Zwischenspeicher  (bei USING - Format)
S9E71:  DEFS    1               ; Speicher zur Zahlaufbereitung in ASCII  (33 Byte)
S9E72:  DEFS    3               ; Anfang Speicher für ASCII - Zahl
S9E75:  DEFS    1               ; Speicher für ASCII - Zahl  (mindestens 5 Z.)
S9E76:  DEFS    4               ; Speicher für Aufbereitung Hex - Wert
S9E7A:  DEFS    1               ; Stelle für Dezimalpunkt
S9E7B:  DEFS    8               ; Speicher für Nachkommastellen
S9E83:  DEFS    25              ; maximales Ende Mantisse ohne Exponent
;
S9E9C:  DEFB    8               ; Wertart des bereitgestellten Wertes
;
S9E9D:  DEFS    8               ; Zwischenspeicher für Berechnung
ZFAC1:  DEFS    8               ; Speicher für Real - Zahlwert
S9EAD:  DEFS    8               ; Speicher für Real - Zahl   (ASCII-Aufber.)


;   Text for copyright message
;
;   This space is also used for tokenized line after output 
;
IMDBUF: DEFB    C_CLR,CR
        DEFB    0D7H,0D7H,0D7H,0D7H     ; Balken oben
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFM    " DISK BASIC I"         ; DISK BASIC interpreter MZ-2Z046 V1.0A
        DEFB    _SML
        DEFM    "NTERPRETER "
        DEFB    _CAP
        DEFM    "MZ-2Z046 V 1.0A "
        DEFB    CR
        DEFM    "   C"                  ; Copyright (C) by SHARP CORP.
        DEFB    _SML
        DEFM    "OPYRIGHT "
        DEFB    _CAP
        DEFM    "(C) 1984 "
        DEFB    _SML
        DEFM    " BY"
        DEFB    _CAP
        DEFM    " SHARP CORP.   "
        DEFB    0CFH,0CFH,0CFH,0CFH     ; Underlined
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
		DEFB    CR,_SML
        DEFM    "22338 BYTES FREE "     ; 22338 bytes free
        DEFB    CR,CR,NUL
;
        DEFS    92                      ; Rest Speicher für Zwischencodezeile
;
;
;   Die folgenden Routinen sind im wesentlichen für den MZ - 800 - Plotter
;
M9FD0:  DEFM    "N"             ; Textgrößenflag Drucker
;
;
;   Plotterroutinen löschen   (NEW ON)
;
A9FD1:  LD      BC,T63CB        ; Fehler 59'   Can't execute error
        LD      DE,B9FF9        ; Zeiger auf Tabelle mit gelöschten Befehlen
A9FD7:  LD      A,(DE)          ; Zwischencode aus Tabelle holen
        INC     DE              ; Zeiger auf Tabelle auf nächsten Befehl
        ADD     A,A             ; Tabellenende  ?
        JR      Z,A9FE7         ; ja -->  noch Parallelausgabe abschalten
        LD      HL,W5C5B        ; Zeiger auf Tabelle mit Anfangsadressen
        CALL    ADDHLA          ; Wert im Accu zum HL - Register addieren
        LD      (HL),C          ;! Fehleradresse als Anfangsadresse
        INC     HL              ;! des Befehls eintragen
        LD      (HL),B          ;!
        JR      A9FD7           ; weitere Befehle abnippeln
;
A9FE7:  XOR     A               ; Accu auf Null
        LD      (INPFLG),A      ; Parallelausgabeflag Drucker zurücksetzen
        LD      A,(PNMODE)      ; Drucker - Modus - Flag holen
        DEC     A               ; im Textmodus  ?
        CALL    NZ,AA04D        ; nein -->  umschalten auf Textmodus
        LD      HL,AA017        ; neuer Anfang freier Speicher vorgeben
        LD      (TEXTST),HL     ; Zeiger auf Basic - Programmanfang merken
        RET
;
;
;   Tabelle mit Zwischencodes der mit NEW ON gelöschten Befehle
;
B9FF9:  DEFB    0A2H            ; PMODE
        DEFB    0A3H            ; PSKIP
        DEFB    0A4H            ; PLOT
        DEFB    0A5H            ; PLINE
        DEFB    0A6H            ; RLINE
        DEFB    0A7H            ; PMOVE
        DEFB    0A8H            ; RMOVE
        DEFB    0AEH            ; PCOLOR
        DEFB    0AFH            ; PHOME
        DEFB    0B0H            ; HSET
        DEFB    0B1H            ; GPRINT
        DEFB    0B3H            ; AXIS
        DEFB    0BBH            ; PCIRCLE
        DEFB    0BCH            ; PTEST
        DEFB    0BDH            ; PAGE
        DEFB    0               ; End of table
;
;
;   Drucker auf Textmodus überprüfen
;
AA009:  LD      B,1             ; Code for 'Textmodus'
        JR      AA00F           ; Drucker - Modus überprüfen
;
;
;   Drucker auf Graphic - Modus überprüfen
;
AA00D:  LD      B,2             ; Code for 'Graphic - Modus'
AA00F:  LD      A,(PNMODE)      ; Drucker - Modus - Flag holen
        CP      B               ; mit Vorgabe vergleichen
        RET     Z               ; Drucker - Modus ist OK
        JP      A63B7           ; Fehler 68   Dev. mode error
;
;
;   Die folgenden Graphic - Plotter - Routinen werden mit NEW ON abgekoppelt.
;   Ab hier kann dann das BASIC - Anwender - Programm gespeichert werden.
;
;
;   Basic - Befehl   MODE     (Token code 162 / 0A2H)
;
AA017:  CALL    AA01F           ; Drucker - Modus auswerten und Drucker umstellen
        XOR     A               ; Accu auf Null
        LD      (LPOSB),A       ; als Spaltennummer Drucker merken
        RET
;
;
;   angegebenen Drucker - Modus auswerten und Drucker umstellen
;
AA01F:  LD      A,(INPFLG)      ; Parallelausgabeflag Drucker holen
        OR      A               ; Parallelausgabe gesetzt  ?
        JP      NZ,A63B7        ; ja -->  Fehler 68   Dev. mode error
        CALL    AA46A           ; Abfrage, ob angewählter Drucker der MZ-800 - Plotter ist
        CALL    TEST1           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    "G"             ; MODE  G   ?
        JP      Z,AA071         ; ja -->  auf Graphic - Modus umschalten
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "T"             ; MODE  T   ?
        CALL    TEST1           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    "N"             ; MODE  TN   ?
        JR      Z,AA044         ; ja -->  Textgrößenflag merken und Drucker umschalten
        CALL    TEST1           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    "L"             ; MODE  TL   ?
        JR      Z,AA044         ; ja -->  Textgrößenflag merken und Drucker umschalten
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "S"             ; MODE  TS   ?
AA044:  LD      (M9FD0),A       ; Textgrößenflag Drucker merken
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        CALL    AA069           ; Zeilenvorschub / Zeilenrückzug  ausgeben
AA04D:  LD      A,1             ; Code for 'Umschalten auf Textmodus'
        LD      (PNMODE),A      ; als Drucker - Modus - Flag merken
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        LD      A,(M9FD0)       ; Textgrößenflag Drucker holen
        CP      'N'             ; MODE  TN  ?
        RET     Z               ; ja -->  fertig
        CP      'L'             ; MODE  TL  ?
        LD      A,00BH          ; Code for 'Umschalten auf 26 Zeichen/Zeile'
        JR      Z,AA066         ; Steuercode an Drucker ausgeben
;
;
;   Drucker / Plotter  umschalten auf 80 Zeichen / Zeile
;
AA060:  LD      A,009H          ; Code for 'Umschalten auf 80 Zeichen / Zeile'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
AA066:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        RET
;
;
;   Zeilenvorschub / Zeilenrückzug ausgeben, im Papier zu spannen
;
AA069:  LD      A,LF            ; Code for 'Zeilenvorschub'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        LD      A,ETX           ; Code for 'Zeilenrückzug'
        JR      AA066           ; Zeichen im Accu an Drucker ausgeben
;
;
;   Drucker auf Graphic - Modus umstellen
;
AA071:  INC     HL              ; ausgewertetes Zeichen überspringen
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        LD      A,2             ; Code for 'Umschalten auf Graphic - Modus'
        LD      (PNMODE),A      ; als Drucker - Modus - Flag merken
        JR      AA066           ; Zeichen im Accu an Drucker ausgeben
;
;
;   Basic - Befehl   SKIP     (Token code 163 / 0A3H)
;
AA07C:  CALL    AA46A           ; Abfrage, ob angewählter Drucker der MZ-800 - Plotter ist
        CALL    AA009           ; Drucker auf Text - Modus überprüfen
        CALL    IDEEXP          ; Ausdruck (HL) auswerten und 2-Byte-Wert nach DE bereitstellen
        LD      A,E             ; Low - Byte Wert holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  fertig
        CP      -20             ; mit maximal erlaubter Anzahl Rückschritte vergleichen
        JR      NC,AA091        ; Wert ist OK
        CP      20 + 1          ; mit maximal erlaubter Anzahl Vorschübe vergleichen
        JP      NC,A636A        ; zu groß -->  Fehler 3   Illegal data error
AA091:  CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        BIT     7,E             ; Wert negativ  ?
        JR      NZ,AA0A0        ; ja -->  Zeilenrückschübe ausgeben
AA098:  LD      A,LF            ; Code for 'Zeilenvorschub'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        DEC     E               ; Zähler  'Restanzahl Zeilen'  minus eins
        JR      NZ,AA098        ; weitere Zeilenvorschübe ausgeben
        RET
;
AA0A0:  LD      A,ETX           ; Code for 'Zeilenrückzug'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        INC     E               ; Zähler  'Restanzahl Zeilen'  plus eins
        JR      NZ,AA0A0        ; weitere Zeilenrückschübe ausgeben
        RET
;
;
;   Wert in DE auf Y - Koordinate Graphic - Modus überprüfen
;
AA0A8:  PUSH    HL              ; Keep register value
        LD      HL,999          ; maximale Y - Koordinate vorgeben
        JR      AA0B2           ; Koordinate in DE überprüfen
;
;
;   Wert in DE auf X - Koordinate Graphic - Modus überprüfen
;
AA0AE:  PUSH    HL              ; Keep register value
        LD      HL,480          ; maximale X - Koordinate vorgeben
AA0B2:  PUSH    HL              ; maximale Koordinate retten
        ADD     HL,DE           ; Koordinate in DE auf minus Maximum überprüfen
        POP     HL              ; maximale Koordinate holen
        JR      C,AA0BC         ; Koordinate ist OK -->  geretteten Register - Wert holen
        SBC     HL,DE           ; auf maximale Koordinate überprüfen
        JP      C,A636A         ; zu groß -->  Fehler 3   Illegal data error
AA0BC:  POP     HL              ; gerettete Register - Wert holen
        RET
;
;
;   Basic - Befehl   PLINE     (Token code  165 / 0A5H)
;
AA0BE:  LD      C,'D'           ; D   (Draw)     (absolute Linie)
        DEFB    LD_DE
;
;
;   Basic - Befehl   RLINE     (Token code  166 / 0A6H)
;
AA0C1:  LD      C,'J'           ; J              (relative Linie)
        DEFB    LD_DE
;
;
;   Basic - Befehl   PMOVE     (Token code  167 / 0A7H)
;
AA0C4:  LD      C,'M'           ; M   (Move)     (absolute Kopfbewegung)
        DEFB    LD_DE
;
;
;   Basic - Befehl   RMOVE     (Token code  168 / 0A8H)
;
AA0C7:  LD      C,'R'           ; R   (relativ)  (relative Kopfbewegung)
        CALL    AA46A           ; Abfrage, ob angewählter Drucker der MZ-800 - Plotter ist
        CALL    AA00D           ; Drucker auf Graphic - Modus überprüfen
        LD      A,C             ; Steuercode für Drucker holen
        LD      (DA112 + 1),A   ; und in Routine eintragen
        CP      'M'             ; Kopfbewegung  ?
        JR      NC,AA0F9        ; ja -->  nicht auf Linientyp untersuchen
        CALL    TEST1           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    "%"             ; Code for 'Linientyp'  ?
        JR      NZ,AA0F9        ; kein Linientyp angegeben
        CALL    IBYTE           ; 1-Byte - Wert nach E/Accu bereitstellen
        LD      A,E             ; Linientypwert holen
        DEC     A               ; intern von 0 - 15
        CP      15 + 1          ; mit maximalem Wert vergleichen
        JP      NC,A636A        ; zu groß -->  Fehler 3   Illegal data error
        DEC     DE              ; Zähler corrigieren
        LD      A,'L'           ; L  (Line)    (Code  Linientyp)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        CALL    AA158           ; Zeilenvorschub an Drucker ausgeben
        CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        RET     Z               ; nur Linie spezifiziert -->  fertig
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
AA0F9:  CALL    IDEEXP          ; Ausdruck (HL) auswerten und 2-Byte-Wert nach DE bereitstellen
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
        CALL    AA0AE           ; Wert in DE auf X-Koordinate Graphic-Modus überprüfen
        PUSH    DE              ; X - Koordinate Graphic merken
        CALL    IDEEXP          ; Ausdruck (HL) auswerten und 2-Byte-Wert nach DE bereitstellen
        CP      ','             ; nächstes Zeichen gleich Komma  ?
        JR      Z,AA10D         ; ja -->  weitere Koordinaten angegeben
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
AA10D:  CALL    AA0A8           ; Wert in DE auf Y-Koordinate Graphic-Modus überprüfen
        POP     BC              ; X - Koordinate Graphic holen
        PUSH    DE              ; Y - Koordinate Graphic holen
DA112:  LD      A,0             ; Befehlsbuchstaben für Bewegung   (wird eingetragen)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        LD      E,C             ;! X - Koordinate nach DE kopieren
        LD      D,B             ;!
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        CALL    AA15C           ; Komma an Drucker ausgeben
        POP     DE              ; Y - Koordinate Graphic holen
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        CALL    AA158           ; Zeilenvorschub an Drucker ausgeben
        CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        RET     Z               ; fertig
        INC     HL              ; Trennzeichen überspringen
        JR      AA0F9           ; nächstes Koordinatenpaar bereitstellen und ausgeben
;
;
;   Basic - Befehl   PCOLOR     (Token code  174 / 0EAH)
;
AA12C:  CALL    AA46A           ; Abfrage, ob angewählter Drucker der MZ-800 - Plotter ist
        CALL    IBYTE           ; 1-Byte - Wert nach E/Accu bereitstellen
        LD      A,E             ; bereitgestellte Zeichenfarbe holen
        CP      3 + 1           ; Farbe gleich 0 - 3  ?
        JP      NC,A636A        ; nein -->  Fehler 3   Illegal data error
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        LD      A,(PNMODE)      ; Drucker - Modus - Flag holen
        CP      2               ; im Graphic - Modus  ?
        JR      Z,AA14F         ; ja -->  Farbwert ausgeben
        CALL    AA069           ; Zeilenvorschub/Zeilenrückzug ausgeben
        LD      A,2             ; im Graphic - Modus  ?
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        CALL    AA14F           ; Stiftfarbe an Drucker ausgeben
        JP      AA45C           ; nächstes Koordinatenpaar bereitstellen und ausgeben
;
;
;   Stiftfarbe in E an Drucker ausgeben
;
AA14F:  LD      A,'C'           ; Code for 'Stiftfarbe wechseln'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        LD      A,E             ; Stiftfarbnummer holen
        OR      '0'             ; umsetzen in ASCII
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
AA158:
        LD      A,CR            ; Code for 'Zeilenvorschub'
        JR      AA15E           ; Zeichen im Accu an Drucker ausgeben
;
;
;   Komma an Drucker ausgeben
;
AA15C:  LD      A,','           ; Komma
AA15E:  RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        RET
;
;
;   Basic - Befehl   PHOME     (Token code  175 / 0AFH)
;
AA161:  LD      C,'H'           ; Code   'HOME'
        DEFB    LD_DE
;
;
;   Basic - Befehl   HSET     (Token code  176 / 0B0H)
;
AA164:  LD      C,'I'           ; Code   'Initialize'
        CALL    AA00D           ; Drucker auf Graphic - Modus überprüfen
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        LD      A,C             ; Steuerzeichen für Drucker holen
        JR      AA15E           ; Zeichen im Accu an Drucker ausgeben
;
;
;   Basic - Befehl   GPRINT     (Token code  177 / 0B1H)
;
AA16F:  CALL    AA46A           ; Abfrage, ob angewählter Drucker der MZ-800 - Plotter ist
        CALL    AA00D           ; Drucker auf Graphic - Modus überprüfen
        CALL    TEST1           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    "["             ; Eckige Klammer auf  ?
        JR      NZ,AA1B3        ; nein -->  keine Zeichengröße/-lage angegeben
        CALL    IBYTE           ; 1-Byte - Wert nach E/Accu bereitstellen
        CP      63 + 1          ; mit maximaler Zeichengröße vergleichen
        JP      NC,A636A        ; zu groß -->  Fehler 3   Illegal data error
        PUSH    DE              ; Zeichengröße retten
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    IBYTE           ; 1-Byte - Wert nach E/Accu bereitstellen
        CP      3 + 1           ; Schriftrichtung  0  -  3  ?
        JP      NC,A636A        ; zu groß -->  Fehler 3   Illegal data error
        PUSH    DE              ; Schriftrichtung merken
        CALL    TESTX           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "]"             ; Eckige Klammer zu  ?
        POP     BC              ; Schriftrichtung holen
        POP     DE              ; Zeichengröße holen
        PUSH    BC              ; Schriftrichtung wieder merken
        LD      A,'S'           ; Code for 'Zeichengröße'   (Scale)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        CALL    AA15C           ; Komma an Drucker ausgeben
        POP     DE              ; Schriftrichtung holen
        LD      A,'Q'           ; Code for 'Schriftrichtung'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        CALL    AA158           ; Zeilenvorschub an Drucker ausgeben
        CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        RET     Z               ; kein Text angegeben
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
AA1B3:  CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        JR      Z,AA1BF         ; ja -->  keine weitere Texte
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
        DEC     HL              ; Programmzeiger corrigieren
AA1BF:  LD      A,B             ; Textlänge holen
        OR      A               ; gleich Null  ?
        JR      Z,AA1D0         ; ja -->  kein Text zur ausgabe bereitgestellt
        LD      A,'P'           ; Code for 'Text zeichnen'   (PRINT)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
AA1C7:  LD      A,(DE)          ; ein Zeichn Text holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        INC     DE              ; Zeiger auf Text auf nächstes Zeichen
        DJNZ    AA1C7           ; weitere Zeichen Text ausgeben
        CALL    AA158           ; Zeilenvorschub an Drucker ausgeben
AA1D0:  CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        RET     Z               ; Befehlsende -->  fertig
        INC     HL              ; Trennzeichen überspringen
        JR      AA1B3           ; nächste Zeichenkette bereitstellen und ausgeben
;
;
;   Basic - Befehl   AXIS     (Token code  179 / 0B3H)
;
AA1D7:  CALL    AA00D           ; Drucker auf Graphic - Modus überprüfen
        CALL    IBYTE           ; 1-Byte - Wert nach E/Accu bereitstellen
        CP      1 + 1           ; Achse null oder eins  ?
        JP      NC,A636A        ; zu groß -->  Fehler 3   Illegal data error
        PUSH    AF              ; Achsennummer merken
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    IDEEXP          ; Ausdruck (HL) auswerten und 2-Byte-Wert nach DE bereitstellen
        PUSH    DE              ; Skalenfaktor holen
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
        CALL    IBYTE           ; 1-Byte - Wert nach E/Accu bereitstellen
        OR      A               ; gleich Null  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        LD      A,'X'           ; Code for 'Achse zeichnen'    (aXis)
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        POP     BC              ; Skalenfaktor holen
        POP     AF              ; Achsennummer holen
        PUSH    DE              ; Anzahl Markierungen merken
        PUSH    BC              ; Skalenfaktor merken
        OR      '0'             ; Achsennummer in ASCII umsetzen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        CALL    AA15C           ; Komma an Drucker ausgeben
        POP     DE              ; Skalenfaktor holen
        CALL    AA0A8           ; Wert in DE auf Y-Koordinate Graphic-Modus überprüfen
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        CALL    AA15C           ; Komma an Drucker ausgeben
        POP     DE              ; Anzahl Markierungen holen
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        JP      AA158           ; Zeilenvorschub an Drucker ausgeben
;
;
;   Basic - Befehl   PCIRCLE     (Token code  187 / 0BBH)
;
AA217:  CALL    AA00D           ; Drucker auf Graphic - Modus überprüfen
        PUSH    HL              ; Programmzeiger retten
        LD      DE,0            ; Vorgabe für  Anfangswinkel  0  Grad
        LD      HL,SA3B1        ; Zeiger auf Speicher für Anfangswinkel
        CALL    A79CB           ; Integer - Wert in DE umsetzen in Real-Wert nach (HL)
        LD      DE,360          ; Vorgabe für  Endwinkel  360  Grad
        LD      HL,SA3B6        ; Zeiger auf Speicher für Endwinkel
        CALL    A79CB           ; Integer - Wert in DE umsetzen in Real-Wert nach (HL)
        LD      HL,B7C40        ; Zeiger auf +10   (Real - Format)
        LD      DE,SA3BB        ; Zeiger auf Speicher für Schrittwinkel
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; geretteten Programmzeiger holen
;
;
;   X - Koordinate des Mittelpunktes für PCIRCLE bereitstellen
;
        CALL    EXPR            ; Ausdruck (HL) auswerten/Zeiger auf Ergebnis bereitstellen
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
        PUSH    HL              ; Programmzeiger retten
        LD      HL,SA3A2        ; Zeiger auf Speicher für X-Koordinate Mittelpunkt
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; geretteten Programmzeiger holen
;
;
;   Y - Koordinate des Mittelpunktes für PCIRCLE bereitstellen
;
        CALL    EXPR            ; Ausdruck (HL) auswerten/Zeiger auf Ergebnis bereitstellen
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
        PUSH    HL              ; Programmzeiger retten
        LD      HL,SA3A7        ; Zeiger auf Speicher für Y - Koordinate Mittelpunkt
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     HL              ; geretteten Programmzeiger holen
;
;
;   Radius für PCIRCLE bereitstellen
;
        CALL    EXPR            ; Ausdruck (HL) auswerten/Zeiger auf Ergebnis bereitstellen
        PUSH    HL              ; Programmzeiger retten
        PUSH    AF              ; nächstes Programmbyte retten
        LD      HL,SA3AC        ; Zeiger auf Speicher für Radius
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        LD      A,(SA3AC + 1)   ; MSByte Mantisse Radius holen
        RLCA                    ; Vorzeichenbit nach Carry schieben
        JP      C,A636A         ; Radius negativ -->  Fehler 3   Illegal data error
        POP     AF              ; nächstes Programmbyte holen
        CP      ','             ; Komma  ?
        JR      NZ,AA2A7        ; nein -->  keine weiteren Parameter angegeben
        POP     HL              ; geretteten Programmzeiger holen
        INC     HL              ; komma überspringen
;
;
;   Anfangswinkel für PCIRCLE bereitstellen
;
        CALL    EXPR            ; Ausdruck (HL) auswerten/Zeiger auf Ergebnis bereitstellen
        PUSH    HL              ; Programmzeiger retten
        PUSH    AF              ; nächstes Programmbyte retten
        LD      HL,SA3B1        ; Zeiger auf Speicher für Anfangswinkel
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     AF              ; nächstes Programmbyte holen
        CP      ','             ; Komma  ?
        JR      NZ,AA2A7        ; nein -->  keine weiteren Parameter angegeben
        POP     HL              ; geretteten Programmzeiger holen
        INC     HL              ; komma überspringen
;
;
;   Endwinkel für PCIRCLE bereitstellen
;
        CALL    EXPR            ; Ausdruck (HL) auswerten/Zeiger auf Ergebnis bereitstellen
        PUSH    HL              ; Programmzeiger retten
        PUSH    AF              ; nächstes Programmbyte retten
        LD      HL,SA3B6        ; Zeiger auf Speicher für Endwinkel
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) übertragen
        POP     AF              ; nächstes Programmbyte holen
        CP      ','             ; Komma  ?
        JR      NZ,AA2A7        ; nein -->  keine weiteren Parameter angegeben
        POP     HL              ; geretteten Programmzeiger holen
        INC     HL              ; Komma überspringen
;
;
;   Provide step angle for PCIRCLE
;
        CALL    EXPR            ; Evaluate expression (HL)/provide pointer to result
        PUSH    HL              ; Save program pointer
        LD      HL,SA3BB        ; Pointer to step angle memory
        EX      DE,HL           ; Pointer to result after HL
        CALL    A79C5           ; Real - number value transferred from (HL) to (DE).
        LD      A,(SA3BB+1)      ; Get MSByte mantissa increment
        RLCA                    ; Shift sign bit after carry
        JP      C,A636A         ; Increment negative --> Error 3 Illegal data error
AA2A7:  POP     HL              ; get saved program pointer
        CALL    A797A           ; examine for 'syntax end of command'
        PUSH    HL              ; Save program pointer
;
;
;   Draw circle according to provided parameters
;
        LD      HL,SA3B6        ; Pointer to storage for end angles
        LD      DE,SA3B1        ; Pointer to storage for initial angles
        LD      A,(SA3BB)       ; Get step angle exponent
        OR      A               ; equals zero  ?
        CALL    NZ,A9153        ; no --> compare real numerical values ??(HL) and (DE).
        JP      C,A636A         ; End angle smaller start angle --> Error 3 Illegal data error
        CALL    AA358           ; Calculate X/Y coordinates from center/radius/angle
        LD      HL,SA3C0        ; Pointer to current X coordinate
        LD      (DA32F + 1),HL  ; enter into routine
        LD      HL,SA3C5        ; Pointer to current Y coordinate
        LD      (DA33A + 1),HL  ; enter into routine
        CALL    AA32C           ; Set character head to current coordinate
        LD      A,(SA3BB)       ; Get step angle exponent
        OR      A               ; equals zero  ?
        JR      Z,AA306         ; yes --> line from start to middle to end point
AA2D4:  LD      HL,SA3B1        ; Pointer to storage for initial angles
        LD      DE,SA3BB        ; Pointer to step angle memory
        CALL    A90BC           ; + - Routine ( (HL) = (HL) + (DE) )
        LD      DE,SA3B6        ; Pointer to storage for end angles
        CALL    A9153           ; Real - compare numerical values ??(HL) and (DE).
        JR      NC,AA2F1        ; End angle < current angle --> line after end point
        CALL    AA358           ; Calculate X/Y coordinates from center/radius/angle
        CALL    AA329           ; Draw a line to the calculated point
        RST     _DOCMD          ; Software - Execute command
        DEFB    14              ; Code 14 Query whether (Shift) - BREAK is pressed
        JR      NZ,AA2D4        ; no --> draw more polygon pieces
        POP     HL              ; get saved program pointer
        RET
;
AA2F1:  CALL    AA2F9           ; Calculate X/Y coordinates of the end point
        CALL    AA329           ; Draw a line to the calculated point
        POP     HL              ; get saved program pointer
        RET
;
;
;   Calculate the absolute coordinates of the end point
;
AA2F9:  LD      HL,SA3B6        ; Pointer to storage for end angles
        LD      DE,SA3B1        ; Pointer to storage for initial angles
        LD      BC,5            ; Length of a number in internal format
        LDIR                    ; Specify the end angle as the current angle
        JR      AA358           ; Calculate X/Y coordinates from center/radius/angle
;
;
;   Draw a line from the starting point through the midpoint to the ending point
;
AA306:  LD      HL,SA3A2        ; Pointer to memory for X coordinate center point
        LD      (DA32F + 1),HL  ; enter into routine
        LD      HL,SA3A7        ; Pointer to memory for Y - coordinate center
        LD      (DA33A + 1),HL  ; enter into routine
        CALL    AA329           ; Draw a line to the calculated point
        CALL    AA2F9           ; Calculate the absolute coordinates of the end point
        LD      HL,SA3C0        ; Pointer to current X coordinate
        LD      (DA32F + 1),HL  ; enter into routine
        LD      HL,SA3C5        ; Pointer to current Y coordinate
        LD      (DA33A + 1),HL  ; enter into routine
        CALL    AA329           ; Draw a line to the calculated point
        POP     HL              ; get saved program pointer
        RET
;
;
;   Draw a line to the calculated point
;
AA329:  LD      A,'D'           ; Code 'Draw line' (Draw)
        DEFB    LD_HL
;
;
;   Set character head to current coordinate
;
AA32C:  LD      A,'M'           ; Code 'position head' (Move)
        PUSH    AF              ; Remember command letters for printers
DA32F:  LD      HL,SA3A2        ; Pointer to memory for X coordinate center point
        CALL    HLFLT           ; Real - convert value (HL) into integer - value after HL
        PUSH    HL              ; Note X coordinate
        EX      DE,HL           ; X - coordinate to DE
        CALL    AA0A8           ; Check value in DE on Y coordinate graphic mode
DA33A:  LD      HL,SA3A7        ; Pointer to memory for Y - coordinate center
        CALL    HLFLT           ; Real - convert value (HL) into integer - value after HL
        PUSH    HL              ; Y - remember coordinate
        EX      DE,HL           ; Y - coordinate to DE
        CALL    AA0A8           ; Check value in DE on Y coordinate graphic mode
        POP     HL              ; Y - get coordinate
        POP     DE              ; Y - get coordinate
        POP     AF              ; Printer - get command letters
        RST     _DOCMD          ; Software - Execute command
        DEFB    6               ; Output code 6 characters in Accu to printer
        PUSH    HL              ; Y - save coordinate
        CALL    AA3CF           ; Prepare value in DE in ASCII / output to printer
        CALL    AA15C           ; Output comma to printer
        POP     DE              ; retrieve saved Y coordinate
        CALL    AA3CF           ; Prepare value in DE in ASCII / output to printer
        JP      AA158           ; Output newline to printer
;
;
;   Calculate X/Y coordinates from center/radius/angle
;
AA358:  LD      DE,(INTFAC)     ; Get pointer to start of arithmetic memory
        LD      HL,SA3B1        ; Pointer to storage for initial angles
        CALL    A79C5           ; Real - number value transferred from (HL) to (DE).
        LD      HL,(INTFAC)     ; Get pointer to start of arithmetic memory
        CALL    A98B3           ; RAD - call function (angle in radians)
        CALL    A96F9           ; Call COS routine ( COS( (HL) ) )
        LD      DE,SA3AC        ; Pointer to memory for radius
        CALL    A92EA           ; * - Routine ( (HL) = (HL) * (DE) )
        LD      DE,SA3A2        ; Pointer to memory for X coordinate center point
        CALL    A90BC           ; + - Routine ( (HL) = (HL) + (DE) )
        LD      DE,SA3C0        ; Pointer to current X coordinate
        CALL    A79C5           ; Real - number value transferred from (HL) to (DE).
        LD      DE,(INTFAC)     ; Get pointer to start of arithmetic memory
        LD      HL,SA3B1        ; Pointer to storage for initial angles
        CALL    A79C5           ; Real - number value transferred from (HL) to (DE).
        LD      HL,(INTFAC)     ; Get pointer to start of arithmetic memory
        CALL    A98B3           ; RAD - call function (angle in radians)
        CALL    A9709           ; Call SIN routine ( SIN( (HL) ) )
        LD      DE,SA3AC        ; Pointer to memory for radius
        CALL    A92EA           ; * - Routine ( (HL) = (HL) * (DE) )
        LD      DE,SA3A7        ; Pointer to memory for Y - coordinate center
        CALL    A90BC           ; + - Routine ( (HL) = (HL) + (DE) )
        LD      DE,SA3C5        ; Pointer to current Y coordinate
        JP      A79C5           ; Real - number value transferred from (HL) to (DE).
;
;
;   Memory area for PCIRCLE command
;
SA3A2:  DEFS    5               ; Memory for X coordinate center
SA3A7:  DEFS    5               ; Memory for Y - coordinate center point
SA3AC:  DEFS    5               ; Memory for Radius
SA3B1:  DEFS    5               ; Storage for initial angles
SA3B6:  DEFS    5               ; Storage for end angles
SA3BB:  DEFS    5               ; Memory for step angle
SA3C0:  DEFS    5               ; current X coordinate
SA3C5:  DEFS    5               ; current Y coordinate
;
        DEFS    5
;
;
;   Prepare value in DE in decimal - ASCII and output to printer
;
AA3CF:  PUSH    AF              ;!Register - save values
        PUSH    HL              ;!
        LD      HL,(INTFAC)     ; Get pointer to start of arithmetic memory
        CALL    A79CB           ; Integer - convert value in DE into real value according to (HL)
        CALL    A7B5B           ; Convert real value (HL) to ASCII to buffer
        RST     _DOCMD          ; Software - Execute command
        DEFB    23              ; Code 23 Count length of text (DE).
AA3DC:  LD      A,(DE)          ; get a character text
        RST     _DOCMD          ; Software - Execute command
        DEFB    6               ; Output code 6 characters in Accu to printer
        INC     DE              ; Pointer to text on next character
        DJNZ    AA3DC           ; output additional characters of text
        POP     HL              ;!  saved registers - get values
        POP     AF              ;!
        RET
;
;
;   Basic - Befehl   PTEST     (Token code  188 / 0BCH)
;
AA3E5:  CALL    AA46A           ; Abfrage, ob angewählter Drucker der MZ-800 - Plotter ist
        CALL    AA009           ; Drucker auf Text - Modus überprüfen
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        LD      A,___TST        ; Code for 'Testmuster zeichnen'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        RET
;
;
;   Basic - Befehl   PAGE     (Token code  189 / 0BDH)
;
AA3F3:  CALL    AA009           ; Drucker auf Text - Modus überprüfen
        CALL    IDEEXP          ; Ausdruck (HL) auswerten und 2-Byte-Wert nach DE bereitstellen
        LD      A,E             ; Anzahl Zeilen je Seite holen
        OR      A               ; gleich Null  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        CP      72 + 1          ; größer 72  ?
        JP      NC,A636A        ; ja -->  Fehler 3   Illegal data error
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        LD      A,009H          ; Einleitungscode
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        LD      A,(PSEL)        ; Drucker - Typ - Nummer holen
        BIT     0,A             ; MZ - 800 - Plotter  ?
        JR      Z,AA419         ; nein
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        JP      AA158           ; Zeilenvorschub an Drucker ausgeben
;
AA419:  LD      A,E             ; Anzahl Zeile je Seite holen
        LD      DE,S11A4        ; Zeiger auf Zwischenspeicher vorgeben
        CALL    HEXACC          ; Byte im Accu umsetzen on 2 ASCII-Hex-Zeichen nach (DE)
        DEC     DE              ;! Zeiger auf erstes aufbereitetes Zeichen
        DEC     DE              ;!
        LD      A,(DE)          ; ein Zeichen Text holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        INC     DE              ; ausgegebenes Zeichen überspringen
        LD      A,(DE)          ; ein Zeichen Text holen
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        RET
;
;
;   Basic - Befehl   PLOT   (Token code  164 / 0A4H)
;
AA42A:  LD      A,(HL)          ; nächstes Programmbyte holen
        CP      ____ON          ; Zwischencode  ON  ?
        JR      Z,AA43A         ; ja -->  Parallelausgabe auf Drucker einschalten
        CP      ___OFF          ; Zwischencode  OFF  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
        XOR     A               ; Code for 'keine Parallelausgabe'
AA435:  LD      (INPFLG),A      ; Parallelausgabeflag Drucker merken
        INC     HL              ; Code for 'ON/OFF'  überspringen
        RET
;
;
;   Parallelausgabe auf Drucker einschalten
;
AA43A:  CALL    AA009           ; Drucker auf Text - Modus überprüfen
        CALL    AA46A           ; Abfrage, ob angewählter Drucker der MZ-800 - Plotter ist
        LD      A,(M9FD0)       ; Textgrößenflag Drucker holen
        CP      'L'             ; L   (Large)  ?
        JP      Z,A63B7         ; ja -->  Fehler 68   Dev. mode error
        CALL    AA45C           ; Drucker auf Textmodus und richtige Anzahl Zeichen/Zeile
        LD      A,(INPFLG)      ; Parallelausgabeflag Drucker holen
        OR      A               ; gesetzt  ?
        JR      NZ,AA435        ; ja -->  Programmzeiger corrigieren
        CALL    A6A8D           ; Standardwerte für CONSOLE vorgeben
        LD      A,C_CLR         ; Code for 'Bildschirm löschen'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    3               ; Code 3  Accu auf Bildschirm ausgeben  (Ausführung Steuerzeichen)
        OR      00000001B       ; Accu auf Wert ungleich Null
        JR      AA435           ; Parallelausgabeflag Drucker setzen
;
;
;   Drucker auf Textmodus und richtiger Anzahl Zeichen / Zeile setzen
;
AA45C:  LD      A,1             ; Code for 'Umschalten auf Textmodus'
        RST     _DOCMD          ; Software - Kommando ausführen
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        LD      A,(S137A)       ; Bildschirm - Modus - Nummer holen
        CP      2 + 1           ; Bildschirm auf 40  Zeichen je Zeile  ?
        RET     C               ; ja
        CALL    AA060           ; Drucker umschalten auf 80 Zeichen / Zeile
        RET
;
;   Abfrage, ob angewählter Drucker der MZ-800 - Plotter ist
;
AA46A:  LD      A,(PSEL)        ; Drucker - Typ - Nummer  holen
        BIT     0,A             ; MZ - 800 - Plotter  (Drucker 1)  ?
        JP      Z,A63B7         ; nein -->  Fehler 68   Dev. mode error
        RET
;

BASIC_PGM:                          ; from here free memory for basic - program


; ..the original tape dump here contains useless program code and data, including an old disclaimer:
; =====================================
; DISK BASIC INTERPRETER MZ-2Z046 V0.2G
; =====================================
; COPYRIGHT (C) 1984 BY SHARP CORP.
; 22929 BYTES FREE


; Data block filler
defs $b000-BASIC_PGM

