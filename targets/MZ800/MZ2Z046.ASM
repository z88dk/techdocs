;
;  MZ-800  Disk Basic  MZ-2Z046

;
;  It is basically a Hu-Basic interpreter engine together with a Sharp Monitor.
;  The comments are useful to decode other eastern computer products (Sharp, Samsung, etc..)
;  Other than being a valid reference for developers.
;

; It can be built with the z88dk's z80asm tool:
;   z80asm -b -m MZ2Z046.asm
;   (z88dk-appmake +mz --org 0 -b MZ2Z046.bin)

; (use: "z88dk-appmake +mz" to look at all the options)
; Add -DCLASSIC_FNK to z80asm for for a different way to map the FN function keys.


; The comments are based on a (not fully correct) hand-edited disassembly
; published in 1985 by Rainer Sch√§fer (Kirchwald, Germany)


; The sharp MZ 800 was the successor of the MZ 700.
; It was partially compatible with the 700 series and the old MZ 80K series as well.
;
; It was sold under three reference numbers:
;   MZ-811 without tape drive,
;   MZ-821 with built-in 1200-baud tape drive,
;   MZ-831 with tape drive and built-in 4-colour printer-plotter.
;

; The Tape drive could be substituted for a Quick-disk drive unit.
; The Quick-Disc was a small 2.8-inch disk with sequential access.
;
; Like the MZ 700, there was no language in ROM, it had to be loaded
; from tape, quick disk or floppy disk.
; The ROM only contained boot code, OS calls and special code to allow
; the user to use the 64 KB RAM as a virtual disk.



;
        ORG     00000H
;
;
;       The Basic - Interpreter uses routines of the monitor 1Z-013B
;       (or the monitor 9Z-504M)
;
;       The underlined bytes are changed by the Basic Interpreter at runtime
;
;


;
;
;   Control chatacters
;

defc  _PRESS   =      0x7F            ; key press characters
defc  NUL      =      0x00            ; End-of-text/line-end character
defc  __GRPH   =      0x02            ; Switch to graphic mode (printer)
defc  ETX      =      0x03            ; line retraction (printer)
defc  CTRL_D   =      0x04            ; Initialize screen
defc  ___TST   =      0x04            ; Test print pattern call for plotter
defc  _SML     =      0x05            ; Switch to lowercase
defc  _CAP     =      0x06            ; Switch to capital letters
defc  LEADIN   =      0x09            ; Printer initiation code - control characters
defc  LF       =      0x0A            ; newline
defc  CR       =      0x0D            ; carriage return
defc  DEL      =      0x7F            ; control character for DELete (CTL-P)
;defc  _DEL      =      0x10            ; control character for DELete (CTL-P)
defc  C_DOWN   =      0x11            ; cursor down
defc  C_UP     =      0x12            ; cursor up
defc  C_RIGHT  =      0x13            ; cursor right
defc  C_LEFT   =      0x14            ; cursor left
defc  C_HOME   =      0x15            ; HOME		(CTL-U)
defc  C_CLR    =      0x16            ; CLR
defc  _ALPHA   =      0x19            ; Switch to alpha mode
defc  CTRL_Z   =      0x1A            ; end of file character
defc  ESC      =      0x1B            ; Code of the BREAK key
;
defc  _NOTXT   =      0x80            ; Code 'no error text'
defc  _free    =      0x80            ; Code 'intermediate code not used'

;
;
;   Z-80 commands passed as data
;
defc  _NOP     =      0x00            ; Z-80 instruction  NOP
defc  LD_BC    =      0x01            ; Z-80 instruction  LD BC,nn
defc  LD_B     =      0x06            ; Z-80 instruction  LD B,n
defc  LD_DE    =      0x11            ; Z-80 instruction  LD DE,nn
defc  INC_DE   =      0x13            ; Z-80 instruction  INC DE
defc  DEC_DE   =      0x1B            ; Z-80 instruction  DEC DE
defc  LD_HL    =      0x21            ; Z-80 instruction  LD HL,nn
defc  INC_HL   =      0x23            ; Z-80 instruction  INC HL
defc  ADD_HL   =      0x29            ; Z-80 instruction  ADD HL,HL
defc  DEC_HL   =      0x2B            ; Z-80 instruction  DEC HL
defc  _CPL     =      0x2F            ; Z-80 instruction  CPL
defc  _SCF     =      0x37            ; Z-80 instruction  SCF
defc  LD_A     =      0x3E            ; Z-80 instruction  LD A,n
defc  RES_HL   =      0x86            ; Z-80 instruction  RES x,(HL)
defc  AND_B    =      0xA0            ; Z-80 instruction  AND B
defc  AND_D    =      0xA2            ; Z-80 instruction  AND D
defc  XOR_D    =      0xAA            ; Z-80 instruction  XOR D
defc  XOR_A    =      0xAF            ; Z-80 instruction  XOR A
defc  OR_B     =      0xB0            ; Z-80 instruction  OR B
defc  OR_C     =      0xB1            ; Z-80 instruction  OR C
defc  OR_D     =      0xB2            ; Z-80 instruction  OR D
defc  _JP      =      0xC3            ; Z-80 instruction  JP nn
defc  SET_HL   =      0xC6            ; Z-80 instruction  SET x,(HL)
defc  _RET     =      0xC9            ; Z-80 instruction  RET
defc  _OUT     =      0xD3            ; Z-80 instruction  OUT (n),A
defc  JP_HL    =      0xE9            ; Z-80 instruction  JP (HL)
defc  EX_DE    =      0xEB            ; Z-80 instruction  EX DE,HL
defc  OR_N     =      0xF6            ; Z-80 instruction  OR n
;
defc  DO_CMD   =      0x18            ; Restart to invoke a command

;
;
;   Filetype identifiers
;
defc  _OBJ     =      1               ; Filetype: machine program
defc  _BTX     =      2               ; Filetype: Basic - Program
defc  _BSD     =      3               ; Filetype: sequential file
defc  _BRD     =      4               ; Filetype: RANDOM - file

;
;
;  TOKEN codes used by the BASIC interpeter
;
defc  _LINNO   =      00BH            ; Token code - Line number identifier
defc  _LIN_P   =      00CH            ; Token code - Pointer to line identifier
defc  _HEXNO   =      011H            ; Token code - Hex value identifier
defc  _INTNO   =      012H            ; Token code - Integer value identifier
defc  __REAL   =      015H            ; Token code - Real value identifier
;
__GOTO   =      080H            ; Token code  GOTO
defc  _GOSUB   =      081H            ; Token code  GOSUB
defc  ____GO   =      082H            ; Token code  GO
defc  __LIST   =      087H            ; Token code  LIST
defc  ___RND   =      088H            ; Token code  RND
defc  __PEEK   =      089H            ; Token code  PEEK
defc  __NEXT   =      08EH            ; Token code  NEXT
defc  _PRINT   =      08FH            ; Token code  PRINT  (?)
defc  ____IF   =      093H            ; Token code  IF
defc  __DATA   =      094H            ; Token code  DATA
defc  ___REM   =      097H            ; Token code  REM
defc  __STOP   =      099H            ; Token code  STOP
defc  ____ON   =      09DH            ; Token code  ON
defc  ___CHR   =      0A0H            ; Token code  CHR
defc  ___OFF   =      0A1H            ; Token code  OFF
defc  _RMOVE   =      0A8H            ; Token code  RMOVE
defc  _SPACE   =      0A8H            ; Token code  SPACE
defc  ___KEY   =      0B2H            ; Token code  KEY
defc  ___ERL   =      0B4H            ; Token code  ERL
defc  __WAIT   =      0BEH            ; Token code  WAIT
defc  _ERROR   =      0C1H            ; Token code  ERROR
defc  __ELSE   =      0C2H            ; Token code  ELSE
defc  ____TI   =      0C4H            ; Token code  TI$
defc  ____FN   =      0C7H            ; Token code  FN
defc  _LABEL   =      0CAH            ; Token code  LABEL
defc  __INIT   =      0DCH            ; Token code  INIT
defc  __RMOV   =      0DFH            ; Token code  RMOV
defc  ____TO   =      0E0H            ; Token code  TO
defc  __STEP   =      0E1H            ; Token code  STEP
defc  __THEN   =      0E2H            ; Token code  THEN
defc  _USING   =      0E3H            ; Token code  USING
defc  ____PI   =      0E4H            ; Token code  Pi
defc  ___ALL   =      0E5H            ; Token code  ALL
defc  ___TAB   =      0E6H            ; Token code  TAB
defc  ___SPC   =      0E7H            ; Token code  SPC
defc  ___XOR   =      0EAH            ; Token code  XOR
defc  ____OR   =      0EBH            ; Token code  OR
defc  ___AND   =      0ECH            ; Token code  AND
defc  ___NOT   =      0EDH            ; Token code  NOT
defc  ____LE   =      0F0H            ; Token code  <=
defc  ____GE   =      0F2H            ; Token code  >=
defc  ____EQ   =      0F4H            ; Token code  =
defc  ____GT   =      0F5H            ; Token code  >
defc  ____LT   =      0F6H            ; Token code  <
defc  __PLUS   =      0F7H            ; Token code  +
defc  _MINUS   =      0F8H            ; Token code  -
defc  __IDIV   =      0F9H            ; Token code  DIV  (nicht bekannt)
defc  ___MOD   =      0FAH            ; Token code  MOD 
defc  ___DIV   =      0FBH            ; Token code  /
defc  ___POT   =      0FDH            ; Token code  ^

;
;
;   1Z-013B MONITOR routine entries
;
defc  _MELDY   =      030H            ; Restart for 'play melody'
;
defc  TIMIN    =      0038DH          ; Start address time - interrupt - routine
defc  EDGE     =      00601H          ; Search impulse start on tape
defc  RBYTE    =      00624H          ; read a byte from tape
defc  TMARK    =      0065BH          ; Read license plate from tape
defc  MSTOP    =      00700H          ; motor off (cassette)
defc  CKSUM    =      0071AH          ; Count checksum of memory area
defc  WBYTE    =      00767H          ; write a byte to tape
defc  GAP      =      0077AH          ; Write ID tag on tape
defc  DLY12    =      00996H          ; Time loop approx. 7 msec
defc  _SHORT   =      00A01H          ; write a short impulse on tape
defc  LONG     =      00A1AH          ; write a long pulse to tape
defc  DLY3     =      00A4AH          ; Time loop about 330 usec
defc  _ADCN    =      00BB9H          ; Convert ASCII code to display code
defc  _DACN    =      00BCEH          ; Convert display code to ASCII code
defc  KTBL     =      00BEAH          ; Keyboard decode table for Normal mode
defc  KTBLS    =      00C2AH          ; Keyboard decode table for Shift mode
defc  KTBLG    =      00CE9H          ; Keyboard decode table for Shift-Graphic mode
defc  KTBLSG   =      00C6AH          ; Keyboard decode table for graphic mode 

;
;
;   Serial port addresses (RS 232 C)
;
defc  SERA_D   =      0B0H            ; data port device RS1
defc  SERA_S   =      0B1H            ; data port device RS1
;
defc  SERB_D   =      0B2H            ; data port device RS2
defc  SERB_S   =      0B3H            ; status port device RS2

;
;
;   CRT controller port addresses
;
defc  CRTCWF   =      0CCH            ; Write - Format - Register   CRT - Controller
defc  CRTCRF   =      0CDH            ; Read - Format - Register    CRT - Controller
defc  CRTCDM   =      0CEH            ; Display - Mode - Register   CRT - Controller
defc  CRTCMP   =      0CFH            ; Scroll - Register - Flag    CRT - Controller

;
;
;   8255 I/O port addresses
;
defc  KEYP_A   =      0D0H            ; Keyboard - Output - Lines
defc  KEYP_B   =      0D1H            ; Keyboard - Input - Lines
defc  KEYP_C   =      0D2H            ; Tape recorder control
defc  KEYP_F   =      0D3H            ; 8255 control word register  

;
;
;   8253 counter module addresses
;
defc  CT0_53   =      0D4H            ; 8253 - counter zero
defc  CT1_53   =      0D5H            ; 8253 - counter one
defc  CT2_53   =      0D6H            ; 8253 - counter two
defc  CTC_53   =      0D7H            ; 8253 counter module word register  

;
;
;   Floppy-Disk controller port addresses
;
defc  CD_REG   =      0D8H            ; Command - Register
defc  ST_REG   =      0D8H            ; Status - Register
defc  TR_REG   =      0D9H            ; Track - Register
defc  SC_REG   =      0DAH            ; Sector - Register
defc  DA_REG   =      0DBH            ; Data - Register
defc  MO_REG   =      0DCH            ; Motor - Register
defc  PG_REG   =      0DDH            ; Page - Register
defc  DE_REG   =      0DEH            ; Density - Register

;
;
;   Switching addresses for RAM switching
;
defc  _CGVIN   =      0E0H            ; Turn on character set ROM and video ram
defc  _CGVOT   =      0E1H            ; Turn off character set ROM and video ram
;      
defc  _00RAM   =      0E0H            ; Switch to RAM from 00000H - 07FFFH
defc  _E0RAM   =      0E1H            ; Switching port for RAM from 0E000H - 0FFFFH
defc  _E0ROM   =      0E3H            ; Monitor ROM switch port from 0E000H - 0FFFFH
defc  _00ROM   =      0E2H            ; Switch port for monitor - ROM
defc  _KMODE   =      0E4H            ; Switching port for MZ-80K mode

;
;
;   Port addresses of the 64K byte add-on RAM card
;
defc  ERAM_D   =      0EAH            ; RAM-card data port
defc  ERAM_A   =      0EBH            ; RAM-card addresses port

;
;
;   Palette - Color - Register
;
defc  PALLET   =      0F0H            ; Palette - Register

;
;
;  Sound Generator - Port Address
;
defc  PSGOUT   =      0F2H            ; PSG sound generator port address

;
;
;   Z-80 PIO system addresses
;
defc  PIOA_C   =      0FCH            ; Control Port - Z80 PIO channel A
defc  PIOB_C   =      0FDH            ; Control Port - Z80 PIO channel B

;
;
;   Printer - System - Addresses
;
defc  LST_ST   =      0FEH            ; Printer - Control Port
defc  LST_DA   =      0FFH            ; Printer - Data Port
;
;
;
;
defc  SCREEN   =      08000H          ; Start address of Graphic - image memory
defc  ZC000    =      0C000H          ; Start address of character generator - RAM in MZ-700 mode
defc  ZD800    =      0D800H          ; Start address of color memory in MZ-700 mode
defc  XF400    =      0F400H          ; Start address of jump table in ROM monitor
                                        
defc  XFF00    =      0FF00H          ; Top of memory for BASIC data
defc  ZFF00    =      0FF00H

defc  ZFF12    =      0FF12H

defc  ZFDA0    =      0FDA0H




; ----------------------------------------------------------------------------
;
;       Program start here
;
; ----------------------------------------------------------------------------

;
;
;   RAM - Monitor - jump table
;
A0000:  JP      A0EF9           ; Monitor / Basic  -  Home entry
;
        JP      A0A84           ; Get line from keyboard to memory (DE).
;
        JP      A09AB           ; Output newline to screen
;
        JP      A099B           ; Line feed when cursor is not at beginning of line
;
        JP      A0E5F           ; print a space on the screen
;
        JP      A0A58           ; Move cursor to next tab position
;
A0012:  JP      A0E61           ; Display accu on screen (execution of control characters)
;
        JP      A0E50           ; Output text (DE) on screen (execution of control characters)
;
_DOCMD:                           
        JP      A022C           ; Software - execute command (RST _DOCMD)
;
        JP      A0BA1           ; Query whether key is pressed
;
A001E:  JP      A0D22           ; Query whether (Shift) - BREAK is pressed
;
        JP      A3ADD           ; File - write identifier on tape (cassette) (here RET)
;
        JP      A3ADD           ; File - write data to tape (cassette) (here RET)
;
        JP      A3ADD           ; Read file identifier from tape (cassette) (here RET)
;
        JP      A3ADD           ; File - read data from tape (cassette) (here RET)
;
        JP      A3ADD           ; File - compare data on tape with storage data (here RET)
;
        JP      A00B2           ; RET (formerly Music - Play Text (DE))
;
        JP      A149E           ; set time
;
        DEFS    2                 
;
        JP      A00B2           ; RET (formerly interrupt for clock)
;
        JP      A14A2           ; read time
;
A003E:  JP      A44F3           ; Treat reference tone according to code in Accu
;
A0041:  JP      A4520           ; set pace
;
        JP      A447B           ; turn off the sound
;
        JP      A447B           ; turn off the sound
;
        JP      A0A84           ; Get line from keyboard to memory (DE).
;

W004D:  DEFW    A5800           ; Start - Address Basic - Interpreter
;
S004F:  DEFS    2               ; error handling addresses
;
        JP      A0E50           ; Output text (DE) on screen (execution of control characters)
;
        DEFS    4                 
;
        JP      A0B1A           ; Query keyboard status in Accu
;
;
;   Table with the start addresses of the CTRL routines
;
W005B:  DEFW    A00B2           ; CTRL  @
        DEFW    A00B2           ; CTRL  A   (free for switching to ASCII keyboard)
        DEFW    A00B2           ; CTRL  B   (free for switching the border color )
        DEFW    A09B0           ; CTRL  C   (CR ?)
        DEFW    A00B2           ; CTRL  D   (free for switching to German keyboard)
        DEFW    A0A1B           ; CTRL  E   (Switch to Shift - Lock - mode)
        DEFW    A0A19           ; CTRL  F   (Switch to Alpha - mode)
        DEFW    A00B2           ; CTRL  G   (free for switching to a different color for plotter )
        DEFW    A00B2           ; CTRL  H   (free for background color switching)
        DEFW    A0A24           ; CTRL  I   (TAB - Taste)
        DEFW    A00B2           ; CTRL  J
        DEFW    A00B2           ; CTRL  K   (free for 'hardcopy')
        DEFW    A00B2           ; CTRL  L
        DEFW    A09B0           ; CTRL  M   (CR)
        DEFW    A1500           ; CTRL  N   (start/stop printing )
        DEFW    A00B2           ; CTRL  O
        DEFW    A06BE           ; CTRL  P   (Control character: DELete)
        DEFW    A09CF           ; CTRL  Q   (Control character: Cursor down)
        DEFW    A09F9           ; CTRL  R   (Control character: Cursor up)
        DEFW    A09D4           ; CTRL  S   (Control character: Cursor right)
        DEFW    A09FE           ; CTRL  T   (Control character: Cursor left)
        DEFW    A0992           ; CTRL  U   (Control character: HOME)
        DEFW    A061D           ; CTRL  V   (Control character: CLR)
        DEFW    A0A1E           ; CTRL  W   (Control character: Graphic mode)
        DEFW    A0776           ; CTRL  X   (Control character: INSerT)
        DEFW    A0A19           ; CTRL  Y   (Switch to Alpha - mode)
        DEFW    A00B2           ; CTRL  Z   (free for switching character color)
        DEFW    A09B0           ; CTRL  [   (CR ?)
        DEFW    A00B2           ; CTRL  ]
        DEFW    A00B2           ; CTRL  \
        DEFW    A00B2           ; CTRL  ^
        DEFW    A00B2           ; CTRL  /
;
;
;   Call control character routine, control character in Accu 
;
A009B:  ADD     A,A             ; Control characters times two (two bytes per address)
        LD      HL,W005B        ; Pointer to table with start addresses of routines
        CALL    A0158           ; Add the value in the Accu to the HL register
        CALL    A0151           ; Get address from table (HL) to HL
        JP      (HL)            ; Call control character routine (HL). 
;
S00A6:  DEFB    NUL             ; Default for text without characters
;
A00A7:  JP      (HL)            ; Call program from address (HL).
;
;
;   Disable interrupts     (Software command code:  16)
;
A00A8:  EI                      ; Enable interrupt
        PUSH    AF              ; Register - save value
        CALL    A44A3           ; wait until all parts of the melody have been played
        CALL    A14F8           ; Printer - Disable interrupt
        POP     AF              ; rescued register - fetch value
        DI                      ; Disable interrupts
A00B2:  RET
;
;
;   Enable interrupt      (Software command code:  17)
;
A00B3:  PUSH    AF              ; Register - save value
        CALL    A14FC           ; Printer - enable interrupt
        POP     AF              ; rescued register - fetch value
        EI                      ; Enable interrupt
        RET
;
;
;   Save registers IX, HL, BC, DE and AF
;
A00BA:  EX      (SP),IX         ; IX - Store Register / Get Return Address
        PUSH    HL              ; HL - register - save value
        PUSH    BC              ; BC - register - save value
        PUSH    DE              ; DE - register - save value
        PUSH    AF              ; AF - register - save value
        PUSH    HL              ; HL - register - store value again
        LD      HL,T00D3        ; Pointer to routine for repeating register values
        EX      (SP),HL         ; Store address / get value for HL
        JP      (IX)            ; Return to calling program
;
;
;   Save registers IX, HL, BC, DE and AF
;
A00C7:  EX      (SP),IX         ; IX - Store Register / Get Return Address
        PUSH    HL              ; HL - register - save value
        PUSH    BC              ; BC - register - save value
        PUSH    DE              ; DE - register - save value
        PUSH    HL              ; HL - register - store value again
        LD      HL,T00D4        ; Pointer to routine for repeating register values
        EX      (SP),HL         ; Store address / get value for HL
        JP      (IX)            ; Return to calling program
;
;
;   saved registers - reload values
;
T00D3:  POP     AF              ;! saved registers - reload values
T00D4:  POP     DE              ;!
        POP     BC              ;!
        POP     HL              ;!
        POP     IX              ;!
        RET
;
;
;   Start BASIC - interpreter after switching on
;
A00DA:  DI                      ; Disable interrupts
        LD      SP,0            ; Reset stack pointer
        IM      2               ; Specify interrupt mode
        OUT     (_E0RAM),A      ; Switch to RAM from 0E000H to 0FFFFH
        LD      HL,(W004D)      ; Get current start address (boot start / warm start)
        JP      (HL)            ; Basic - Start interpreter
;
;
;   Abort program without error message; no 'CONT' possible 
;
A00E6:  XOR     A               ; Code for 'Abort program; no 'CONT' possible' 
        DEFB    LD_HL
;
;
;   Abort the program with 'BREAK'
;
A00E8:  LD      A,080H          ; Code for 'Abort program with 'BREAK'
        DEFB    LD_HL
;
;
;   Devices - output name and error number in Accu
;
A00EB:  OR      10000000B       ; Code 'Output device name for error number'
;
;
;   Handle error with number in Accu
;
A00ED:  PUSH    AF              ; Save error number
        CALL    A447B           ; turn off the sound
        POP     AF              ; Retrieve saved error number
        LD      HL,(S004F)      ; Get start address of error handler
        JP      (HL)            ; Jump to the error handling routine
;
;
;   Count the length of the text (DE); the end of the text is marked by the character NUL 
;
;   (Software command code:  23)
;
A00F6:  PUSH    DE              ; Save pointer to beginning of text
        LD      B,0             ; Set counter to zero
A00F9:  LD      A,(DE)          ; get a character text
        OR      A               ; equal to end-of-text character (NUL) ?
        JR      Z,A0102         ; yes --> retrieve saved pointer to start of text
        INC     DE              ; Pointer to text on next character
        INC     B               ; Counter 'Number of characters text' plus one
        JR      NZ,A00F9        ; Counter still OK (< 256) --> continue counting
        DEC     B               ; specify a maximum string length of 255
A0102:  POP     DE              ; retrieve the saved pointer to the beginning of the text 
        RET
;
;
;   Output table of values (HL) to ports; B contains number of values in table 
;
;   (Software command code:  36)
;
A0104:  LD      A,(HL)          ; fetch the value to be output from the table
        INC     HL              ; Skip value in table
        LD      C,(HL)          ; Get port number from table
        INC     HL              ; Skip port number in table
        OUT     (C),A           ; Output value from table to port
        DJNZ    A0104           ; output more values 
        RET
;
;
;   Convert ASCII value (HL) to hex value after DE, compare to upper limit in B 
;
A010D:  RST     _DOCMD          ; Software - Execute command
        DEFB    19              ; Command 19 convert ASCII value (HL) into hex value after DE
        LD      A,D             ; Get high byte of evaluated value
        OR      A               ; equals zero  ?
        JP      NZ,A1F7F        ; no --> Error 3 Illegal data error
        LD      A,E             ; Get low byte value
        CP      B               ; compare with maximum allowed value
        RET     C               ; value is ok
        JP      A1F7F           ; Error 3 Illegal data error
;
        DEFS    1               ; just so that starting address of the following routine with the
                                ; MZ-700 - Basic - Interpreter MZ-5Z008 matches. 
;
;
;   Compare Accu with bytes specified after CALL
;
A011B:  EX      (SP),HL         ; Get return address
        PUSH    BC              ; Register - save value
        LD      B,(HL)          ; Get number of bytes specified
A011E:  INC     HL              ; Pointer to next character to be compared
        CP      (HL)            ; Character in Accu same character after CALL ?
        JR      Z,A0127         ; yes --> skip the rest of the specified bytes
        DJNZ    A011E           ; compare other characters
        INC     HL              ; skip last compared character
        JR      A012A           ; saved register - get value and return
;
A0127:  INC     HL              ; skip an unmatched character
        DJNZ    A0127           ; skip more uncompared characters
A012A:  POP     BC              ; saved register - retrieve value again
        EX      (SP),HL         ; Store new return address / get HL register value 
        RET
;
;
;   Get address from table (HL) to DE; Count up HL 
;
A012D:  LD      E,(HL)          ; Get low - byte address from table
        INC     HL              ; Skip low - byte address
        LD      D,(HL)          ; Get high byte address from table
        INC     HL              ; Skip high - byte address
        RET
;
;
;   Get address from table (HL) to DE; do not change HL
;
A0132:  LD      E,(HL)          ; Get low - byte address from table
        INC     HL              ; Pointer to table on high - byte address
        LD      D,(HL)          ; Get high byte address from table
        DEC     HL              ; Set the pointer to the table back to the low byte
        RET
;
;
;   Delete memory area (HL); B contains number of bytes to delete 
;
A0137:  XOR     A               ; Accu = zero
;
;
;   Assign memory area (HL) with constant in Accu; B contains number of bytes 
;
A0138:  LD      (HL),A          ; set a byte to a constant value
        INC     HL              ; Pointer to memory area to next byte
        DJNZ    A0138           ; occupy further bytes with constants
        RET
;
;
;   Delete storage area (DE); B contains number of bytes 
;
A013D:  XOR     A               ; Accu to zero
A013E:  LD      (DE),A          ; delete a byte
        INC     DE              ; Pointer to memory area to next byte
        DJNZ    A013E           ; delete more bytes 
        RET
;
;
;   move storage area from (HL) to (DE); B contains number of bytes
;
A0143:  LD      A,(HL)          ; fetch a byte from source area
        LD      (DE),A          ; and drop it in the target area
        INC     HL              ; Pointer to source area to next byte
        INC     DE              ; Pointer to target area to next byte
        DJNZ    A0143           ; move more bytes 
        RET
;
;
;   Move storage area from (DE) to (HL); B contains number of bytes
;
A014A:  LD      A,(DE)          ; fetch a byte from source area
        LD      (HL),A          ; and drop it in the target area
        INC     HL              ; Pointer to target area to next byte
        INC     DE              ; Pointer to source area to next byte
        DJNZ    A014A           ; move more bytes 
        RET
;
;
;   Get address from table (HL) to HL
;
A0151:  PUSH    AF              ; Save AF
        LD      A,(HL)          ; Get low - byte address from table
        INC     HL              ; Pointer to table on high - byte address
        LD      H,(HL)          ; Get high byte address from table
        LD      L,A             ; Specify low - byte address
        POP     AF              ; Restore AF
        RET
;
;
;   Add the value in the Accu to the HL register 
;
A0158:  ADD     A,L             ; Add Accu to the low byte value
        LD      L,A             ; and note the result
        RET     NC              ; no carry --> finished
        INC     H               ; Correct high - byte value for carry 
        RET
;
;
;   Skip spaces (HL).
;
A015D:  INC     HL              ; Pointer to text on next character
A015E:  LD      A,(HL)          ; get a character text
        CP      ' '             ; equal to space ?
        JR      Z,A015D         ; yes --> search for the next relevant text character 
        RET
;
;
;   Test whether the next relevant text character (HL) is the same byte after the CALL call
;   if so --> ZERO - flag set and characters skipped
;
A0164:  CALL    A015E           ; Skip spaces (HL).
        EX      (SP),HL         ; Get return address from stack
        CP      (HL)            ; Accu same byte after CALL call?
        INC     HL              ; Skip comparison characters
        EX      (SP),HL         ; correct return address
        RET     NZ              ; bytes not equal
        INC     HL              ; skip correct text character 
        RET
;
;
;   Syntax Check. If next relevant text character (HL) is a valid code, then call
;   Otherwise --> Error 1 Syntax error 
;
A016E:  CALL    A015E           ; Skip spaces (HL).
        EX      (SP),HL         ; Get return address / HL - register - save value
        CP      (HL)            ; Accu same byte after CALL call?
        INC     HL              ; Skip comparison characters
        EX      (SP),HL         ; store new return address / retrieve text pointer
        INC     HL              ; skip compared syntax character
        RET     Z               ; Syntax is OK
        LD      A,1             ; Error 1 Syntax error
        JP      A00ED           ; Handle error with number in Accu 
;
;
;   Table with the start addresses of the software commands
;
W017C:  DEFW    A1587           ; Code  0  Call Software - Machine - Monitor
        DEFW    A09AB           ; Code  1  Output newline to screen
        DEFW    A099B           ; Code  2  Line feed when cursor is not at beginning of line
        DEFW    A0E61           ; Code  3  Display accu on screen (execution control mark)
        DEFW    A0EA2           ; Code  4  Display accu on screen (display control characters)
        DEFW    A0D94           ; Code  5  Output text (DE) with upper/lower case
        DEFW    A14F0           ; Code  6  Output characters in Accu to printer
        DEFW    A14B9           ; Code  7  Output characters in the Accu to the printer (and screen).
        DEFW    A0E2A           ; Code  8  Output line feed to screen or printer
        DEFW    A0E2C           ; Code  9  Accu on screen or printer (execution control card)
        DEFW    A0E3A           ; Code 10  Accu on screen or printer (display control line)
        DEFW    A0E48           ; Code 11  Output text (DE) on screen or printer
        DEFW    A0A84           ; Code 12  Get line from keyboard to memory (DE).
        DEFW    A0B1A           ; Code 13  Keyboard query for status in Accu
        DEFW    A0D22           ; Code 14  Query whether (Shift) - BREAK is pressed
        DEFW    A02F8           ; Code 15  if space pressed --> wait for other key
        DEFW    A00A8           ; Code 16  Disable interrupts
        DEFW    A00B3           ; Code 17  Enable interrupt
        DEFW    A094D           ; Code 18  Place cursor on coordinates in HL
        DEFW    A029E           ; Code 19  Convert ASCII value (HL) to hex value according to DE
        DEFW    A02CE           ; Code 20  Convert hexadecimal value (HL) into hex value after DE
        DEFW    A02E9           ; Code 21  Convert hexadecimal ASCII characters in Accu to hex
        DEFW    A025E           ; Code 22  Convert hex value in HL to decimal ASCII to (DE)
        DEFW    A00F6           ; Code 23  Count the length of the text (DE).
        DEFW    A031C           ; Code 24  Pointer to I/O work area, basic var., strings corr.
        DEFW    A0323           ; Code 25  Fix pointers to basic variables and strings
        DEFW    A032A           ; Code 26  Fix pointers to string ranges
        DEFW    A0340           ; Code 27  Output error text according to error number in Accu
        DEFW    A3C1C           ; Code 28  Convert display code characters to ASCII code
        DEFW    A3C00           ; Code 29  Convert ASCII characters in Accu to display code
        DEFW    A14A6           ; Code 30  Query joystick for direction
        DEFW    A14AA           ; Code 31  Query the joystick's fire button
        DEFW    A44F3           ; Code 32  Output reference tone
        DEFW    A4422           ; Code 33  Assign values ??(DE) to the tone generator in the Accu
        DEFW    A437A           ; Code 34  Play tone by generator number/frequency or note/length
        DEFW    A44AF           ; Code 35  Treat music by status in Accu
        DEFW    A0104           ; Code 36  Output table of values ??(HL) to ports; B = number
        DEFW    A14A2           ; Code 37  read time
        DEFW    A149E           ; Code 38  set time
        DEFW    A1989           ; Code 39  provide the next data block of the file
        DEFW    A1BFA           ; Code 40  delete all file data in the computer
        DEFW    A1EF0           ; Code 41  Pointer to record by record number. provide
        DEFW    A1F32           ; Code 42  provide dynamic cache
        DEFW    A1F06           ; Code 43  Clear dynamic cache
        DEFW    A1A45           ; Code 44  Examine text (DE) for device names
        DEFW    A1AC0           ; Code 45  Evaluate device names and file numbers
        DEFW    A19E8           ; Code 46  File management record by file no. provide
        DEFW    A1B83           ; Code 47  Open (program) file
        DEFW    A1CC6           ; Code 48  Load program according to specified identifier
        DEFW    A1CEA           ; Code 49  Save program
        DEFW    A1CDB           ; Code 50  Compare (program) file
        DEFW    A1AE9           ; Code 51  Open file according to provided data
        DEFW    A18D0           ; Code 52  if screen --> get line from keyboard
        DEFW    A18E4           ; Code 53  provide a line from device/file
        DEFW    A194C           ; Code 54  Text constant (HL) up to comma or character in C already.
        DEFW    A180F           ; Code 55  Output text (DE) on selected device
        DEFW    A1BB9           ; Code 56  Close file or delete file data in the computer
        DEFW    A1D2D           ; Code 57  Read or print table of contents
        DEFW    A0314           ; Code 58  Pointer to device table/device no. notice
        DEFW    A3AE0           ; Code 59  Write or read RAM card contents to quick disk
        DEFW    A1E6D           ; Code 60  Initialize device
        DEFW    A343C           ; Code 61  delete file
        DEFW    A347B           ; Code 62  Rename file
        DEFW    A341B           ; Code 63  Protect or share file
        DEFW    A30D0           ; Code 64  RANDOM - remember block number
        DEFW    A326D           ; Code 65  Read record from RANDOM file
        DEFW    A30F5           ; Code 66  Write record to RANDOM file
        DEFW    A1FC0           ; Code 67  Delete file data of the output file
        DEFW    A32CC           ; Code 68  SWAP - Write or load main program
        DEFW    A0652           ; Code 69  clear entire screen
        DEFW    A4D08           ; Code 70  Check if graphic coordinate in DE',HL' is OK
        DEFW    A4D13           ; Code 71  Set graphic cursor to coordinates in DE',HL'
        DEFW    A4694           ; Code 72  Set or reset point in graphic
        DEFW    A46CE           ; Code 73  Draw a line in Graphic
        DEFW    A4F52           ; Code 74  Graphic - pattern - output text
        DEFW    A4BE9           ; Code 75  Draw rectangle
        DEFW    A5036           ; Code 76  Paint area (B=number of colors/(HL)=border color values)
        DEFW    A47E7           ; Code 77  draw circle
        DEFW    A4629           ; Code 78  Query whether point is set in graphic
        DEFW    A14AE           ; Code 79  Output screen content to graphic printer
        DEFW    A03BE           ; Code 80  Screen - set operating mode
        DEFW    A044F           ; Code 81  Memorize pallet block number/output to controller
        DEFW    A0476           ; Code 82  Match color code in B to pallet code number in Accu
        DEFW    A04AE           ; Code 83  Set values ??for screen - scroll - area
        DEFW    A048A           ; Code 84  Set character color
        DEFW    A0493           ; Code 85  Graphic - set palette value
        DEFW    A458E           ; Code 86  Initialize screen
        DEFW    A4D2D           ; Code 87  Output text with magnification
;
;
;   Execute software command   (RST 018H - Routine)
;
A022C:  EX      (SP),HL         ; Get return address
        PUSH    AF              ; Register - save value
        LD      A,(HL)          ; Get software command number
        INC     HL              ; Command - skip number
        PUSH    HL              ; store new return address
        LD      HL,W017C        ; Pointer to table with start addresses of routines
        ADD     A,A             ; Command number times two (2 bytes per address)
        ADD     A,L             ; and add the start address to the low byte
        JR      NC,A0239        ; no carry
        INC     H               ; Correct carry
A0239:  LD      L,A             ; Remember low byte result
        LD      A,(HL)          ; Get low byte start address from table
        INC     HL              ; Pointer to table on high - byte address
        LD      H,(HL)          ; Get high byte start address from table
        LD      L,A             ; Enter low - byte address
        LD      (D0244 + 1),HL  ; Enter start address in JP command
        POP     HL              ; fetch saved return address
        POP     AF              ; rescued register - fetch value
        EX      (SP),HL         ; Store return address/HL - register - get value
D0244:  JP      0               ; Execute software command (address is entered)
;
;
;   Call routine (IX) with error handling
;
A0247:  PUSH    HL              ;! Register - save values
        PUSH    DE              ;!
        LD      (D0252 + 1),IX  ; Enter the start address of the routine
        LD      IX,A00EB        ; Address 'Output error with device name'
        OR      A               ; reset carry flag (code 'no error')
D0252:  CALL    0               ; Call routine (address is entered)
        POP     DE              ;! saved registers - retrieve values
        POP     HL              ;!
        RET     NC              ; no error --> OK
        OR      A               ; end of file ?
        SCF                     ; Set code 'Error Occurred'
        RET     Z               ; End of file --> OK
        JP      A00EB           ; Error with device - output name
;
;
;   Convert hex value in HL to decimal ASCII value to (DE)
;
;   (Software command code:  22)
;
A025E:  PUSH    HL              ; save value to be implemented
        PUSH    BC              ; Register - save value
        PUSH    DE              ; Push pointer to text memory on stack
        LD      DE,10000        ; specify priority
        CALL    A0284           ; implement a position
        LD      DE,1000         ; specify priority
        CALL    A0284           ; implement a position
        LD      DE,100          ; specify priority
        CALL    A0284           ; implement a position
        LD      DE,10           ; specify priority
        CALL    A0284           ; implement a position
        LD      A,L             ; Get value of last digit
        POP     DE              ; Get pointer to ASCII - text - memory
        OR      '0'             ; Convert number to ASCII characters
        LD      (DE),A          ; Enter ASCII digits in text memory
        INC     DE              ; skip entered number
        XOR     A               ; Accu to zero (code 'End of text (NUL)')
        LD      (DE),A          ; Enter end of text character after number in memory
        POP     BC              ; rescued register - fetch value
        POP     HL              ; get converted value
        RET
;
;
;   implement a position according to the priority in DE
;
A0284:  LD      A,-1            ; Default for counter
A0286:  INC     A               ; counter plus one
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; Subtract the value of the position once
        JR      NC,A0286        ; still OK --> continue to pull off
        ADD     HL,DE           ; Correct remainder value
        OR      A               ; Value of digit equal to zero ?
        JR      NZ,A0293        ; no --> relevant number
        OR      B               ; digit already entered?
        RET     Z               ; no --> suppress leading zero
        XOR     A               ; Accu back to zero
A0293:  LD      B,1             ; Specify code 'digit entered'
        OR      '0'             ; Convert number to ASCII characters
        POP     DE              ; Get return address
        EX      (SP),HL         ; Save register value / get pointer to memory
        LD      (HL),A          ; Enter ASCII characters in text memory
        INC     HL              ; skip entered number
        EX      (SP),HL         ; Save pointer to memory / get residual value
        PUSH    DE              ; Put the return address back on the stack
        RET
;
;
;   Convert decimal or hexadecimal ASCII value (HL) into hex value according to DE
;
;   (Software command code:  19)
;
A029E:  CALL    A0164           ; Comparison on byte after CALL call
        DEFM    "$"             ; ID 'hexadecimal - value' ?
        JR      Z,A02CE         ; yes --> convert hexadecimal value (HL) into hex value after DE
        LD      DE,0            ; Default value result
A02A7:  CALL    A015E           ; Skip spaces (HL).
        SUB     '0'             ; Convert ASCII characters to decimal value
        CP      10              ; digit ?
        RET     NC              ; no --> numerical value implemented
        INC     HL              ; skip converted digit
        PUSH    HL              ; Save pointer to rest of text
        LD      H,D             ;! duplicate old value
        LD      L,E             ;!
        ADD     HL,HL           ; old value times two
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     HL,HL           ;            times four
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     HL,DE           ;            times five
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     HL,HL           ;            times ten
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        LD      E,A             ; value of the new position
        LD      D,0             ; High - byte value to zero
        ADD     HL,DE           ; Add the value of the new digit
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        EX      DE,HL           ; new result after DE
        POP     HL              ; Get pointer to rest of text
        JR      A02A7           ; examine whether additional digits are specified
;
A02C9:  LD      A,2             ; Error 2 Overflow error
        JP      A00ED           ; Handle error with number in Accu
;
;
;   Convert hexadecimal ASCII value (HL) to hex value according to DE
;
;   (Software command code:  20)
;
A02CE:  LD      DE,0            ; Default value result
A02D1:  LD      A,(HL)          ; get a text character
        CALL    A02E9           ; Convert hexadecimal ASCII characters in Accu to hex value
        RET     C               ; no hex-ASCII character --> done
        INC     HL              ; skip evaluated character
        EX      DE,HL           ; old value to HL / pointer to text to DE
        ADD     HL,HL           ; old value times 2
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     HL,HL           ;             times 4
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     HL,HL           ;             times 8
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     HL,HL           ;             times 16
        JR      C,A02C9         ; Carry over --> Error 2 Overflow error
        ADD     A,L             ; Add the value of the new digit
        LD      L,A             ; note the result
        EX      DE,HL           ; Value after DE / pointer to remaining text after HL
        JR      A02D1           ; implement another position
;
;
;   Convert hexadecimal ASCII characters in Accu to hex value after Accu
;
;   (Software command code:  21)
;
A02E9:  SUB     '0'             ; Convert ASCII characters to decimal - value
        CP      10              ; decimal digit ?
        CCF                     ; Reverse result comparison
        RET     NC              ; is decimal - digit --> done
        SUB     17              ;!  hexadecimal digit ?
        CP      6               ;!
        CCF                     ; Reverse result comparison
        RET     C               ; no hex - ascii - value
        ADD     A,10            ; correct value
        RET
;
;
;   Check whether the space bar is pressed
;   If so -->  wait until another key is pressed
;
;   (Software command code:  15)
;
A02F8:  CALL    A0305           ; Check whether button or 'BREAK' is pressed
        CP      ' '             ; Space key pressed ?
        RET     NZ              ; no
A02FE:  CALL    A0305           ; Check whether button or 'BREAK' is pressed
        OR      A               ; key pressed ?
        JR      Z,A02FE         ; no --> keep waiting
        RET
;
;
;   Check whether button is pressed with BREAK --> Interrupt program
;
A0305:  RST     _DOCMD          ; Software - Execute command
        DEFB    14              ; Code 14 Query whether (Shift) BREAK is pressed
        JR      Z,A0310         ; yes --> interrupt program (BREAK)
        LD      A,-1            ; Code 'keyboard query with debouncing'
        RST     _DOCMD          ; Software - Execute command
        DEFB    13              ; Code 13 Keypad query for status in Accu
        CP      ESC             ; Shift-BREAK pressed?
        RET     NZ              ; no
A0310:  JP      A00E8           ; Shift - BREAK pressed --> interrupt program
;
        RET
;
;
;   Pointer to device table and device number as DEFAULT - remember device
;
;   (Software command code:  58)
;
A0314:  LD      (S106A),DE      ; Pointer to device - remember table (DEFAULT).
        LD      (S1069),A       ; Devices - remember number
        RET
;
;
;   Fix pointers to file work areas, basic variables and string areas
;
;   (Software command code:  24)
;
A031C:  LD      HL,(S1072)      ; Get pointers to file work areas (I/O work area).
        ADD     HL,DE           ; Correct pointer
        LD      (S1072),HL      ; and remember new pointer
;
;
;   Correct pointers to Basic - variable and string ranges
;
;   (Software command code:  25)
;
A0323:  LD      HL,(S1074)      ; Get pointer to start of basic variable
        ADD     HL,DE           ; Correct pointer
        LD      (S1074),HL      ; and remember again
;
;
;   Correct pointers to string areas
;
;   (Software command code:  26)
;
A032A:  LD      HL,(S1076)      ; Get pointer to beginning of string text area
        ADD     HL,DE           ; Correct pointer
        LD      (S1076),HL      ; and remember again
        LD      HL,(S1078)      ; Get pointer to start of string workspace
        ADD     HL,DE           ; Correct pointer
        LD      (S1078),HL      ; and remember again
        LD      HL,(S107A)      ; Get pointer to end of string workspace
        ADD     HL,DE           ; Correct pointer
        LD      (S107A),HL      ; and remember again
        RET
;
;
;   Output error text according to error number in Accu
;
;   (Software command code:  27)
;
A0340:  LD      C,A             ; Remember error number
        RST     _DOCMD          ; Software - Execute command
        DEFB    32              ; Output code 32 reference tone
        RST     _DOCMD          ; Software - Execute command
        DEFB    2               ; Code 2 line feed if cursor not at beginning of line
        BIT     7,C             ; Output device name?
        JR      Z,A0353         ; no
        LD      HL,S11A4        ; Specify pointer to cache
        PUSH    HL              ; Remember pointer to beginning of memory
        CALL    A0397           ; Devices - Provide Names by Storage (HL).
        POP     DE              ; Pointers to Recycled Devices - Get Names
        RST     _DOCMD          ; Software - Execute command
        DEFB    5               ; Code 5 Output text (DE) with upper/lower case
A0353:  LD      A,C             ; Get error number
        AND     01111111B       ; mask actual error number
        LD      C,A             ; and remember again
        RST     _DOCMD          ; Software - Execute command
        DEFB    16              ; Code 16 disable interrupt
        OUT     (_E0ROM),A      ; Switch to ROM - monitor from 0E000H to 0FFFFH
        JR      A035F           ; Output error text
;                                 
A035D:  LD      C,69            ; Error 69 Unprintable error
A035F:  LD      DE,ZFDA0        ; Pointer to start of error text table in ROM monitor
A0362:  DEC     C               ; Counter minus one
        JR      Z,A036F         ; Pointer is on correct error text --> output
A0365:  LD      A,(DE)          ; Get a character from the error text table
        INC     DE              ; Table pointer to next text character
        OR      A               ; end of text character ?
        JP      P,A0365         ; no --> find end of text
        JR      Z,A035D         ; End of table --> Specify error 69 Unprintable error
        JR      A0362           ; test whether pointer is on correct error text
;                                 
A036F:  LD      A,(DE)          ; get first text character
        CP      _NOTXT          ; Code 'no text available' ?
        JR      Z,A035D         ; Yes --> Specify error 69 Unprintable error
        EX      DE,HL           ; Pointer to error text after HL
        LD      DE,S11A4        ; Specify pointer to cache
A0378:  LD      A,(HL)          ; one character Get error text from table
        OR      A               ; end of text character ?
        JP      M,A0381         ; yes --> output provided text
        LDI                     ; transfer a text character from table to memory
        JR      A0378           ; transfer more text characters
;                                 
A0381:  AND     01111111B       ; mask actual text character
        LD      (DE),A          ; and remember in memory
        OUT     (_E0RAM),A      ; Switch to RAM from 0E000H to 0FFFFH
        RST     _DOCMD          ; Software - Execute command
        DEFB    17              ; Code 17 enable interrupt
        INC     DE              ; skip last character of text in memory
        LD      HL,M03B6        ; Text " error"
        LD      B,8             ; Specify text length
        CALL    A0143           ; Move text from (HL) to (DE).
        LD      DE,S11A4        ; Pointer to memory with edited error text
        RST     _DOCMD          ; Software - Execute command
        DEFB    5               ; Code 5 Output text (DE) with upper/lower case
        RET
;
;
;   Devices - Provide name of current device after (HL).
;
A0397:  LD      DE,(S1044)      ; Pointers to current devices - get table
        INC     DE              ;! Pointer to next devices - table
        INC     DE              ;! skip
        RST     _DOCMD          ; Software - Execute command
        DEFB    23              ; Code 23 Count length of text (DE).
        CALL    A014A           ; Move memory area from (DE) to (HL).
        LD      A,(S1046)       ; Get current device number
        ADD     A,'1'           ; convert to ASCII
        LD      (HL),A          ; and after devices - enter the name
        LD      A,(S1051)       ; Devices - numbers - get flag
        AND     00001111B       ; maximum devices - mask number
        JR      Z,A03B0         ; no device number allowed
        INC     HL              ; entered devices - skip number
A03B0:  LD      (HL),':'        ; Enter a colon after the device name
        INC     HL              ; skip colon
        LD      (HL),NUL        ; Enter the end of the text after the device name
        RET
;
M03B6:  DEFB    ' ', _SML       ; Text  "error"
        DEFM    "ERROR"
		DEFB    NUL
;
;   
;   Screen - set operating mode  (Software command code: 80)
;
A03BE:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        LD      B,A             ; Screen - remember operating mode
        LD      A,(S1099)       ; Get flag 'additional graphic RAM available' (1=yes)
        OR      A               ; Additional graphic RAM available?
        LD      A,B             ; get new screen - operating mode
        JR      NZ,A03D1        ; Graphic RAM available --> all operating modes are permitted
        CP      2               ; Operating mode 2 (320 x 200 pixels / 16 colors) ?
        JR      Z,A0417         ; yes --> not possible without additional graphic --> error
        CP      4               ; Operating mode 4 (640 x 200 pixels / 4 colors) ?
        JR      Z,A0417         ; Yes --> Not possible without additional graphics --> Error
A03D1:  PUSH    AF              ; new screen - remember operating mode
        DEC     A               ; Screen - mode minus one
        LD      D,11111111B     ; Specification for mask 'Number of screen pages'
        LD      HL,B1389        ; Pointer to default color code mode 1
        LD      BC,256*4+0011B  ; maximum palette value / default for color planes
        JR      Z,A03F7         ; Screen - Operating mode 1 --> Note values
        DEC     A               ; Screen - mode minus one
        LD      HL,B138D        ; Pointer to default color code mode 2
        LD      BC,256*16+1111B ; maximum palette value / default for color planes
        JR      Z,A03F7         ; Screen - Operating mode 2 --> Note values
        DEC     A               ; Screen - mode minus one
        LD      HL,B1385        ; Pointer to default color code mode 3
        LD      BC,256*2+0001B  ; maximum palette value / default for color planes
        JR      Z,A03F7         ; Screen - Mode 3 --> Remember values
        LD      HL,B1389        ; Pointer to default for color code mode 4
        LD      BC,256*8+0101B  ; maximum palette value / default for color planes
        LD      D,11111101B     ; Specification for mask 'Number of screen pages'
A03F7:  LD      (S109C),BC      ; remember maximum palette value / default for color planes
        LD      A,D             ; Get mask for number of screen pages
        LD      (S109E),A       ; and remember
        LD      (W137F),HL      ; Pointer to color code - remember default
        CALL    A0441           ; Initialize palette registers for basic colors
        POP     AF              ; Screen - Get operating mode
        DEC     A               ; minus one (--> 0 - 3)
        RLCA                    ; and now two
        LD      (S1098),A       ; Note value for display - mode - register
        OUT     (CRTCDM),A      ; Output value to display - mode - register
        AND     00000100B       ; Mask flag '40/80 characters per line'
        CALL    A04EF           ; Change routine to 40 or 80 characters per line
        CALL    A0419           ; Unclip/Initialize Palette
        OR      A               ; reset Carry flag (code 'Function OK')
        RET
;
A0417:  SCF                     ; Set code 'Error Occurred'
        RET
;
;
;   Set scroll area to full screen and initialize palette registers
;
A0419:  LD      HL,256 * 24 + 0 ; Specify Y - Coordinate minimum / maximum
        CALL    A04AE           ; Calculate values ??for scroll area from Y coordinates
        LD      A,(S109C)       ; Get default used color planes
        LD      (S109B),A       ; and remember as currently used color planes
        XOR     A               ; Accu to zero
        CALL    A044F           ; Pallet block - remember number and output to controller
        LD      HL,W137F        ; Pointer to Pointer to color code - default
        LD      E,(HL)          ;! Get pointer to default palette register
        INC     HL              ;!
        LD      D,(HL)          ;!
        EX      DE,HL           ; Pointer to default palette register after HL
        LD      DE,S1381        ; Pointer to storage for palette values
        PUSH    DE              ; Remember pointer to beginning of memory
        LD      BC,4            ; Specify number of values
        LDIR                    ; Transfer default pallet value to memory
        POP     HL              ; Pointer to start of memory with palette values
A043A:  LD      B,4             ; four values ??in memory
        LD      C,PALLET        ; Port - number of the palette register
        OTIR                    ; Output values ??to palette registers
        RET
;
;
;   Initialize palette registers for basic colors Black/Blue/Red/Light White
;
A0441:  PUSH    BC              ; Register - save value
        XOR     A               ; Default initial value (zero)
        LD      B,5             ; output five values
        LD      C,PALLET        ; Specify the port number of the palette register
A0447:  OUT     (C),A           ; Output pallet value
        ADD     A,010H          ; Calculate next pallet value
        DJNZ    A0447           ; output further pallet values
        POP     BC              ; saved register - retrieve value again
        RET
;
;
;   Palette block - Set number (Software command code: 81)
;
A044F:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        LD      (S137E),A       ; current pallet block - remember number
        LD      E,A             ; Pallet block - remember number
        LD      A,(S1098)       ; Get value for Display - Mode - Register
        CP      2               ; Resolution 320 x 200 pixels / 16 colors ?
        JR      NZ,A0470        ; not the finest graphic resolution
        LD      A,E             ; Pallet block - get number
        RLCA                    ;! times two
        RLCA                    ;! times four
        LD      HL,S1381        ; Pointer to storage for palette values
        LD      B,4             ; four values ??in the palette block
        PUSH    HL              ; Remember pointer to beginning of memory
A0466:  LD      (HL),A          ; remember a palette value
        ADD     A,011H          ; Calculate next value in palette block
        INC     HL              ; Pointer to next memory for palette value
        DJNZ    A0466           ; Calculate further initial values ??for pallet block
        POP     HL              ; Get pointer to beginning of memory with palette values
        CALL    A043A           ; output new values ??to palette registers
A0470:  LD      A,E             ; Pallet block - get number
        OR      01000000B       ; plus code 'switch 0/1'
        OUT     (PALLET),A      ; Pallet block - issue number to controller
        RET
;
;
;   Assign the color code in B to the pallet code number in the Accu
;   and output it to the palette register
;
;   (Software command code:  82)
;
A0476:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        LD      HL,S1381        ; Pointer to storage for palette values
        LD      D,0             ; High - byte offset to zero
        LD      E,A             ; Specify pallet code number as low byte offset
        ADD     HL,DE           ; Pointer to correct pallet code - calculate value
        OR      A               ; Reset carry flag
        RLCA                    ;! Pallet code - number on pallets - bits
        RLCA                    ;! push
        RLCA                    ;!
        RLCA                    ;!
        OR      B               ; plus color value - number
        LD      (HL),A          ; Remember palette code and color value
        OUT     (PALLET),A      ; and output to pallet registers
        RET
;
;
;   Set current drawing color to palette value in accu
;
;   (Software command code:  84)
;
A048A:  PUSH    AF              ; Save pallet value
        CALL    A049C           ; Correct palette value for maximum resolution
        LD      (S109B),A       ; current character - remember palette value
        POP     AF              ; retrieve saved pallet value
        RET
;
;
;   Set current graphic color to palette value in Accu
;
;   (Software command code:  85)
;
A0493:  PUSH    AF              ; Save pallet value
        CALL    A049C           ; Correct palette value for maximum resolution
        LD      (S109F),A       ; Remember current graphic palette value
        POP     AF              ; recover saved pallet value
        RET
;
;
;   Correct pallet value in Accu for maximum resolution
;
A049C:  PUSH    BC              ; Register - save value
        LD      B,A             ; Remember pallet value
        LD      A,(S1098)       ; Get value for Display - Mode - Register
        CP      6               ; Resolution 640 x 200 pixels / 4 colors ?
        LD      A,B             ; retrieve saved pallet value
        JR      NZ,A04AC        ; not maximum resolution
        CP      2                 
        JR      C,A04AC         ; Palette value is OK
        ADD     A,2             ; Correct palette value
A04AC:  POP     BC              ; rescued register - fetch value
        RET
;
;
;   Calculate values for screen - scroll - area
;   from start to end coordinates and output to display controller
;
;   (Software command code:  83)
;
A04AE:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        LD      (S136F),HL      ; Y - Remember coordinate minimum / maximum
        LD      A,H             ;! Calculate the number of lines in the scroll area
        SUB     L               ;!
        INC     A               ;!
        LD      (S1371),A       ; Note the number of lines in the scroll area
        LD      B,A             ; Note number of lines
        ADD     A,A             ;! times two
        ADD     A,A             ;!     four
        ADD     A,B             ;!     five
        LD      (S1374),A       ; and note it as the value for 'Scroll - width'
        EX      DE,HL           ; Note the start and end coordinates
        LD      H,0             ; High - byte value to zero
        LD      L,A             ; Number of lines in the scroll area multiplied by five
        ADD     HL,HL           ;! Calculate maximum scroll offset
        ADD     HL,HL           ;!
        ADD     HL,HL           ;!
        LD      (W1377),HL      ; remember maximum scroll offset according to scroll area
        EX      DE,HL           ; Start and end coordinates back to HL
        INC     H               ; End coordinate plus one
        LD      A,H             ; End coordinate scroll - area
        ADD     A,A             ;! times two
        ADD     A,A             ;!     four
        ADD     A,H             ;!     five
        LD      (S1376),A       ; and note it as the value for 'Scroll-End-Address-Register'
        LD      A,L             ; Start coordinate scroll - get area
        ADD     A,A             ;! times two
        ADD     A,A             ;!     four
        ADD     A,L             ;!     five
        LD      (S1375),A       ; and note it as the value for 'Scroll-Start-Address-Register'
        LD      HL,0            ; Default for offset
        LD      (S1372),HL      ; remember as 'scroll offset' for screen controllers
        LD      HL,S1376        ; Pointers to prepared values ??for screen controllers
        LD      BC,256*6+CRTCMP ; Port number Multi-purpose register in the display controller
        OTDR                    ; Output provided values ??to screen controllers
        CALL    A0652           ; Software command 69 clears the entire screen
        JP      A0992           ; Execute control character 'HOME'
;
;
;   Change screen routines to 40 or 80 characters per line
;   (if Accu is not zero --> 80 characters per line)
;
A04EF:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        OR      A               ; 40 or 80 characters per line?
        LD      A,40            ; 40 characters per line
        LD      DE,256*INC_HL + _NOP
        JR      Z,A04FE         ; change to 40 characters per line
        ADD     A,A             ; Counter to 80 characters per line
        LD      DE,256*_NOP + INC_HL
A04FE:  LD      (W136B),A       ; Note counter '40/80 characters per line'
        LD      H,0             ; High - byte value to zero
        LD      L,A             ; Number of characters per line as low - byte value
        ADD     HL,HL           ;!  times two (eight graphic columns per text character)
        ADD     HL,HL           ;!      four
        ADD     HL,HL           ;!      eight
        LD      (W136D),HL      ; Note the number of pixels per line
        DEC     A               ; Counter to maximum X - coordinate
        LD      (S136A),A       ; note the maximum X coordinate
        LD      A,D             ; Get command for second value
        LD      (D0535),A       ;!  and enter into routines
        LD      (D0536),A       ;!
        LD      (D0547),A       ;!
        LD      A,E             ; Get command for first value
        LD      (D053E),A       ;!  and enter into routines
        LD      (D053F),A       ;!
        LD      (D054B),A       ;!
        LD      BC,256 * 11 + 7 ; 10 two-byte values / 7 one-byte values
        LD      HL,W054F        ; Pointer to table with values to be changed
        CALL    A0531           ; Change program according to table (HL).
        CALL    A45D0           ; Change graphic routine to 40 or characters/line
        JP      A0652           ; Software - command 69 delete complete screen
;
;
;   Change program routines according to table (HL).
;
A0531:  LD      E,(HL)          ;!Get address from table
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL              ; Skip high - byte address
D0535:  INC     HL              ;!  skip the first value (NOP is written here if
D0536:  INC     HL              ;!           the first value is to be entered)
        LD      A,(HL)          ;!  Get the value from the table and enter it at the address in the routine
        INC     HL              ;!      Pointer to table to next byte
        LD      (DE),A          ;!      Enter value in routine
        INC     DE              ;!      Address to next byte
        LD      A,(HL)          ;!      Get value from table
        INC     HL              ;!      Skip value in table
        LD      (DE),A          ;!      Enter value in routine
D053E:  NOP                     ;!  INC HL stands here if the first value from the table
D053F:  NOP                     ;!  was entered
        DJNZ    A0531           ; enter another two byte values from the table
        LD      B,C             ; Specify number of one-byte values for counters
A0543:  LD      E,(HL)          ;!  Get address from table
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL              ; Skip high - byte address
D0547:  INC     HL              ; skip first value (or NOP)
        LD      A,(HL)          ; Get value from table
        INC     HL              ; Skip value in table
        LD      (DE),A          ; Enter value in routine
D054B:  NOP                     ; INC HL stands here if the first value was entered
        DJNZ    A0543           ; enter another one - byte - values
        RET
;
;
;   Table for changing the monitor text routines to 40 or 80 characters per line
;
W054F:  DEFW    A05E5 + 1       ; Address
        DEFW    80              ; Value for 80 characters per line
        DEFW    40              ; Value for 40 characters per line 
;
        DEFW    A063D           ; Address
        DEFW    021CBH          ; Value for 80 characters per line   (SLA C)
        DEFW    00000H          ; Value for 40 characters per line    (NOP NOP)
;
        DEFW    A0666 + 1       ; Address
        DEFW    400             ; Value for 80 characters per line
        DEFW    200             ; Value for 40 characters per line 
;
        DEFW    A0669 + 1       ; Address
        DEFW    SCREEN + 16000  ; Value for 80 characters per line
        DEFW    SCREEN +  8000  ; Value for 40 characters per line 
;
        DEFW    A071F + 1       ; Address
        DEFW    80              ; Value for 80 characters per line
        DEFW    40              ; Value for 40 characters per line 
;
        DEFW    A0747 + 1       ; Address
        DEFW    7 * 80          ; Value for 80 characters per line
        DEFW    7 * 40          ; Value for 40 characters per line 
;
        DEFW    A07C2 + 1       ; Address
        DEFW    80              ; Value for 80 characters per line
        DEFW    40              ; Value for 40 characters per line 
;
        DEFW    A07E8 + 1       ; Address
        DEFW    -80             ; Value for 80 characters per line
        DEFW    -40             ; Value for 40 characters per line 
;
        DEFW    A0814 + 1       ; Address
        DEFW    - (7 * 80)      ; Value for 80 characters per line
        DEFW    - (7 * 40)      ; Value for 40 characters per line 
;
        DEFW    A0829 + 1       ; Address
        DEFW    80              ; Value for 80 characters per line
        DEFW    40              ; Value for 40 characters per line 
;
        DEFW    A08D4 + 1       ; Address
        DEFW    8 * 80 - 1      ; Value for 80 characters per line
        DEFW    8 * 40 - 1      ; Value for 40 characters per line 
;
;
;
        DEFW    A06E4 + 1       ; Address
        DEFB    80 - 1          ; Value for 80 characters per line
        DEFB    40 - 1          ; Value for 40 characters per line 
;
        DEFW    A070D + 1       ; Address
        DEFB    80 - 1          ; Value for 80 characters per line
        DEFB    40 - 1          ; Value for 40 characters per line 
;
        DEFW    A07B3 + 1       ; Address
        DEFB    80 - 1          ; Value for 80 characters per line
        DEFB    40 - 1          ; Value for 40 characters per line 
;
        DEFW    A0824 + 1       ; Address
        DEFB    80 - 1          ; Value for 80 characters per line
        DEFB    40 - 1          ; Value for 40 characters per line 
;
        DEFW    A0858 + 1       ; Address
        DEFB    80              ; Value for 80 characters per line
        DEFB    40              ; Value for 40 characters per line 
;
        DEFW    A0972           ; Address
        DEFB    ADD_HL          ; Value for 80 characters per line
        DEFB    _NOP            ; Value for 40 characters per line 
;
        DEFW    A0989           ; Address
        DEFB    ADD_HL          ; Value for 80 characters per line
        DEFB    _NOP            ; Value for 40 characters per line 
;
;
;   Display characters in Accu on screen
;
A05AD:  CALL    A00BA           ; Save registers IX, HL, BC, DE and AF
        LD      HL,(W1084)      ; Get pointer to current location in text memory
        LD      C,A             ; note the character to be output
        CP      ' '             ; Space ?
        JR      NZ,A05B9        ; no
        XOR     A               ; Note space as 000H
A05B9:  LD      (HL),A          ; Enter text characters in pseudo image memory
        LD      HL,(W1086)      ; Get text cursor position in Graphic screen
        LD      A,C             ; get the character to be output
        CALL    A05CE           ; Enter characters in the Accu in Graphic screen
        XOR     A               ; Code 'Concatenate line if to next line'
        LD      (D09E1 + 1),A   ; Enter jump offset in routine
        CALL    A09D4           ; Execute 'Cursor right'
        LD      A,7             ; Code 'move cursor only'
        LD      (D09E1 + 1),A   ; Enter jump offset in routine 
        RET
;
;
;   Enter characters in the Accu in Graphic screen
;
A05CE:  RST     _DOCMD          ; Software - Execute command
        DEFB    29              ; Code 29 Convert ASCII characters to display code
        DI                      ; Disable interrupts
        EXX                     ; Save first register record
        PUSH    HL              ; Register - save value
        LD      H,0             ; High - byte value to zero
        LD      L,A             ; Specify display code character as low - byte value
        LD      A,(S109B)       ; current character - get palette value
        OR      10000000B       ; plus code 'Replace (REPLACE)'
        OUT     (CRTCWF),A      ; to 'Write-Format-Register' of the display controller
        ADD     HL,HL           ;! display code character times two
        ADD     HL,HL           ;!                        four
        ADD     HL,HL           ;!                        eight
        SET     4,H             ; Set offset to address from 01000H (beginning of character ROM)
                                ; (with SET 5,H characters from the second character set are used
                                ;  issued)
        EXX                       
        LD      B,8             ; eight vertical rows per character
A05E5:  LD      DE,40           ; Distance to the next vertical row (is entered)
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
A05EA:  EXX                       
        LD      A,(HL)          ; get a byte from character set - ROM
        INC     HL              ; Pointer to character set - ROM to next byte
        EXX                       
        LD      (HL),A          ; Enter characters in the Graphci image memory
        ADD     HL,DE           ; Pointer to graphic frame buffer to next line
        DJNZ    A05EA           ; enter further lines of the character in graphic image memory
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Enable interrupt
        EXX                       
        POP     HL              ; rescued register - fetch value
        EXX
        RET
;
;
;   Y - Provide coordinates of beginning of current line and beginning of next line after DE 
;
;
A05F9:  CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
A05FC:  LD      A,(HL)          ; Get the row's concatenation flag
        OR      A               ; equals zero  ?
        JR      Z,A0608         ; yes --> Y - coordinate found at beginning of line
        DEC     HL              ; Pointer to concatenation flags minus one
        DEC     E               ; Y - coordinate minus one
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        CP      E               ; compare with Y - coordinate
        JR      C,A05FC         ; still within the scroll area --> search for the beginning of the line
A0608:  LD      D,E             ; Y - Remember the coordinates at the beginning of the line
A0609:  INC     E               ; Y - coordinate plus one
        INC     HL              ; Pointer to concatenation flags plus one
        LD      A,(HL)          ; Get the row's concatenation flag
        OR      A               ; equal to zero (beginning of line) ?
        RET     Z               ; yes --> Found the beginning of the next line
        LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        CP      E               ; compare with current Y - coordinate
        JR      NC,A0609        ; still within the scroll area --> beginning of next line
        RET
;
;
;   Provide pointer to concatenation flag of row in HL
;   On entry, H = Y coordinate
;
A0615:  LD      E,H             ; Y - coordinate of the row as low - byte offset
        LD      D,0             ; High - byte offset to zero
        LD      HL,S13A9        ; Pointer to memory with concatenation flags of text lines
        ADD     HL,DE           ; Set pointer to row concatenation flag
        RET
;
;
;   Cursor - control character CLR (clear screen (section))
;
A061D:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        LD      H,A             ; specify as the Y coordinate
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      A,(S1371)       ; Get number of lines in scroll area
        LD      B,A             ;! and remember
        LD      E,A             ;!
        CALL    A0137           ; Clear memory area (HL) (concatenation flags)
        LD      C,E             ; Number of lines in the scroll area
        LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        INC     A               ; Y - coordinate of line inter scroll area
        LD      L,0             ; X - coordinate to zero
        LD      H,A             ; Specify Y coordinate
        PUSH    HL              ; Save initial coordinates of line behind scroll area
        CALL    A0963           ; Calculate text memory address from coordinates in HL
        LD      B,0             ; High - byte number of rows to zero
A063D:  NOP                     ;! if 80 characters/line it says SLA C
        NOP                     ;! (Delete duplicate count)
        PUSH    BC              ; Save number of lines
        CALL    A0671           ; Delete storage area from back to front
        POP     HL              ; Get Number of Rows
        ADD     HL,HL           ;! times two (eight bytes per text character in the graphic
        ADD     HL,HL           ;!     four image buffers)
        ADD     HL,HL           ;!     eight
        LD      C,L             ;! Number of rows transferred to BC
        LD      B,H             ;!
        POP     HL              ; Get start coordinate of line after scroll area
        CALL    A097A           ; Calculate graphic image memory coordinate from coordinate in HL
        CALL    A0671           ; Delete storage area from back to front
        JR      A06AC           ; Reset scroll offset
;
;
;   Clear entire screen (Software command code: 69)
;
A0652:  CALL    A00BA           ; Save registers IX, HL, BC, DE and AF
        LD      HL,S2000 + 2000 ; Pointer to end of pseudo image memory (text memory)
        LD      BC,50           ; 50 half lines of 40 bytes each
        CALL    A0671           ; Delete storage area from back to front
        LD      B,25            ; maximum 25 lines
        LD      HL,S13A9        ; Pointer to memory with concatenation flags of text lines
        CALL    A0137           ; Delete memory area (HL).
A0666:  LD      BC,200          ; Number of 40 byte range for erasure (200/400)
A0669:  LD      HL,SCREEN+8000  ; Pointer to end of graphic frame buffer (SCREEN+16000)
        CALL    A0671           ; Delete storage area from back to front
        JR      A06AC           ; Reset scroll offset
;
;
;   Delete storage area from back to front
;   (HL = pointer to end of area / BC = number of 40 - byte - units)
;
A0671:  LD      (D06A2 + 1),SP  ; Save stack pointer at start routine
        LD      (D0683 + 1),HL  ; Enter pointer to end of memory area
        LD      HL,0            ; Default for erasing value
        LD      A,(S109C)       ; Get background color value
        OR      10000000B       ; plus code 'Replace (REPLACE)'
        OUT     (CRTCWF),A      ; to 'Write-Format-Register' of the display controller
A0682:  DI                      ; Disable interrupts
D0683:  LD      SP,0            ; Set pointer to end of memory area
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        PUSH    HL              ;!   Delete 2 bytes
        PUSH    HL              ;!   4
        PUSH    HL              ;!   6
        PUSH    HL              ;!   8th
        PUSH    HL              ;!  10
        PUSH    HL              ;!  12
        PUSH    HL              ;!  14
        PUSH    HL              ;!  16
        PUSH    HL              ;!  18
        PUSH    HL              ;!  20
        PUSH    HL              ;!  22
        PUSH    HL              ;!  24
        PUSH    HL              ;!  26
        PUSH    HL              ;!  28
        PUSH    HL              ;!  30
        PUSH    HL              ;!  32
        PUSH    HL              ;!  34
        PUSH    HL              ;!  36
        PUSH    HL              ;!  38
        PUSH    HL              ;!  Delete 40 bytes
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        LD      (D0683 + 1),SP  ; Re-enter pointer to remaining memory area in routine
D06A2:  LD      SP,0            ; Set the stack pointer to the correct value again
        EI                      ; Enable interrupt
        DEC     BC              ; Counter minus one
        LD      A,C             ;!  Counter equal to zero?
        OR      B               ;!
        JR      NZ,A0682        ; no --> delete another 40 byte areas
        RET
;
;
;   Reset screen controller scroll offset
;
A06AC:  LD      HL,0            ; Scroll - offset to zero
        LD      (S1372),HL      ; remember as 'scroll offset' for screen controllers
        LD      B,2             ; High - Byte 'Scroll Offset Register'
        LD      C,CRTCMP        ; Port - number of the multi-purpose register
        OUT     (C),H           ; High - Output byte scroll offset to controller
        DEC     B               ; Address on Low - Byte 'Scroll Offset Register'
        OUT     (C),L           ; Output low - byte offset to screen controller
        JP      A0992           ; Execute control character 'HOME'
;
;
;   Cursor - control character DELete
;
A06BE:  EXX                     ; switch to second register set
        PUSH    HL              ; HL' - register - save value
        PUSH    DE              ; DE' - register - save value
        PUSH    BC              ; BC' - register - save value
        EXX                     ; switch back to the first register set
        CALL    A06CC           ; Delete character at cursor position
        EXX                     ; switch to second register set
        POP     BC              ; fetch saved BC' - register - value
        POP     DE              ; retrieve saved DE' register value
        POP     HL              ; retrieve saved HL' register value
        EXX                     ; switch back to the first register set
        RET
;
;
;   Delete character at cursor position
;
A06CC:  LD      HL,(S1082)      ; Get current cursor coordinates
        DEC     L               ; X - coordinate minus one
        JP      P,A06E6         ; still in line --> remember new coordinate
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      A,(HL)          ; Get the row's concatenation flag
        LD      H,E             ; current y coordinate
        LD      L,0             ; X - coordinate to zero
        OR      A               ; concatenation flag set ?
        JR      Z,A06E6         ; no
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        CP      H               ; compare with current Y - coordinate
        JR      Z,A06E6         ; is minimal - coordinate
        DEC     H               ; Y - coordinate minus one
A06E4:  LD      L,39            ; X - coordinate at maximum (39/79)
A06E6:  LD      (S1082),HL      ; new current cursor - remember coordinates
        CALL    A0822           ; Cursor at the beginning of the next logical screen line
        CALL    A0960           ; Text image memory address from current cursor coordinate
        PUSH    BC              ; Number of characters in line/remaining number of characters in cursor line
        LD      D,H             ;! Duplicate text - image storage address to DE
        LD      E,L             ;!
        INC     HL              ; Pointer to character after cursor position
        EXX                       
        PUSH    HL              ; Place number of characters in line on stack
        EXX                       
        POP     BC              ; Get number of characters in line
        LDIR                    ; Move line to pseudo - image memory (text memory).
        XOR     A               ; Accu to zero (code 'Space')
        LD      (DE),A          ; enter as the last character of the line
        POP     BC              ; Number of characters in line/remaining number of characters in cursor line
        LD      HL,(S1082)      ; Get current cursor coordinates
        INC     HL              ; X - coordinate cursor plus one
        CALL    A097A           ; Calculate graphic image memory coordinate from coordinate in HL
A0703:  EXX                       
        LD      D,8 + 1         ; eight rows of dots make a character
        LD      HL,(S109D)      ; get maximum palette value / mask for screen pages
        DEC     D               ; Correct number of point rows
        EXX                       
        JR      A0723           ; move the rest of the line
;                                 
A070D:  LD      C,39            ; Number of characters to move in line (39/79)
        DEC     B               ; Remaining number of rows minus one
        JR      Z,A0755         ; done --> delete last character in logical line
        INC     DE              ;! Correct pointer to graphic - image memory
        INC     DE              ;!
        LD      H,D             ;! Transfer pointer to HL
        LD      L,E             ;!
        JR      A0703           ; Move characters in graphic image memory
;                                 
A0718:  LD      HL,(S109D)      ; get maximum palette value / mask for screen pages
        DEC     D               ; Remaining number of rows minus one
        EXX                       
        JR      Z,A070D         ; once done --> test whether more lines
A071F:  LD      DE,40           ; Offset to next graphic line (40/80)
        ADD     HL,DE           ; Calculate pointer to next graphic line
A0723:  EXX                       
        RRC     L               ; one bit maximum palette value after carry
        JR      C,A0718         ; Bit is set --> all palette value levels processed
        LD      A,L             ; Get pallet value
        AND     H               ; link to mask for screen page
        EXX                       
        JR      Z,A0723         ; Color plane is not used
        DI                      ; Disable interrupts
        PUSH    HL              ; Pointer to Graphic - save image memory
        PUSH    BC              ; Save number of bytes / remaining number of lines
        OUT     (CRTCRF),A      ; Color plane to 'Read-Format-Register' of screen controller
        OUT     (CRTCWF),A      ; Color plane to the 'Write-Format-Register' of the screen controller
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
        LD      D,H             ;! Duplicate pointer to Graphic - Image memory
        LD      E,L             ;!
        DEC     DE              ; Pointer to previous byte
        LD      A,C             ; Get number of characters to move
        OR      A               ; Number equal to zero ?
        JR      Z,A0747         ; yes --> do not move line
        LD      A,B             ; Get counter 'Remaining number of rows'
        LD      B,0             ; High - byte count to zero
        LDIR                    ; move a graphic screen line
        DEC     A               ; Counter 'Remaining number of rows' minus one
        JR      Z,A074D         ; no more lines
A0747:  LD      BC,280          ; Offset for pointer to next graphic - text - line
        ADD     HL,BC           ; Calculate pointer to next graphic text line
        LD      A,(HL)          ; get a byte
        LD      (DE),A          ; and transfer
A074D:  IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Enable interrupt
        POP     BC              ; Get number of bytes / remaining number of lines
        POP     HL              ; Pointer to Graphic - get image memory
        JP      A0723           ; Remaining graphic - move lines
;                                 
A0755:  EX      DE,HL           ; Pointer to graphic memory after HL
        INC     C               ; Correct value to number of characters in line
        LD      E,C             ; Number of characters in the screen line (bytes per graphic line)
        LD      D,B             ; High - byte count to zero
        LD      B,8             ; eight lines of graphic in one line of text
        DI                      ; Disable interrupts
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
        LD      A,(S109C)       ; Get background color value
        OR      10000000B       ; plus code 'Replace (REPLACE)'
        OUT     (CRTCWF),A      ; and to the 'Write-Format-Register' of the display controller
A0767:  XOR     A               ; Accu to zero
        LD      (HL),A          ; delete a byte in the graphic screen
        SBC     HL,DE           ; Graphic screen pointer on line above
        DJNZ    A0767           ; delete more bytes in the graphic screen
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Release interrupt again
        LD      HL,(S1082)      ; Get current cursor coordinates
        JP      A094D           ; Set cursor to current coordinates in HL
;
;
;   Cursor - control character INSerT
;
A0776:  EXX                     ; switch to second register set
        PUSH    HL              ; HL' - register - save value
        PUSH    DE              ; DE' - register - save value
        PUSH    BC              ; BC' - register - save value
        EXX                     ; switch back to the first register set
        CALL    A0784           ; insert a character at the cursor position
        EXX                     ; switch to second register set
        POP     BC              ; fetch saved BC' - register - value
        POP     DE              ; retrieve saved DE' register value
        POP     HL              ; retrieve saved HL' register value
        EXX                     ; switch back to the first register set
        RET
;
;
;   Insert character (space) at cursor position in line
;
A0784:  LD      HL,(S1082)      ; Get current cursor coordinates
        CALL    A0822           ; Cursor at the beginning of the next logical screen line
        PUSH    HL              ; Remember cursor coordinates of next logical line
        CALL    A0963           ; Calculate text memory address from coordinates in HL
        DEC     HL              ; Set pointer to last character in current line
        LD      A,(HL)          ; Get last character of line from text memory
        OR      A               ; vacancy ?
        JR      NZ,A07AE        ; no --> correct the stack and you're done
        PUSH    BC              ; Save number of screen lines
        LD      D,H             ;! Duplicate pointer to last character in line
        LD      E,L             ;!
        DEC     HL              ; Pointer to next to last character
        EXX                       
        PUSH    HL              ; Number of characters to move in line
        EXX                       
        POP     BC              ; bring to BC
        LDDR                    ; Move rest of line in pseudo frame store
        XOR     A               ; Accu to zero (code 'Space')
        LD      (DE),A          ; Enter an empty space in the text memory
        POP     BC              ; Get number of screen rows
        POP     HL              ; Get cursor coordinate of next logical line
        CALL    A097A           ; Calculate graphic image memory coordinate from coordinate in HL
        DEC     HL              ; Pointer to last byte of line in graphic memory
        LD      A,C             ; Get remaining number of characters in cursor line
        LD      (A07BA + 1),A   ; and enter into routine
        DEC     B               ; Number of rows minus one
        JR      Z,A07BC         ; just one line on the screen
        JR      A07B3           ; Move characters in graphic memory
;                                 
A07AE:  POP     HL              ; saved register - get value (fix stack)
        RET                       
;                                 
A07B0:  DEC     B               ; Remaining number of rows minus one
        JR      Z,A07BA         ; just move the cursor line
A07B3:  LD      C,39            ; Number of bytes to be shifted in one line (39/79)
        CALL    A07DC           ; move a line of text in the Graphic screen
        JR      A07B0           ; examine whether there are more rows to move
;                                 
A07BA:  LD      C,0             ; Remaining number of characters in the cursor line (will be entered)
A07BC:  CALL    A07DC           ; move a line of text in the Graphic screen
        CALL    A0977           ; absolute graphic memory address from cursor coordinate
A07C2:  LD      DE,40           ; Distance to next graphic line (40/80)
        LD      B,8             ; eight graphic lines make up one text line
        DI                      ; Disable interrupts
        LD      A,(S109C)       ; Get background color value
        OR      10000000B       ; plus code 'Replace (REPLACE)'
        OUT     (CRTCWF),A      ; and to the 'Write-Format-Register' of the display controller
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
A07D3:  XOR     A               ; Accu to zero (code 'Space')
        LD      (HL),A          ; clear a byte in graphic memory
        ADD     HL,DE           ; Calculate pointer to next graphic line
        DJNZ    A07D3           ; clear more bytes in graphic memory
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Enable interrupt
        RET
;
;
;   Graphic Screen - Shift line with end address in HL
;   by one text character (8 pixels) to the right
;
A07DC:  EXX
        LD      D,8 + 1         ; Number Graphic - Lines for one line of text
A07DF:  LD      HL,(S109D)      ; get maximum palette value / mask for screen pages
        DEC     D               ; Remaining number of graphic lines minus one
        EXX                       
        RET     Z               ; finished
        CALL    A07EF           ; Move the remainder of a graphic line
A07E8:  LD      DE,-40          ; Offset to previous graphic line (-40/-80)
        ADD     HL,DE           ; Calculate pointer to previous graphic line
        EXX                       
        JR      A07DF           ; test whether there are more rows to move
;                                 
A07EF:  EXX                       
        RRC     L               ; Shift maximum palette value by one bit
        LD      A,L             ; get current color plane bit to accu
        EXX                       
        RET     C               ; all color planes processed
        EXX                       
        AND     H               ; link to mask for screen page
        EXX                       
        JR      Z,A07EF         ; do not edit this color plane
        PUSH    HL              ; Save pointer to graphic frame buffer
        PUSH    BC              ; Save number of bytes in graphic line
        DI                      ; Disable interrupts
        OUT     (CRTCRF),A      ; Color plane to 'Read-Format-Register' of screen controller
        OUT     (CRTCWF),A      ; Color plane to the 'Write-Format-Register' of the screen controller
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
        LD      D,H             ;! Pointer to end of graphic - duplicate line
        LD      E,L             ;!
        DEC     HL              ; Pointer to penultimate byte (character)
        LD      A,C             ; Get number of bytes in line
        OR      A               ; Number equal to zero ?
        JR      Z,A0814         ; yes --> do not shift bytes in line
        LD      A,B             ; Get remaining rows
        LD      B,0             ; High - Byte Number of characters in line to zero
        LDDR                    ; move a Graphic line
        OR      A               ; Remaining number of lines equal to zero ?
        JR      Z,A081A         ; yes --> saved registers - fetch values
A0814:  LD      BC,-280         ; Offset to previous line of text (Graphic*8) (-280/-560)
        ADD     HL,BC           ; Calculate pointer to previous row
        LD      A,(HL)          ; Graphic - Get pattern from previous line
        LD      (DE),A          ; and enter in a new line
A081A:  IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Enable interrupt
        POP     BC              ; Get number of bytes in graphic line
        POP     HL              ; get saved pointer to graphic memory
        JP      A07EF
;
;
;   Calculate number of connected characters from cursor coordinates in HL to DE
;   Set the cursor coordinate in HL to the beginning of the next logical screen line
;
A0822:  LD      B,1             ; Default for number of lines
A0824:  LD      A,39            ; Specify maximum X coordinate
        SUB     L               ; Calculate remaining number of characters in cursor line
        LD      C,A             ; and remember
        EXX                       
A0829:  LD      DE,40           ; Number of characters in physical screen line (40/80)
        LD      H,0             ; High - byte default to zero
        LD      L,A             ; Remaining number of characters in cursor line as low - byte specification
        EXX                       
A0830:  INC     H               ; Y - coordinate plus one
        LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        CP      H               ; compare with Y - coordinate
        JR      C,A0845         ; End scroll area
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      A,(HL)          ; Get the row's concatenation flag
        OR      A               ; line concatenated ?
        LD      H,E             ; Specify Y coordinate again
        JR      Z,A0845         ; Found the beginning of the next logical line
        INC     B               ; Number of lines plus one
        EXX                       
        ADD     HL,DE           ; Number of characters plus number in a line
        EXX                       
        JR      A0830           ; Find end of logical screen line
;                                 
A0845:  LD      L,0             ; X - coordinate to zero
        RET
;
;
;   Scroll screen content
;
A0848:  CALL    A00BA           ; Save registers IX, HL, BC, DE and AF
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        LD      H,A             ; as the Y coordinate of the start of the scroll area
        LD      L,0             ; X - coordinate start scroll - area to zero
        CALL    A0963           ; Calculate text memory address from coordinates in HL
        LD      D,H             ;! Duplicate text memory address after DE
        LD      E,L             ;!
        LD      B,0             ; High - byte number of characters to zero
A0858:  LD      C,40            ; Low - byte number of characters per line (40/80)
        ADD     HL,BC           ; Calculate pointer to second line in scroll area
        LD      A,(S1371)       ; Get number of lines in scroll area
        DEC     A               ; correct to number of rows to move
        JR      Z,A0870         ; delete only one line in the scroll area
        PUSH    BC              ; Save number of characters per line
        PUSH    HL              ; Save pointer to second line in scroll area
        LD      HL,0            ; Specification for the number of characters in the scroll area
A0866:  ADD     HL,BC           ;! Calculate number of characters to be moved
        DEC     A               ;!   Remaining number of rows minus one
        JR      NZ,A0866        ;!   Add character for further line
        LD      B,H             ;! Transfer number of characters to be shifted to BC
        LD      C,L             ;!
        POP     HL              ; Get pointer to second row in pseudo image memory
        LDIR                    ; Scroll text in pseudo-image memory
        POP     BC              ; Get number of characters in line
A0870:  LD      B,C             ; Specify the number of characters in the line as a counter
        CALL    A013D           ; Delete memory area (DE) (B contains number)
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        LD      H,A             ; and note it as the Y coordinate
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      A,(S1371)       ; Get number of lines in scroll area
        DEC     A               ; correct to number of rows to move
        LD      B,A             ; Remember counter
        LD      (HL),0          ; clear first concatenation flag
        INC     HL              ; Pointer to second concatenation flag
        LD      D,H             ;! Duplicate pointers to concatenation flags
        LD      E,L             ;!
        INC     DE              ; Pointer to next flag
        CALL    NZ,A014A        ; Move memory area from (DE) to (HL).
        LD      (HL),0          ; Clear flag of last line in scroll area
        LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        LD      H,A             ; and note it as the Y coordinate
        LD      L,0             ; X - coordinate to zero (set left margin)
        CALL    A097A           ; Calculate graphic image memory coordinate from coordinate in HL
        LD      (D08CC + 1),HL  ; Enter the end address of the graphic scroll area in the routine
        LD      DE,5 * 8        ; Offset for a line
        LD      HL,(S1372)      ; Get 'scroll offset' for screen controller
        ADD     HL,DE           ; Calculate offset for next line
        PUSH    HL              ; remember new scroll offset
        LD      DE,(W1377)      ; get maximum scroll offset according to scroll area
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; compare new scroll offset to maximum scroll offset
        POP     HL              ; get saved new scroll offset
        JR      NZ,A08AC        ; not yet maximum offset
        LD      HL,0            ; start over again
A08AC:  LD      (S1372),HL      ; 'Scroll offset' for screen - remember controller
A08AF:  IN      A,(CRTCDM)      ; Screen - Controller - Read Status
        AND     01000000B       ; Screen controller active ?
        JR      NZ,A08AF        ; yes --> wait
        DI                      ; Disable interrupts
        LD      C,CRTCMP        ; Port Number Multi Purpose Register
        LD      B,2             ; Address 'high byte scroll offset register'
        OUT     (C),H           ; Output high byte scroll offset to screen controller
        DEC     B               ; Address on 'low byte scroll offset register'
        OUT     (C),L           ; Output low-byte scroll offset to screen controller
        LD      A,(S109B)       ; current character - get palette value
        OUT     (CRTCRF),A      ; output to the screen controller's 'Read-Format-Register'
        OR      10000000B       ; plus code 'Replace (REPLACE)'
        OUT     (CRTCWF),A      ; to 'Write-Format-Register' of the display controller
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
D08CC:  LD      HL,0            ; End address graphic scroll area
        LD      (HL),0          ; delete first byte in line
        LD      D,H             ;! Duplicate pointer to Graphic frame store to DE
        LD      E,L             ;!
        INC     DE              ; Pointer to second byte in last scroll line
A08D4:  LD      BC,320 - 1      ; Number of bytes -1 for a text line in graphic memory
        LDIR                    ; delete the last line of text in the graphic scroll area
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Enable interrupt
        LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        LD      H,A             ; as the new Y coordinate
        LD      L,0             ; X - coordinate at zero (left edge)
        JP      A094D           ; Set cursor to current coordinates in HL
;
;
;   Change character at cursor position for cursor blinking
;
A08E5:  CALL    A00BA           ; Save registers IX, HL, BC, DE and AF
        EXX                       
        PUSH    HL              ; Register - save value
        LD      HL,B1391        ; Pointer to cursor - Bit pattern for alpha mode
        LD      A,(S108D)       ; Current keyboard mode (0=Alpha / 1=Small / 2=Graphic)
        OR      A               ; alpha mode ?
        JR      Z,A08FC         ; Yes
        LD      HL,B1399        ; Pointer to cursor bit pattern for lowercase cursor
        DEC     A               ; lowercase mode ?
        JR      Z,A08FC         ; Yes
        LD      HL,B13A1        ; Pointer to cursor bit pattern for graphic cursor
A08FC:  EXX
        DI                      ; Disable interrupts
        LD      A,(S108C)       ; Get flag 'original/cursor character' (0=original)
        XOR     00000001B       ; reverse flag
        LD      (S108C),A       ; and remember new flag
        LD      HL,(W1086)      ; Get text cursor position in Graphic screen
        LD      D,0             ; High - byte offset to zero
        LD      A,(W136B)       ; Get counter '40/80 characters per line'
        LD      E,A             ; and specify as low - byte offset
        LD      B,8             ; eight graphic lines make up one text line
        LD      A,(S109B)       ; current character - get palette value
        OR      00100000B       ; plus code 'XOR'
        OUT     (CRTCWF),A      ; and to the 'Write-Format-Register' of the display controller
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
A091C:  EXX                       
        LD      A,(HL)          ; get a line of the cursor character
        INC     HL              ; Pointer to cursor bitmap to next byte
        EXX                       
        LD      (HL),A          ; Enter line of cursor bit pattern in graphic memory
        ADD     HL,DE           ; Pointer to Graphic - store to next line
        DJNZ    A091C           ; print more lines of the cursor pattern
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EXX                       
        POP     HL              ; rescued register - fetch value
        EXX                       
        EI                      ; Enable interrupt
        RET
;
;
;   Initialize keyboard and display cursor characters on screen
;
A092B:  CALL    A00BA           ; Save registers IX, HL, BC, DE and AF
        XOR     A               ;!  Initialize cursor - blink - encoder
        OUT     (KEYP_A),A      ;!
        CPL                     ;!
        OUT     (KEYP_A),A      ;!
        LD      A,(S108C)       ; Get flag 'original/cursor character' (0=original)
        OR      A               ; Original characters in display ?
        RET     NZ              ; no --> cursor character in image memory
        JR      A08E5           ; Enter cursor characters in graphic memory
;
;
;   Enter original character at cursor position
;
A093B:  CALL    A00BA           ; Save registers IX, HL, BC, DE and AF
        LD      A,(S108C)       ; Get flag 'original/cursor character' (0=original)
        OR      A               ; Original characters in graphic memory ?
        RET     Z               ; yes --> done
        JR      A08E5           ; Enter original character at cursor position
;
;
;   Change cursor character for blinking
;
A0945:  IN      A,(KEYP_C)      ; Cursor - query timer
        RLCA                    ;!  Timer - shift bit after carry
        RLCA                    ;!
        JR      NC,A092B        ; not set --> show cursor characters
        JR      A093B           ; set --> show original characters
;
;
;   Coordinates in HL as current cursor - remember coordinates
;
;   (Software command code:  18)
;
A094D:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        LD      (S1082),HL      ; current cursor - remember coordinates
        CALL    A0963           ; Calculate text memory address from coordinates in HL
        LD      (W1084),HL      ; Remember pointer to current position in text memory
        CALL    A0977           ; Calculate graphic memory address from cursor coordinates
        LD      (W1086),HL      ; Remember text cursor position in Graphic screen
        RET
;
;
;   Calculate text cursor position in pseudo image memory from current cursor coordinate
;
A0960:  LD      HL,(S1082)      ; Get current cursor coordinates
;
;
;   Convert text cursor position in pseudo image memory from coordinates in HL
;
A0963:  PUSH    DE              ;!  Register - save values
        PUSH    AF              ;!
        LD      D,S2000/256     ; High - byte starting address of text memory
        LD      E,L             ; Specify X coordinate as low byte
        LD      A,H             ; Y - get coordinate
        ADD     A,A             ;!  times 2
        ADD     A,A             ;!       4
        ADD     A,H             ;!       5
        LD      L,A             ; Y - Remember the coordinate times five
        LD      H,0             ; High - byte to zero
        ADD     HL,HL           ;!  times 10
        ADD     HL,HL           ;!      20
        ADD     HL,HL           ;!      40
A0972:  NOP                     ; or ADD HL,HL for times 80 (80 characters/line)
        ADD     HL,DE           ; Add start address and X - offset
        POP     AF              ;!  saved registers - get values
        POP     DE              ;!
        RET
;
;
;   Graphic - Calculate memory address from current cursor coordinate
;
A0977:  LD      HL,(S1082)      ; Get current cursor coordinates
;
;
;   Graphic - Calculate memory address from coordinates in HL
;
A097A:  PUSH    DE              ;!Register - save values
        PUSH    AF              ;!
        LD      D,H             ; Y - coordinate
        LD      E,0             ; in DE is now Y - coordinate times 256
        LD      A,L             ; Note X coordinate
        LD      L,H             ; Y - coordinate
        LD      H,E             ; High - byte to zero
        ADD     HL,HL           ;! Y - coordinate times 2
        ADD     HL,HL           ;!                times 4
        ADD     HL,HL           ;!                times 8
        ADD     HL,HL           ;!                times 16
        ADD     HL,HL           ;!                times 32
        ADD     HL,HL           ;!                times 64
        ADD     HL,DE           ;!                times 320
A0989:  NOP                     ; or ADD HL,HL if in 640 x 200 mode
        CALL    A0158           ; Add the value in the Accu to the HL register
        SET     7,H             ; the graphic - image memory starts at 08000H
        POP     AF              ;! saved registers - retrieve values
        POP     DE              ;!
        RET
;
;
;   Set the cursor to the upper left corner of the scroll area
;   (control character 'Cursor HOME')
;
A0992:  LD      L,0             ; X - coordinate at zero (left edge)
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        LD      H,A             ; and specify as the Y coordinate
        JP      A09F6           ; Remember coordinates in HL as current cursor coordinates
;
;
;   Print newline on screen if cursor is not at beginning of line
;
;   (Software command code:  2)
;   
A099B:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        LD      HL,(S1082)      ; Get current cursor coordinates
        LD      A,L             ; X - Get cursor coordinate
        OR      A               ; equal to zero (left margin) ?
        JR      NZ,A09AB        ; no --> output line feed on screen
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      A,(HL)          ; Get cursor line concatenation flag
        OR      A               ; line concatenated ?
        RET     Z               ; no --> cursor is at the beginning of the line
;
;
;   Output newline to screen (Software command code: 1)
;
A09AB:  LD      A,CR            ; Specify newline character
        JP      A0E61           ; Display accu on screen (execution of control characters)
;
;
;   Perform a carriage return (line feed).
;
A09B0:  XOR     A               ;! Convert 'uppercase flag' to
        LD      (D0DAA + 1),A   ;! Reset text output routine
        LD      HL,(S1082)      ; Get current cursor coordinates
        PUSH    HL              ; and remember
        INC     H               ; Y - coordinate cursor plus one
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        LD      D,A             ; and remember
A09C0:  LD      A,(HL)          ; Get concatenation flag
        OR      A               ; line concatenated ?
        JR      Z,A09CA         ; no
        INC     HL              ; Pointer to concatenation flags on next line
        INC     E               ; Y - coordinate plus one
        LD      A,D             ; Y - Get maximum coordinate
        CP      E               ; compare with Y - coordinate
        JR      NC,A09C0        ; still OK --> find the beginning of the next line
A09CA:  DEC     E               ; Y - Coordinate of the end of the logical line
        POP     HL              ; old cursors - get coordinates
        LD      H,E             ; specify a new Y coordinate
        JR      A09DE           ; Y - Coordinate at beginning of line and remember
;
;
;   Cursor - control character cursor down
;
A09CF:  LD      HL,(S1082)      ; Get current cursor coordinates
        JR      A09E0           ; Y - coordinate plus one
;
;
;   Cursor - control character cursor right
;
A09D4:  LD      HL,(S1082)      ; Get current cursor coordinates
        INC     L               ; X - coordinate plus one
        LD      A,(S136A)       ; Get maximum X coordinate
        CP      L               ; compare with current X - coordinate
        JR      NC,A09F6        ; X - coordinate is OK --> remember new coordinates
A09DE:  LD      L,0             ; Specify minimum X coordinate (left edge)
A09E0:  INC     H               ; Y - coordinate plus one
D09E1:  JR      A09EA           ; check if coordinate is in scroll area
;
;
;   Concatenate screen lines and possibly scroll screen
;
        PUSH    HL              ; save new coordinates
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        LD      (HL),1          ; concatenate row
        POP     HL              ; get saved new coordinates
A09EA:  LD      A,(S1370)       ; Y - Get Coordinate Maximum (Scroll - Range)
        CP      H               ; compare with new Y - coordinate
        JR      NC,A09F6        ; Y - coordinate is OK --> remember coordinates
        LD      H,A             ; Specify the maximum Y coordinate as the new Y coordinate
        PUSH    HL              ; remember new cursor coordinates
        CALL    A0848           ; scroll screen
        POP     HL              ; new cursor - get coordinates
A09F6:  JP      A094D           ; Set cursor to current coordinates in HL
;
;
;   Cursor - Cursor up control character
;
A09F9:  LD      HL,(S1082)      ; Get current cursor coordinates
        JR      A0A09           ; Y - coordinate minus one
;
;
;   Cursor - control character cursor left
;
A09FE:  LD      HL,(S1082)      ; Get current cursor coordinates
        LD      A,L             ; Get X coordinate
        OR      A               ; equal to zero (left margin) ?
        JR      NZ,A0A14        ; no --> X - coordinate minus one
        LD      A,(S136A)       ; Get maximum X coordinate
        LD      L,A             ; and specify as the X coordinate
A0A09:  LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        CP      H               ; compare with current Y - coordinate
        JR      C,A0A16         ; still OK --> Y - coordinate minus one
        LD      A,(S136F)       ; Y - Get Minimum Coordinate (Scroll - Area)
        LD      H,A             ; and specify as the new Y coordinate
        DEFB    LD_A            ; LD A,n (Z-80 command) --> DEC L is skipped
A0A14:  DEC     L               ; X - coordinate minus one
        DEFB    LD_A            ; LD A,n (Z-80 command) --> DEC H is skipped
A0A16:  DEC     H               ; Y - coordinate minus one
        JR      A09F6           ; Remember coordinates in HL as current cursor coordinates
;
;
;   Switch keyboard to alpha mode
;
A0A19:  XOR     A               ; Flag for 'Alpha mode'
        DEFB    LD_HL
;
;
;   Switch keyboard to lowercase mode
;
A0A1B:  LD      A,1             ; Flag for 'Lowercase mode'
        DEFB    LD_HL
;
;
;   Switch keyboard to graphics mode
;
A0A1E:  LD      A,2             ; Flag for 'Graphics mode'
        LD      (S108D),A       ; Current keyboard mode (0=Alpha / 1=Lowercase / 2=Graphics)
        RET
;
;
;   Move cursor to next tabulator position (TAB key)
;
A0A24:  LD      B,0             ; counter to zero
        LD      HL,(S1082)      ; Get current cursor coordinates
        INC     L               ; X - coordinate plus one
        LD      A,L             ; Get X coordinate
A0A2B:  INC     B               ; counter plus one
        SUB     10              ; subtract 10 (10s TAB)
        JR      NC,A0A2B        ; still OK --> continue to pull off
        XOR     A               ; Accu to zero
A0A31:  ADD     A,10            ;! Calculate next tab position
        DJNZ    A0A31           ;!
        LD      L,A             ; remember the new X coordinate
        LD      A,(S136A)       ; Get maximum X coordinate
        CP      L               ; compare with new X - coordinate
        RET     C               ; new X coordinate is greater than maximum --> forgotten
        PUSH    HL              ; remember new cursor coordinates
        LD      A,(S108F)       ; Get parallel output flag printer
        OR      A               ; Parallel output set?
        JR      Z,A0A54         ; no --> place cursor on coordinates
        LD      A,(S1082)       ; Get current X - coordinate cursor
        LD      H,A             ; Note the current X coordinate
        LD      A,L             ; Get new X coordinate
        SUB     H               ; Calculate coordinate difference
        JR      Z,A0A54         ; new coordinate equals old coordinate
        LD      B,A             ; Note the difference in coordinates as a counter
A0A4B:  PUSH    BC              ; Save coordinate difference
        LD      A,' '           ; Specify spaces
        CALL    A0EBF           ; Output characters in Accu to printer
        POP     BC              ; Get saved remaining number of spaces
        DJNZ    A0A4B           ; print more spaces
A0A54:  POP     HL              ; Get new cursor coordinate
        JP      A094D           ; Set cursor to current coordinates in HL
;
;
;   Move cursor to next tabulator position (emit spaces)
;
A0A58:  CALL    A0E5F           ; print a space on the screen
        LD      A,(S1082)       ; Get current X - coordinate cursor
A0A5E:  SUB     10              ; subtract 10 (10s TAB)
        JR      NC,A0A5E        ; still OK --> continue to pull off
        ADD     A,10            ; add 10 again
        RET     Z               ; stands on 10s - TAB
        JR      A0A58           ; Emit spaces and test again
;
;
;   Get line from keyboard and set pointer to actual input
;
A0A67:  PUSH    HL              ; Register - save value
        LD      HL,(S1082)      ; Get current cursor coordinates
        PUSH    HL              ; and save
        PUSH    DE              ; Pointer to input - save memory
        CALL    A0615           ; Provide pointer to concatenation flag by Y coordinate in H
        POP     DE              ; Pointer to start of input - fetch memory
        LD      (HL),0          ; Set current cursor line as start line
        POP     HL              ; saved cursors - get coordinates
        CALL    A0A84           ; Get line from keyboard to memory (DE).
        JR      C,A0A82         ; Break pressed --> no input
        LD      A,L             ; Get old X coordinate cursor
        OR      A               ; equals zero  ?
        JR      Z,A0A82         ; yes --> pointer is on input
        LD      H,0             ; High - byte offset to zero
        ADD     HL,DE           ; Compute pointer to input
        EX      DE,HL           ; Pointer to DE
        OR      A               ; reset carry flag (code 'no error')
A0A82:  POP     HL              ; rescued register - fetch value
        RET
;
;
;   Get line from keyboard to memory (DE) (Software command code: 12)
;
A0A84:  PUSH    BC              ;!Register - save values
        PUSH    HL              ;!
        PUSH    DE              ; Pointer to input - save memory
A0A87:  CALL    A0B21           ; fetch a character from keyboard with cursor blinking
        CP      CR              ; Entry complete ?
        JP      Z,A0ABB         ; yes --> provide current text screen line
        CP      ESC             ; BREAK ?
        JR      Z,A0AB4         ; yes --> cancel input
        PUSH    AF              ; remember entered character
        LD      A,(S108D)       ; Current keyboard mode (0=Alpha / 1=Small / 2=Graphic)
        CP      2               ; Graphic mode ?
        JR      NZ,A0AAF        ; no --> check for control characters
        POP     AF              ; get entered character
        CP      C_CLR + 1       ; end of cursor control character ?
        JR      NC,A0AB0        ; no cursor control key
        CP      C_DOWN          ; start cursor control character ?
        JR      C,A0AB0         ; no cursor control key
        LD      HL,(S0D30 + 1)  ; Get row value of keyboard column 9
        BIT     6,L             ; CTRL key pressed?
        JR      Z,A0AB0         ; no --> output characters in the Accu
        RST     _DOCMD          ; Software - Execute command
        DEFB    4               ; Output Code 4 Accu on screen (display control characters)
        JR      A0A87           ; Query and edit next key
;                                 
A0AAF:  POP     AF              ; get entered key
A0AB0:  RST     _DOCMD          ; Software - Execute command
        DEFB    3               ; Display Code 3 Accu on screen (execution of control characters)
        JR      A0A87           ; Query and edit next key
;
;
;   Keyboard input aborted with BREAK
;
A0AB4:  SCF                     ; Code 'Input aborted with BREAK'
A0AB5:  RST     _DOCMD          ; Software - Execute command
        DEFB    1               ; Code 1 Output line feed to screen
        POP     DE              ; Get pointer to memory with entered text
        POP     HL              ;! saved registers - get values
        POP     BC              ;!
        RET
;
;
;   Current text - screen line after input - fetch memory
;
A0ABB:  LD      HL,(S1082)      ; Get current cursor coordinates
        CALL    A05F9           ; Y coordinate start current line/next line.
        LD      A,E             ;! Calculate the number of connected screen lines
        SUB     D               ;!
        LD      E,A             ; Remember number of concatenated lines
        LD      H,D             ; Starting line number as Y - coordinate
        LD      L,0             ; X - coordinate at zero (left edge)
        CALL    A0963           ; Calculate text memory address from coordinates in HL
        LD      A,(W136B)       ; Get counter '40/80 characters per line'
        LD      D,A             ; Note the number of characters per line
        POP     BC              ; Get pointer to memory for row
        PUSH    BC              ; and remember again
        EXX                       
        PUSH    HL              ; Register - save value
        LD      HL,(S1364)      ; Length input - fetch memory
        EXX                       
A0AD6:  LD      A,(HL)          ; get a character from text-image memory
        INC     HL              ; Skip characters in text image memory
        LD      (BC),A          ; ASCII - remember characters in memory by line
        INC     BC              ; Pointer to next location in memory
        EXX                       
        DEC     L               ; Remaining number of characters in input memory minus one
        JR      Z,A0AEA         ; Input - memory full
        EXX                       
        DEC     D               ; Remaining number of characters in line minus one
        JR      NZ,A0AD6        ; Get more characters from line
        LD      A,(W136B)       ; Get counter '40/80 characters per line'
        LD      D,A             ; Note the number of characters in a line
        DEC     E               ; Remaining number of rows minus one
        JR      NZ,A0AD6        ; provide more lines of text-image memory
        EXX                       
A0AEA:  POP     HL              ; rescued register - fetch value
        EXX                       
        XOR     A               ; Code 'End of line' (NUL)
        LD      (BC),A          ; Enter behind provided text
        LD      L,C             ;! Pointer to end of provided text in
        LD      H,B             ;! Input - transfer memory to HL
        POP     DE              ; Pointer to start of input - fetch memory
        PUSH    DE              ; and remember again
        PUSH    HL              ; Pointer to end of text in input - remember memory
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; Calculate number of characters in input memory
        LD      B,L             ; Number of characters after B
        POP     HL              ; Get pointer to end of text in memory
        LD      A,' '           ; Specify spaces
        LD      D,A             ; also spaces
        JP      Z,A0AB5         ; Zero length --> print CR and get saved registers
        DEC     HL              ; Pointer to input - store to previous character
A0AFF:  LD      A,(HL)          ; get a character from input - memory
        OR      A               ; equals zero  ?
        JR      Z,A0B08         ; yes --> examine whether additional characters
        CP      D               ; character equals space ?
        JR      NZ,A0B0D        ; no --> replace NUL in the rest of the text with a space
        LD      (HL),NUL        ; Replace space at end of text
A0B08:  DEC     HL              ; Pointer to text in memory to previous character
        DJNZ    A0AFF           ; exchange more characters
        JR      A0B16           ; Reset carry flag and get saved registers
;                                 
A0B0D:  LD      A,(HL)          ; fetch a character from memory
        OR      A               ; equal to NUL ?
        JR      NZ,A0B13        ; no
        LD      (HL),' '        ; Exchange NUL for Space
A0B13:  DEC     HL              ; Pointer to memory on previous character
        DJNZ    A0B0D           ; exchange more characters
A0B16:  OR      A               ; reset carry flag (code 'no BREAK')
        JP      A0AB5           ; Output CR and retrieve saved register values
;
;
;   Keyboard query for status in Accu
;   (-1 --> keyboard query with debouncing)
;   ( 0 --> Query whether a key is pressed)
;   ( 1 --> get a character from keyboard with blinking cursor)
;
;   Software - Kommando  13)
;
A0B1A:  INC     A               ; State equal to -1 ?
        JR      Z,A0B8B         ; yes --> keyboard query with debouncing
        DEC     A               ; Status equal to zero?
        JP      Z,A0BA1         ; yes --> Query whether key is pressed
;
;
;   Fetch a character from keyboard with cursor blinking
;
A0B21:  CALL    A0BAB           ; check whether there are still characters from the function key
        CALL    A00C7           ; Save registers IX, HL, BC and DE
        CALL    A092B           ; Initiate keyboard and display cursor characters on screen
        EX      AF,AF           ;! Save value of register AF'
        PUSH    AF              ;!
        CALL    A0BC1           ; determine if keyboard status has changed
        LD      A,(S0D44)       ; Get counter for repeat
A0B32:  EX      AF,AF           ; Remember counter
A0B33:  LD      B,16            ; Wait time counter
A0B35:  CALL    A0945           ; Change cursor character for blinking
        CALL    A0BC1           ; determine if keyboard status has changed
        BIT     1,A             ; Button bruised?
        JR      NZ,A0B33        ; yes --> forgot and keep asking
        DJNZ    A0B35           ; keep waiting and asking
        BIT     0,A             ; button pressed at all?
        JR      Z,A0B51         ; yes --> query key
        BIT     2,A             ; Keyboard status changed?
        JR      NZ,A0B62        ; yes --> query key
        EX      AF,AF           ; Remainder Repeat - Get counter
        DEC     A               ; Counter minus one
        JR      NZ,A0B32        ; keep waiting
        LD      A,6             ; Default for repeat speed
        JR      A0B64           ; Memorize counter and query keyboard
;                                 
A0B51:  PUSH    HL              ;! Register - save values
        PUSH    DE              ;! 
        PUSH    BC              ;!
        LD      HL,S0D3A        ; Pointer to values ??of last row status
        LD      DE,S0D30        ; Pointers to values ??of current row states
        LD      BC,10           ; 10 columns to query
        LDIR                    ; save current row value
        POP     BC              ;! saved registers - retrieve values
        POP     DE              ;!
        POP     HL              ;!
A0B62:  LD      A,64            ; Default for delay before repeat
A0B64:  LD      (S0D44),A       ; note in the repeat counter
A0B67:  CALL    A0945           ; Change cursor character for blinking
        CALL    A0BF6           ; Query keyboard for pressed key
        OR      A               ; key pressed ?
        JR      Z,A0B7B         ; no --> forget all line statuses and query again
        LD      (S1365),A       ; Remember last key pressed
        LD      C,A             ; remember pressed key
        CALL    A093B           ; Enter original character at cursor position
        POP     AF              ;! retrieve saved AF' register value again
        EX      AF,AF           ;!
        LD      A,C             ; get pressed key
        RET
;
;
;   Forget all pressed keys and query keyboard again (with cursor blinking)
;
A0B7B:  PUSH    HL              ;!Register - save value
        PUSH    BC              ;!
        LD      B,10            ; 10 keyboard columns
        LD      HL,S0D30        ; Pointers to values of current row states
A0B82:  LD      (HL),11111111B  ;!  Clear current line status of all keys
        INC     HL              ;!
        DJNZ    A0B82           ;!
        POP     BC              ;!  saved registers - get values
        POP     HL              ;!
        JR      A0B67           ; Prompt keyboard again
;
;
;   Keyboard query with debouncing (without repeat)
;
A0B8B:  CALL    A0BAB           ; check whether there are still characters from the function key
        PUSH    HL              ; Register - save value
        CALL    A0BF6           ; Query keyboard for pressed key
        LD      HL,S1365        ; Pointer to value of last key pressed
        OR      A               ; key pressed ?
        JR      Z,A0B9E         ; no --> delete last key pressed
        CP      (HL)            ; same as the last key pressed?
        JR      NZ,A0B9E        ; no --> remember new key
        POP     HL              ; rescued register - fetch value
        XOR     A               ; Specify code 'no key pressed'
        RET
;
A0B9E:  LD      (HL),A          ; remember new key as last key pressed
        POP     HL              ; rescued register - fetch value
        RET
;
;
;   Query whether key is pressed; if so --> code of the pressed key in the Accu 
;
A0BA1:  CALL    A0BAB           ; check whether there are still characters from the function key
        CALL    A0BF6           ; Query keyboard for pressed key
        LD      (S1365),A       ; Remember key as last key pressed
        RET
;
;
;   If text of a function key is still available -->
;   Get characters and forget a CALL level
;
A0BAB:  PUSH    HL              ; Register - save value
        LD      HL,(S1352)      ; L = number of characters fetched H = length of text
        LD      A,L             ;! both counters the same?
        CP      H               ;!
        POP     HL              ; saved register - retrieve value again
        RET     Z               ; no more function key text available
        EX      (SP),HL         ; Save HL register again / discard return address
        INC     A               ; Counter 'number of characters fetched' plus one
        LD      (S1352),A       ; remember new counter
        LD      HL,S1353        ; Pointer to start of memory with function key text
        CALL    A0158           ; Add the value in the Accu to the HL register
        LD      A,(HL)          ; get a character keytext
        POP     HL              ; rescued register - fetch value
        RET
;
;
;   Query whether keyboard status has changed
;
A0BC1:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        LD      DE,S0D3A        ; Pointer to values ??of last row status
        LD      HL,S0D30        ; Pointers to values ??of current row states
        LD      BC,256 * 10 + 0 ; 10 = number of columns 0 = default for flags
        DI                      ; Disable interrupts
A0BCE:  LD      A,B             ; 'Remaining number of columns' counter
        ADD     A,0EFH          ; convert to column value for port A / 8255
        OUT     (KEYP_A),A      ; Output column number to port A / 8255
        CP      0F8H            ; Column with SHIFT/CTRL/BREAK ?
        IN      A,(KEYP_B)      ; Get line value from keyboard
        JR      NZ,A0BDB        ; normal column
        OR      01111111B       ; Forgotten keys except for BREAK
A0BDB:  CP      11111111B       ; key pressed ?
        JR      Z,A0BE1         ; no
        SET     0,C             ; Remember code 'key pressed'
A0BE1:  EX      DE,HL           ; Pointer to last value after HL
        CP      (HL)            ; to compare
        LD      (HL),A          ; remember new status
        EX      DE,HL           ; Pointer to current value after HL
        JR      Z,A0BE9         ; same status --> key not bounced
        SET     1,C             ; Set code 'key bruised'
A0BE9:  CPL                     ;! Key also pressed?
        AND     (HL)            ;!
        JR      Z,A0BEF         ; no
        SET     2,C             ; Set code 'keyboard state changed'
A0BEF:  INC     HL              ; Pointer to current column values ??plus one
        INC     DE              ; Pointer to last column values ??plus one
        DJNZ    A0BCE           ; query further columns
        LD      A,C             ; get status flag
A0BF4:  EI                      ; Enable interrupt
        RET
;
;
;   Query keyboard, return in Accu ASCII code
;   of the pressed key or 000H if no key is pressed
;
A0BF6:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        LD      HL,S0D30        ; Pointers to current column state values
        LD      DE,S0D3A        ; Pointer to values ??of last column status
        PUSH    HL              ;! save pointer
        PUSH    DE              ;!
        LD      BC,10           ; Number of keyboard columns
        LDIR                    ; Save current key values
        POP     HL              ;! retrieve saved hands
        POP     DE              ;!
        LD      BC,256*10+0F9H  ; 10 = number of columns 0F9H = specification for column number
        DI                      ; Disable interrupts
        LD      A,C             ; Get column number
        OUT     (KEYP_A),A      ; and output to keyboard
        NOP                     ; waiting
        IN      A,(KEYP_B)      ; Get line value from keyboard
        LD      (DE),A          ; and remember
A0C13:  LD      A,C             ; Get column number
        OUT     (KEYP_A),A      ; and output to keyboard
        CP      0F8H            ; same column with SHIFT/CTRL/BREAK ?
        IN      A,(KEYP_B)      ; Get line value from keyboard
        LD      (DE),A          ; and remember
        JR      Z,A0C3E         ; cancel debouncing with SHIFT/CTRL/BREAK
        CPL                     ;! Mask keyboard change
        AND     (HL)            ;!
A0C1F:  LD      (HL),A          ; and remember
A0C20:  INC     DE              ; Pointer to current values ??plus one
        INC     HL              ; Pointer to changes plus one
        DEC     C               ; Column number minus one
        DJNZ    A0C13           ; query other columns
        EI                      ; Enable interrupt
        LD      BC,256 * 10 + 0 ; 10 = number of columns 0 = counter
A0C29:  DEC     HL              ; Pointer to change value
        LD      A,(HL)          ; fetch value
        OR      A               ; The change  ?
        JR      NZ,A0C68        ; yes --> button lock
        INC     C               ; counter plus one
        DJNZ    A0C29           ; Query other columns for key changes
        LD      B,10            ; 10 columns
A0C33:  DEC     DE              ; Pointer to row values
        LD      A,(DE)          ; get a row value
        CP      11111111B       ; key pressed ?
        JR      NZ,A0C41        ; yes --> determine which key
A0C39:  DJNZ    A0C33           ; test other column values
A0C3B:  XOR     A               ; Set code 'no key pressed'
        JR      A0BF4           ; Enable interrupt
;                                 
A0C3E:  XOR     A               ; Cancel debouncing (column 9)
        JR      A0C1F           ; Return to routine
;                                 
A0C41:  LD      A,B             ; get counter
        CP      2               ; Column with SHIFT/CRTL/BREAK ?
        JR      NZ,A0C4F        ; no
        LD      A,(DE)          ; get row value
        AND     10000001B       ; Mask SHIFT and BREAK
        JR      NZ,A0C39        ; not SHFIT BREAK --> investigate further
        LD      A,ESC           ; Code 'BREAK'
        JR      A0BF4           ; Enable interrupt
;                                 
A0C4F:  CP      1               ; Column 1 (function keys) ?
        JR      Z,A0C3B         ; yes --> code 'no key pressed' (F-keys not repeat)
        LD      A,(S0D45)       ; Get column number changed value
        CP      B               ; Column numbers the same?
        JR      NZ,A0C39        ; no --> investigate further
        LD      A,(DE)          ; get row value
        PUSH    DE              ; Remember pointer
        LD      D,A             ; Remember row value
        LD      A,(B0D46)       ; Get mask for changed value
        AND     D               ; Mask row value
        POP     DE              ; get rescued pointer
        JR      NZ,A0C39        ; Button just released --> investigate further
        LD      A,(S1365)       ; Get last key pressed
        JR      A0BF4           ; Enable interrupt
;                                 
A0C68:  PUSH    AF              ; Register - save value
        LD      A,B             ; Get column number
        LD      (S0D45),A       ; note changed value as column number
        LD      A,(HL)          ; Get mask for changed value
        LD      (B0D46),A       ; remember as mask for changed value
        POP     AF              ; rescued register - fetch value
        DEC     B               ; Counter minus one
        JR      NZ,A0CAB        ; normal row of keys --> evaluate
;
;
;   Function key pressed
;
        CALL    A0D18           ; Convert the bit set in the Accu to a bit number
        LD      A,(S0D30 + 1)   ; Get row value of keyboard column 9
        BIT     6,A             ; CTRL key pressed?
        JR      Z,A0C3B         ; yes --> specify code 'no key pressed'
        BIT     0,A             ; SHIFT key pressed?
        LD      A,B             ; Get key number
        JR      NZ,A0C86        ; SHIFT key not pressed
        ADD     A,5             ; SHIFT - function keys are from 5 - 9
A0C86:  CP      10              ; function key ?
        JR      NC,A0C3B        ; no --> specify code 'no key pressed'
        LD      L,A             ; button number
        LD      H,0             ; High - byte value to zero
        ADD     HL,HL           ;! Key number times 2 (16 characters per function key)
        ADD     HL,HL           ;!              times 4
        ADD     HL,HL           ;!              times 8
        ADD     HL,HL           ;!              times 16
        LD      BC,B12B2        ; Pointer to start of function key texts
        ADD     HL,BC           ; Calculate pointer to correct function key text
        LD      A,(HL)          ; Get length of function key text
        OR      A               ; zero length?
        JR      Z,A0C3B         ; yes --> specify code 'no key pressed'
        LD      DE,S1352        ; Pointer to memory for current key text
        LD      A,1             ; Code 'first character fetched'
        LD      (DE),A          ; enter
        INC     DE              ; Fix pointer for text
        LD      BC,16           ; maximum length key text
        LDIR                    ; Transfer function key text to clipboard
        LD      A,(S1354)       ; get first text character
        JP      A0BF4           ; Enable interrupt
;
;
;   Provide ASCII code of pressed key from line number and column value
;
A0CAB:  CALL    A0D18           ; Convert the bit set in the Accu to a bit number
        LD      A,C             ; Get column number
        ADD     A,A             ;! Column number times 2 (8 keys per column)
        ADD     A,A             ;!               times 4
        ADD     A,A             ;!               times 8
        ADD     A,B             ; Add line number
        LD      L,A             ; Note the offset on the keyboard matrix (key number).
        LD      H,0             ; Set high - byte offset to zero
        LD      A,(S0D30 + 1)   ; Get row value of keyboard column 9
        BIT     6,A             ; CTRL key pressed?
        LD      BC,W0D47        ; Set pointer to table for normal mode
        JR      Z,A0CEF         ; CTRL plus other key
        PUSH    AF              ; Save row value column 9
        LD      A,(S108D)       ; Current keyboard mode (0=Alpha / 1=Small / 2=Graphic)
        CP      1               ; lowercase cursor ?
        JR      NZ,A0CCC        ; no
        POP     AF              ; Get row value of column 9
        XOR     00000001B       ; Invert the state of the SHIFT key
        PUSH    AF              ; and remember again
A0CCC:  POP     AF              ; Get row value of column 9
        BIT     0,A             ; SHIFT key pressed?
        JR      NZ,A0CD4        ; no
        LD      BC,W0D59        ; Pointer to keyboard table for SHIFT mode
A0CD4:  LD      A,(S108D)       ; Current keyboard mode (0=Alpha / 1=Small / 2=Graphic)
        CP      2               ; Graphic mode ?
        JR      NZ,A0CE8        ; no
        LD      BC,W0D6B        ; Specify keyboard table for SHIFT graphic mode
        LD      A,(S0D30 + 1)   ; Get row value of keyboard column 9
        BIT     0,A             ; SHIFT key pressed?
        JR      Z,A0CE8         ; Yes
        LD      BC,W0D7D        ; Pointer to keyboard table for graphic mode
A0CE8:  CALL    A3C3E           ; Provide key code by key number and table
        LD      A,C             ; Get code of pressed key
        JP      A0BF4           ; Enable interrupt
;
;
;   Decode pressed CTRL key
;
A0CEF:  CALL    A3C3E           ; Get key code by key number
        LD      A,C             ; Get code of pressed key
        CP      ' '             ; control character ?
        JP      C,A0BF4         ; yes --> enable interrupt
        LD      HL,M0D8F        ; Pointer to table with additional CTRL characters
        LD      B,5             ; 5 characters in table
A0CFD:  CP      (HL)            ; compare a character
        JR      Z,A0D12         ; sign is allowed
        INC     HL              ; Pointer to table to next character
        DJNZ    A0CFD           ; further compare values
        CP      '@'               
        JP      C,A0C3B         ; less than letter --> no key pressed
        CP      'Z' + 1           
        JP      NC,A0C3B        ; greater than letter --> no key pressed
        SUB     '@'             ; Convert letters to CTRL - value
        JP      A0BF4           ; Enable interrupt
;                                 
A0D12:  LD      A,' '           ;! CTRL - Calculate key code
        SUB     B               ;!
        JP      A0BF4           ; Enable interrupt
;
;
;   Convert the bit set in the Accu to a bit number
;
A0D18:  LD      B,8             ; default for value
A0D1A:  RRCA                    ; shift one bit after carry
        JR      C,A0D20         ; set bit found
        DJNZ    A0D1A           ; keep pushing
        RET
;
A0D20:  DEC     B               ; correct value
        RET
;
;
;   Query whether SHIFT - BREAK is pressed
;   if so --> zero flag set on return.
;   If only BREAK is pressed, the program will be stopped until this button is released. 
;
A0D22:  LD      A,0E8H          ; Number of the column with SHIFT/CTRL/BREAK
        OUT     (KEYP_A),A      ; Output column number to keyboard
        NOP                     ; waiting
        IN      A,(KEYP_B)      ; Get line value from keyboard
        AND     10000001B       ; Mask SHIFT and BREAK
        RET     Z               ; both buttons pressed
        RLCA                    ; BREAK - slide key to carry
        RET     C               ; BREAK not pressed
        JR      A0D22           ; wait until the button is released
;
;
;   Storage area for keyboard query routine
;
S0D30:  DEFS    10              ; Values of current row status
;
S0D3A:  DEFS    10              ; Values of last row status
;
S0D44:  DEFS    1               ; Counter for repeat
;
S0D45:  DEFS    1               ; Column number changed value
;
B0D46:  DEFB    1               ; Mask for changed value
;
;
;   Keyboard decode table for Normal mode
;
W0D47:  DEFW    KTBL                    ; Pointer to table in ROM monitor 1Z-013B
;
        DEFB    090H,017H,0FCH,019H     ; Column 1 buttons
        DEFB    009H,03BH,03AH,00DH
;
        DEFB    018H,010H,012H,011H     ; Column 8 buttons
        DEFB    013H,014H,03FH,02FH
;
;
;   Keyboard decode table for SHIFT mode
;
W0D59:  DEFW    KTBLS                   ; Pointer to table in ROM monitor 1Z-013 B
;
        DEFB    090H,017H,0FBH,005H     ; Column 1 buttons
        DEFB    009H,02BH,02AH,00DH
;
        DEFB    016H,015H,012H,011H     ; Column 8 buttons
        DEFB    013H,014H,0C6H,05FH
;
;
;   Keyboard decode table for SHIFT - Graphic - mode
;
W0D6B:  DEFW    KTBLG                   ; Pointer to table in ROM monitor 1Z-013 B
;
        DEFB    090H,017H,068H,005H     ; Column 1 buttons
        DEFB    009H,084H,0E9H,00DH
;
        DEFB    016H,015H,012H,011H     ; Column 8 buttons
        DEFB    013H,014H,08FH,08BH
;
;
;   Keyboard decode table for graphics mode
;
W0D7D:  DEFW    KTBLSG                  ; Pointer to table in ROM monitor 1Z-013 B
;
        DEFB    090H,017H,06CH,019H     ; Column 1 buttons
        DEFB    009H,0FEH,089H,00DH
;
        DEFB    016H,015H,012H,011H     ; Column 8 buttons
        DEFB    013H,014H,08AH,07BH
;
;
;   Table for implementing the additionally defined CTRL keys
;
M0D8F:  DEFM    "[\\]^/"
;
;
;   Output text in (DE);
;   Convert uppercase to lowercase according to control characters
;
;   (Software command code:  5)
;
A0D94:  CALL    A00C7           ; Save registers IX, HL, BC and DE
A0D97:  LD      A,(DE)          ; Get a character of the text to be output
        INC     DE              ; Pointer to text on next character
        OR      A               ; Text character equal to NUL (end of text) ?
        RET     Z               ; yes --> done
        LD      C,A             ; note the character to be output
        CP      _SML            ; Code 'switch to lowercase' ?
        JR      Z,A0DBE         ; yes --> Switch to lower case
        CP      _CAP            ; Code 'switch to uppercase' ?
        JR      Z,A0DBD         ; yes --> Switch to capital letters
        SUB     'A'             ;!  Character to be output same as capital letter ?
        CP      26              ;!
        JR      NC,A0DB6        ; no --> output characters
D0DAA:  LD      A,0             ; Get flag 'convert uppercase'
        OR      A               ; set  ?
        JR      Z,A0DB6         ; no --> output characters
        LD      HL,B0DC3 + -65  ; Pointer to lowercase table
        LD      B,0             ; High - byte offset to zero
        ADD     HL,BC           ; Calculate pointer to table character
        LD      C,(HL)          ; Get lower case letters from table
A0DB6:  LD      A,C             ; get the character to be output
        RST     _DOCMD          ; Software - Execute command
        DEFB    3               ; Display Code 3 Accu on screen (execution of control characters)
        CP      CR              ; newline character output ?
        JR      NZ,A0D97        ; no --> output more characters
A0DBD:  XOR     A               ; Code 'do not convert uppercase'
A0DBE:  LD      (D0DAA + 1),A   ; Set flag 'convert to upper case'
        JR      A0D97           ; output more characters

;
;
;   Table with lowercase letters in SHARP - Code
;
B0DC3:  DEFB    0A1H            ; a
        DEFB    09AH            ; b
        DEFB    09FH            ; c
        DEFB    09CH            ; d
        DEFB    092H            ; e
        DEFB    0AAH            ; f
        DEFB    097H            ; g
        DEFB    098H            ; h
        DEFB    0A6H            ; i
        DEFB    0AFH            ; j
        DEFB    0A9H            ; k
        DEFB    0B8H            ; l
        DEFB    0B3H            ; m
        DEFB    0B0H            ; n
        DEFB    0B7H            ; o
        DEFB    09EH            ; p
        DEFB    0A0H            ; q
        DEFB    09DH            ; r
        DEFB    0A4H            ; s
        DEFB    096H            ; t
        DEFB    0A5H            ; u
        DEFB    0ABH            ; v
        DEFB    0A3H            ; w
        DEFB    09BH            ; x
        DEFB    0BDH            ; y
        DEFB    0A2H            ; z
;
;
;   Devices - Table for Display (CRT:)
;
W0DDD:  DEFW    W0DF6           ; Pointer to Next Devices - Table (KB:)
        DEFM    "CRT"           ; Device - name
		DEFB    NUL               
        DEFB    10001010B       ; Device - Type - Byte
        DEFB    00000000B       ; Devices - numbers - bytes
        DEFB    0                 
        DEFW    A453A           ; Initialize device
        DEFW    A00B2           ; RET (open to read)
        DEFW    A00B2           ; RET (open for writing)
        DEFW    A00B2           ; RET (test device readiness)
        DEFW    A00B2           ; RET
        DEFW    A0E0F           ; get a row from keyboard
        DEFW    A0E17           ; Display characters in Accu on screen
        DEFW    A0E26           ; Provide current X coordinate
;
;
;   Devices - Table for Keyboard (KB:)
;
W0DF6:  DEFW    W1479           ; Pointer to next devices table (LPT:)
        DEFM    "KB"            ; Device - name
		DEFB    NUL,NUL           
        DEFB    10000001B       ; Device - Type - Byte
        DEFB    00000000B       ; Devices - numbers - bytes
        DEFB    0                 
        DEFW    A00B2           ; RET (initialize device)
        DEFW    A00B2           ; RET (Open Device to Read)
        DEFW    A00B2           ; RET (open device for writing)
        DEFW    A00B2           ; RET
        DEFW    A00B2           ; RET
        DEFW    A0E0F           ; get a row from keyboard
        DEFW    A00B2           ; RET
        DEFW    A00B2           ; RET
;
;
;   Get line from keyboard and provide line length
;
A0E0F:  RST     _DOCMD          ; Software - Execute command
        DEFB    12              ; Code 12, line from keyboard to memory (DE).
        LD      A,080H          ; Code for 'BREAK'
        RET     C               ; Entry aborted with BREAK
        RST     _DOCMD          ; Software - Execute command
        DEFB    23              ; Code 23, Count length of text (DE).
        RET
;
;
;   Output characters in Accu
;
A0E17:  EX      AF,AF           ; save character to be printed
        LD      HL,A0E61        ; Output address Accu on screen (execution of control characters)
        LD      A,(S1090)       ; Get flag 'execute control characters'
        OR      A               ; Execute control characters ?
        JR      Z,A0E24         ; Yes
        LD      HL,A0EA2        ; Output address Accu on screen (output of control characters)
A0E24:  EX      AF,AF           ; get the character to be output
        JP      (HL)            ; Output characters in Accu
;
;
;   Provide current X coordinate screen
;
A0E26:  LD      A,(S1082)       ; Get current X - coordinate cursor
        RET
;
;
;   Output line feed to screen or printer
;
;   (Software command code:  8)
;
A0E2A:  LD      A,CR            ; Code for 'Line feed'
;
;
;   Output characters in the Accu to the screen or printer (execution of control characters)
;
;   (Software command code:  9)
;
A0E2C:  PUSH    AF              ; save character to be printed
        LD      A,(S1091)       ; Monitor - Printer - Get status
        OR      A               ; output on screen?
        JR      NZ,A0E36        ; no --> Output characters to printer
        POP     AF              ; get the character to be printed
        JR      A0E61           ; Display accu on screen (execution of control characters)
;                                 
A0E36:  POP     AF              ; get the character to be output
        JP      A14B9           ; Output characters in Accu to printer
;
;
;   Output characters in the Accu to the screen or printer (display control characters)
;
;   (Software command code:  10)
;
A0E3A:  PUSH    AF              ; save character to be printed
        LD      A,(S1091)       ; Monitor - Printer - Get status
        OR      A               ; output on screen?
        JR      NZ,A0E44        ; no --> Output characters to printer
        POP     AF              ; get the character to be output
        JR      A0EA2           ; Display accu on screen (display control characters)
;                                 
A0E44:  POP     AF              ; get the character to be output
        JP      A14E0           ; Output Accu to printer (display control characters)
;
;
;   Output text (DE) on screen or printer
;
;   (Software command code:  11)
;
A0E48:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        LD      HL,A0E2C        ; Address 'Output Accu on screen or printer'
        JR      A0E56           ; Output text (DE).
;
;
;   Output text (DE) with execution of control characters on screen
;
A0E50:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        LD      HL,A0E61        ; Display address 'Accu on screen (execution of control characters)
A0E56:  LD      A,(DE)          ; get a character text
        OR      A               ; equal to NUL (end of text character) ?
        RET     Z               ; yes --> done
        CALL    A00A7           ; JP (HL) (call output routine (HL))
        INC     DE              ; Pointer to text to be output to next character
        JR      A0E56           ; output additional characters of text
;
;
;   print a space on the screen
;
A0E5F:  LD      A,' '           ; Specify space character
;
;
;  Display accu on screen (execution of control characters)
;
;   (Software command code:  3)
;
A0E61:  CALL    A00BA           ; Save registers IX, HL, BC, DE and AF
A0E64:  LD      C,A             ; note the character to be output
        LD      A,(S108F)       ; Get parallel output flag printer
        OR      A               ; set  ?
        JR      Z,A0E99         ; no --> no parallel output
        LD      A,C             ; get the character to be output
        CP      ' '             ; control character ?
        JR      NC,A0E96        ; no --> output characters
        LD      DE,(S1082)      ; Get current cursor coordinates
        LD      HL,(S1369)      ; X - Get minimum/maximum coordinate
        CP      C_LEFT          ; 'cursor left' ?
        JR      Z,A0E83         ; yes --> compare to minimal coordinates
        CP      C_UP            ; 'cursor up' ?
        JR      NZ,A0E88        ; no --> execute characters
        LD      HL,(S136F)      ; Y - Get minimum/maximum coordinate
        LD      E,D             ; current Y coordinate to E
A0E83:  LD      A,L             ; Minimal - get coordinate
        CP      E               ; compare with current coordinate
        JP      NC,A003E        ; Characters not allowed --> output reference tone
A0E88:  LD      HL,B0ED9        ; Pointer to conversion table for control characters
        LD      B,0             ; High - byte offset to zero (low byte equals character)
        ADD     HL,BC           ; Calculate pointer to character in table
        LD      A,(HL)          ; Get control characters for printer from table
        INC     A               ; Swallow characters for printer?
        JR      Z,A0E99         ; Yes
        DEC     A               ; Characters not allowed on printer ?
        JP      Z,A003E         ; yes --> output reference tone
A0E96:  CALL    A0EBF           ; Output characters in Accu to printer
A0E99:  LD      A,C             ; get the character to be output
        CP      ' '             ; control character ?
        JP      C,A009B         ; yes --> Call control character routine
        JP      A05AD           ; Display characters in Accu on screen
;
;
;   Display accu on screen (display control characters)
;
;   (Software command code:  4)
;
A0EA2:  CALL    A00BA           ; Save registers IX, HL, BC, DE and AF
        LD      C,A             ; note the character to be output
        CP      CR              ; Carriage return?
        JR      Z,A0E64         ; yes --> perform line feed
        CALL    A05AD           ; Display characters in Accu on screen
        LD      A,(S108F)       ; Get parallel output flag printer
        OR      A               ; Parallel output set?
        RET     Z               ; no --> done
        LD      A,C             ; get output character
        CP      C_DOWN          ; start cursor control character ?
        JR      C,A0ED4         ; no --> Output characters as dots on printer
        CP      C_CLR + 1       ; end cursor control character ?
        JR      C,A0ED6         ; Cursor character --> output to printer
        CP      ' '             ; control character ?
        JR      C,A0ED4         ; yes --> output point to printer
A0EBF:  CP      '`'
        JR      C,A0ED6         ; Output correct character to printer
        CP      070H
        JR      C,A0ED4         ; Output point to printer
        CP      0C1H
        JR      C,A0ED6         ; Output correct character to printer
        CALL    A011B           ; Compare Accu with bytes specified after CALL
        DEFB    3               ; compare three characters
        DEFB    0D7H            ;!  characters familiar to printers
        DEFB    0CFH            ;!
        DEFB    0FFH            ;!
        JR      Z,A0ED6         ; known character --> output to printer
A0ED4:  LD      A,'.'           ; Dot for unknown character
A0ED6:  JP      A14F0           ; Output characters in Accu to printer

;
;
;   Table for converting control characters for output to printer
;
B0ED9:  DEFB    0               ; CTRL @   (characters not allowed) 
        DEFB    0               ; CTRL A   (characters not allowed) 
        DEFB    0               ; CTRL B   (characters not allowed) 
        DEFB    0               ; CTRL C   (characters not allowed) 
        DEFB    -1              ; CTRL D   (do not output characters) 
        DEFB    -1              ; CTRL E   (do not output characters) 
        DEFB    -1              ; CTRL F   (do not output characters) 
        DEFB    01DH            ; CTRL G   Code for 'Switch to next character color'
        DEFB    0               ; CTRL H   (characters not allowed) 
        DEFB    -1              ; CTRL I   (do not output characters) 
        DEFB    0               ; CTRL J   (characters not allowed) 
        DEFB    0               ; CTRL K   (characters not allowed) 
        DEFB    0               ; CTRL L   (characters not allowed) 
        DEFB    CR              ; CTRL M   Code for 'carriage return '
        DEFB    0               ; CTRL N   (characters not allowed) 
        DEFB    0               ; CTRL O   (characters not allowed) 
        DEFB    0               ; CTRL P   (characters not allowed) 
        DEFB    LF              ; CTRL Q   Code for 'newline'
        DEFB    003H            ; CTRL R   Code for 'new line'
        DEFB    ' '             ; CTRL S   Cursor right as space
        DEFB    00EH            ; CTRL T   Code for 'regression'
        DEFB    0               ; CTRL U   (characters not allowed) 
        DEFB    0               ; CTRL V   (characters not allowed) 
        DEFB    -1              ; CTRL W   (do not output characters) 
        DEFB    0               ; CTRL X   (characters not allowed) 
        DEFB    -1              ; CTRL Y   (do not output characters) 
        DEFB    -1              ; CTRL Z   (do not output characters) 
        DEFB    CR              ; CTRL [   Code for 'carriage return'
        DEFB    -1              ; CTRL \   (do not output characters) 
        DEFB    0               ; CTRL ]   (characters not allowed) 
        DEFB    0               ; CTRL ^   (characters not allowed) 
        DEFB    0               ; CTRL /   (characters not allowed) 
;
;
;   Bootstart  Monitor / Basic
;
A0EF9:  DI                      ; Disable interrupts
        XOR     A               ; Code for '320 x 200 pixels / 4 colors'
        OUT     (CRTCDM),A      ; to 'Display-Mode-Register' of the screen controllerben
        LD      (S108F),A       ; Reset printer parallel output flag
        LD      (S1091),A       ; Monitor - Printer - Reset status
        LD      SP,0            ; Set stack pointer to RAM - end
        IM      2               ; Specify interrupt mode
        LD      A,00000100B     ; Code for 'Disable Timer - Interrupt'
        OUT     (KEYP_F),A      ; output to control module 8255
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
        OUT     (_E0RAM),A      ; Switch to RAM from 0E000H to 0FFFFH
        CALL    A0441           ; Initialize palette registers for basic colors
        LD      A,A0FFE/256     ; High - Byte Pointer to Interrupt - Vector
        LD      I,A             ; in the interrupt register
        LD      A,A0FFE%256     ; Low - Byte Pointer to Interrupt - Vector
        OUT     (PIOB_C),A      ; output to Z-80 PIO channel B
        LD      A,00001111B     ; Code for 'Mode 0 - Select'
        OUT     (PIOB_C),A      ; output to Z-80 PIO channel B
        PUSH    BC              ; Load - save code
        CALL    A0F4E           ; Query whether graphic extension is installed
        CALL    A44B9           ; Muisc - initialize routines
        CALL    A3F58           ; Determine if RAM card is initialized
        POP     BC              ; retrieve the saved loading code
B0F2A:  DEFB    LD_HL           ; Skip autostart skip sequence
        JR      A0F4B           ; Skip autostart sequence
;
;
;   Loading - use current device 
;
        XOR     A               ; Accu auf Null  (Code 'NOP')
        LD      (B0F2A),A       ; Routine imstelle, um Kaltstart zu √ºberspringen
        LD      D,A             ;! Uhrzeit auf 00.00.00
        LD      E,A             ;!
        RST     _DOCMD          ; Software - Execute command
        DEFB    38              ; cmd 38 - set time
        LD      DE,W3AD7        ; Pointer to pseudo table 'CMT:'
        LD      A,B             ; Get loading code
        OR      A               ; no loading code given?
        JR      Z,A0F48         ; yes --> save the cassette as the current device
        DEC     A               ; Basic interpreter loaded from cassette?
        JR      Z,A0F48         ; yes --> note the cassette as the current device
        LD      DE,W37C2        ; Pointer to device table for device 'FD:'
        DEC     A               ; Basic interpreter loaded from disk?
        JR      Z,A0F48         ; yes --> remember diskette as current device
        LD      DE,W3ADA        ; Pointer to pseudo table 'QD:'
A0F48:  LD      A,C             ; Devices - get number
        RST     _DOCMD          ; Software - Execute command
        DEFB    58              ; cmd 58-  Remember pointer to device table/number for DEFAULT
A0F4B:  JP      A00DA           ; Cold Start Monitor - Basic
;
;
;   Query whether graphic extension is installed
;
A0F4E:  DI                      ; Disable interrupts
        XOR     A               ; Code for 'small graphic - resolution'
        OUT     (CRTCDM),A      ; to the 'Display-Mode-Register' of the graphic controller
        LD      A,00010100B     ; Code for 'Screen B/Level III'
        OUT     (CRTCRF),A      ; to the 'Read format register' of the graphic controller
        LD      A,10010100B     ; Code for 'Replace/Screen B/Level III'
        OUT     (CRTCWF),A      ; to the 'Write Format Register' of the graphic controller
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 07FFFH
        LD      HL,09FFFH       ; Pointer to last byte in graphic memory
        LD      A,(HL)          ; get old value
        LD      C,A             ; and remember
        CPL                     ; Reverse bit pattern
        LD      (HL),A          ; re-enter as the new value in the graphic memory
        CP      (HL)            ; check if value was saved
        LD      (HL),C          ; enter old value again
        LD      A,0             ; Specify code for 'additional graphic not available'
        JR      NZ,A0F6C        ; Additional - Graphic not available
        INC     A               ; Set code for 'additional graphic available'
A0F6C:  LD      (S1099),A       ; Note flag 'additional graphic RAM available' (1=yes)
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Release interrupt again
        LD      A,1             ; Code for '320 x 200 pixels / 4 colors'
        CALL    A03BE           ; Screen - set operating mode
        XOR     A               ; Accu to zero
        LD      (S108C),A       ; Clear flag 'original/cursor character' (0=original)
        LD      (S108D),A       ; Current keyboard mode (0=Alpha / 1=Small / 2=Graphic)
        RET
;
;
;   Devices - Table for USR Routine
;
W0F7F:  DEFW    0               ; Pointer to next devices table (non-existent)
        DEFM    "USR"           ; Device - name
		DEFB    NUL
        DEFB    10011111B       ; Device - Type - Byte
        DEFB    00000000B       ; Devices - numbers - bytes
        DEFB    0
        DEFW    A00B2           ; RET (initialize device)
        DEFW    A0F98           ; Open file on device for reading
        DEFW    A0F98           ; Open file on devices for writing
        DEFW    A00B2           ; RET
        DEFW    A00B2           ; RET
        DEFW    A0FA7           ; deploy a line of device
        DEFW    A0FA7           ; Output characters in the Accu to the device
        DEFW    A00B2           ; RET
;
;
;   Provide start address of USR routine (open device for reading/writing)
;
A0F98:  LD      HL,S1001        ; Pointer to storage for file names in handle
        RST     _DOCMD          ; Software - Execute command
        DEFB    19              ; Code 19 convert ASCII value (HL) into hex value after DE
        LD      A,D             ;!  Start address zero?
        OR      E               ;!
        JP      Z,A1FAF         ; yes --> Error 60 Illegal filename error
        LD      (S1048),DE      ; Note the start address of the USR routine
        RET
;
;
;   Provide data from device 'USR:' or output to device
;
A0FA7:  LD      HL,(S1048)      ; Get start address of USR routine
        JP      (HL)            ; USR - call routine
;
        DEFS    81
;
;
;   Beginning addresses of the interrupt routines for music and printers
;   (addresses must be on an even address)
;
A0FFC:  DEFW    A421A           ; Start address for music interrupt
;
A0FFE:  DEFW    A1561           ; Start address for printer interrupt

;
;   Storage for file identifier (directory entry)
;
S1000:  DEFS    1               ; File type - Identifier
S1001:  DEFS    17              ; File name
S1012:  DEFS    1               ; Write protect - flag
        DEFS    1                 
S1014:  DEFS    2               ; File length
S1016:  DEFS    2               ; Starting address
S1018:  DEFS    2               ; Start address
        DEFS    4                 
S101E:  DEFS    2               ; Sector number of first logical sector
;                               ; End of memory for directory entry 
S1020:
        DEFS    24
;
INT_JP: DEFS    3               ; Interrupt jump for time interrupt (ROM monitor) 
;
S103B:  DEFS    5
;
S1040:  DEFW    2               ; Pointer to current file record
;
;
;   Storage for current file record management
;
S1042:  DEFS    1               ; (internal): current device number 
;
S1043:  DEFS    1               ; File access mode
                                ; Bit 0  =  Open for reading
                                ; Bit 1  =  Open for writing
                                ; Bit 2  =  Random R/W access mode
;
S1044:  DEFS    2               ; Pointer to current devices - table 
;
S1046:  DEFS    2               ; Current device number 
;
S1048:  DEFS    2               ; Start address of the USR routine 
;
;
;   Speicher f√ºr aktuelle Ger√§te - Tabelle
;
S104A:  DEFS    2               ; Zeiger auf n√§chste Ger√§te - Tabelle
;
        DEFS    4               ; Ger√§te - Name
;
S1050:  DEFB    1               ; Ger√§te - Typ - Byte
                                ; Bit 2  =  Ger√§t stellt einzelne Zeichen zur Verf√ºgung
                                ; Bit 3  =  Zeichenorientierte Ausgabe (nicht Zeilenorientiert)
                                ; Bit 4  =  auf Dateinamen untersuchen
                                ; Bit 5  =  SWAP m√∂glich   (Ger√§t gleich Diskette)
                                ; Bit 6  =  mehrere Dateinamen auf Ger√§t zul√§ssig
                                ; Bit 7  =  nicht im Block - Modus
;
S1051:  DEFS    1               ; Ger√§te - Nummern - Byte
                                ; Bit 0-3  =  Ger√§te - Nummer maximal
                                ; Bit 4    =  End - of - File nicht erlaubt
                                ; Bit 5    =  nur eine Datei zum Schreiben er√∂ffnen
                                ; Bit 6    =  nur eine Datei auf Ger√§t erlaubt
                                ; Bit 7    =  Dateiname mu√ü nicht angegeben sein
;
S1052:  DEFS    1               ; maximale Anzahl Dateien auf Ger√§t / Datentr√§ger
;
S1053:  DEFS    2               ; Anfangsadresse  'Ger√§t initialisieren'
;
S1055:  DEFS    2               ; Anfangsadresse  'f√ºr Lesen er√∂ffnen'
                                ; Sektornummer f√ºr Sektorverzeichnis
;
S1057:  DEFS    2               ; Anfangsadresse  'f√ºr Schreiben er√∂ffnen'
                                ; Physikalische Sektorl√§nge
;
S1059:  DEFS    2               ; Anfangsadresse  'Datei schliessen'
                                ; Anzahl reservierter Sektoren
;
S105B:  DEFS    2               ; Anfangsadresse  'Dateidaten im Rechner l√∂schen'
                                ; maximale Anzahl Zeichen im Sektor
;
S105D:  DEFS    2               ; Anfangsadresse  'Daten bereitstellen'
;
S105F:  DEFS    2               ; Anfangsadresse  'Daten ausgeben'
;
S1061:  DEFS    2               ; Anfangsadresse  'aktuelle Spaltennummer bereitstellen'
                                ; Anfangsadresse  'Datei l√∂schen'
;
S1063:  DEFS    2               ; Anfangsadresse  'Datei umbenennen'
;
S1065:  DEFS    2               ; Anfangsadresse  'freie Kilobyte bereitstellen'
;
        DEFS    2  
;
;
;   Speicher f√ºr DEFAULT - Ger√§te - Daten  
;
S1069:  DEFS    1               ; DEFAULT   Ger√§te - Nummer
;
S106A:  DEFS    2               ; DEFAULT   Zeiger auf Ger√§te - Tabelle  
;
;
;
W106C:  DEFW    W0DDD           ; Zeiger auf Ger√§te-Tabelle Bildschirm  (erstes Ger√§t in Kette)
;
W106E:  DEFW    W1479           ; Zeiger auf Ger√§te-Tabelle Drucker
;
; 
;   Speicherbereich f√ºr Zeiger auf die verschiedenen Bereiche
;
S1070:  DEFS    2               ; Pointer to Basic - beginning of program
;
S1072:  DEFS    2               ; Pointer to file work areas (I/O work area)
;
S1074:  DEFS    2               ; Pointer to start of Basic variable
;
S1076:  DEFS    2               ; Pointer to start of string text area
;
S1078:  DEFS    2               ; Pointer to start of string work area
;
S107A:  DEFS    2               ; Pointer to end of string work area
;
S107C:  DEFS    2               ; Pointer to start of arithmetic memory
;
S107E:  DEFS    2               ; LIMIT - address
;
W1080:  DEFW    XFF00           ; maximum allowed RAM address 
;
;
;   Speicherbereich f√ºr Cursorverwaltung
;
S1082:  DEFS    1               ; current X - coordinate text cursor
;
S1083:  DEFS    1               ; current Y - coordinate text cursor
;
W1084:  DEFW    S2000           ; Pointer to current position in text memory
;
W1086:  DEFW    08000H          ; Text cursor position in Graphic screen
;
S1088:  DEFS    2               ; X - Coordinate Graphic - Cursor
;
S108A:  DEFS    2               ; Y - Coordinate Graphic - Cursor
;
S108C:  DEFS    1               ; Flag 'Original/cursor character' (0=Original)
;
S108D:  DEFS    1               ; Current keyboard mode (0=Alpha / 1=Small / 2=Graphic)
;
S108E:  DEFS    1               ; Text output flag for cassette routine
;
S108F:  DEFS    1               ; Printer parallel output flag
;
S1090:  DEFS    1               ; 'Execute control characters' flag
;
S1091:  DEFS    1               ; Monitor - Printer - Status
;
S1092:  DEFB    1               ; Printer - type - number (bit of number set)
;
        DEFB    CR              ; CR - code - value
;
        DEFB    14              ; Time-out counter printer
;
S1095:  DEFS    1               ; Column number printer
;
        DEFS    1                 
;
S1097:  DEFB    1               ; Printer - Mode - Flag (1=Text / 2=Graphic)
;
S1098:  DEFS    1               ; Value for Display - Mode - Register
;
S1099:  DEFS    1               ; Flag 'Additional graphic RAM available' (1=yes)
;
S109A:  DEFS    1               ; current override value
;
S109B:  DEFB    3               ; current character - palette value
;
S109C:  DEFB    3               ; background color value
;
S109D:  DEFB    4               ; maximum pallet value
;
S109E:  DEFB    11111111B       ; Mask for screen page (used Grapic - pages)
;
S109F:  DEFB    3               ; current graphic palette value
;
        DEFS    80              ; Memory for stack in MZ-80K mode
;
S10F0:  DEFS    128             ; Memory for file - identifier (cassette)
;
        DEFS    34                
;
FLSDT:  DEFB    0EFH            ; Cursor Character (Monitor 1Z-013B)
;
        DEFS    2                 
;
TMCNT:  DEFS    2               ; Memory for number of impulses of the tag
;
SUMDT:  DEFS    2               ; Memory for checksum (cassette routine)
;
CSMDT:  DEFS    2               ; second memory for checksum
;
        DEFS    2                 
;
SWRK:   DEFB    1               ; 'Beep on keypress' flag (1Z-13 B monitor)
;
        DEFB    4               ; Memory for Tempo (Monitor 1Z-013B)
;
ONTYO:  DEFB    5               ; default tone length (monitor 1Z-013B)
;
OCTV:   DEFS    1               ; Memory for Octave (Monitor 1Z-013B)
;
RATIO:  DEFS    2               ; Division Ratio for Sound (Monitor 1Z-013B)
;
S11A3:  DEFS    1  
;
;
;   die folgenden 270 Byte dienen als Zwischenspeicher f√ºr alle m√∂glichen Zwecke
;
S11A4:  DEFS    2               ; Anzahl noch zu untersuchende Werte   (PAINT)
S11A6:  DEFS    2               ; Zeiger auf PAINT - werte
S11A8:  DEFS    1               ; Speicher f√ºr Stackpointer   (BOX)
S11A9:  DEFS    1  
S11AA:  DEFS    1  
S11AB:  DEFS    1  
S11AC:  DEFS    1  
S11AD:  DEFS    1  
S11AE:  DEFS    1               ; Octantenflag der Anfangskoordinate   (CIRCLE)
S11AF:  DEFS    1               ; Y - Koordinate PAINT / Octantenflag Endpunkt
S11B0:  DEFS    1               ; X - Offset 3 / 6 Octant   (CIRCLE)
S11B1:  DEFS    1               ; linke X - Koordinate   (PAINT)
S11B2:  DEFS    1               ; X - Offset 4 / 5 Octant   (CIRCLE)
S11B3:  DEFS    1               ; rechte X - Koordinate   (PAINT)
S11B4:  DEFS    1               ; Y - Offset 1 / 4 Octant   (CIRCLE)
S11B5:  DEFS    1               
S11B6:  DEFS    1               ; Y - Offset 2 / 3 Octant   (CIRCLE)
S11B7:  DEFS    1  
S11B8:  DEFS    1  
S11B9:  DEFS    1  
S11BA:  DEFS    9               ; Octantenbytes   (CIRCLE)
S11C3:  DEFS    2               ; X - Offset Startpunkt   (CIRCLE)
S11C5:  DEFS    2               ; Y - Offset Startpunkt   (CIRCLE)
S11C7:  DEFS    2               ; X - Offset Endpunkt     (CIRCLE)
S11C9:  DEFS    2               ; Y - Offset Endpunkt     (CIRCLE)
S11CB:  DEFS    2               ; Y - Offset 6 / 7 Octant (CIRCLE)
S11CD:  DEFS    2               ; Y - Offset 5 / 8 Octant (CIRCLE)
S11CF:  DEFS    2               ; X - Offset 1 / 8 Octant (CIRCLE)
S11D1:  DEFS    2               ; Y - Offset 2 / 7 Octant (CIRCLE)
S11D3:  DEFS    1               ; Aspect - Flag           (CIRCLE)
S11D4:  DEFS    1               ; Aspect - Verh√§ltnis     (CIRCLE)
;        DEFS    43
        DEFS    25
S11EE:							; Area used by M/C program loader
        DEFS    18	
S1200:  DEFS    8               ; Speicher f√ºr gedrehtes Zeichen  (mu√ü auf 1200H stehen)
S1208:  DEFS    1
S1209:  DEFS    5
S120E:  DEFS    2
S1210:  DEFS    2
S1212:  DEFS    1
S1213:  DEFS    1
S1214:  DEFS    2               ; Anzahl Punkte in Y - Zeichenrichtung   (SYMBOL)
S1216:  DEFS    2               ; Anzahl Punkte in X - Zeichenrichtung   (SYMBOL)
S1218:  DEFS    2
S121A:  DEFS    2
S121C:  DEFS    2
S121E:  DEFS    1
S121F:  DEFS    1
S1220:  DEFS    1
S1221:  DEFS    2
;S1223:  DEFS    123
S1223:  DEFS    9


S122C:  DEFS    18              ; (relocated) Error handling routine for loading machine programs 

S123E:  DEFS    8

S1246:  DEFS    13              ; (reloc) Initiate peripheral modules for MZ - 700 mode

S1253:  DEFS    34              ; (reloc) Table for initializing the control blocks in MZ-700 mode


S1275:
        DEFS    41




S129E:  DEFS    2  
S12A0:  DEFS    2  
        DEFS    8               ; Memory for stack at ROM - routines - callf
S12AA:  DEFS    2                 
S12AC:  DEFS    2               ; Storage for stack pointers
S12AE:  DEFS    2               ; Storage for pointers to ROM - commit - text 
        DEFS    2  


;
;
;   Memory for function key texts
;
; ---------------------------------------------------------------

B12B2:  DEFB    7               ; text length
        DEFM    "RUN   "        ; Text for F1 key
        DEFB    CR                
        DEFS    8               ; Rest of text memory
;
        DEFB    5               ; text length
        DEFM    "LIST "         ; Text for F2 key
        DEFS    10              ; Rest of text memory


IF CLASSIC_FNK
; ---------------------------------------------------------------

        DEFB    5               ; text length
        DEFM    "AUTO "         ; Text for F3 key
        DEFS    10              ; Rest of text memory
;
        DEFB    6               ; text length
        DEFM    "RENUM "        ; Text for F4 key
        DEFS    9               ; Rest of text memory
;
        DEFB    6               ; text length
        DEFM    "COLOR "        ; Text for F5 key
        DEFS    9               ; Rest of text memory
;
        DEFB    5               ; text length
        DEFM    "CHR$("         ; Text for key Sft F1
        DEFS    10              ; Rest of text memory
;
        DEFB    8               ; text length
        DEFM    "DEF KEY("      ; Text for key Sft F2
        DEFS    7               ; Rest of text memory
;
        DEFB    4               ; text length
        DEFM    "CONT"          ; Text for key Sft F3
        DEFS    11              ; Rest of text memory
;
        DEFB    6               ; text length
        DEFM    "SAVE  "        ; Text for key Sft F4
        DEFS    9               ; Rest of text memory
;
        DEFB    6               ; text length
        DEFM    "LOAD  "        ; Text for key Sft F5
        DEFS    9               ; Rest of text memory

; ---------------------------------------------------------------
ELSE
; ---------------------------------------------------------------

        DEFB    5               ; text length
        DEFM    "LOAD "         ; Text for F3 key
        DEFS    10              ; Rest of text memory
;
        DEFB    5               ; text length
        DEFM    "SAVE "         ; Text for F4 key
        DEFS    10              ; Rest of text memory
;
        DEFB    5               ; text length
        DEFM    "DIR "          ; Text for F5 key
		DEFB    CR
        DEFS    10              ; Rest of text memory
;
        DEFB    12              ; text length
        DEFM    "INIT\"CRT:M2"  ; Text for key Sft F1
		DEFB    C_LEFT
        DEFS    3               ; Rest of text memory
;
        DEFB    8               ; text length
        DEFM    "DEF KEY("      ; Text for key Sft F2
        DEFS    7               ; Rest of text memory
;
        DEFB    11              ; text length
        DEFM    "OUT@ $E9,0"    ; Text for key Sft F3
		DEFB    C_LEFT
        DEFS    4               ; Rest of text memory
;
        DEFB    8               ; text length
        DEFM    "DEF.RAM"       ; Text for key Sft F4
		DEFB    CR
        DEFS    7               ; Rest of text memory
;
        DEFB    8               ; text length
        DEFM    "DEF.FD1"       ; Text for key Sft F5
		DEFB    C_LEFT
        DEFS    7               ; Rest of text memory
;
; ---------------------------------------------------------------

ENDIF

;
;
;   Storage for values of the current function key
;
S1352:  DEFS    1               ; Fetched number of characters
;
S1353:  DEFS    1               ; Text length current function key
;
S1354:  DEFS    16              ; Text of the current function key
;
S1364:  DEFB    255             ; length input - memory
;
S1365:  DEFS    1               ; last key pressed
;
        DEFS    2               ; Pointer to memory for time (IPL ROM - monitor) 
;
        DEFS    1  
;
;
;   Memory for current screen - control values
;
S1369:  DEFS    1               ; minimum X coordinate
;
S136A:  DEFS    1,39            ; maximum X coordinate
;
W136B:  DEFW    40              ; Counter '40/80 characters per line'
;
W136D:  DEFW    320             ; Number of pixels per line
;
S136F:  DEFS    1               ; Y - coordinate minimum (scroll - range)
;
S1370:  DEFB    24              ; Y - coordinate maximum (scroll - range)
;
S1371:  DEFB    25              ; Number of lines in the scroll area 
;
;
;   Memory for values via scroll area for screen controller
;
S1372:  DEFS    2               ; 'Scroll offset for screen controllers
;
S1374:  DEFS    1,5 * 25        ; Value for 'Scroll width Register' in the Controller screen
;
S1375:  DEFS    1               ; Value for 'Scroll Start Address Register'
;
S1376:  DEFS    1,5 * 25        ; Value for 'Scroll End Address Register'
;
W1377:  DEFW    25 * 5 * 8      ; maximum scroll offset corresponding to scroll area
;
S1379:  DEFB    0000001B        ; Screen Mode Bit (Mode # bit is set)
;
S137A:  DEFB    1               ; Screen - Mode - Number
;
S137B:  DEFB    3               ; maximum palette value / current drawing color
;
S137C:  DEFS    2               ; End of memory for PAINT
;
S137E:  DEFS    1               ; current pallet block number
;
W137F:  DEFW    B1389           ; Pointer to color code - default
;
S1381:  DEFS    4               ; Storage for palette values
;
;
;   Farbcode - Palettencodevorgabe f√ºr Bildschirm - Modus  3
;
B1385:  DEFB    00000000B       ; Palettencode 0  Schwarz
        DEFB    00011111B       ; Palettencode 1  Hellwei√ü
        DEFB    00101111B       ; Palettencode 2  Hellwei√ü
        DEFB    00111111B       ; Palettencode 3  Hellwei√ü
;
;
;   Farbcode - Palettencodevorgabe f√ºr Bildschirm - Modus  1 oder 4
;
B1389:  DEFB    00000000B       ; Palettencode 0  Schwarz
        DEFB    00010001B       ; Palettencode 1  Blau
        DEFB    00100010B       ; Palettencode 2  Rot
        DEFB    00111111B       ; Palettencode 3  Hellwei√ü
;
;
;   Farbcode - Palettencodevorgabe f√ºr Bildschirm - Modus  2
;
B138D:  DEFB    00000000B       ; Palettencode 0  Schwarz
        DEFB    00010001B       ; Palettencode 1  Blau
        DEFB    00100010B       ; Palettencode 2  Rot
        DEFB    00110011B       ; Palettencode 3  Magenta
;
;
;   Cursor - Bit pattern for  Alpha - Modus
;
B1391:  DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
;
;
;   Cursor - Bit pattern for  Kleinschreibungscursor
;
B1399:  DEFB    01111110B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    11111111B
        DEFB    01111110B
;
;
;   Cursor - Bit pattern for  Graphic-Cursor
;
B13A1:  DEFB    00000000B
        DEFB    00000000B
        DEFB    00000000B
        DEFB    00000000B
        DEFB    00000000B
        DEFB    00000000B
        DEFB    00000000B
        DEFB    11111111B
;
;
S13A9:  DEFS    26              ; Speicher mit Verkettungsflags der Textzeilen
;
;
;   Speicherbereich f√ºr RAM - Karten - Routine
;
S13C3:  DEFS    1               ; Flag  'RAM - Karte vorhanden'
                                ; (0=nein / 1=Kein Spooler / 2=Spooling / 3=Spller m√∂glich)
S13C4:  DEFS    2  
;
S13C6:  DEFS    2               ; Anfangsadresse der neuen RAM - Datei
;
S13C8:  DEFS    2               ; RAM - Kartenadresse f√ºr Datenblock
;
;
;   Speicher f√ºr ROM - Monitor - Drucker - Routinen
;
        DEFS    1               ; SHARP/Centronics-√úbernahme - Flag  (0=Sharp)
;
        DEFS    1               ; SHARP/Centronics-Strobe - Flag     (0=Sharp)
;
        DEFW    03FF0H          ; L√§nge Drucker - Spooler
;
S13CE:  DEFS    2               ; Anzahl Zeichen im Drucker - Spooler
;
        DEFW    0C000H          ; Spooler - Einschreib - Adresse
;
        DEFW    0C000H          ; Spooler - Auslese - Adresse
;
        DEFW    0C000H          ; Anfangsadresse des Spooler - Speichers
;
        DEFS    1               ; Spooler - Status - Flag
;
        DEFS    1               ; Null - Be - Flag
;
        DEFB    4               ; Maximale Drucker - Typ - Nummer
;
S13D9:  DEFS    1               ; ROM - Fehlerstatus
;
W13DA:  DEFW    B13DC           ; Anfangsadresse der Umsetztabelle f√ºr ASCII-Zeichen
;
;
;   Tabelle zum Umsetzen der kleinen Buchstaben und Umlaute von Sharp - Code
;   in ASCII - Code und umgekehrt
;
B13DC:  DEFB    39              ; Anzahl Zeichen in Tabelle
;
        DEFB    '#'             ; Sharp - Code
        DEFB    '#'             ; ASCII - Code - Zeichen
        DEFB    '@'             ; Sharp - Code          
        DEFB    '@'             ; ASCII - Code - Zeichen
        DEFB    '['             ; Sharp - Code     (Eckige Klammer auf)
        DEFB    '['             ; ASCII - Code - Zeichen
        DEFB    '\\'             ; Sharp - Code     (Backslash)
        DEFB    '\\'             ; ASCII - Code - Zeichen
        DEFB    ']'             ; Sharp - Code     (Eckige Klammer zu)
        DEFB    ']'             ; ASCII - Code - Zeichen
        DEFB    08BH            ; Sharp - Code          
        DEFB    '^'             ; ASCII - Code - Zeichen
        DEFB    090H            ; Sharp - Code          
        DEFB    '_'             ; ASCII - Code - Zeichen
        DEFB    093H            ; Sharp - Code          
        DEFB    '`'             ; ASCII - Code - Zeichen
        DEFB    0A1H            ; Sharp - Code          
        DEFB    'a'             ; ASCII - Code - Zeichen
        DEFB    09AH            ; Sharp - Code          
        DEFB    'b'             ; ASCII - Code - Zeichen
        DEFB    09FH            ; Sharp - Code          
        DEFB    'c'             ; ASCII - Code - Zeichen
        DEFB    09CH            ; Sharp - Code          
        DEFB    'd'             ; ASCII - Code - Zeichen
        DEFB    092H            ; Sharp - Code          
        DEFB    'e'             ; ASCII - Code - Zeichen
        DEFB    0AAH            ; Sharp - Code          
        DEFB    'f'             ; ASCII - Code - Zeichen
        DEFB    097H            ; Sharp - Code          
        DEFB    'g'             ; ASCII - Code - Zeichen
        DEFB    098H            ; Sharp - Code          
        DEFB    'h'             ; ASCII - Code - Zeichen
        DEFB    0A6H            ; Sharp - Code          
        DEFB    'i'             ; ASCII - Code - Zeichen
        DEFB    0AFH            ; Sharp - Code          
        DEFB    'j'             ; ASCII - Code - Zeichen
        DEFB    0A9H            ; Sharp - Code          
        DEFB    'k'             ; ASCII - Code - Zeichen
        DEFB    0B8H            ; Sharp - Code          
        DEFB    'l'             ; ASCII - Code - Zeichen
        DEFB    0B3H            ; Sharp - Code          
        DEFB    'm'             ; ASCII - Code - Zeichen
        DEFB    0B0H            ; Sharp - Code          
        DEFB    'n'             ; ASCII - Code - Zeichen
        DEFB    0B7H            ; Sharp - Code          
        DEFB    'o'             ; ASCII - Code - Zeichen
        DEFB    09EH            ; Sharp - Code          
        DEFB    'p'             ; ASCII - Code - Zeichen
        DEFB    0A0H            ; Sharp - Code          
        DEFB    'q'             ; ASCII - Code - Zeichen
        DEFB    09DH            ; Sharp - Code          
        DEFB    'r'             ; ASCII - Code - Zeichen
        DEFB    0A4H            ; Sharp - Code          
        DEFB    's'             ; ASCII - Code - Zeichen
        DEFB    096H            ; Sharp - Code          
        DEFB    't'             ; ASCII - Code - Zeichen
        DEFB    0A5H            ; Sharp - Code          
        DEFB    'u'             ; ASCII - Code - Zeichen
        DEFB    0ABH            ; Sharp - Code          
        DEFB    'v'             ; ASCII - Code - Zeichen
        DEFB    0A3H            ; Sharp - Code          
        DEFB    'w'             ; ASCII - Code - Zeichen
        DEFB    09BH            ; Sharp - Code          
        DEFB    'x'             ; ASCII - Code - Zeichen
        DEFB    0BDH            ; Sharp - Code          
        DEFB    'y'             ; ASCII - Code - Zeichen
        DEFB    0A2H            ; Sharp - Code          
        DEFB    'z'             ; ASCII - Code - Zeichen
        DEFB    0BEH            ; Sharp - Code   (geschweifte Klammer auf)
        DEFB    '{'             ; ASCII - Code - Zeichen
        DEFB    0C0H            ; Sharp - Code   (senkrechter Strich)
        DEFB    '|'             ; ASCII - Code - Zeichen
        DEFB    080H            ; Sharp - Code   (geschweifte Klammer zu)
        DEFB    '}'             ; ASCII - Code - Zeichen
        DEFB    094H            ; Sharp - Code          
        DEFB    '~'             ; ASCII - Code - Zeichen
        DEFB    07FH            ; Sharp - Code          
        DEFB    DEL             ; ASCII - Code - Zeichen
;
;
;   Zeichen f√ºr Ausgabe auf ASCII - Ger√§t umsetzen
;
A142B:  CP      CR              ; Wagenr√ºcklauf  ?
        JR      Z,A1442         ; ja -->  Zeichen ausgeben und Spaltenz√§hler zur√ºcksetzen
        CP      LF              ; Zeilenvorschub  ?
        JR      Z,A1442         ; ja -->  Zeichen ausgeben und Spaltenz√§hler zur√ºcksetzen
        CALL    A1448           ; Zeichen im Accu in ASCII - Code umsetzen
        CP      ' '             ; Steuerzeichen  ?
        JR      NC,A1440        ; nein -->  Zeichen im Accu ausgeben
        BIT     0,E             ; Steuerzeichen ausgeben  ?
        JR      Z,A1440         ; ja -->  Zeichen im Accu ausgeben
        LD      A,' '           ; Leerzeichen  (Space)  f√ºr Steuerzeichen vorgeben
A1440:  JP      (IX)            ; Zeichen im Accu auf Ger√§t ausgeben
;
A1442:  CALL    A1440           ; Zeichen im Accu auf Ger√§t ausgeben
        LD      (HL),0          ; Spaltenz√§hler des Ger√§tes zur√ºcksetzen
        RET
;
;
;   Textzeichen im Accu zur Ausgabe auf ASCII - Ger√§t umsetzen
;
A1448:  PUSH    BC              ; Register - Wert retten
        LD      C,0             ; Code for 'von Sharp in ASCII - Code umsetzen'
        CALL    A1450           ; Zeichen in Austauschtabelle suchen
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Zeichen im Accu in Austauschtabelle suchen und Ersatzzeichen bereitstellen
;
A1450:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      HL,(W13DA)      ; Anfangsadresse der Umsetztabelle holen
        LD      B,(HL)          ; Anzahl Zeichen in Tabelle holen
        INC     HL              ; Anzahl Zeichen √ºberspringen
        LD      D,H             ;! Zeiger auf Tabelle nach DE duplizieren
        LD      E,L             ;!
        INC     DE              ; Zeiger auf Tabelle auf ASCII - Zeichen
        BIT     0,C             ; von Sharp - Code in ASCII - Code umsetzen
        JR      Z,A1460         ; ja
        EX      DE,HL           ; Zeiger auf Tabellenwerte vertauschen
A1460:  CP      (HL)            ; Zeichen mit Tabellenzeichen vergleichen
        JR      Z,A146A         ; Zeichen gefunden -->  Austauschzeichen holen
        INC     HL              ;! Zeiger auf Suchzeichen auf n√§chstes Zeichen
        INC     HL              ;!
        INC     DE              ;! Zeiger auf Austauschzeichen auf n√§chstes Zeichen
        INC     DE              ;!
        DJNZ    A1460           ; weitere Zeichen vergleichen
        RET
;
A146A:  LD      A,(DE)          ; Austauschzeichen aus Tabelle holen
        RET
;
;
;   Routine (IX) aufrufen und bereitgestelltes Zeichen in Sharp - Code umsetzen
;
A146C:  CALL    A1440           ; Routine (IX) aufrufen   (Zeichen bereitstellen)
        RET     C               ; Fehler aufgetreten -->  Abbruch
        PUSH    BC              ; Register - Wert retten
        LD      C,1             ; Code for 'von ASCII in Sharp - Code umsetzen'
        CALL    A1450           ; Zeichen im Accu umsetzen
        POP     BC              ; geretteten Register - Wert wieder holen
        OR      A               ; Carry - Flag zur√ºcksetzen   (Code for 'kein Fehler')
        RET
;
;
;   Ger√§te - Tabelle f√ºr Drucker   (LPT:)
;
W1479:  DEFW    W3AD7           ; Zeiger auf n√§chste Ger√§te - Tabelle   (CMT:)
        DEFM    "LPT"
		DEFB    NUL             ; Ger√§te - Name
        DEFB    10001010B       ; Ger√§te - Typ - Byte
        DEFB    00000000B       ; Ger√§te - Nummern - Byte
        DEFB    0
        DEFW    A14EC           ; Ger√§t initialisieren
        DEFW    A1FAC           ; Fehler 59  Can't execute error  (zum Lesen er√∂ffnen)
        DEFW    A00B2           ; RET
        DEFW    A00B2           ; RET
        DEFW    A00B2           ; RET
        DEFW    0               ; Code for 'Zeichen bereitstellen nicht m√∂glich'
        DEFW    A14B2           ; Accu an Drucker ausgeben
        DEFW    A1492           ; aktuelle X - Koordinate Drucker bereitstellen
;
;
;   aktuelle X - Koordinate Drucker bereitstellen
;
A1492:  LD      A,(S108F)       ; Parallelausgabeflag Drucker  holen
        OR      A               ; Parallelausgabe gesetzt  ?
        LD      A,(S1095)       ; Spaltennummer Drucker  holen
        RET     Z               ; keine Parallelausgabe -->  Wert Drucker zur√ºckliefern
        LD      A,(S1082)       ; X - Koordinate Textcursor holen
        RET
;
;
;   Uhrzeit auf Sekunden in DE und Flag Vormittag/Nachmittag im Accu setzen
;
;   (Software command code:  38)
;
A149E:  CALL    A1517           ; IPL - ROM - Routine aufrufen
        DEFB    003H            ; Low - Byte Anfangsadresse  'Uhrzeit setzen'
;
;
;   Uhrzeit lesen     (Software command code:  37)
;
A14A2:  CALL    A1517           ; IPL - ROM - Routine aufrufen
        DEFB    006H            ; Low - Byte Anfangsadresse  'Uhrzeit lesen'
;
;
;   Joy - Stick nach Richtung abfragen   (Accu gleich Joy-Stick-Nummer)
;
;   (Software command code:  30)
;
A14A6:  CALL    A1517           ; IPL - ROM - Routine aufrufen
        DEFB    009H            ; Low - Byte Anfangsadresse  'Joy - Stick abfragen'
;
;
;   Abfrage, ob Feuerknopf des Jopy - Sticks gedr√ºckt ist
;
;   (Software command code:  31)
;
A14AA:  CALL    A1517           ; IPL - ROM - Routine aufrufen
        DEFB    00CH            ; Low - Byte Anfangsadresse  'Feuerknopf abfragen'
;
;
;   Graphic - Bildschirm - Inhalt auf Graphic - Drucker ausgeben
;
;   (Software command code:  79)
;
A14AE:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    00FH            ; Low - Byte Anfangsadresse  'Graphic auf Drucker kopieren'
;
;
;   ASCII - Zeichen im Accu an Drucker ausgeben
;
A14B2:  LD      HL,S1090        ; Zeiger auf Flag  'Steuerzeichen ausf√ºhren'
        BIT     0,(HL)          ; Steuerzeichen ausf√ºhren  ?
        JR      NZ,A14E0        ; nein -->  Steuerzeichen anzeigen
;
;
;   Zeichen im Accu auf Drucker  (und Bildschirm)  ausgeben
;
;   Software - Kommando  7)
;
A14B9:  PUSH    IY              ; Register - Wert retten
        EX      AF,AF           ; auszugebendes Zeichen retten
        LD      A,012H          ; Code for 'Zeichen an Drucker ausgeben, wenn nicht Parallelausgabe'
        LD      (B14DF),A       ; in Routine eintragen
        LD      A,3             ; Code 3  Accu auf Bildschirm ausgeben  (Ausf√ºhrung Steuerzeichen)
A14C3:  LD      (B14D6),A       ; in Routine eintragen
        EX      AF,AF           ; auszugebendes Zeichen holen
        CALL    A14D8           ; Zeichen im Accu an Drucker ausgeben
        POP     IY              ; geretteten Register - Wert wieder holen
        PUSH    BC              ; Register - Wert retten
        LD      B,A             ; auszugebendes Zeichen retten
        LD      A,(S108F)       ; Parallelausgabeflag Drucker  holen
        OR      A               ; Parallelausgabe  ?
        LD      A,B             ; auzugebendes Zeichen holen
        POP     BC              ; geretteten Register - Wert holen
        RET     Z               ; keine Parallelausgabe -->  fertig
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
B14D6:  DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausf√ºhrung Steuerzeichen)
        RET
;
A14D8:  LD      IY,A142B        ; Adresse  'Zeichen f√ºr Ausgabe auf ASCII-Drucker umsetzen'
        CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
B14DF:  DEFB    012H            ; Low - Byte Anfangsadresse  'Zeichen auf Drucker ausgeben'
;
;
;   Zeichen im Accu auf Bildschirm und Drucker ausgeben   (Steuerzeichen anzeigen)
;
A14E0:  PUSH    IY              ; Register - Wert retten
        EX      AF,AF           ; auszugebendes Zeichen retten
        LD      A,015H          ; Code for 'Steuerzeichen auf Drucker anzeigen'
        LD      (B14DF),A       ; in Routine eintragen
        LD      A,3             ; Code 3  Accu auf Bildschirm ausgeben
        JR      A14C3           ; Zeichen ausgeben
;
;
;   Drucker initialisieren
;
A14EC:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    018H            ; Low - Byte Anfangsadresse  'Drucker initialisieren'
;
;
;   Zeichen im Accu auf Drucker ausgeben     (Software command code:  6)
;
A14F0:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    01BH            ; Low - Byte Anfangsadresse  'Zeichen auf Drucker ausgeben'
;
;
;   Spooler - Daten nach Spooler - Anfangsadresse setzen
;
A14F4:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    01EH            ; Low - Byte Anfangsadresse  der ROM - Routine
;
;
;   Drucker - Interrupt abschalten
;
A14F8:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    021H            ; Low - Byte Anfangsadresse  der ROM - Routine
;
;
;   Drucker - Interrupt freigeben
;
A14FC:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    024H            ; Low - Byte Anfangsadresse  der ROM - Routine
;
;
;   Druckvorgang stoppen / anlaufen lassen
;
A1500:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    027H            ; Low - Byte Anfangsadresse  der ROM - Routine
;
;
;   auf 'Drucker READY' abfragen und Spooler abschalten
;
A1504:  CALL    A1508           ; warten, bis Melodie gespielt; dann IPL-ROM-Routine aufrufen
        DEFB    02AH            ; Low - Byte Anfangsadresse  der ROM - Routine
;
;
;   wenn P5-A - Drucker -->  erst Music spielen und dann ROM - Routine aufrufen
;
A1508:  EX      AF,AF           ; Register - Wert retten
        LD      A,(S1092)       ; Drucker - Nummern - byte holen
        BIT     1,A             ; MZ - 80 A   P5 - Drucker  ?
        JR      Z,A1516         ; nein -->  ROM - Routine direkt aufrufen
        PUSH    BC              ; Register - Wert retten
        LD      B,3             ; Code for 'warten, bis Music - Daten gespielt'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    35              ; Code 35  Music nach Status in B behandeln
        POP     BC              ; geretteten Register - Wert wieder holen
A1516:  EX      AF,AF           ; geretteten Accu - Wert wieder holen
;
;
;   IPL - ROM - Routine aufrufen
;
A1517:  EX      AF,AF           ; Wert im Accu retten
        XOR     A               ; Accu auf Null
        LD      (S12AE),HL      ; Zeiger auf ROM - √úbergabe - Text eintragen
        LD      (S13D9),A       ; ROM - Fehlerstatus l√∂schen
        EX      AF,AF           ; geretteten Accu - Wert wieder holen
        DI                      ; Interrupt sperren
        LD      (S12AC),SP      ; Stackpointer retten
        EX      (SP),HL         ; HL - Register retten / R√ºcksprungadresse holen
        LD      SP,HL           ; Stackpointer mit R√ºcksprungadresse laden
        POP     HL              ; Low - Byte der Adresse hinter Call - Aufruf holen
        OUT     (_E0ROM),A      ; Umschalten auf ROM - Monitor von 0E000H bis 0FFFFH
        LD      SP,S12AA        ; Stackpointer f√ºr ROM - Routine setzen
        CALL    A1543           ; High - Byte Adresse vorgeben und ROM - Routine aufrufen
        OUT     (_E0RAM),A      ; Umschalten auf RAM von 0E000H bis 0FFFFH
        LD      SP,(S12AC)      ; alten Stackpointer wieder holen
        EX      (SP),HL         ; geretteten HL - Register - Wert wieder holen
        INC     SP              ;! Stack - Pointer corrigieren
        INC     SP              ;!
        EI                      ; Interrupt freigeben
        EX      AF,AF           ; Wert im Accu retten
        LD      A,(S13D9)       ; ROM - Fehlerstatus holen
        OR      A               ; Fehler aufgetreten  ?
        JR      NZ,A1546        ; ja -->  Fehler behandeln
        EX      AF,AF           ; geretteten Accu - Wert holen
        RET
;
A1543:  LD      H,0F4H          ; High - Byte ROM - Routinen - Adresse vorgeben
        JP      (HL)            ; ROM - Routine aufrufen
;
;
;   Fehler bei ROM - Routine behandeln
;
A1546:  LD      B,A             ; Fehlerstatus merken
        EX      AF,AF           ; geretteten Accu - Wert holen
        DEC     B               ; Fehlerstatus gleich 1  ?
        JP      Z,A00E8         ; ja -->  Programm abbrechen  (BREAK)
        DEC     B               ; Fehlerstatus gleich 2  ?
        JP      NZ,A00ED        ; nein -->  Fehler mit Nummer im Accu behandeln
A1550:  LD      HL,(S13CE)      ; Anzahl Zeichen im Drucker - Spooler holen
        LD      A,H             ;! gleich Null  ?
        OR      L               ;!
        JR      Z,A1504         ; ja -->  auf Drucker Ready abfragen und Spooler abschalten
        CALL    A14FC           ; Drucker - Interrupt freigeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    14              ; Code 14   Abfrage, ob (Shift) BREAK gedr√ºckt ist
        JP      Z,A00E8         ; ja -->  Programm abbrechen  (BREAK)
        JR      A1550           ; warten, bis Drucker - Spooler leer
;
;
;   PIO - Interrupt f√ºr Drucker behandeln
;
A1561:  DI                      ; Interrupt sperren
        PUSH    AF              ;! Register - Werte retten
        PUSH    HL              ;!
        PUSH    BC              ;!
        LD      (S1585),SP      ; Stackpointer retten
        LD      SP,S1585        ; neuen Stackpointer f√ºr ROM - Routine vorgeben
        OUT     (_E0ROM),A      ; Umschalten auf ROM - Monitor von 0E000H bis 0FFFFH
        CALL    XF400           ; Drucker - Interrupt - Routine im ROM aufrufen
        OUT     (_E0RAM),A      ; Umschalten auf RAM von 0E000H bis 0FFFFH
        LD      SP,(S1585)      ; geretteten Stackpointer holen
        POP     BC              ;! gerettete Register - Werte holen
        POP     HL              ;!
        POP     AF              ;!
        EI                      ; Interrupt wieder freigeben
        RETI                    ; Interrupt - Routine abschliessen
;
        DEFS    8               ; Speicher f√ºr Stack
;
S1585:  DEFS    2               ; Speicher f√ºr Stackpointer
;
;
;   Software - Maschinen - Monitor aufrufen
;
;   (Software command code:  0)
;
A1587:  PUSH    HL              ; Register - Wert retten
        LD      DE,(S004F)      ; Fehlerbehandlungsadresse holen
        PUSH    DE              ; und retten
        LD      DE,T15CE        ; neuen Fehlerbehandlungsadresse
        LD      (S004F),DE      ; eintragen
        LD      A,(S1364)       ; L√§nge Eingabe - Speicher  holen
        PUSH    AF              ; und retten
        LD      A,100           ; Vorgabe f√ºr neue Pufferl√§nge
        LD      (S1364),A       ; als L√§nge Eingabe - Speicher merken
        LD      (A1644 + 1),SP  ; Stackpointer merken
        XOR     A               ; Accu auf Null
        LD      (S1091),A       ; Monitor - Drucker - Status  zur√ºcksetzen
A15A5:  LD      SP,0            ; Stackpointer neu setzen
;
; 
;   Anfang  Monitor - Schleife
;
T15A8:  LD      BC,T15A8        ; R√ºcksprungadresse f√ºr Schleife 
        PUSH    BC              ; auf Stack ablegen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    2               ; Code 2  Zeilenvorschub, wenn Cursor nicht auf Anfang Zeile
        LD      A,'*'           ; Monitor - Prompt - Symbol
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausf√ºhrung Steuerzeichen)
A15B2:  CALL    A1651           ; Zeile von Tastatur holen und auswerten
        JR      NC,A15B2        ; Zeile vollst√§ndig ausgewertet -->  n√§chste Zeole holen
        LD      A,(DE)          ; erstes Zeichen der Zeile holen
        CP      '*'             ; Monitor - Prompt - Symbol
        RET     NZ              ; nein -->  erneut von Tastatur abfragen
        INC     DE              ; Prompt - Symbol √ºberspringen
        LD      A,(DE)          ; n√§chstes Textzeichen holen
        INC     DE              ; Textzeichen √ºberspringen
        EXX
        LD      HL,M15E0        ; Zeiger auf Tabelle mit Monitorbefehlen
        LD      B,10            ; 10 Befehle in Tabelle
A15C4:  CP      (HL)            ; Befehlszeichen vergleichen
        INC     HL              ; Zeiger auf Tabelle auf Adresse
        JR      Z,A15DA         ; Befehl gefunden -->  Adresse aus Tabelle holen
        INC     HL              ;! Anfangsadresse des Befehls √ºberspringen
        INC     HL              ;!
        DJNZ    A15C4           ; weitere Befehle vergleichen
        EXX
        RET
;
;
;   Software - Monitor - Fehlerbehandlung
;
T15CE:  LD      C,A             ; Fehlernummer merken
        AND     01111111B       ; eigentliche Fehlernummer maskieren
        JR      Z,A15A5         ; BREAK -->  Monitor - Schleife
        LD      A,C             ; Fehlernummer holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    27              ; Code 27  Fehlertext nach Fehlernummer in A ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    67              ; Code 67   Datei - Daten der Ausgabe - Datei l√∂schen
        JR      A15A5           ; n√§chsten Monitor - Befehl holen und abarbeiten
;
;
;   Anfangsadresse der Befehlsroutine aus Tabelle holen und Routine aufrufen
;
A15DA:  LD      E,(HL)          ;! Anfangsadresse der Routine aus Tabelle holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        PUSH    DE              ; Anfangsadresse auf Stack ablegen
        EXX             
        RET                     ; Routine aufrufen
;
;
;   Tabelle mit Anfangsadressen der Monitor - Befehle
;
M15E0:  DEFM    "D"             ; D  (Dump)
        DEFW    A16C6           ; Adresse  'Speicher ausgeben'
;
        DEFM    "M"             ; M  (Memory correction)
        DEFW    A1738           ; Adresse  'Speicher √§ndern'
;
        DEFM    "P"             ; P  (Printer mode)
        DEFW    A15FE           ; Adresse  'Druckerausgabe toggeln'
;
        DEFM    "G"             ; G  (Goto)
        DEFW    A16C1           ; Adresse  'Programm aufrufen'
;
        DEFM    "F"             ; F  (Find)
        DEFW    A175C           ; Adresse  'Daten im Speicher suchen'
;
        DEFM    "R"             ; R  (Return)
        DEFW    A1644           ; Adresse  'R√ºcksprung zum Basic'
;
        DEFM    "S"             ; S  (Save)
        DEFW    A1607           ; Adresse  'Programm abspeichern'
;
        DEFM    "L"             ; L  (Load)
        DEFW    A161E           ; Adresse  'Programm laden'
;
        DEFM    "V"             ; V  (Verify)
        DEFW    A163B           ; Adresse  'Programm vergleichen'
;
        DEFM    "T"             ; T  (Transfer)
        DEFW    A17AC           ; Adresse  'Programm verschieben'
;
;
;   Monitor - Befehl  P   (Ausgabe Drucker umschalten)
;
A15FE:  LD      A,(S1091)       ; Monitor - Drucker - Status  holen
        XOR     00000001B       ; Druckerstatus umkehren
        LD      (S1091),A       ; und wieder merken
        RET
;
;
;   Monitor - Befehl  S   (Programm abspeichern)
;
A1607:  CALL    A1795           ; Anfangs-, End- und Startadresse bereitstellen
        RET     C               ; Fehler aufgetreten -->  Monitor - Schleife
        EXX
        CALL    A17C3           ; Ger√§te- und Dateinamen auswerten und aufbereiten
        EXX
        LD      (S1014),BC      ; Datei - L√§nge merken
        LD      (S1016),DE      ; Anfangsadresse merken
        LD      (S1018),HL      ; Startadresse merken
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    49              ; Code 49  Programm abspeichern
        RET
;
;
;   Monitor - Befehl  L   (Programm laden)
;
A161E:  CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        PUSH    HL              ; Ladeadresse merken
        PUSH    AF              ; Fehlerflag merken
        CALL    A1630           ; Dateinamen auswerten und Kennung lesen
        POP     AF              ; Fehlerflag holen
        POP     HL              ; Ladeadresse holen
        JR      NC,A162D        ; kein Fehler -->  Ladeadresse angegeben
        LD      HL,(S1016)      ; Anfangsadresse aus Datei - Daten holen
A162D:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    48              ; Code 48  Programm nach Kennungsdaten laden
        RET
;
;
;   Dateinamen auswerten und Kennung lesen
;
A1630:  CALL    A17C3           ; Ger√§te- und Dateinamen auswerten und aufbereiten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    47              ; Code 47  (Programm-)Datei er√∂ffnen
        CP      _OBJ            ; Maschinenprogramm gefunden  ?
        RET     Z               ; ja -->  OK
        JP      A1FB2           ; Fehler 61, Illegal filemode error
;
;
;   Monitor - Befehl  V   (Programm vergleichen)
;
A163B:  CALL    A1630           ; Dateinamen auswerten und Kennung lesen
        LD      HL,(S1016)      ; Anfangsadresse holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    50              ; Code 50  Programm vergleichen
        RET
;
;
;   Monitor - Befehl  R   (R√ºcksprung zum Basic - Interpreter)
;
A1644:  LD      SP,0            ; Stackpointer wieder setzen  (wird eingetragen)
        POP     AF              ; gerettete Pufferl√§nge holen
        LD      (S1364),A       ; und wieder als L√§nge Eingabe - Speicher eintragen
        POP     HL              ; gerettete Fehlerbehandlungsadresse holen
        LD      (S004F),HL      ; Fehlerbehandlungsadresse eintragen
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;   Zeile von Tastatur holen und soweit wie m√∂glich auswerten
;
A1651:  LD      DE,ZFF00        ; Zeiger auf Speicher f√ºr Tastatureingabe vorgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    12              ; Code 12   Zeile von Tastatur nach Speicher (DE) holen
        JR      C,A1670         ; Eingabe geBREAKt -->  BREAK merken
        LD      A,(DE)          ; erstes Zeichen der Eingabe holen
        CP      ':'             ; Doppelpunkt  ?
        SCF                     ; Code for 'Zeile nicht editierbar'  setzen
        RET     NZ              ; Zeile nicht editierbar
        INC     DE              ; Doppelpunkt √ºberspringen
        CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        RET     C               ; Fehler aufgetreten
        LD      A,(DE)          ; n√§chstes Textzeichen holen
        INC     DE              ; Textzeichen √ºberspringen
        XOR     '='             ; gleich =  ?
        RET     NZ              ; nein
A1667:  CALL    A1697           ; 2 ASCII-Hex-Zeichen oder ein ASCII-Zeichen -->  Hex-Wert
        CCF                     ; Fehlerstatus umkehren
        RET     NC              ; Fehler oder Datenende
        LD      (HL),A          ; Wert in Speicher eintragen
        INC     HL              ; Zeiger auf Speicher auf n√§chstes Byte
        JR      A1667           ; untersuchen, ob weitere Werte angegeben sind
;
A1670:  LD      (DE),A          ; Code for 'BREAK'  merken
        RET
;
;
;   4 ASCII - Hex - Zeichen (DE) umsetzen in Hex - Wert nach HL
;
A1672:  PUSH    HL              ; Register - Wert retten
        CALL    A168C           ; Zeiger in DE auf n√§chstes relevantes Zeichen setzen
        PUSH    DE              ; Zeiger auf Textanfang merken
        CALL    A169E           ; 2 ASCII-Hex-Zeichen (DE) umsetzen in Hex nach Accu
        JR      C,A1687         ; Fehler aufgetreten -->  Abbruch
        LD      H,A             ; High - Byte Wert merken
        CALL    A169E           ; 2 ASCII-Hex-Zeichen (DE) umsetzen in Hex nach Accu
        JR      C,A1687         ; Fehler aufgetreten -->  Abbruch
        LD      L,A             ; Low - Byte Wert merken
        POP     AF              ; Zeiger auf Textanfang verwerfen
        POP     AF              ; alten HL - Register - Wert verwerfen
        XOR     A               ; Carry-Flag zur√ºcksetzen  (Code for 'Funktion ok')
        RET
;
A1687:  POP     DE              ; Zeiger auf Textanfang wieder holen
        POP     HL              ; alten HL - Register - Wert wieder holen
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
;
;   Zeiger in DE auf n√§chstes relevantes Zeichen setzen
;
A168B:  INC     DE              ; Zeiger auf Text auf n√§chstes Zeichen
A168C:  LD      A,(DE)          ; ein Textzeichen holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A168B         ; ja -->  n√§chstes relevante Zeichen suchen
        RET
;
;
;   ASCII - Zeichen (DE) umsetzen in Hex - Wert nach Accu
;
A1692:  LD      A,(DE)          ; Textzeichen holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    21              ; Code 21  Sedezimal-ASCII-Zeichen im Accu umsetzen in Hex
        INC     DE              ; ausgewertetes Zeichen √ºberspringen
        RET
;
;
;   2 ASCII - Hex - Zeichen oder ein ASCII - Zeichen (DE) umsetzen in
;   entsprechenden Hex - Wert nach Accu
;
A1697:  CALL    A168C           ; Zeiger in DE auf n√§chstes relevantes Zeichen setzen
        CP      ';'             ; Strichpunkt  ?
        JR      Z,A16BC         ; ja -->  Hex - Wert des n√§chste ASCII - Zeichens holen
;
;
;   2 ASCII - Hex - Zeichen (DE) umsetzen in HEX - Wert nach Accu
;
A169E:  PUSH    BC              ; Register - Wert retten
        PUSH    DE              ; Zeiger auf Textanfang retten
        CALL    A1692           ; HEX-ASCII-Zeichen (DE) umsetzen in Hex-Wert nach Accu
        JR      C,A16B8         ; kein HEX - Zeichen -->  gerettete Register holen
        LD      C,A             ; High - Nibble - Wert merken
        CALL    A1692           ; HEX-ASCII-Zeichen (DE) umsetzen in Hex-Wert nach Accu
        JR      C,A16B8         ; kein HEX - Zeichen -->  gerettete Register holen
        LD      B,A             ; Low - Nibble merken
        LD      A,C             ; High - Nibble - Wert holen
        RLCA                    ;! auf High - Nibble schieben
        RLCA                    ;!
        RLCA                    ;!
        RLCA                    ;!
        ADD     A,B             ; plus Low - Nibble
        LD      C,A             ; Wert merken
        LD      A,C             ; und wieder holen  (Warum  ?)
        POP     BC              ; Zeiger auf Textanfang verwerfen
        POP     BC              ; geretteten Register - Wert holen
        OR      A               ; Carry - Flag zur√ºcksetzen  (Code for 'kein Fehler')
        RET
;
A16B8:  POP     DE              ; geretteten Zeiger auf Textanfang holen
        POP     BC              ; geretteten Register - Wert holen
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
A16BC:  INC     DE              ; Strichpunkt √ºberspringen
        LD      A,(DE)          ; Textzeichen holen
        INC     DE              ; ausgewertetes Textzeichen √ºberspringen
        OR      A               ; Carry-Flag zur√ºcksetzen   (Code 'kein Fehler')
        RET
;
;
;   Monitor - Befehl  G   (Programmaufruf)
;
A16C1:  CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        RET     C               ; Fehler aufgetreten -->  Monitor - Haupt - Schleife
        JP      (HL)            ; Programm aufrufen
;
;
;   Monitor - Befehl  D   (Speicherbereich ausgeben)
;
A16C6:  CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        JR      C,A16D6         ; keine Adresse angegeben -->  weiter ab letzter Stelle
        PUSH    HL              ; Anfangsadresse merken
        CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        JR      C,A16D5         ; keine Endadresse angegeben --> 128 Bytes ausgeben
        POP     DE              ; Anfangsadresse holen
        EX      DE,HL           ; Adressen vertauschen
        JR      A16DC           ; Speicherbereich ausgeben
;
A16D5:  POP     HL              ; Anfangsadresse holen
A16D6:  EX      DE,HL           ; Adresse nach DE
        LD      HL,128          ; 128 Bytes ausgeben
        ADD     HL,DE           ; Endadresse errechnen
        EX      DE,HL           ; Adressen vertauschen
A16DC:  LD      C,8             ; 8 Byte je Zeile ausgeben
        CALL    A16E9           ; eine Zeile aufbereiten und ausgeben
        RET     C               ; BREAK gedr√ºckt -->  Monitor - Schleife
        PUSH    HL              ; aktuelle Adresse retten
        SBC     HL,DE           ; mit Endadresse vergleichen
        POP     HL              ; aktuelle Adresse holen
        RET     NC              ; fertig
        JR      A16DC           ; weitere Zeilen ausgeben
;
;
;   eine Zeile f√ºr Monitor - Befehl D aufbereiten und ausgeben
;
A16E9:  CALL    A1711           ; Doppelpunkt, Anfangsadresse und = ausgeben
        LD      B,C             ; Anzahl Bytes je Zeile als Z√§hler vorgeben
        PUSH    HL              ; Adresse  'Anfang Zeile'  merken
A16EE:  LD      A,(HL)          ; ein Byte holen
        CALL    A1722           ; Hex-Wert im Accu umsetzen in ASCII-Hex-Wert und ausgeben
        INC     HL              ; Zeiger auf Speicher auf n√§chstes Byte
        LD      A,' '           ; Leerzeichen  (Space)  als Trennzeichen zwischen Bytes
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker ausgeben
        DJNZ    A16EE           ; weitere Speicherzellen ausgeben
        POP     HL              ; Adresse des Zeilenanfangs holen
        LD      A,'/'           ; Schr√§gstrich als Trennzeichen zwischen Bytes und Text
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker ausgeben
        LD      B,C             ; Anzahl Bytes je Zeile als Z√§hler vorgeben
A16FF:  LD      A,(HL)          ; ein Byte holen
        CP      ' '             ; Steuerzeichen  ?
        JR      NC,A1706        ; nein -->  Textzeichen ausgeben
        LD      A,'.'           ; Punkt f√ºr Steuerzeichen vorgeben
A1706:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker ausgeben
        INC     HL              ; Zeiger auf Speicher auf n√§chstes Byte
        DJNZ    A16FF           ; weitere Bytes als Text ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    8               ; Code 8  Zeilenvorschub auf Bildschirm oder Drucker ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    15              ; Code 15  wenn Space gedr√ºckt -->  warten bis andere Taste
        OR      A               ; Carry-Flag zur√ºcksetzen  (Code 'kein Fehler')
        RET
;
;
;   Doppelpunkt, Anfangsadresse und = ausgeben
;
A1711:  LD      A,':'           ; Doppelpunkt
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker ausgeben
        LD      A,H             ; High - Byte Adresse holen
        CALL    A1722           ; Hex-Wert im Accu umsetzen in ASCII-Hex-Wert und ausgeben
        LD      A,L             ; Low - Byte Adresse holen
        CALL    A1722           ; Hex-Wert im Accu umsetzen in ASCII-Hex-Wert und ausgeben
        LD      A,'='           ; Gleichheitszeichen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker ausgeben
        RET
;
;
;   Hex - Wert im Accu umsetzen in ASCII - Hex - Wert und ausgeben
;
A1722:  PUSH    AF              ; auszugebenden Wert retten
        RLCA                    ;! High - Nibble auf Low - Nibble schieben
        RLCA                    ;!
        RLCA                    ;!
        RLCA                    ;!
        CALL    A172B           ; Low - Nibble umsetzen in ASCII und ausgeben
        POP     AF              ; auszugebenden Wert holen
A172B:  AND     00001111B       ; Low - Nibble maskieren
        ADD     A,'0'           ; umsetzen in ASCII
        CP      '9' + 1         ; Dezimalziffer  ?
        JR      C,A1735         ; ja -->  ausgeben
        ADD     A,7             ; ASCII - Zeichen f√ºr A - F corrigieren
A1735:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker ausgeben
        RET
;
;
;   Monitor - Befehl  M   (Speicherbereich √§ndern)
;
A1738:  CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        LD      A,(S1091)       ; Monitor - Drucker - Status holen
        PUSH    AF              ; aktuellen Status merken
        XOR     A               ; Code for 'Ausgabe auf Bildschirm'
        LD      (S1091),A       ; als Monitor - Drucker - Status  merken
A1743:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    2               ; Code 2  Zeilenvorschub, wenn Cursor nicht auf Anfang Zeile
        CALL    A1711           ; Doppelpunkt, Anfangsadresse und = ausgeben
        LD      A,(HL)          ; ein Byte aus Speicher holen
        CALL    A1722           ; Hex-Wert im Accu umsetzen in ASCII-Hex-Wert und ausgeben
        LD      A,C_LEFT        ; Steuerzeichen  'Cursor links'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausf√ºhrung Steuerzeichen)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausf√ºhrung Steuerzeichen)
        CALL    A1651           ; Zeile von Tastatur holen und auswerten
        JR      NC,A1743        ; kein Fehler oder BREAK -->  n√§chste Zeile
        POP     AF              ; geretteten Drucker - Status holen
        LD      (S1091),A       ; alten Monitor - Drucker - Status wieder vorgeben
        RET
;
;
;   Monitor - Befehl  F   (Speicherbereich nach Bytefolge absuchen)
;
A175C:  CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        RET     C               ; Fehler aufgetreten -->  Monitor - Schleife
        PUSH    HL              ; Anfangsadresse retten
        CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        POP     BC              ; gerettete Anfangsadresse holen
        RET     C               ; Fehler aufgetreten -->  Monitor - Schleife
        PUSH    HL              ; Endadresse merken
        PUSH    BC              ; Anfangsadresse merken
        LD      HL,ZFF00        ; Zeiger auf Speicher f√ºr Suchbytefolge vorgeben
        CALL    A1667           ; ASCII-Hex-Zeichen oder Textzeichen umsetzen in Hex-Werte
        LD      DE,ZFF00        ; Zeiger auf Anfang Suchbytefolge 
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Anzahl Suchbytes errechnen
        LD      C,L             ; und merken
        POP     HL              ; Anfangsadresse holen 
        PUSH    HL              ; und merken
        EXX
        POP     HL              ; Anfangsadresse des Suchbereiches
        POP     DE              ; Endadresse des Suchbereiches
        EXX
        RET     Z               ; keine Suchbytes angegeben -->  fertig
A177C:  CALL    A17D6           ; Zeichen (HL) auf Suchbytes √ºberpr√ºfen
        JR      NZ,A1785        ; nicht Suchstring
        CALL    A16E9           ; gefundene Adresse und Bytes ausgeben
        RET     C               ; BREAK gedr√ºckt -->  Monitor - Schleife
A1785:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    14              ; Code 14   Abfrage, ob (Shift) BREAK gedr√ºckt ist
        RET     Z               ; Shift - BREAK gedr√ºckt -->  Monitor - Schleife
        EXX
        INC     HL              ; aktuelle Adresse plus eins
        PUSH    HL              ; aktuelle Adresse retten
        SCF                     ;! √ºberpr√ºfen, ob angegebenen Bereich durchsucht
        SBC     HL,DE           ;!
        POP     HL              ; aktuelle Adresse wieder holen
        RET     NC              ; fertig -->  Monitor - Schleife
        PUSH    HL              ; aktuelle Adresse auf Stack ablegen
        EXX
        POP     HL              ; aktuelle Adresse holen
        JR      A177C           ; weiter untersuchen
;
;
;   Anfangsadresse, Anzahl Bytes und Start-/Neue Adresse bereitstellen
;
A1795:  CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        PUSH    HL              ; Anfangsadresse retten
        CALL    NC,A1672        ; kein Fehler -->  4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        POP     BC              ; Anfangsadresse holen
        RET     C               ; Fehler aufgetreten -->  Abbruch
        SBC     HL,BC           ;! Anzahl Bytes errechnen
        INC     HL              ;!
        PUSH    HL              ; Anzahl Bytes merken
        PUSH    BC              ; Anfangsadresse merken
        CALL    A1672           ; 4 ASCII-Hex-Zeichen (DE) umsetzen in Hex-Wert nach HL
        PUSH    HL              ; Startadresse / Neue Adresse merken
        EXX
        POP     HL              ; Startadresse / Neue Adresse
        POP     DE              ; Anfangsadresse
        POP     BC              ; Anzahl Bytes
        RET
;
;
;   Monitor - Befehl  T   (Speicherblock verschieben)
;
A17AC:  CALL    A1795           ; Anfangs-, End- und neue Adresse bereitstellen
        RET     C               ; Fehler aufgetreten -->  Monitor - Schleife
        EX      DE,HL           ; Anfangs- und neue Adresse vertauschen
        PUSH    HL              ; Anfangsadresse retten
        SBC     HL,DE           ; Adressen vergleichen
        POP     HL              ; gerettete Anfangadresse holen
        JR      C,A17BA         ; von oben nach unten schieben
        LDIR                    ; Speicherblock verschieben
        RET
;
A17BA:  ADD     HL,BC           ;! Adressen auf Ende der Bereiche umrechnen
        DEC     HL              ;!
        EX      DE,HL           ;!
        ADD     HL,BC           ;!
        DEC     HL              ;!
        EX      DE,HL           ;!
        LDDR                    ; Speicherblock verschieben
        RET
;
;
;   Ger√§te- und Dateinamen auswerten und aufbereiten
;
A17C3:  LD      A,(DE)          ; ein Textzeichen holen
        OR      A               ; Textendezeichen  ?
        JR      Z,A17CC         ; ja -->  kein Dateiname angegeben
        INC     DE              ; Textzeichen √ºberspringen
        CP      ':'             ; Doppelpunkt  ?
        JR      NZ,A17C3        ; nein -->  weitersuchen
A17CC:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    23              ; Code 23  L√§nge des Textes (DE) ausz√§hlen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    45              ; Code 45   Ger√§te- und Dateinamen auswerten
        LD      A,_OBJ          ; Datei - Typ  OBJ - Datei   (Maschinensprachendatei)
        LD      (S1000),A       ; in Speicher f√ºr Kennung eintragen
        RET
;
;
;   in C angegebene Anzahl Bytes (DE) mit Bytes (HL) vergleichen
;
A17D6:  LD      A,(DE)          ;! erstes Byte vergleichen
        CP      (HL)            ;!
        RET     NZ              ; schon nicht gleich
        PUSH    BC              ; Anzahl Bytes retten
        PUSH    DE              ; Zeiger auf Vorgabe retten
        PUSH    HL              ; Zeiger auf Speicher retten
        LD      B,C             ; Anzahl zu vergleichende Bytes vorgeben
A17DD:  LD      A,(DE)          ;! ein Byte vergleichen
        CP      (HL)            ;!
        JR      NZ,A17E6        ; Bytes nicht gleich
        INC     DE              ;! Zeiger auf Bytes auf n√§chstes Paar
        INC     HL              ;! 
        DJNZ    A17DD           ; weitere Bytes vergleichen
        XOR     A               ; Code for 'Bytes gleich'  setzen  (unn√∂tig)
A17E6:  POP     HL              ; Zeiger auf Speicher holen
        POP     DE              ; Zeiger auf Vorgabe holen
        POP     BC              ; Anzahl Bytes holen
        RET
;
;
        DEFS    22,0
;
;
;   Weiterleitung Sprung auf Kaltstart  BASIC - Interpreter
;
        JP      A5800           ; Kaltstart BASIC - Programm
;
;
;   Abfrage, ob aktuelles Ger√§t gleich Bildschirm ist
;
A1803:  LD      A,(S1042)       ; interne aktuelle Ger√§te-/Dateinummer holen
        CP      136             ; gleich Bildschirm  (CRT:)  ?
        RET
;
;
;   Speicherbereich f√ºr Daten der aktuellen Datei
;
S1809:  DEFS    2               ; Zeiger auf aktuelle Dateikennung
;
S180B:  DEFS    2               ; Zeiger auf Anfang Speicher f√ºr Sektor
;
S180D:  DEFS    2               ; Zeiger auf Sektornummer im Sektor
;
;
;   Text (DE) auf angew√§hltem Ger√§t oder Datei ausgeben
;
;   (Software command code:  55)
;
A180F:  CALL    A181A           ; interne Ger√§te-Nummer als AUsgabe-Nummer vorgeben
        CALL    A1821           ; Text (DE) auf Datei/Ger√§t ausgeben
;
;
;   Ausgabe - Ger√§te - Nummer zur√ºcksetzen
;
A1815:  XOR     A               ; Accu auf Null
        LD      (S1FD9),A       ; Ausgabe - Ger√§te - Nummer zur√ºcksetzen
        RET
;
;
;   interne Ger√§te-Nummer als Ausgabe - Nummer vorgeben
;
A181A:  LD      A,(S1042)       ; interne aktuelle Ger√§te-/Dateinummer holen
        LD      (S1FD9),A       ; als Ausgabe - Ger√§te - Nummer merken
        RET
;
;
;   Text (DE) auf aktuellem Ger√§t oder aktueller Datei ausgeben
;
A1821:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      A,(S1050)       ; Ger√§te - Typ - Byte holen
        BIT     7,A             ; nicht Block - orientiertes Ger√§t  ?
        LD      HL,T1848        ; Adresse  'Zeichen an Datei ausgeben'
        JR      Z,A183D         ; Text (DE) mit L√§nge in B √ºber Routine (HL) ausgeben
        BIT     3,A             ; Zeilenorientertes Ger√§t  ?
        LD      HL,T1835        ; Adresse  'Text √ºber Ausgaberoutine ausgeben'
        JR      NZ,A183D        ; Text (DE) mit L√§nge in B √ºber Routine (HL) ausgeben
T1835:  LD      IX,(S105F)      ; Adresse  'Daten ausgeben'  aus Ger√§te - Tabelle holen
        CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        RET
;
;
;   in B angegebene Anzahl Bytes (DE) nach Routine (HL) ausgeben
;
A183D:  LD      A,B             ; Restanzahl Zeichen holen
        OR      A               ; Restanzahl gleich Null  ?
        RET     Z               ; ja -->  fertig
        LD      A,(DE)          ; ein Zeichen holen
        CALL    A00A7           ; JP (HL)   (Routine mit Adresse (HL) aufrufen)
        INC     DE              ; ausgegebenes Textzeichen √ºberspringen
        DEC     B               ; Restanzahl Zeichen minus eins
        JR      A183D           ; testen, ob fertig
;
;
;   Zeichen im Accu an Datei ausgeben
;
T1848:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      E,(IY+64)       ;! relativen Sektorzeiger holen
        LD      D,(IY+65)       ;!
        LD      HL,(S180B)      ; Zeiger auf Anfang Speicher f√ºr Sektor holen
        ADD     HL,DE           ; Zeiger auf Stelle f√ºr Zeichen errechnen
        LD      (HL),A          ; Textzeichen im Speicher f√ºr Sektor merken
        INC     DE              ; relativen Sektorzeiger plus eins
        LD      HL,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Sektor (oder Block) voll  ?
        CALL    Z,A1871         ; ja -->  Sektor wegschreiben
        LD      (IY+64),E       ;! neuen relativen Sektorzeiger merken
        LD      (IY+65),D       ;!
        INC     (IY+20)         ; Low - Byte Dateil√§nge plus eins
        RET     NZ              ; kein √úbertrag -->  fertig
        INC     (IY+21)         ; High - Byte Dateil√§nge plus eins
        RET     NZ              ; kein √úbertrag -->  OK
        JP      A1FA6           ; Fehler 55'  Too long file error
;
;
;   aktuellen Sektor der Datei wegschreiben
;
A1871:  PUSH    BC              ; Register - Wert retten
        LD      B,0010B         ; Code for 'Schreiben / nicht letzter Sektor'
A1874:  CALL    A1D27           ; aktuelles Ger√§t gleich Diskette  ?
        LD      IX,T1835        ; Adresse  'Sektor √ºber Ger√§te-Ausgabe-Routine ausgeben'
        JR      Z,A1881         ; nicht Diskette -->  √ºber Ger√§te-Ausgabe-Routine ausgeben
        LD      IX,A30D7        ; Adresse  'Sektor auf Diskette wegschreiben'   (nur RET)
A1881:  LD      A,B             ; Dateiendecode holen
        CALL    A18B6           ; Daten des aktuellen  (Sektoren-) Blocks laden
        CALL    A1890           ; Routine  (IX)  aufrufen
        INC     (IY+78)
        LD      DE,0            ; Vorgabe  'keine Zeichen im Sektor'
        POP     BC              ; geretteten Register - Wert holen
        RET
;
A1890:  JP      (IX)            ; Routine (IX) aufrufen
;
;
;   Dateiendezeichen in Datei eintragen und letzten Sektor/Block schreiben
;
A1892:  LD      A,CTRL_Z        ; Dateiendezeichen
        LD      E,(IY+64)       ;! relativen Sektorzeiger holen
        LD      D,(IY+65)       ;!
A189A:  LD      HL,(S180B)      ; Zeiger auf Anfang Speicher f√ºr Sektor holen
        ADD     HL,DE           ; Zeiger auf aktuelle Stelle im Sektorspeicher errechnen
        LD      (HL),A          ; Dateiendezeichen eintragen
        INC     DE              ; relativen Sektorzeiger plus eins
        LD      HL,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Zeiger auf Ende Sektor  ?
        JR      NZ,A189A        ; nein -->  Rest Speicher mit Dateiendezeichen auff√ºllen
        PUSH    BC              ; Register - Wert retten
        LD      HL,(S180B)      ; Zeiger auf Anfang Speicher f√ºr Sektor holen
        DEC     HL              ; Zeiger auf Stelle f√ºr Block - Nummer
        LD      (HL),-1         ;! Code for 'letzter Block'  eintragen
        DEC     HL              ;!
        LD      (HL),-1         ;!
        LD      B,0110B         ; Code for 'Schreiben / letzter Sektor'
        JR      A1874           ; letzten Sektor der Datei wegschreiben
;
;
;   Daten des aktuellen  (Sektoren-) Blocks laden
;
A18B6:  LD      BC,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        INC     BC              ;! f√ºr wahre Sektorl√§nge oder Blockl√§nge corrigieren
        INC     BC              ;!
        LD      HL,(S180B)      ; Zeiger auf Anfang Speicher f√ºr Sektor holen
        DEC     HL              ;! Zeiger auf Stelle f√ºr Block - Nummer setzen
        DEC     HL              ;!
        LD      DE,(S1809)      ; Zeiger auf aktuellen Dateikennungseintrag holen
        RET
;
;
;   Ger√§t in 'Stand By' schalten
;
B18C6:  DEFB    OR_N            ; Code for 'Stand By'
;
;
;   Datei auf Ger√§t nach Tabellenadresse schliessen
;
A18C7:  XOR     A               ; Code for 'Datei schliessen'
        LD      IX,(S1059)      ; Adresse  'Datei schliessen' aus Ger√§te-Tabelle holen
        CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        RET
;
;
;   wenn aktuelles Ger√§t gleich Bildschirm -->  Zeile von Tastatur holen
;
;   (Software command code:  52)
;
A18D0:  CALL    A1803           ; Abfrage, ob aktuelles Ger√§t gleich Bildschirm ist
        RET     NZ              ; nicht Bildschirm -->  fertig
        PUSH    DE              ; Register - Wert retten
        LD      DE,S11A4        ; Zeiger auf Zwischenspeicher vorgeben
        CALL    A0A67           ; Zeiger von Tastatur holen und Zeiger auf Eingabe stellen
        LD      (A193B + 1),DE  ; Zeiger auf eingegebenen Text in Routine eintragen
        POP     DE              ; geretteten Register - Wert holen
        RET     NC              ; Eingabe nicht geBREAKt
        JP      A00E8           ; Programm abbrechen  (BREAK)
;
;
;   einen Datensatz aus Datei oder vom angew√§hltem Ger√§t bereitstellen
;   (mit Untersuchung auf 'End of File')
;
;   (Software command code:  53)
;
A18E4:  PUSH    HL              ; Register - Wert retten
        PUSH    DE              ; Zeiger auf Stelle f√ºr Datensatz merken
        CALL    A181A           ; interne Ger√§te-Nummer als Ausgabe-Nummer vorgeben
        LD      HL,(S1040)      ; Zeiger auf aktuellen Daten-Verwaltungssatz holen
        INC     HL              ; Datei - Nummer √ºberspringen
        BIT     7,(HL)          ; EOF - Bit gesetzt   ?
        PUSH    HL              ; Zeiger auf EOF - Bit retten
        LD      B,0             ; Code for 'keine Zeichen bereitgestellt'  vorgeben
        SCF                     ; vorsorglich schon mal EOF - Flag setzen
        CALL    Z,A1913         ; nicht EOF -->  einen Datensatz bereitstellen
        POP     HL              ; Zeiger auf EOF - Bit holen
        CALL    C,A1908         ; End of File -->  merken
        POP     DE              ; Zeiger auf Stelle f√ºr Datensatz holen
        PUSH    AF              ; Ergebnisflag retten
        CALL    A1815           ; Ausgabe - Ger√§te - Nummer zur√ºcksetzen
        LD      L,B             ; bereitgestellte Anzahl Zeichen vorgeben
        LD      H,0             ; High - Byte Offset auf Null
        ADD     HL,DE           ; Zeiger auf Ende der bereitgestellten Daten errechnen
        LD      (HL),NUL        ; Textendezeichen eintragen
        POP     AF              ; gerettetes Ergebnisflag holen
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;   End of File  setzen und eventuell Fehler ausgeben
;
A1908:  SET     7,(HL)          ; Code for 'End of File'  setzen
        LD      HL,S1051        ; Ger√§te - Nummer - Flag holen
        BIT     4,(HL)          ; End - of File nicht erlaubt  ?
        RET     Z               ; End of File erlaubt
        JP      A1FB5           ; Fehler 63   Out of file error
;
;
;   einen Datensatz von Ger√§t/Datei bereitstellen
;
A1913:  CALL    A1803           ; Abfrage, ob aktuelles Ger√§t gleich Bildschirm ist
        JR      Z,A193B         ; Bildschirm -->  untersuchen, ob noch Text vorhanden ist
        LD      A,(S1050)       ; Ger√§te - Typ - Byte holen
        BIT     7,A             ; nicht Block - orientiertes Ger√§t  ?
        LD      HL,T1991        ; Adresse  'ein Zeichen aus Datenblock Datei bereitstellen'
        JR      Z,A1975         ; Block - Orientiertes Ger√§t
        BIT     2,A             ; 'Ger√§t stellt nur einzelne Zeichen zur Verf√ºgung'  ?
        LD      HL,A1929        ; Adresse  'Daten bereitstellen aufrufen'  vorgeben
        JR      NZ,A1975        ; ja -->  Datensatz √ºber einzelne Zeichen einlesen
A1929:  LD      IX,(S105D)      ; Anfangsadresse  'Daten bereistellen' aus Ger√§te-Tabelle holen
        CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        RET
;
;
;   Fragezeichen ausgeben und Zeile von Tastatur holen
;
A1931:  LD      A,'?'           ; ?   (Fragezeichen)  vorgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausf√ºhrung Steuerzeichen)
        LD      A,' '           ; Leerzeichen  (Space)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausf√ºhrung Steuerzeichen)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    52              ; Code 52  wenn akt. Ger√§t=Bildschirm -->  Zeile von Tastatur
A193B:  LD      HL,0            ; Zeiger auf Text holen  (wird eingetragen)
        CALL    A015E           ; Leerzeichen (Spaces)  (HL) √ºberspringen
        OR      A               ; Textendezeichen  (NUL)  ?
        JR      Z,A1931         ; ja -->  erneut Text von Tastatur holen
        LD      C,NUL           ; Textendezeichen als Endezeichen vorgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    54              ; Code 54  Textkonstante (HL) bis Zeichen in C bereitstellen
        LD      (A193B + 1),HL  ; Zeiger auf Resttext wieder in Routine eintragen
        RET
;
;
;   Textkonstante (HL) bis Trennzeichen oder Zeichen in C nach (DE) bereitstellen
;
;   (Software command code:  54)
;
A194C:  LD      B,0             ; Z√§hler  'Anzahl √ºbertragene Zeichen '  auf Null
        CALL    A0164           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFB    '\"'            ; Anf√ºhrungszeichen  (Kennung Textkonstante)  ?
        JR      NZ,A1967        ; kein Anf√ºhrungszeichen
A1954:  LD      A,(HL)          ; ein Zeichen Text holen
        OR      A               ; Textendezeichen  (NUL)   ?
        RET     Z               ; ja -->  fertig
        INC     HL              ; Zeiger auf Text auf n√§chstes Zeichen
        CP      '\"'            ; Anf√ºhrungszeichen  ?
        JR      Z,A1961         ; ja -->  wenn n√§chstes Zeichen Komma -->  vergessen
        LD      (DE),A          ; Textzeichen merken
        INC     DE              ; Zeiger auf Speicher f√ºr Text auf n√§chste Stelle
        INC     B               ; Z√§hler  'Anzahl √ºbertragene Zeichen '  plus eins
        JR      A1954           ; testen, ob weitere Zeichen
;
A1961:  CALL    A0164           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    ","             ; Komma  ?
        OR      A               ; Carry - Flag zur√ºcksetzen   (Code for 'kein Fehler')
        RET
;
A1967:  LD      A,(HL)          ; ein Zeichen Text holen
        OR      A               ; Textendezeichen  (NUL)   ?
        RET     Z               ; ja -->  fertig
        CP      C               ; gleich vorgegebenem Textendezeichen  ?
        RET     Z               ; ja -->  fertig
        INC     HL              ; Textzeichen √ºberspringen
        CP      ','             ; Komma als Trennzeichen  ?
        RET     Z               ; ja -->  fertig
        LD      (DE),A          ; Textzeichen merken
        INC     DE              ; Zeiger auf Speicher f√ºr Text auf n√§chste Stelle
        INC     B               ; Z√§hler  'Anzahl √ºbertragene Zeichen'  plus eins
        JR      A1967           ; testen, ob weitere Zeichen
;
;
;   einen Datensatz aus Datei √ºber einzelne Zeichen bereitstellen
;
A1975:  LD      (A197A + 1),HL  ; CALL - Adresse in Routine eintragen
        LD      B,0             ; Z√§hler  'Anzahl bereitgestellte Zeichen'  auf Null
A197A:  CALL    0               ; ein Zeichen bereitstellen   (Adresse wird eingetragen)
        RET     C               ; Fehler aufgetreten -->  Abbruch
        CP      CR              ; Textendezeichen  ?
        RET     Z               ; ja -->  fertig
        LD      (DE),A          ; bereitgestelltes Zeichen merken
        INC     DE              ; Zeiger auf Speicher f√ºr Text auf n√§chste Stelle
        INC     B               ; Z√§hler  'Anzahl bereitgestellte Zeichen'  plus eins
        JR      NZ,A197A        ; noch OK -->  weitere Zeichen bereitstellen
        JP      A1F8B           ; Fehler  41   Hardware error
;
;
;   n√§chsten Datenblock der Datei  (oder ein Zeichen)  bereitstellen
;
;   (Software command code:  39)
;
A1989:  LD      A,(S1050)       ; Ger√§te - Typ - Byte holen
        BIT     7,A             ; nicht Block - orientiertes Ger√§t  ?
        JP      NZ,A1FAC        ; ja -->  Fehler 59'  Can't execute error
T1991:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      E,(IY+64)       ;! relativen Sektorzeiger holen
        LD      D,(IY+65)       ;!
        LD      HL,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; alle Zeichen aus Speicher geholt  ?
        CALL    Z,A19BC         ; ja -->  n√§chsten Sektor oder Block einlesen
        RET     C               ; Fehler aufgetreten -->  Abbruch
        LD      L,(IY+78)       
        LD      H,(IY+79)
        XOR     A               ; Accu auf Null / Carry - Flag zur√ºcksetzen
        SBC     HL,DE
        SCF                     ; Code for 'Fehler aufgetreten' setzen
        RET     Z               ; keine Zeichen mehr vorhanden
        LD      HL,(S180B)      ; Zeiger auf Anfang Speicher f√ºr Sektor holen
        ADD     HL,DE           ; Zeiger auf aktuelle Stelle im Sektor errechnen
        LD      A,(HL)          ; Zeichen aus Speicher f√ºr Sektor holen
        INC     DE              ; relativen Zeiger auf Sektor auf n√§chstes Zeichen
        LD      (IY+64),E       ;! neuen relativen Sektorzeiger merken
        LD      (IY+65),D       ;!
        RET
;
;
;   n√§chsten Sektor aus Datei einlesen
;
A19BC:  CALL    A1D27           ; aktuelles Ger√§t gleich Diskette  ?
        JP      NZ,A321C        ; ja -->  n√§chsten Sektor von Diskette lesen
        DEFB    OR_N            ; Code for 'n√§chsten sektor lesen'
;
;  
;   ersten Sektor der Datei einlesen
;
A19C3:  XOR     A               ; Code for 'ersten Sektor lesen'
        CALL    A18B6           ; Daten des aktuellen  (Sektoren-) Blocks laden
        CALL    A1929           ; Datenblock nach Adresse in Ger√§te-Tabelle bereitstellen
        RET     C               ; Fehler aufgetreten -->  Abbruch
        LD      A,(HL)          ;! Block - Nummer gleich 0FFFFH   (letzter Block)  ?
        INC     HL              ;!
        AND     (HL)            ;!
        LD      (HL),255        ;      255 Zeichen im Block
        INC     A               ;!
        LD      DE,0            ; Offset auf Speicherblock vorgeben
        RET     NZ              ; nicht letzter Block
        PUSH    HL
        LD      HL,(S180D)      ; Zeiger auf Sektornummer im Sektor holen
        LD      BC,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
A19DD:  DEC     HL              ; Zeiger auf vorheriges Zeichen 
        DEC     BC              ; Z√§hler  'Restanzahl Zeichen'  minus eins
        LD      A,(HL)          ; ein Zeichen holen
        OR      A               ; gleich NUL   (Textendezeichen)  ?
        JR      Z,A19DD         ; ja -->  letztes relevantes Zeichen suchen
        POP     HL
        LD      (HL),B          ;! Restanzahl Zeichen im Block eintragen
        DEC     HL              ;!
        LD      (HL),C          ;!
        RET
;
;
;   internen Datei - Verwaltungs - Datensatz nach Datei-/Ger√§te-Nummer aufbereiten
;
;   (Software command code:  46)
;
A19E8:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      HL,B1A35        ; Zeiger auf Vorgabe f√ºr Ger√§t Bildschirm  (CRT:)
        CP      136             ; Ger√§t Bildschirm  ?
        JR      Z,A19FC         ; ja -->  Daten f√ºr Bildschirm vorgeben
        LD      HL,B1A3D        ; Zeiger auf Vorgabe f√ºr Ger√§t Drucker  (LPT:)
        CP      137             ; Ger√§t Drucker  ?
        JR      Z,A19FC         ; ja -->  Daten f√ºr Drucker vorgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    41              ; Code 41  Zeiger auf Datensatz nach Datensatznr bereitstellen
        RET     C               ; Datei - Datensatz nicht gefunden -->  Abbruch
A19FC:  LD      (S1040),HL      ; Zeiger auf aktuellen Daten-Verwaltungssatz merken
        LD      DE,S1042        ; Zeiger auf Stelle f√ºr aktuellen Ger√§te-/Dateiverwaltungsdatensatz
        LD      BC,8            ; Zugriffscode / Zeiger / Nummer / USR - Adresse
        LDIR                    ; Daten √ºbertragen
        LD      (S1809),HL      ; Zeiger auf aktuelle Dateikennung merken
        PUSH    HL              ;! Zeiger auf Dateikennung nach IY √ºbertragen
        POP     IY              ;!
        LD      DE,S1000        ; Zeiger auf Speicher f√ºr Dateikennung vorgeben
        CALL    A1C66           ; 64 Byte  (L√§nge Kennungsdaten)  von (HL) nach (DE) √ºbertragen
        PUSH    HL              ; Zeiger auf Ende Kennung retten
        LD      HL,(S1044)      ; Zeiger auf aktuelle Ger√§te - Tabelle holen
        LD      DE,S104A        ; Zeiger auf Speicher f√ºr Ger√§te - Tabelle vorgeben
        LD      BC,29           ; L√§nge Ger√§te - Tabelle vorgeben
        LDIR                    ; Ger√§te - Tabelle in Speicher √ºbertragen
        POP     HL              ; Zeiger auf Ende Kennung holen
        LD      BC,16           ; Offset auf Anfang Sektor
        ADD     HL,BC           ; Zeiger auf Anfang Sektor errechnen
        LD      (S180B),HL      ; Zeiger auf Anfang Speicher f√ºr Sektor merken
        LD      BC,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        ADD     HL,BC           ; Zeiger auf Stelle f√ºr Sektornummer errechnen
        LD      (S180D),HL      ; Zeiger auf Sektornummer im Sektor merken
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        AND     00001111B       ; eigentlichen Zugriffscode  maskieren
        RET
;
;
;   Vorgabe f√ºr Dateidaten f√ºr Ger√§t  Bildschirm
;
B1A35:  DEFB    136             ; interne Ger√§te - Nummer  Ger√§t CRT:
        DEFB    00000011B       ; Lesen / Schreiben m√∂glich
        DEFW    W0DDD           ; Zeiger auf Ger√§te - Tabelle Bildschirm
        DEFW    0
        DEFW    0
;
;
;   Vorgabe f√ºr Dateidaten f√ºr Ger√§t  Drucker
;
B1A3D:  DEFB    137             ; interne Ger√§te - Nummer  Ger√§t LPT:
        DEFB    00000010B       ; Schreiben  m√∂glich
        DEFW    W1479           ; Zeiger auf Ger√§te - Tabelle  Drucker
        DEFW    0
        DEFW    0
;
;
;   Text (DE) auf Ger√§te - Namen auswerten und als aktuelles Ger√§t bereitstellen
;
;   (Software command code:  44)
;
A1A45:  LD      HL,S11A4        ; Zeiger auf Zwischenspeicher f√ºr Text vorgeben
        PUSH    HL              ; Zeiger auf Anfang Speicher retten
        LD      A,B             ; Textl√§nge holen
        OR      A               ; gleich Null  ?
        CALL    NZ,A014A        ; nein -->  Speicherbereic√® vo√Æ (DE¬© nac√® (HL¬© verschieben
        LD      (HL),NUL        ; Textende hinter bereitgestelltem Text eintragen
        LD      HL,W0DDD        ; Zeiger auf erstes Ger√§t in Tabellenkette
        JR      A1A58           ; richtige Ger√§te - Tabelle suchen
;
A1A55:  LD      HL,0            ; Zeiger auf n√§chste Ger√§te-Tabelle  (wird eingetragen)
A1A58:  LD      A,L             ;! Zeiger gleich Null  (Ende Kette)  ?
        OR      H               ;!
        JR      Z,A1A91         ; ja -->  DEFAULT - Ger√§t vorgeben
        LD      (D1A8B + 1),HL  ; Zeiger auf aktuelle Tabelle in Routine eintragen
        CALL    A012D           ; Adresse aus Tabelle (HL) nach DE holen
        LD      (A1A55 + 1),DE  ; Zeiger auf n√§chste Tabelle in Routine eintragen
        LD      DE,S11A4        ; Zeiger auf Speicher mit Ger√§te - Namen
        EX      DE,HL           ; Zeiger vertauschen
A1A6A:  LD      A,(DE)          ; ein Zeichen aus Ger√§te - Tabelle holen
        OR      A               ; Textendezeichen  (NUL)   ?
        JR      Z,A1A75         ; ja -->  untersuchen, ob Ger√§te - Nummer
        CP      (HL)            ; Zeichen mit Ger√§te - Namen vergleichen
        JR      NZ,A1A55        ; nicht gleich -->  n√§chsten Ger√§te - Namen testen
        INC     HL              ; Zeiger auf vorgegebenen Namen auf n√§chstes Zeichen
        INC     DE              ; Zeiger auf Namen in Tabelle auf n√§chstes Zeichen
        JR      A1A6A           ; n√§chstes Zeichen Name vergleichen
;
A1A75:  LD      A,(HL)          ; n√§chstes Zeichen Ger√§te - Name holen
        INC     HL              ; Zeichen √ºberspringen
        CP      ':'             ; Doppelpunkt   (Namenendezeichen)   ?
        LD      C,0             ; Vorgabe f√ºr Ger√§te - Nummer
        JR      Z,A1A8A         ; keine Ger√§te - Nummer im Namen
        SUB     '1'             ; Nummer umrechnen in Dezimal-Wert
        CP      9               ; Ger√§t eins bis acht  ?
        JR      NC,A1A55        ; nein -->  auf n√§chste Ger√§te - Tabelle vergleichen
        LD      C,A             ; Ger√§te - Nummer merken
        LD      A,(HL)          ; n√§chstes Textzeichen holen
        INC     HL              ; Textzeichen √ºberspringen
        CP      ':'             ; Doppelpunkt  (Namenendezeichen)   ?
        JR      NZ,A1A55        ; nein -->  n√§chste Ger√§te - Tabelle vergleichen
A1A8A:  EX      (SP),HL         ; Zeiger verwerfen / Zeiger auf Dateinamen retten
D1A8B:  LD      HL,0            ; Zeiger auf Ger√§te-Tabelle   (wird eingetragen)
        LD      A,C             ; Ger√§te - Nummer holen
        JR      A1AA3           ; Ger√§te - Nummer und Zeiger auf Tabelle merken
;
A1A91:  POP     HL              ; Zeiger auf Ger√§te - Namen holen
        PUSH    HL              ; und wieder merken
A1A93:  LD      A,(HL)          ; ein Zeichen holen
        INC     HL              ; Zeiger auf Namen auf n√§chstes Zeichen
        CP      ':'             ; Doppelpunkt   ?
        JP      Z,A1FA9         ; ja -->  Fehler 58  Dev. name error
        OR      A               ; Textendezeichen  (NUL)  ?
        JR      NZ,A1A93        ; nein -->  Rest Name auf Doppelpunkt √ºberpr√ºfen
        LD      HL,(S106A)      ; Zeiger auf Ger√§te - Tabelle  (DEFAULT) holen
        LD      A,(S1069)       ; Ger√§te - Nummer  (DEFAULT)  holen
A1AA3:  LD      (S1044),HL      ; Zeiger auf aktuelle Ger√§te - Tabelle merken
        PUSH    HL              ; Zeiger merken
        LD      (S1046),A       ; aktuelle Ger√§te - Nummer merken
        LD      DE,S104A        ; Zeiger auf Speicherbereich f√ºr Ger√§te - Tabelle
        LD      BC,29           ; L√§nge Ger√§te - Tabelle
        LDIR                    ; Ger√§te - Tabelle in Speicher √ºbertragen
        LD      B,A             ; Ger√§te - Nummer merken
        LD      A,(S1051)       ; Ger√§te - Nummern - Flag holen
        AND     00000111B       ; maximale Ger√§te - Nummer maskieren
        CP      B               ; mit angegebener Ger√§te-Nummer vergleichen
        JP      C,A1FA9         ; Nummer zu gro√ü -->  Fehler 58  Dev. name error
        LD      A,B             ; Ger√§te - Nummer holen
        POP     DE              ; Zeiger auf aktuelle Ger√§te - Tabelle holen
        POP     HL              ; Zeiger auf Resttext mit Dateinamen holen
        RET
;
;
;   Text (DE) auf Ger√§te - Namen und Datei - Namen auswerten
;
;   (Software- Kommando  45)
;
A1AC0:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    44              ; Code 44   Text (DE) auf Ger√§te - Namen auswerten
        EX      DE,HL           ; Zeiger auf Datei - Namen nach DE
        LD      HL,S1001        ; Zeiger auf Speicher f√ºr Dateinamen in Kennung
        LD      B,31            ; Restl√§nge Dateikennung
        CALL    A0137           ; Speicherbereich (HL) l√∂schen
        LD      HL,S1000        ; Zeiger auf Speicherbereich f√ºr Dateikennung
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    23              ; Code 23  L√§nge des Textes (DE) ausz√§hlen
        CALL    A1EC9           ; Dateinamen aus Text (DE) nach (HL) bereitstellen
        LD      HL,S1050        ; Zeiger auf Ger√§te - Typ - Byte vorgeben
        BIT     4,(HL)          ; auf Dateinamen untersuchen  ?
        RET     Z               ; nein -->  fertig
        INC     HL              ; Zeiger auf Ger√§te - Nummern - Byte
        BIT     7,(HL)          ; mu√ü Dateiname angegeben sein  ?
        RET     NZ              ; nein -->  fertig
        LD      A,(S1001)       ; erstes Zeichen des aufbereiteten Dateinamens holen
        CP      CR              ; gleich Namenendezeichen  ?
        JP      Z,A1FAF         ; ja -->  Fehler 60  Illegal filename error
        RET
;
;
;   Datei nach bereitgestellten Daten er√∂ffnen
;
;   (Software- Kommando  51)
;
A1AE9:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        CALL    A1AF7           ; Speicherplatz f√ºr Verwaltung reservieren / Datei er√∂ffnen
        LD      B,00000000B     ; Code for 'Vom Basic verarbeitbare Datei'
        CALL    A1BA9           ; Datei - Kennung √ºberpr√ºfen
        JP      A34CE           ; nicht mehr ben√∂tigte Diskettendaten l√∂schen
;
;
;   Speicherbereich f√ºr Verwaltungsdatensatz im Rechner reservieren
;   und Datei auf Ger√§t er√∂ffnen
;
A1AF7:  LD      A,(S1042)       ; interne aktuelle Ger√§te-/Dateinummer holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    41              ; Code 41  Zeiger auf Datensatz nach Datensatznr bereitstellen
        JP      NC,A1F91        ; Datensatz gefunden -->  Fehler 43`  Already open error
        CALL    A1C6D           ; testen, ob auf ger√§t nicht schon Datei er√∂ffnet ist
        LD      HL,64 + 29      ; L√§nge  Datei - Kennung und Ger√§te - Tabelle
        LD      A,(S1050)       ; Ger√§te - Typ - Byte holen
        LD      DE,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        INC     DE              ;! auf Sektorl√§nge corrigieren
        INC     DE              ;!
        BIT     7,A             ; nicht Block - orientiertes Ger√§t  ?
        JR      NZ,A1B13        ; ja -->  kein Sektorpuffer
        ADD     HL,DE           ; Sektorl√§nge addieren
A1B13:  LD      A,(S1043)       ; Datei - Zugriffscode holen
        BIT     2,A             ; RANDOM - Datei  ?
        JR      Z,A1B1B         ; nein
        ADD     HL,DE           ; Sektorl√§nge noch einmal addieren
A1B1B:  EX      DE,HL           ; Speicherl√§nge f√ºr Datei - Datensatz nach DE
        LD      A,(S1042)       ; interne aktuelle Ger√§te-/Dateinummer holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    42              ; Code 42   dynamischen Zwischenspeicher bereitstellen
        LD      (S1FD9),A       ; Ausgabe - Ger√§te - Nummer merken
        LD      (S1040),HL      ; Zeiger auf aktuellen Daten-Verwaltungssatz merken
        EX      DE,HL           ; Zeiger auf Speicher f√ºr Datei-Datensatz nach DE
        LD      HL,S1042        ; Zeiger auf interne Ger√§te - Nummer / Dateinummer
        LD      BC,8            ; Datensatzl√§nge
        LDIR                    ; aktuellen Datensatz in Datei - Daten merken
        LD      (S1809),DE      ; Zeiger auf aktuelle Datei - Kennung merken
        PUSH    DE              ;! Zeiger auf Datei - Kennung nach IY holen
        POP     IY              ;!
        LD      HL,S1000        ; Zeiger auf Speicher mit aufbereiteter Dateikennung
        CALL    A1C66           ; 64 Byte  (L√§nge Kennungsdaten)  von (HL) nach (DE) √ºbertragen
        LD      HL,16           ; Abstand zum Sektorspeicher
        ADD     HL,DE           ; Zeiger auf Sektorspeicher errechnen
        LD      (S180B),HL      ; Zeiger auf Anfang Speicher f√ºr Sektor merken
        LD      DE,(S105B)      ; maximale Anzahl Zeichen im Sektor holen
        ADD     HL,DE           ; Zeiger auf Stelle f√ºr Sektornummer errechnen
        LD      (S180D),HL      ; Zeiger auf Stelle f√ºr Sektornummer im Sektor merken
        CALL    A1D27           ; aktuelles Ger√§t gleich Diskette  ?
        JP      NZ,A334F        ; ja -->  Datei auf Diskette er√∂ffnen
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        BIT     2,A             ; Schreib - Lesezugriff  (RANDOM-Datei)  ?
        JP      NZ,A1FAC        ; ja -->  Fehler 59'  Can't execute error
        BIT     1,A             ; Datei zum Schreiben er√∂ffnen  ?
        LD      IX,(S1057)      ; Adresse  'Datei zum Schreiben er√∂ffnen'  holen
        JR      NZ,A1B6D        ; Datei zum Schreiben er√∂ffnen
        LD      A,(S1050)       ; Ger√§te - Typ - Byte holen
        BIT     7,A             ; nicht Block - orientiertes Ger√§t  ?
        JR      Z,A1B73         ; nein
        LD      IX,(S1055)      ; Adresse  'Datei zum Lesen er√∂ffnen'  holen
A1B6D:  LD      HL,S1000        ; Zeiger auf aufbereitete Datei - Kennung
        JP      A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
;
A1B73:  LD      B,(IY+0)        ; Datei - Typ - Flag aus Datensatz holen
        CALL    A1C4B           ; Datei zum Lesen er√∂ffnen
        LD      A,(S1000)       ; Datei-Typ-Flag aus bereitgestellter Kennung holen
        CP      B               ; mit Datei - Typ - Flag vergleichen
        JP      NZ,A1FB2        ; nicht gleich -->  Fehler 61
        JP      A19C3           ; ersten Sektor der Datei lesen
;
;
;   Datei zum Lesen er√∂ffnen     (Software command code:  47)
;
A1B83:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      IY,256 * 1 + 0  ; Code for 'Datei zum Lesen er√∂ffnen'
        LD      (S1042),IY      ; als interne aktelle Ger√§te-Nummer/Zugriffscode merken
        LD      IY,S1000        ; Zeiger auf Speicher f√ºr Dateikennung vorgeben
        CALL    A1D27           ; aktuelles Ger√§t gleich Diskette  ?
        LD      HL,T334A        ; Adresse  'Datei auf Diskette er√∂ffnen'
        JR      NZ,A1B9D        ; ja -->  Datei auf Diskette er√∂ffnen
        LD      HL,A1C4B        ; Adresse  'Datei zum Lesen er√∂ffnen'
A1B9D:  CALL    A00A7           ; JP (HL)   (Routine mit Adresse (HL) aufrufen)
        LD      B,10000000B     ; Code for 'vom Basic nicht bearbeitbare Datei'
        CALL    A1BA9           ; Datei - Kennung √ºberpr√ºfen
        LD      A,(S1000)       ; Datei - Typ - Flag holen
        RET
;
;
;   Datei - Kennung √ºberpr√ºfen
;
A1BA9:  LD      A,(S1000)       ; Datei - Typ - Kennung holen
        CP      _BRD + 1        ; bekannte Datei - Kennung  ?
        RET     C               ; ja -->  OK
        LD      A,(S1012)       ; Schreib - Schutz - Flag holen
        AND     10000000B       ; Bit  'vom Basic bearbeitbar'  maskieren
        CP      B               ; gleich richtigem Status  ?
        RET     Z               ; ja
        JP      A1FB2           ; Fehler 61, Illegal filemode error
;
;
;   Datei schliessen oder Dateidaten im Rechner l√∂schen
;
;   (Software command code:  56)
;
A1BB9:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        OR      A               ; Datei - Nummer angegeben  ?
        JR      Z,A1BFF         ; nein -->  alle Dateien behandeln
        CALL    A1BC5           ; Datei mit Nummer im Accu schliessen oder Dateidaten l√∂schen
        JP      A34CE           ; nicht mehr ben√∂tigte Diskettendaten l√∂schen
;
;
;   Datei mit Nummer im Accu schliessen oder Daten der Datei im Rechner l√∂schen
;
A1BC5:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    46              ; Code 46   Datei-Verwaltungssatz nach Nummer bereitstellen
        RET     C               ; keine Datei - Daten im Rechner
        CALL    A181A           ; interne Ger√§te-Nummer als Ausgabe-Nummer vorgeben
        PUSH    AF              ; interne Ger√§te - Nummer merken
        CALL    A1D27           ; aktuelles Ger√§t gleich Diskette  ?
        JR      NZ,A1BF3        ; ja -->  Datei auf Diskette
        BIT     7,A             ; nicht Block - orientiertes Ger√§t  ?
        LD      A,B             ; FLag  'Schlie√üen/L√∂schen'  holen
        JR      Z,A1BE6         ; Block - orientiertes Ger√§t
        OR      A               ; Schlie√üen oder L√∂schen  ?
        LD      IX,(S105B)      ; Anfangsadresse der KILL - Routine holen
        JR      Z,A1BE1         ; Datei - Daten l√∂schen
        LD      IX,(S1059)      ; Anfangsadresse der CLOSE - Routine holen
A1BE1:  CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        JR      A1BF6           ; dynamisches Segment l√∂schen
;
A1BE6:  OR      A               ; Datei schliessen oder Dateidaten l√∂schen
        JR      Z,A1BF6         ; Datei - Daten im Rechner l√∂schen
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        BIT     1,A             ; Datei zum Schreiben ge√∂ffnet  ?
        CALL    NZ,A1892        ; ja -->  Dateiendezeichen eintragen/Sektor wegschreiben
        JR      A1BF6           ; dynamisches Segment l√∂schen
;
;
;   Datei auf Diskette schliessen oder Dateidaten im Rechner l√∂schen
;
A1BF3:  CALL    A33C1           ; Datei, wenn n√∂tig ins Inhaltsverzeichnis eintragen
A1BF6:  POP     AF              ; Interne Datei - Nummer holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    43              ; Code 43   dynamischen Zwischenspeicher l√∂schen
        RET
;
;
;   alle Dateidaten im Rechner l√∂schen     (Software command code:  40)
;
A1BFA:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      B,0             ; Code for 'Dateidaten l√∂schen'
;
;
;   alle offenen Dateien schliessen oder alle Datedaten im Rechner l√∂schen
;
A1BFF:  LD      C,142           ; interne Datei - Nummer vorgeben
A1C01:  LD      A,C             ; Datei - Nummer holen
        PUSH    BC              ; Flag und Datei - Nummer retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    41              ; Code 41  Zeiger auf Datensatz nach Datensatznr bereitstellen
        CALL    NC,A1BC5        ; Datensatz vorhanden -->  Datei schliessen oder Dateidaten l√∂schen
        POP     BC              ; Flag und Datei - Nummer holen
        DEC     C               ; Datei - Nummer minus eins
        JR      NZ,A1C01        ; weitere Dateien schliessen oder Datei - Daten l√∂schen
        JP      A1FC0           ; Datei-Daten der Ausgabe-Datei  (wenn vorhanden)  l√∂schen
;
;
;   testen, ob  Datei - Name schon auf Ger√§t / Datentr√§ger vorhanden ist
;
A1C0F:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      A,(S1050)       ; Ger√§te - Typ - Byte holen
        BIT     6,A             ; mehrere Dateinamen zul√§ssig  ?
        JP      Z,A1FAC         ; nein -->  Fehler 59'  Can't execute error
        CALL    A18C7           ; Datei auf Ger√§t nach Tabellenadresse schliessen
        LD      A,(S1052)       ; maximale Anzahl Dateien auf Ger√§t/Dateitr√§ger holen
        LD      B,A             ; Z√§hler merken
A1C21:  LD      HL,S11A4        ; Zeiger auf Zwischenspeicher vorgeben
        PUSH    BC              ; Z√§hler retten
        LD      IX,(S1055)      ; Adresse  'Datei zum Lesen er√∂ffnen'  aus Ger√§te - Tabelle holen
        CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        POP     BC              ; geretteten Z√§hler holen
        SET     0,A             ; Code for 'Fehler'  setzen
        RET     C               ; Fehler aufgetreten -->  Abbruch
        PUSH    IY              ;! Zeiger auf Kennung der aktuellen Datei nach DE
        POP     DE              ;!
        CALL    A1EB2           ; Dateinamen (HL) mit Dateinamen (DE) vergleichen
        LD      A,(HL)          ; Datei - Typ - Kennung holen
        RET     Z               ; Datei - Namen gleich
        DJNZ    A1C21           ; weitere Dateien testen
        XOR     A               ; Code for 'Dateinamen nicht gefunden'
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
;
;   testen, ob Datei noch nicht vorhanden und noch Platz f√ºr neue Datei
;
A1C3D:  CALL    A1C6D           ; testen, ob auf Ger√§t nicht schon Datei er√∂ffnet ist
        CALL    A1C0F           ; testen, ob Dateiname schon auf Ger√§t vorhanden ist
        JP      NC,A1F8E        ; Fehler 42'  Already exist error
        OR      A               ; alle m√∂glichen Dateikennungen durchprobiert  ?
        JP      Z,A1F9A         ; ja -->  Fehler 51'  Too many files error
        RET
;
;
;   Datei zum Lesen er√∂ffnet
;
A1C4B:  CALL    A1C6D           ; testen, ob auf Ger√§t nicht schon Datei er√∂ffnet ist
        CALL    A1C0F           ; testen, ob Dateiname schon auf Ger√§t vorhanden ist
        JP      C,A1F88         ; nein -->  Fehler 40'  File not found error
        CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      HL,S11A4        ; Zeiger auf Speicher mit Dateikennung vorgeben
        PUSH    IY              ;! Zeiger auf Stelle f√ºr Dateikennung nach DE
        POP     DE              ;!
        PUSH    HL              ; Zeiger auf Dateikennung retten
        CALL    A1C66           ; 64 Byte  (L√§nge Kennungsdaten)  von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Dateikennung holen
        LD      DE,S1000        ; Zeiger auf Speicher f√ºr Dateikennung
        LD      A,(HL)          ; Datei - Typ - Kennung holen
;
;
;   64 Byte  (L√§nge Kennungsdaten) von (HL) nach (DE) √ºbertragen
;
A1C66:  LD      BC,64           ; L√§nge Datei - Kennung  
        LDIR                    ; Dateikennung von (HL) nach (DE) √ºbertragen
        OR      A               ; Carry - Flag zur√ºcksetzen  (Code for 'Funktion OK')
        RET
;
;
;   testen, ob auf Ger√§t nicht schon Datei  (zum Schreiben) er√∂ffnet ist
;
A1C6D:  LD      IX,T1CAF        ; Adresse  'testen, ob Datei noch er√∂ffnet werden darf'
;
;
;   alle im Zugriff befindlichen Datei - Datens√§tze durchspielen
;   wenn aktuelles Ger√§t gefunden -->  Routine in IX aufrufen
;
A1C71:  LD      (D1CAA + 1),IX  ; Anfangsadresse der Routine eintragen
        CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      A,(S1042)       ; interne aktuelle Ger√§te-/Dateinummer holen
        LD      C,A             ; und merken
        LD      HL,(S1072)      ; Zeiger auf Datei-Arbeitsbereiche (I/O-Work-Area) holen
        PUSH    HL              ; und merken
A1C80:  POP     HL              ; Zeiger auf Datei-Arbeitsbereich holen
        LD      A,(HL)          ; Dateisatz - Nummer holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  alle Dateis√§tze abgearbeitet
        LD      B,A             ; Datensatznummer merken
        INC     HL              ; Zeiger auf L√§nge Speicherbereich
        CALL    A012D           ; L√§nge Speicherbereich nach DE holen
        PUSH    HL              ; Zeiger auf aktuellen Datensatz retten
        ADD     HL,DE           ; Zeiger auf n√§chsten Datensatz errechnen
        EX      (SP),HL         ; Zeiger n√§chster Datensatz retten/akt. Zeiger holen
        CP      08FH            ; nur interner Verwaltungsdatensatz  ?
        JR      NC,A1C80        ; ja -->  n√§chsten Datensatz testen
        CP      C               ; Datensatznummer gleich aktuellem Datensatz
        JR      Z,A1C80         ; ja -->  n√§chsten Datensatz testen
        INC     HL              ; Datensatznummer √ºberspringen
        LD      A,(HL)          ; Zugriffscode holen
        EX      AF,AF           ; und retten
        INC     HL              ; Zugriffscode √ºberspringen
        LD      DE,S1044        ; Zeiger auf aktuelle Ger√§te - Tabelle
        PUSH    BC              ; Register - Wert retten
        LD      BC,256 * 3 + 0  ; drei Byte √ºberpr√ºfen / 0 = Vorgabe f√ºr Ergebnis
A1C9E:  LD      A,(DE)          ;! ein Byte vergleichen
        SUB     (HL)            ;!
        OR      C               ; plus altes Ergebnis
        LD      C,A             ; neues Ergebnis merken
        INC     DE              ;! Zeiger auf Ger√§te-Tabellenzeigern auf n√§chstes Byte
        INC     HL              ;!
        DJNZ    A1C9E           ; weitere Bytes vergleichen
        POP     BC              ; geretteten Register - Wert holen
        JR      NZ,A1C80        ; Ger√§t nicht gleich -->  n√§chsten Datensatz vergleichen
        LD      A,B             ; Datensatznummer holen
D1CAA:  CALL    0               ; Routine aufrufen  (Adresse wird eingetragen)
        JR      A1C80           ; n√§chsten Datensatz testen
;
;
;   testen, ob Datei noch er√∂ffnet werden darf
;
T1CAF:  LD      A,(S1051)       ; Ger√§te - Nummern - Flag holen
        BIT     6,A             ; nur eine Datei auf Ger√§t erlaubt  ?
        JP      NZ,A1F91        ; ja -->  Fehler 43'  Already open error
        BIT     5,A             ; nur eine Datei zum Schreiben er√∂ffnen  ?
        RET     Z               ; nein
        EX      AF,AF           ; Zugriffscode des Datensatzes holen
        LD      B,A             ; und merken
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        AND     B               ;!  beide Dateien zum Schreiben er√∂ffnet  ?
        BIT     1,A             ;!
        RET     Z               ; nein 
        JP      A1F91           ; Fehler 43'  Already open error
;
;
;   Programm nach aufbereiteter Kennung laden   (Software command code:  48)
;
A1CC6:  CALL    A1D27           ; aktuelles Ger√§t gleich Diskette  ?
        JP      NZ,A32A2        ; nicht mehr ben√∂tigte Diskettendaten l√∂schen
        LD      BC,(S1014)      ; Datei - L√§nge holen
        PUSH    BC              ; und merken
        XOR     A                
        LD      IX,(S105D)      ; Adresse  'Daten vom Ger√§t bereitstellen' holen
        CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        POP     BC              ; gerettete Programml√§nge holen
        RET
;
;
;   (Programm-)  Daten vergleichen     (Software command code:  50)
;
A1CDB:  LD      A,(S1051)       ; Ger√§te - Nummern - Flag holen
        BIT     7,A             ; Block - orientiertes Ger√§t  ?
        JP      Z,A1FAC         ; nein -->  Fehler 59'  Can't execute error
        LD      BC,(S1014)      ; Datei - L√§nge holen
        ;JP      A388D           ; Dateidaten vergleichen
        JP      A3ADF			; RET (Motor der Quick - Disk - Station abschalten)

;
;
;   Programm abspeichern     (Sofware - Kommando  49)
;
A1CEA:  LD      A,(S1000)       ; Datei - Typ - Kennung holen
        CP      _BRD + 1        ; bekannter Datei - Typ  ?
        JR      C,A1CF6         ; ja
        LD      A,10000000B     ; Code for 'vom Basic abgespeicherte Datei'
        LD      (S1012),A       ; im Schreib - Schutz - Flag merken
A1CF6:  CALL    A1D27           ; aktuelles Ger√§t gleich Diskette  ?
        JP      NZ,A32B0        ; ja -->  Programm auf Diskette abspeichern   
        BIT     7,A             ; nicht Block - orientiertes Ger√§t  ?
        JP      NZ,A1FAC        ; ja -->  Fehler 59'  Can't execute error
        PUSH    DE              ; Zeiger auf Programm retten
        LD      HL,2 * 256 + 0  ; Code for 'Datei zum Schreiben er√∂ffnen'
        LD      (S1042),HL      ; als interne aktuelle Ger√§te-Nummer/Zugriffscode merken
        CALL    A1C6D           ; testen, ob auf Ger√§t nicht schon Datei er√∂ffnet ist
        LD      HL,S1000        ; Zeiger auf Speicher mit Datei - Kennung
        PUSH    HL              ;! nach IY √ºbertragen
        POP     IY              ;!
        LD      IX,(S1057)      ; Adresse  'Datei zum Schreiben er√∂ffnen'
        CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        LD      BC,(S1014)      ; Datei - L√§nge holen
        POP     HL              ; Zeiger auf Programm holen
        LD      A,0100B
        LD      IX,(S105F)      ; Adresse  'Daten ausgeben'  holen
        CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        RET
;
;
;   Abfrage, ob aktuelles Ger√§t gleich Diskette ist
;
A1D27:  LD      A,(S1050)       ; Ger√§te - Typ - Byte holen
        BIT     5,A             ; Ger√§t gleich Diskette  ?
        RET
;
;
;   Inhaltsverzeichnis einlesen oder ausgeben     (Software command code:  57)
;
A1D2D:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        OR      A               ; Datei- oder Ger√§tenummer angegeben  ?
        JR      NZ,A1D80        ; ja -->  gelesenes Inhaltsverzeichnis ausgeben
;
;
;   Inhaltsverzeichnis des Ger√§tes / Datentr√§gers einlesen
;
        LD      HL,256 * 1 + 0  ; Code for 'Datei zum Lesen er√∂ffnen'
        LD      (S1042),HL      ; als interne aktuelle Ger√§te-Nummer/Zugriffscode merken
        CALL    A1C6D           ; testen, ob auf Ger√§t nicht schon Datei er√∂ffnet ist
        LD      HL,S1050        ; Zeiger auf Ger√§te - Typ - Byte vorgeben
        BIT     7,(HL)          ; nicht Block-orientiertes ger√§t  ?
        JP      NZ,A1FAC        ; ja -->  Fehler 59'  Can't execute error
        BIT     5,(HL)          ; Ger√§t gleich Diskette  ?
        JP      NZ,A36FD        ; ja -->  Inhaltsverzeichnis von Diskette lesen   
        INC     HL              ; Zeiger auf Ger√§te - Nummern - Byte
        BIT     7,(HL)          ; Dateiname mu√ü nicht angegeben sein  ?
        JP      NZ,A1FAC        ; ja -->  Fehler 59'  Can't execute error
        CALL    A44A3           ; warten, bis alte Melodien vollst√§ndig gespielt sind
        LD      HL,S27D0        ; Zeiger auf Speicher f√ºr Inhaltsverzeichnis
        LD      BC,8            ; 8 * 256 Bytes = 2 K - Byte
A1D58:  CALL    A0137           ; Speicherbereich (HL) l√∂schen
        DEC     C               ; Restanzahl Bl√∂cke minus eins
        JR      NZ,A1D58        ; weitere Bl√∂cke l√∂schen
        CALL    A18C7           ; Datei auf Ger√§t nach Tabellenadresse schliessen 
        LD      A,(S1052)       ; maximale Anzahl Dateien auf Ger√§t/Datentr√§ger holen
        LD      B,A             ; und merken
        LD      HL,S27D0        ; Zeiger auf Speicher f√ºr Inhaltsverzeichnis
A1D68:  PUSH    BC              ; Z√§hler retten
        LD      IX,(S1055)      ; Adresse  'Datei zum Lesen er√∂ffnen' aus Ger√§tetabelle holen
        CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        PUSH    AF              ; Ergebnisflag retten
        LD      BC,32           ; L√§nge Kennungsdatensatz
        ADD     HL,BC           ; Zeiger auf Ende Datensatz errechnen
        LD      (HL),NUL        ; Endezeichen eintragen
        POP     AF              ; gerettetes Ergebnisflag holen
        POP     BC              ; geretteten Z√§hler holen
        JR      C,A1D7D         ; keine weiteren Dateinamen
        DJNZ    A1D68           ; weitere Dateien testen   (Dateikennungen einlesen)
A1D7D:  JP      B18C6           ; Ger√§t in 'Stand by'  schalten
;
;
;   gelesenes Inhaltsverzeichnis aufbereiten und ausgeben
;
A1D80:  LD      (A1E27 + 1),A   ; Ausgabe - Datei - Nummer in Routine eintragen
        XOR     A               ; Accu auf Null
        LD      (S1090),A       ; Code for 'Steuerzeichen ausf√ºhren'  merken
        LD      HL,S11A4        ; Zeiger auf Speicher zur Textaufbereitung
        PUSH    HL              ; Zeiger auf Anfang Speicher merken
        LD      DE,M1E32        ; Text  'DIRECTORY OF'
        LD      B,14            ; Textl√§nge vorgeben
        CALL    A014A           ; Speicherbereich von (DE) nach (HL) verschieben
        CALL    A0397           ; Ger√§te - Namen nach (HL) bereitstellen
        LD      (HL),' '        ; Leerzeichen  (Space)  eintragen
        INC     HL              ; Leerzeichen √ºberspringen
        LD      (HL),' '        ; Leerzeichen  (Space)  eintragen
        INC     HL              ; Leerzeichen √ºberspringen
        EX      DE,HL           ; Zeiger auf Speicher f√ºr Text nach DE
        CALL    A1D27           ; aktuelles Ger√§t gleich Diskette  ?
        LD      IX,(S1065)      ; Adresse  'freie Kilobyte bereitstellen'  aus Ger√§te-Tabelle holen
        JR      Z,A1DAA         ; nicht Diskette
        LD      IX,T3716        ; Adresse  'freie Kilobyte bereitstellen (Diskette)'  
A1DAA:  CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        JR      C,A1DBD         ; Ger√§t kann keine freie Speicherkapazit√§t bereitstellen
        LD      H,B             ;! Anzahl freie Kilobyte nach HL
        LD      L,C             ;!
        LD      B,0             ; Code for 'Vornullen unterdr√ºcken'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    22              ; Code 22   Hex-Wert in HL umsetzen in Dezimal-ASCII (DE)
        LD      HL,M1E40        ; Text  'KB FREE'
        LD      B,9             ; Textl√§nge vorgeben
        CALL    A0143           ; Text von (HL) nach (DE) verschieben
A1DBD:  EX      DE,HL           ; Zeiger auf Ende Text nach HL
        LD      (HL),CR         ; Carriage Return  (Wagenr√ºcklauf)  eintragen
        INC     HL              ; Zeichen √ºberspringen
        LD      (HL),NUL        ; Textendezeichen eintragen
        POP     DE              ; Zeiger auf Anfang aufbereitete Zeile holen
        CALL    A1E27           ; Text (DE) ausgeben
        LD      B,64            ; maximal 64 Datei - Eintr√§ge
        LD      HL,S27D0        ; Zeiger auf Speicher mit Inhaltsverzeichnis
A1DCC:  CALL    A1DD8           ; eine Zeile Inhaltsverzeichnis aufbereiten und ausgeben
        LD      DE,32           ; L√§nge Inhaltsverzeichnis - Eintrag
        ADD     HL,DE           ; Zeiger auf n√§chsten Inhaltsverzeichnis - Eintrag
        DJNZ    A1DCC           ; weitere Zeilen Inhaltsverzeichnis aufbereiten und ausgeben
        JP      A34CE           ; nicht mehr ben√∂tigte Diskettendaten l√∂schen   
;
;
;   eine Zeile Inhaltsverzeichnis aufbereiten und ausgeben
;
A1DD8:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      A,(HL)          ; Datei - Typ - Kennung holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  Datei - Eintrag nicht belegt
        RET     M               ; SWAP - Eintrag -->  nicht ausgeben
        LD      DE,S11A4        ; Zeiger auf Speicher f√ºr Text vorgeben
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        LD      A,' '           ; Leerzeichen  (Space)  vorgeben
        LD      B,38            ; 38 Zeichen
        CALL    A013E           ; Speicherbereich (DE) mit Konstante in A laden  (B = Anzahl)
        LD      A,(HL)          ; Datei - Typ - Flag holen
        CP      12              ; bekannter Datei - Typ  ?
        JR      C,A1DF1         ; ja -->  ausgeben
        LD      A,12            ; Code f√ºr unbekannten Datei - Typ
A1DF1:  PUSH    HL              ;! Zeiger auf Datei - Kennung im Zwischenspeicher
        POP     IY              ;! nach IY √ºbertragen
        POP     DE              ; Zeiger auf Speicher f√ºr Zeile holen
        PUSH    DE              ; und wieder merken
        INC     DE              ; Zeiger auf Stelle f√ºr Datei - Typ
        LD      HL,M1E49 + -3   ; Zeiger auf Texte f√ºr Datei - Typen
        LD      BC,3            ; Textl√§nge je Datei - Typ
A1DFD:  ADD     HL,BC           ;! Zeiger auf richtigen Text stellen
        DEC     A               ;!
        JR      NZ,A1DFD        ;!
        LDIR                    ; Datei-Typ - Text in Textspeicher √ºbertragen
        EX      DE,HL           ; Zeiger auf Textspeicher nach HL
        BIT     0,(IY+18)       ; Datei Schreibgesch√ºtzt  ?
        JR      Z,A1E0C         ; nein
        LD      (HL),'*'        ; Code for 'LOCK'  eintragen
A1E0C:  INC     HL              ;! Zeiger auf Stelle f√ºr Dateinamen setzen
        INC     HL              ;!
        LD      (HL),'\"'       ; Anf√ºhrungszeichen f√ºr Anfang Datei-Name
        INC     HL              ; Anf√ºhrungszeichen √ºberspringen
A1E11:  LD      A,(IY+1)        ; ein Zeichen Datei - Name holen
        CP      CR              ; Ende Datei - Name  ?
        JR      Z,A1E1E         ; ja -->  Anf√ºhrungszeichen eintragen
        LD      (HL),A          ; ein Zeichen Name merken
        INC     IY              ; Zeiger auf Inhaltsverzeichnis - Speicher
        INC     HL              ; Zeiger auf Speicher f√ºr Text 
        JR      A1E11           ; weitere Zeichen Name √ºbertragen
;
A1E1E:  LD      (HL),'\"'       ; Anf√ºhrungszeichen f√ºr Namenende eintragen
        INC     HL              ; Anf√ºhrungszeichen √ºberspringen
        LD      (HL),CR         ; Carriage Return  (Wagenr√ºcklauf)  eintragen
        INC     HL              ; Zeilenvorschubzeichen √ºberspringen
        LD      (HL),NUL        ; Textendezeichen eintragen
        POP     DE              ; Zeiger auf Anfang aufbereiteten Text holen
;
;
;   aufbereitete Inhaltsverzeichniszeile auf Ger√§t / Datei ausgeben
;
A1E27:  LD      A,0             ; Ausgabe - Datei - Nummer   (wird eingetragen)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    46              ; Code 46   Datei-Verwaltungssatz nach Nummer bereitstellen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    23              ; Code 23  L√§nge des Textes (DE) ausz√§hlen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    55              ; Code 55  Text auf angew√§hltem Ger√§t/Datei ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    15              ; Code 15  wenn Space gedr√ºckt -->  warten bis andere Taste
        RET
;
;
;   Texte f√ºr Ausgabe Inhaltsverzeichnis   (DIR)
;
M1E32:  DEFB    CR              ; Text  'DIRECTORY OF '
        DEFM    "DIRECTORY OF "
;
M1E40:  DEFM    " KB FREE."     ; Text  ' KB FREE.'
;
;
;   Vorgabe f√ºr Texte f√ºr Datei - Typ - Kennungen
;
M1E49:  DEFM    "OBJ"           ; Datei - Typ  1
        DEFM    "BTX"           ; Datei - Typ  2
        DEFM    "BSD"           ; Datei - Typ  3
        DEFM    "BRD"           ; Datei - Typ  4
        DEFM    "RB "           ; Datei - Typ  5
        DEFM    " ? "           ; Datei - Typ  6     (frei f√ºr  ASC)
        DEFM    "LIB"           ; Datei - Typ  7
        DEFM    " ? "           ; Datei - Typ  8     (frei f√ºr  PTX)
        DEFM    " ? "           ; Datei - Typ  9     (frei f√ºr  PSD)
        DEFM    "SYS"           ; Datei - Typ 10
        DEFM    "GR "           ; Datei - Typ 11          ! (Datei - Typ  12 = LOG)
        DEFM    " ? "           ; Datei - Typ 12          ! (Datei - Typ  13 = PIC)
;
; 
;   Ger√§t initialisieren     (Software command code:  60)
;
A1E6D:  PUSH    HL              ; Zeiger auf √úbergabetext retten
A1E6E:  XOR     A               ; Accu auf Null
        LD      (S1042),A       ; interne aktuelle Ger√§te-/Dateinummer l√∂schen
        LD      IX,D1E86        ; Adresse  'Dateidaten im Rechner l√∂schen'
        LD      (D1E86 + 1),SP  ; Stackpointer merken
        CALL    A1C71           ; wenn Datei auf Ger√§t er√∂ffnet -->  Routine (IX) aufrufen
        POP     HL              ; geretteten Zeiger auf √úbergabetext holen
        LD      IX,(S1053)      ; Adresse  'Ger√§t initialisieren'  aus Ger√§te-Tabelle holen
        CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        RET
;
;
;   Datei mit Nummer im Accu l√∂schen und erneut probieren, ob Ger√§t noch im Zugriff ist
;
D1E86:  LD      SP,0            ; Stackpointer neu setzen   (Wert wird eingetragen)
        LD      B,0             ; Code for 'Dateidaten im Rechner l√∂schen'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    56              ; Code 56   Datei-Daten im Rechner l√∂schen
        JR      A1E6E           ; erneut testen, ob Ger√§t noch im Zugriff ist
;
;
;   Abfrage, ob wirklich initialisiert werden soll
;
A1E8F:  CALL    A0164           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    "Y"             ; Y  (Yes)  ?
        RET     Z               ; Y angegeben -->  initialisieren
        LD      DE,M1EA3        ; Text  'OK ?  (Y/N)'  
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    5               ; Code 5  Text (DE) mit Gro√ü/Kleinschreibung ausgeben
        LD      A,1             ; Code for 'ein Zeichen von Tastatur mit Cursorblinken'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    13              ; Code 13  Tastaturabfrage nach Status im Accu
        CP      'Y'             ; Y  (Yes)  ?
        RET     Z               ; ja -->  initialisieren
        JP      A00E8           ; Programm abbrechen  (BREAK)
;
;
;   Text to ask whether you really want to initialize 
;
M1EA3:  DEFM    "OK ? [Y/N]"    ; Text  'OK ? [Y/N]'
        DEFB    _ALPHA,NUL

;
;
;   Compare file name with given file name (HL)
;
A1EAF:
        LD      DE,S1000        ; Pointer to storage for file handle 
;
;
;   Compare file name in (HL) with file name in (DE).
;
A1EB2:  CALL    A00C7           ; Save registers IX, HL, BC and DE
        INC     HL              ; File - Skip type in comparison name
        INC     DE              ; File - skip type in given name
        LD      A,(DE)          ; Get first character of given file name
        CP      CR              ; Carriage Return (End of Name Character) ?
        RET     Z               ; yes --> no name specified --> name is OK
        LD      B,17            ; specify the maximum number of characters for the file name
A1EBD:  LD      A,(DE)          ; Get a character given file name
        CP      (HL)            ; compare with a character comparison-name
        RET     NZ              ; File names not the same --> Abort
        CP      CR              ; end file name ?
        RET     Z               ; yes --> file names same
        INC     HL              ; Pointer to comparison name to next character
        INC     DE              ; Pointer to given name to next character
        DJNZ    A1EBD           ; more characters compare file name
        OR      A               ; Reset carry flag 
        RET
;
;
;   Provide file names from text (DE) to (HL).
;
A1EC9:  INC     HL              ; Skip location for file - type - identifier
        LD      C,16            ; maximum length file - specify name
A1ECC:  LD      A,B             ; Get remaining length of file name specification
        OR      A               ; equals zero  ?
        JR      Z,A1EE4         ; yes --> enter the end of name character
        LD      A,(DE)          ; get a character filename
        INC     DE              ; skip characters
        DEC     B               ; Remaining number of characters default minus one
        OR      A               ; end of text character ?
        JR      Z,A1EE4         ; yes --> enter the end of name character
        CP      '\"'            ; quotation marks ?
        JR      Z,A1ECC         ; yes --> forgotten characters
        CP      ':'             ; colon ?
        JP      Z,A1FAF         ; yes --> Error 40 Illegal filename error
        LD      (HL),A          ; Remember characters for file names
        INC     HL              ; skip noted character
        DEC     C               ; Remaining number of allowed characters minus one
        JR      NZ,A1ECC        ; provide more characters
A1EE4:  LD      (HL),CR         ; Enter name end character
        INC     HL              ; Skip name ending characters
A1EE7:  LD      A,C             ; Get counter 'Remaining number of allowed characters'
        OR      A               ; equals zero  ?
        RET     Z               ; yes --> done
        LD      (HL),' '        ; enter a space
        INC     HL              ; Skip spaces
        DEC     C               ; Remaining number of characters minus one
        JR      A1EE7           ; write more spaces 
;
;
;   Zeiger auf dynamisches Segment nach Satz-Nummer im Accu nach HL bereitstellen
;
;   (Software command code:  41)
;
A1EF0:  LD      HL,(S1072)      ; Zeiger auf Datei-Arbeitsbereiche (I/O-Work-Area) holen
A1EF3:  INC     (HL)            ;! Ende Tabelle  ?
        DEC     (HL)            ;!
        SCF                     ; Code for 'Speicher nicht gefunden'  setzen
        RET     Z               ; Speicher nicht gefunden -->  Abbruch
        CP      (HL)            ; Satz - Nummer stimmt  ?
        INC     HL              ; Satz - Nummer √ºberspringen
        JR      Z,A1F03         ; Datensatz gefunden -->  Zeiger auf Bytes stellen
        PUSH    DE              ; Register - Wert retten
        CALL    A012D           ; L√§nge Bereich aus Datensatz holen
        ADD     HL,DE           ; Zeiger auf n√§chsten Datensatz errechnen
        POP     DE              ; geretteten Register - Wert holen
        JR      A1EF3           ; n√§chsten Datensatz testen
;
A1F03:  INC     HL              ;! Bereichsl√§nge √ºberspringen
        INC     HL              ;!
        RET
;
;
;   dynamischen Zwischenspeicher l√∂schen     (Software command code:  43)
;
A1F06:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    41              ; Code 41  Zeiger auf Datensatz nach Datensatznr bereitstellen
        RET     C               ; Speicher nicht er√∂ffnet -->  fertig
        DEC     HL      
        LD      B,(HL)          ;! L√§nge des Speicherbereichs holen
        DEC     HL              ;!
        LD      C,(HL)          ;!
        DEC     HL              ; Zeiger auf Anfang Speicherbereich
        LD      D,H             ;! Zeiger nach DE √ºbertragen
        LD      E,L             ;!
        INC     BC              ;! L√§nge f√ºr Verwaltungsbytes corrigieren
        INC     BC              ;!
        INC     BC              ;!
        PUSH    BC              ; L√§nge merken
        ADD     HL,BC           ; Zeiger auf Ende Bereich errechnen
        PUSH    HL              ; und merken
        LD      B,H             ;! Zeiger auf Ende des dynamischen Speicherbereichs 
        LD      C,L             ;! nach BC
        LD      HL,(S107A)      ; Zeiger auf Ende Stringarbeitsbereich holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; Anzahl zu verschiebende Bytes errechnen
        LD      B,H             ;! Anzahl zu verschiebende Bytes nach BC
        LD      C,L             ;!
        POP     HL              ; Zeiger auf Ende dynamisches Segment holen
        LDIR                    ; Bytes hinter Segment verschieben  (Segment l√∂schen)
        POP     DE              ; L√§nge des gel√∂schten Speichers holen
        LD      HL,0            ;! 2er Complement errechnen
        OR      A               ;!         Carry  - Flag zur√ºcksetzen
        SBC     HL,DE           ;!
        EX      DE,HL           ; negative Segment - L√§nge nach DE
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    25              ; Code 25   Zeiger auf Basic-Variable und Strings corrigieren
        OR      A               ; Carry - Flag zur√ºcksetzen   (Code for 'kein Fehler')
        RET
;
;
;   dynamischen Zwischenspeicher er√∂ffnen     (Software command code:  42)
;
A1F32:  PUSH    AF              ; Nummer des Zwischenspeichers retten
        PUSH    BC              ; Register - Wert retten
        PUSH    DE              ;! L√§nge des zu er√∂ffnenden Zwischenspeichers
        PUSH    DE              ;!
        INC     DE              ;! L√§nge f√ºr Speichernummer und L√§nge corrigieren
        INC     DE              ;!
        INC     DE              ;!
        LD      HL,(S107A)      ; Zeiger auf Ende Stringarbeitsbereich holen
        EX      DE,HL           ; HL - Register - Wert retten
        ADD     HL,DE           ; neues Ende Stringarbeitsbereich errechnen
        EX      DE,HL           ; gerettetes altes Ende wieder nach HL
        JP      C,A1F82         ; √úberlauf -->  Fehler 6  Memory capacity error
        PUSH    HL              ; altes Ende Stringarbeitsbereich merken
        LD      HL,-512         ;! kleinstm√∂gliche RAM - Adresse errechnen
        ADD     HL,SP           ;!
        SBC     HL,DE           ; testen, ob sich Adressen √ºberschneiden
        JR      C,A1F82         ; √úberlauf -->  Fehler 6  Memory capacity error
        LD      HL,(S107E)      ; LIMIT - Adresse holen
        DEC     H               ;! Vorgabe f√ºr freien Arbeitsspeicher  (512 Bytes)
        DEC     H               ;!
        SBC     HL,DE           ; Adressen √ºberpr√ºfen
        JR      C,A1F82         ; Fehler 6  Memory capacity error
        POP     HL              ; altes Ende Stringarbeitsbereich holen
        PUSH    HL              ; und wieder merken
        LD      BC,(S1074)      ; Zeiger auf Anfang Basic-Variable holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; Anzahl zu verschiebende Bytes errechnen
        LD      B,H             ;! und nach BC √ºbertragen
        LD      C,L             ;!
        POP     HL              ; Zeiger auf altes Ende Stringarbeitsbereich holen
        INC     BC              ; L√§nge corrigieren
        LDDR                    ; BASIC - Variable und Strings verschieben
        POP     DE              ; L√§nge des Zwischenspeichers holen
        LD      (HL),A          ; Speichernummer eintragen
        INC     HL              ; Speichernummer √ºberspringen
        LD      (HL),E          ;! Speicherl√§nge eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL
        PUSH    HL              ; Zeiger auf Anfang Speicher merken
        INC     DE
        PUSH    DE              ; L√§nge merken
A1F6D:  LD      (HL),0          ;! Zwischenspeicher l√∂schen
        INC     HL              ;!     Zeiger auf Speicher auf n√§chstes Byte
        DEC     DE              ;!     Restanzahl Bytes minus eins
        LD      A,D             ;!     !  Restanzahl Bytes gleich Null  ?
        OR      E               ;!     !
        JR      NZ,A1F6D        ;!     nein -->  weitere Bytes l√∂schen
        POP     DE              ; Speicherl√§nge holen
        INC     DE              ;! f√ºr Verwaltungsl√§nge corrigieren
        INC     DE              ;!
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    25              ; Code 25   Zeiger auf Basic-Variable und Strings corrigieren
        POP     HL              ; Zeiger auf Speicher holen
        POP     DE              ; Speicherl√§nge holen
        POP     BC              ; geretteten Register - Wert holen
        POP     AF              ; Speicher - Nummer holen
        RET
;
;
;   Tabelle mit Fehlereinspr√ºngen
;
;   (ist Bit 7 der Fehlernummer gesetzt wird auch der Ger√§te - Name ausgegeben)
;
A1F7F:  LD      A,3             ; Fehler  3   Illegal data error
        DEFB    LD_HL
;
A1F82:  LD      A,6             ; Fehler  6   Memory capacity error
        DEFB    LD_HL
;
A1F85:  LD      A,28 + 128      ; Fehler 28   System id error
        DEFB    LD_HL
;
A1F88:  LD      A,40 + 128      ; Fehler 40   File not found error
        DEFB    LD_HL
;
A1F8B:  LD      A,41 + 128      ; Fehler 41   Hardware error
        DEFB    LD_HL
;
A1F8E:  LD      A,42 + 128      ; Fehler 42   Already exist error
        DEFB    LD_HL
;
A1F91:  LD      A,43 + 128      ; Fehler 43   Already open error
        DEFB    LD_HL
;
A1F94:  LD      A,46 + 128      ; Fehler 46   Write protect error
        DEFB    LD_HL
;
A1F97:  LD      A,50 + 128      ; Fehler 50   Not ready error
        DEFB    LD_HL
;
A1F9A:  LD      A,51 + 128      ; Fehler 51   Too many files error
        DEFB    LD_HL
;
A1F9D:  LD      A,52 + 128      ; Fehler 52   Disk mismatch error
        DEFB    LD_HL
;
A1FA0:  LD      A,53 + 128      ; Fehler 53   No file space error
        DEFB    LD_HL
;
        LD      A,54 + 128      ; Fehler 54   Unformat error
        DEFB    LD_HL
;
A1FA6:  LD      A,55 + 128      ; Fehler 55   Too many files error
        DEFB    LD_HL
;
A1FA9:  LD      A,58            ; Fehler 58   Dev. name error
        DEFB    LD_HL
;
A1FAC:  LD      A,59 + 128      ; Fehler 59   Can't execute error
        DEFB    LD_HL
;
A1FAF:  LD      A,60 + 128      ; Fehler 60   Illegal filename error
        DEFB    LD_HL
;
A1FB2:  LD      A,61 + 128      ; Fehler 61   Illegal filemode error
        DEFB    LD_HL
;
A1FB5:  LD      A,63 + 128      ; Fehler 63   Out of file error
        DEFB    LD_HL
;
        LD      A,64            ; Fehler 64   Logical number error
        DEFB    LD_HL
;
A1FBB:  LD      A,68 + 128      ; Fehler 68   Dev. mode error
        JP      A00ED           ; Fehler mit Nummer im Accu behandeln
;
;
;   Datei - Daten der Ausgabe - Datei  (wenn vorhanden)  l√∂schen
;   Diskettenroutinen initialisieren und Motor abschalten   
;
;   (Software command code:  67)
;
A1FC0:  LD      A,(S1FD9)       ; Ausgabe - Ger√§te-/Dateinummer holen
        OR      A               ; gleich Null  (kein Ger√§t angew√§hlt)  ?
        LD      B,0             ; Code for 'Dateidaten l√∂schen'
        CALL    NZ,A1BB9        ; Dateinummer -->  Dateidaten im Rechner l√∂schen
        CALL    A38C2           ; Ger√§t 'FD:' initialisieren   
        CALL    A3ADF           ; Motor der Quick - Disk - Station abschalten
        XOR     A               ; Accu auf Null
        LD      (S1FD9),A       ; Ausgabe - Ger√§te-/Dateinummer zur√ºcksetzen
        JP      A34CE           ; nicht mehr ben√∂tigte Disketten-Daten l√∂schen  
;
        DEFS    3  
;
S1FD9:  DEFS    1               ; Ausgabe - Ger√§te-/Datei - Nummer
;
        DEFS    38,0
;
;
;
;   Speicher zur Simulation des Bildschirm - Text - Speichers
;
;
;   Da im Original - Bildspeicher nur noch Punktmuster stehen, wird im
;   folgenden Speicherbereich noch einmal der komplette Textbildschirm 
;   verwaltet.  Erst dadurch ist √ºberhaupt noch das 'Screen - Editing' 
;   m√∂glich.
;
;
;   Eine Bildschirmkopie des angezeigten Textes kann ganz einfach durch
;   das Auslesen mittels PEEK und die Ausgabe der gelesenen Zeichen auf
;   dem Drucker erzeugt werden.
;
;
S2000:  DEFS    2000            ; Pseudo - Bildspeicher
;
;
;
S27D0:  DEFS    1792            ; Speicher f√ºr Inhaltsverzeichnis
                                ; der folgende Speicherbreich geh√∂rt auch
                                ; noch dazu  (insgesamt 2 K - Byte)
S2ED0:  DEFS    256             ; hier werden Werte der noch zu spielenden
                                ; Melodie gespeichert
;
;
S2FD0:  DEFS    256             ; Speicher f√ºr Sektorverzeichnis  (Diskette)
;
;    RANDOM - Datensatz merken     (Software command code: 64)
;
A30D0:  LD      (S30D5),DE      ; RANDOM - Satznummer merken
        RET
;
;
S30D5:  DEFS    2               ; Speicher f√ºr RANDOM - Satznummer
;
;
;    einen Sektor der sequentiellen Datei auf Diskette wegschreiben
;
A30D7:  LD      BC,0            ; Code 'letzter Sektor'
        LD      DE,1            ; ein Sektor
        BIT     2,A             ; Datei - Ende - Bit abfragen
        CALL    Z,A3696         ; nicht gesetzt -->  Sektoren bereitstellen und reservieren
        LD      HL,(S180D)      ; Zeiger auf Sektornummer im Sektor holen
        LD      A,(HL)          ; Low - Byte Sektornummer holen
        LD      (HL),C          ; und Low - Byte neue Sektornummer eintragen
        LD      C,A             ; Low - Byte Sektornummer des jetzigen Sektors
        INC     HL              ; Zeiger auf High - Byte
        LD      A,(HL)          ; High - Byte Sektornummer holen
        LD      (HL),B          ; und High - Byte neue Sektornummer eintragen
        LD      B,A             ; High - Byte Sektornummer des jetzigen Sektors
        LD      HL,(S180B)      ; Zeiger auf Speicher fuer Sektor holen
        LD      DE,256          ; Sektorl√§nge vorgeben
        JP      B379A           ; Sektor auf Diskette wegschreiben
;
;
;    Datensatz in RANDOM - Datei wegschreiben     (Software command code:  66)
;
A30F5:  CALL    A00C7           ; Register IX, HL, BC, DE retten
        CALL    A181A           ; interne Ger√§te-Nummer als Ausgabe-Ger√§te-Nr. vorgeben
        LD      HL,S11A4        ; Zeiger auf Zwischenspeicher
        PUSH    HL              ; Zeiger auf Anfang Speicher merken
        LD      A,B             ; Anzahl Zeichen holen
        OR      A               ; gleich Null  ?
        CALL    NZ,A014A        ; nein --> Speicherbereich von (DE) nach (HL) verschieben
        LD      B,32            ; 32 Speicherzellen
        LD      A,' '           ; Vorgabe f√ºr L√∂schzeichen
        CALL    A0138           ; Speicherbereich (HL) mit Zeichen im Accu initiieren
        LD      A,(IY+18)       ; Schreib-Schutz-Flag holen
        OR      A               ; gesetzt  ?
        JP      NZ,A1F94        ; ja --> Fehler 46  Write protect error
        CALL    A31AF           ; √ºberpr√ºfen, ob Satznummer kleiner als bisher gr√∂√üte
        JR      NC,A3134        ; Satznummer ist kleiner als bisher gr√∂√üte Satznummer
        LD      (IY+20),E       ;! neue gr√∂√üte Satznummer merken
        LD      (IY+21),D       ;!
        LD      (IY+70),1       ; Flag 'Blocknummernsektor wegschreiben' eintragen
        JR      Z,A3134         ; Satznummer liegt im schon reservierten Sektorenblock
        CALL    A3192           ; RANDOM-Sektor, wenn ge√§ndert, wegschreiben
        CALL    A31D8           ; √ºberpr√ºfen, ob Sektoren f√ºr RANDOM-Satznummer schon reserviert
        CALL    A314C           ; Sektornummer und Zeiger auf Stelle f√ºr Datensatz errechnen
        LD      (IY+64),L       ;! Sektornummer eintragen
        LD      (IY+65),H       ;!
        JR      A313A           ; neuen Datensatz eintragen
;
A3134:  CALL    A314C           ; Sektornummer und Zeiger auf Stelle f√ºr Datensatz errechnen
        CALL    A317B           ; richtigen Sektor der RANDOM - Datei bereitstellen
A313A:  POP     HL              ; Zeiger auf neuen Datensatz holen
        CALL    A35EA           ; 32 Byte (1 Datensatz) von (HL) nach (DE) √ºbertragen
        LD      (IY+68),1       ; Code 'neue Daten im Speicher' merken
;
;
;    RANDOM - Satznummer plus eins
;
A3142:  LD      HL,(S30D5)      ; RANDOM - Satznummer holen
        INC     HL              ; plus eins
        LD      (S30D5),HL      ; und wieder merken
        JP      A1815           ; Ausgabe-Ger√§te-Nummer zur√ºcksetzen
;
;
;    Sektornummer und Zeiger auf Stelle f√ºr Datensatz aus RANDOM - Satznummer errechnen
;
A314C:  LD      HL,(S30D5)      ; RANDOM - Satznummer      
        DEC     HL              ; corrigieren
        PUSH    HL              ; und merken
        ADD     HL,HL           ; mal zwei
        LD      E,H             ; High - Byte als Offset merken
        LD      D,0             ; High - Byte Offset auf Null
        LD      HL,(S180B)      ; Zeiger auf Speicher f√ºr Sektor
        ADD     HL,DE           ;! Zeiger auf Block-Nummer errechnen
        ADD     HL,DE           ;!
        LD      E,(HL)          ;!  Sektor - Block - Nummer holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        POP     HL              ; RANDOM - Satznummer holen
        LD      A,L             ; Low - Byte Satznummer holen
        PUSH    AF              ; merken
        RRA                     ;! Offset im Sektorblock errechnen
        RRA                     ;!
        RRA                     ;!
        AND     00001111B       ;!
        LD      L,A             ; Low - Byte Offset im Sektorblock
        LD      H,0             ; High - Byte Offset auf Null
        ADD     HL,DE           ; Sektor - Nummer errechnen
        POP     AF              ; Low - Byte RANDOM - Satznummer holen
        AND     00000111B       ; Bits f√ºr Offset im Sektor maskieren
        ADD     A,A             ; mal zwei
        ADD     A,A             ; mal vier
        ADD     A,A             ; mal acht
        ADD     A,A             ; mal sechzehn
        ADD     A,A             ; mal zweiunddrei√üig
        LD      DE,(S180B)      ; Zeiger auf Speicher f√ºr Sektor
        INC     D               ; Blocknummernsektor √ºberspringen
        ADD     A,E             ; Low - Byte Offset im Sektor addieren
        LD      E,A             ; Ergebnis merken
        RET     NC              ; kein √úbertrag
        INC     D               ; High - Byte Zeiger auf Speicher f√ºr Sektor
        RET
;
;
;    richtigen Sektor der RANDOM - Datei bereitstellen
;
A317B:  LD      A,(IY+64)       ; Low - Byte alte Sektornummer holen
        CP      L               ; mit Low - Byte neue Sektornummer vergleichen
        JR      NZ,A3186        ; nicht gleich
        LD      A,(IY+65)       ; High - Byte alte Sektornummer holen
        CP      H               ; mit High - Byte neue Sektornummer vergleichen
        RET     Z               ; richtigen Sektor im Speicher
A3186:  CALL    A3192           ; RANDOM - Sektor, wenn ge√§ndert, wegschreiben
        LD      (IY+64),L       ;! neue Sektornummer merken
        LD      (IY+65),H       ;!
        XOR     A               ; Code 'Lesen' 
        JR      A319C           ; RANDOM - Sektor lesen
;
;
;    √úberpr√ºfen, ob Sektor der RANDOM - Datei weggeschrieben werden mu√ü
;
A3192:  XOR     A               ; Accu auf Null
        CP      (IY+68)         ; mit Flag 'neue Daten im Speicher' vergleichen
        RET     Z               ; keine neuen Daten im Sektorspeicher
        LD      (IY+68),A       ; Flag 'neue Daten im Speicher' eintragen
        LD      A,3             ; Code 'Schreiben'
;
;
;    Sektor der RANDOM - Datei lesen oder schreiben
;
A319C:  CALL    A00C7           ; Register IX, HL, BC, DE retten
        LD      C,(IY+64)       ;! absolute Sektornummer holen
        LD      B,(IY+65)       ;!
        LD      DE,256          ; 256 Bytes je Sektor
        LD      HL,(S180B)      ; Zeiger auf Speicher f√ºr Blocknummernsektor
        INC     H               ; Zeiger auf Speicher f√ºr Sektor
        JP      A379C           ; Sektor schreiben oder lesen
;
;
;    √ºberpr√ºfen, ob Satznummer kleiner als bisher gr√∂√üte geschriebene Satznummer ist
;
A31AF:  LD      L,(IY+20)       ;! bisher gr√∂√üte geschriebene RANDOM - Satz -
        LD      H,(IY+21)       ;! Nummer holen
        LD      DE,(S30D5)      ; aktuelle RANDOM - Satznummer holen  ?
        LD      A,H             ;! bisher gr√∂√üte Satznummer gleich Null  ?
        OR      L               ;!
        JR      NZ,A31C1        ; nein --> schon Sektoren reserviert
        OR      11111111B       ; Zero - Flag zur√ºcksetzen
        SCF                     ; Code 'neue Satznummer ist gr√∂√üer' setzen
        RET
;
A31C1:  CALL    A3794           ; HL - und DE - Register vergleichen
        RET     NC              ; neue Satznummer ist kleiner als bisher gr√∂√üte
        CALL    A00C7           ; Register IX, HL, BC, DE retten
        DEC     HL              ;! Satznummern corrigieren
        DEC     DE              ;!
        LD      A,L             ;! Blocknummern - Anteil der bisher gr√∂√üten
        AND     10000000B       ;! Satznummer maskieren
        LD      L,A             ;!
        LD      A,E             ;! Blocknummern - Anteil der neuen Satznummer
        AND     10000000B       ;! maskieren
        LD      E,A             ;!
        CALL    A3794           ; HL - und DE - Register vergleichen
        RET     C               ; neuer Satz liegt auch im anderen Block
        SCF                     ; Code 'neue Satznummer ist gr√∂√üer' setzen
        RET
;
;
;    √ºberpr√ºfen, ob Sektoren f√ºr RANDOM-Satznummer schon reserviert
;
A31D8:  CALL    A00C7           ; Register IX, HL, BC, DE retten
        LD      HL,(S30D5)      ; RANDOM - Satznummer
        DEC     HL              ; corrigieren
        ADD     HL,HL           ; mal zwei
        LD      B,H             ; Sektorblocknummer merken
        INC     B               ; f√ºr Schleife corrigieren
        LD      HL,(S180B)      ; Zeiger auf Speicher f√ºr Sektor mit Block-Nummern
A31E5:  LD      A,(HL)          ;! Sektorblocknummer gleich Null  ?
        INC     HL              ;!
        OR      (HL)            ;!
        CALL    Z,A31F3         ; ja --> Sektorblock bereitstellen
        INC     HL              ; Zeiger auf n√§chste Block - Nummer                              
        DJNZ    A31E5           ; weitere Block - Nummern √ºberpr√ºfen
        LD      (IY+70),1       ; Flag 'Blocknummernsektor wegschreiben' eintragen
        RET
;
;
;    Sektorblock f√ºr RANDOM - Datei bereitstellen und initialisieren
;
A31F3:  CALL    A00C7           ; Register IX, HL, BC, DE retten
        PUSH    HL              ; Zeiger auf Stelle f√ºr Block-Nummer
        LD      DE,16           ; 16 freie Sektoren bereitstellen
        CALL    A3696           ; Sektoren bereitstellen und reservieren
        POP     HL              ; Zeiger auf Stelle f√ºr Block - Nummer
        LD      (HL),B          ;! absolute Sektornummer des Sektorblocks
        DEC     HL              ;! eintragen
        LD      (HL),C          ;!
        LD      HL,(S180B)      ; Zeiger auf Speicher f√ºr Sektor mit Block-Nummern
        INC     H               ; Zeiger auf Speicher f√ºr Sektor
        XOR     A               ; 256 Bytes je Sektor
A3206:  LD      (HL),' '        ;! Speicher f√ºr Sektor mit Space vorinitiieren
        INC     HL              ;!
        DEC     A               ;!    Z√§hler minus eins
        JR      NZ,A3206        ;!    weitere Bytes initiieren
        DEC     H               ; Zeiger wieder auf Anfang Sektor
        LD      DE,256          ; 256 Bytes je Sektor
        LD      A,16            ; 16 Sektoren blocken
A3212:  PUSH    AF              ; Restanzahl Sektoren retten
        CALL    B379A           ; Sektor auf Diskette wegschreiben
        POP     AF              ; Z√§hler Restanzahl Sektoren wieder holen
        INC     BC              ; Sektor - Nummer plus eins
        DEC     A               ; Z√§hler minus eins
        JR      NZ,A3212        ; weitere Sektoren initiieren
        RET
;
;
;    n√§chsten Sektor der sequentiellen Datei f√ºr Lesen bereitstellen
;      
A321C:  LD      L,(IY+20)       ;! Restdateil√§nge holen
        LD      H,(IY+21)       ;!
        LD      A,H             ;! gleich Null  ?
        OR      L               ;!
        SCF                     ; Code 'Dateiende' setzen
        RET     Z               ; Restdateil√§nge gleich null
        LD      DE,-254         ; Anzahl Bytes je Sektor
        PUSH    HL              ; alte Restdateil√§nge merken
        ADD     HL,DE           ; neue Restdateil√§nge errechnen
        JR      C,A3230         ; Restdateil√§nge stimmt
        LD      HL,0            ; neue Restdateil√§nge ist null
A3230:  LD      (IY+20),L       ;! neue Restdateil√§nge merken
        LD      (IY+21),H       ;!
        POP     DE              ; alte Restdateil√§nge holen
        LD      HL,(S180B)      ; Zeiger auf Speicher f√ºr Sektor holen
        DEC     HL
        LD      (HL),D          ;! alte Restdateil√§nge eintragen
        DEC     HL              ;!
        LD      (HL),E          ;!
        CALL    A3258           ; n√§chsten Sektor von Diskette lesen
        OR      A               ; Carry - Flag zur√ºcksetzen
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        BIT     2,A             ; XOPEN - Bit abfragen
        RET     NZ              ; nicht XOPEN
        LD      HL,(S180D)      ; Zeiger auf Sektornummer im Sektor
        LD      A,(HL)          ; Low - Byte Sektornummer holen
        LD      (IY+30),A       ; und als Low - Byte f√ºr n√§chsten Sektor merken
        INC     HL              ; Zeiger auf High - Byte Sektornummer
        LD      A,(HL)          ; High - Byte Sektornummer holen
        LD      (IY+31),A       ; als High - Byte f√ºr n√§chsten Sektor merken
        LD      DE,0
        RET
;
;
;    Sektornummer des n√§chsten Sektors holen und n√§chsten Sektor der sequentiellen Datei
;    lesen oder Blocknummernsektor der RANDOM - Datei lesen
;
A3258:  LD      C,(IY+30)       ;! Sektornummer des n√§chsten (ersten) Sektors
        LD      B,(IY+31)       ;! aus Inhaltsverzeichnis-Eintrag holen
        LD      A,B             ;! Sektornummer gleich Null  ?
        OR      C               ;!
        JP      Z,A1F8B         ; ja --> Fehler 41  Hardware error
        LD      DE,256          ; 256 Bytes je Sektor
        LD      HL,(S180B)      ; Zeiger auf Speicher f√ºr Sektor
        JP      A379B           ; Sektor von Diskette lesen
;
        RET
;
;
;    Datensatz aus RANDOM - Datei lesen   (Software Kommando  65)
;
A326D:  XOR     A               ; Code 'Textende'
        LD      (DE),A          ; erst einmal vorgeben
        PUSH    HL              ; Register - Wert retten
        PUSH    DE              ;! Zeiger auf Stelle f√ºr RANDOM - Satz
        PUSH    DE              ;! retten
        CALL    A31AF           ; √ºberpr√ºfen, ob Satznummer kleiner als bisher gr√∂√üte
        POP     DE              ; Zeiger auf Stelle f√ºr RANDOM - Satz holen
        JR      C,A3297         ; Satznummer ist gr√∂√üer --> Dateiende
        CALL    A181A           ; interne Ger√§tenummer als Ausgabe-Ger√§te-Nummer vorgeben
        PUSH    DE              ; Zeiger auf Stelle f√ºr RANDOM-Satz retten
        CALL    A314C           ; Sektornummer und Zeiger auf Stelle f√ºr Datensatz errechnen
        CALL    A317B           ; richtigen Sektor der RANDOM - Datei bereitstellen
        EX      DE,HL           ; Zeiger auf Stelle im Sektor nach HL
        POP     DE              ; Zeiger auf Stelle f√ºr RANDOM - Satz holen
        CALL    A35EA           ; 32 Byte von (HL) nach (DE) √ºbertragen
        XOR     A               ; Code 'Textende'
        LD      (DE),A          ; hinter RANDOM-Datensatz eintragen
        CALL    A3142           ; RANDOM - Satznummer plus eins
        LD      B,32            ; 32 Byte bereitgestellt
        XOR     A               ; Code 'Funktion OK'
        LD      HL,(S1040)      ; Zeiger auf aktuellen Datei-Verwaltungssatz
        INC     HL              ; Datei-Nummer √ºberspringen
        RES     7,(HL)          ; Code 'nicht Dateiende' setzen
        JR      A329F           ; gerettete Register holen
;
;
;    versucht, Datensatz hinter Dateiende zu lesen --> EOF
;
A3297:  XOR     A               ; Code 'Funktion OK'
        LD      B,A             ; Null Byte bereitgestellt
        LD      HL,(S1040)      ; Zeiger auf aktuellen Datei-Verwaltungssatz
        INC     HL              ; Datei - Nummer √ºberspringen
        SET     7,(HL)          ; Code 'Dateiende' setzen
A329F:  POP     DE              ; Zeiger auf bereitgestellten Datensatz
        POP     HL              ; geretteten Register-Wert holen
        RET
;
;
;    Programmblock von Diskette lesen
;
A32A2:  LD      DE,(S1014)      ; Datei-L√§nge holen
        LD      BC,(S101E)      ; Sektornummer erster Sektor holen
        CALL    A379B           ; Sektor(en) von Diskette lesen
        JP      A34CE           ; nicht mehr ben√∂tigte Diskettendaten im Rechner l√∂schen
;
;
;    Sektoren f√ºr Programm bereitstellen, Programm auf Diskette schreiben
;
A32B0:  CALL    A32BA           ; Anzahl Sektoren errechnen/Programm-Daten wegschreiben
        LD      IY,S1000        ; Zeiger auf Speicher f√ºr Datei - Kennung
        JP      A33DC           ; Programm ins Inhaltsverzeichnis eintragen
;
;
;    Anzahl Sektoren f√ºr Programm errechnen und Programm auf Diskette wegschreiben
;
A32BA:  PUSH    DE              ; Zeiger auf Speicherbereich merken
        CALL    A3596           ; Anzahl Sektoren der Datei errechnen
        CALL    A3696           ; Sektoren bereitstellen und reservieren
        LD      (S101E),BC      ; Sektornummer erster Sektor merken
        LD      D,E             ; Anzahl Sektoren
        LD      E,0             ; DE enth√§lt Anzahl Sektoren
        POP     HL              ; Zeiger auf Speicherbereich
        JP      B379A           ; Sektor(en) auf Diskette wegschreiben
;
;
;    SWAP - Hauptprogramm wegschreiben oder lesen    (Software command code:  68)
;
A32CC:  OR      A               ; Flag 'Lesen/Schreiben'
        JR      NZ,A3304        ; SWAP - Hauptprogramm lesen
;
;
;    SWAP - Hauptprogramm auf Diskette wegschreiben
;
        PUSH    DE              ; Zeiger auf Speicherbereich mit SWAP - Hauptprogramm
        CALL    A333A           ; untersuchen, ob SWAP - Hauptprogramm vorhanden
        LD      A,0             ; Code 'Sektoren freigeben'
        CALL    Z,A3321         ; ja --> altes SWAP - Hauptprogramm l√∂schen
        POP     DE              ; Zeiger auf Speicherbereich mit SWAP - Hauptprogramm
        CALL    A32BA           ; Programm-Daten auf Diskette bereitstellen
        LD      HL,S1000        ; Zeiger auf Speicher f√ºr Datei-Kennung
        OR      11111111B       ; Code 'Sektoren sperren'
        CALL    A3321           ; Sektoren f√ºr SWAP - Hauptprogramm sperren
        CALL    A35F0           ; Sektorverzeichnis auf Diskette schreiben
        LD      HL,S27D0        ; Zeiger auf Speicher f√ºr Inhaltsverzeichnis
        LD      (HL),081H       ; Code 'SWAP - Hauptprogramm'
        PUSH    HL              ;! Zeiger auf Stelle f√ºr Sektorenverzeichnis
        POP     IY              ;! nach IY
        LD      HL,(S1014)      ; Datei-L√§nge holen
        LD      (IY+20),L       ;! und als Datei-L√§nge in Inhaltsverzeichnis-
        LD      (IY+21),H       ;! Eintrag eintragen
        LD      HL,(S101E)      ; Sektornummer erster Sektor holen
        LD      (IY+30),L       ;! Sektornummer des ersten Sektors in
        LD      (IY+31),H       ;! Inhaltsverzeichnis-Eintrag eintragen
        JP      A3702           ; Inhaltsverzeichnis auf Diskette schreiben
;
;
;    SWAP - Hauptprogramm von Diskette lesen
;
A3304:  PUSH    HL              ; Register - Wert retten
        CALL    A333A           ; untersuchen, ob SWAP - Hauptprogramm vorhanden
        JP      NZ,A1F9D        ; nein -->  Fehler 52  Disk mismatch error
        DEC     (HL)            ; Datei-Typ-Code wieder auf 'kein SWAP-Programm
        LD      DE,S1000        ; Zeiger auf Speicher f√ºr Datei - Kennung
        CALL    A35EA           ; 32 Byte von (HL) nach (DE) √ºbertragen
        CALL    A3702           ; Inhaltsverzeichnis auf Diskette schreiben
        XOR     A               ; Code 'Sektoren freigeben'
        LD      HL,S27D0        ; Zeiger auf Speicher f√ºr Inhaltsverzeichnis
        CALL    A3321           ; Sektoren des SWAP - Hauptprogrammes freigeben
        CALL    A35F0           ; Sektorverzeichnis auf Diskette schreiben
        POP     HL              ; geretteten Register-Wert holen
        RET
;
;
;    Sektoren der Datei mit Inhaltsverzeichnis-Eintrag (HL) sperren oder freigeben
;
A3321:  CALL    A00C7           ; Register IX, HL, BC, DE retten
        PUSH    AF              ; Flag 'Sektoren sperren/freigeben' retten
        LD      DE,20           ; Offset auf Dateil√§nge
        ADD     HL,DE           ; Zeiger auf Dateil√§nge errechnen
        CALL    A012D           ; Dateil√§nge aus Inhaltsverzeichnis holen
        LD      BC,8            ; Offset auf erste Sektornummer
        ADD     HL,BC           ; Zeiger auf erste Sektornummer
        LD      C,(HL)          ;! Sektornummer des ersten Sektors aus
        INC     HL              ;! Inhaltsverzeichnis - Eintrag holen
        LD      B,(HL)          ;!
        CALL    A359E           ; Anzahl Sektoren der Datei errechnen
        POP     AF              ; Flag 'Sektoren sperren/freigeben'
        JP      A363D           ; Sektoren sperren oder freigeben
;
;
;    Investigate whether SWAP - main program is present
;
A333A:  CALL    A1D27           ; deletable table of contents on device ?
        JP      Z,A1FAC         ; no --> Error 57: Can't execute error
        CALL    A35FC           ; Read sector directory/compare with computer directory
        CALL    A36FD           ; Read table of contents from diskette
        LD      A,(HL)          ; Get file type mode of first entry
        CP      081H            ; SWAP main program saved? 
        RET
;
;
;
;
T334A:  LD      A,00001001b     ; 'Open file for reading' code
        LD      (S1043),A       ; remember file access mode
;
;
;    Datei auf Diskette er√∂ffnen
;
A334F:  CALL    A3739           ; alle Inhaltsverzeichnis-Eintr√§ge bereitstellen
        DEFW    A3378           ; Adresse f√ºr 'Eintrag vorhanden'
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        BIT     0,A             ; Datei zum Lesen er√∂ffnen  ?
        JP      NZ,A1F88        ; ja --> Fehler 40  File not found error
        PUSH    AF              ; Datei - Zugriffscode retten
        LD      DE,1            ; einen Sektor bereitstellen
        CALL    A3696           ; Sektor bereitstellen und reservieren
        LD      (IY+30),C       ;! Sektornummer des ersten Sektors in
        LD      (IY+31),B       ;! Inhaltsverzeichnis-Eintrag eintragen
        LD      (IY+70),1       ; Flag 'Blocknummernsektor wegschreiben'
        POP     AF              ; Datei - Zugriffscode holen
        BIT     1,A             ; Datei zum Schreiben er√∂ffnen  ?
        RET     Z               ; nein
        LD      HL,(S180D)      ; Zeiger auf Sektornummer im Sektor
        LD      (HL),C          ;! Sektornummer des ersten Sektors eintragen
        INC     HL              ;!
        LD      (HL),B          ;!
        RET
;             
A3378:  RET     M               ; SWAP - Eintrag
        RET     Z               ; Eintrag nicht belegt
        CALL    A1EAF           ; Dateinamen (HL) mit vorgegebenem Dateinamen vergleichen
        RET     NZ              ; Dateinamen nicht gleich
        POP     AF              ; R√ºcksprungadresse verwerfen
        LD      A,(S1043)       ; Datei - Zugriffscode holen
        BIT     1,A             ; Datei zum Schreiben er√∂ffnen  ?
        JP      NZ,A1F8E        ; ja --> Fehler 42  Already exist error
        LD      (S33BF),HL      ; Zeiger auf letzten behandelten Inhaltsverzeichnis-Eintrag
        PUSH    HL              ; Zeiger auf Datei-Eintrag retten
        CALL    A35EA           ; 32 Byte von (HL) nach (DE) √ºbertragen
        LD      B,32            ; L√§nge Inhaltsverzeichniseintrag
        CALL    A013D           ; Speicherbereich (DE) l√∂schen
        POP     HL              ; Zeiger auf Datei-Eintrag holen
        LD      A,(HL)          ; Datei-Typ-Modus holen
        PUSH    IY              ;! Zeiger auf Datei-Kennung
        POP     DE              ;! Dateidatensatz nach DE
        CALL    A35EA           ; 32 Byte von (HL) nach (DE) √ºbertragen
        LD      HL,S1043        ; Datei-Zugriffscode holen
        BIT     3,(HL)          
        RET     NZ              
        BIT     0,(HL)          ; Datei zum Lesen er√∂ffnen  ?
        JP      NZ,A321C        ; n√§chsten Sektor der sequentiellen Datei f√ºr Lesen bereitstellen
        CALL    A3624           ; Sektorverzeichnis des Laufwerks bereitstellen
        CALL    A3258           ; Blocknummernsektor der RANDOM-Datei lesen
        LD      D,H             ;! Zeiger auf Speicher mit Blocknummern-
        LD      E,L             ;! sektor nach DE
A33AE:  LD      A,(HL)          ;! Blocknummer vorhanden  ?
        INC     HL              ;!
        OR      (HL)            ;!
        INC     HL              
        JR      NZ,A33AE        ; ja --> Ende der Blocknummern suchen
        DEC     HL              ;! Zeiger wieder auf letzte Blocknummer
        DEC     HL              ;!
        SBC     HL,DE           ; Offset auf letzte Blocknummer errechnen
        LD      (IY+66),L       ;! und merken
        LD      (IY+67),H       ;!
        RET
;
S33BF:  DEFS    2               ; Zeiger auf letzten behandelten Inhaltsverzeichnis-Eintrag
;
;
;    Datei auf Diskette schlie√üen oder Dateidaten im Rechner l√∂schen
;
A33C1:  LD      A,B             ; Flag 'Schlie√üen/L√∂schen' holen
        OR      A               ; Dateidaten l√∂schen  ?
        RET     Z               ; ja --> fertig
        LD      A,(S1043)       ; Datei-Zugriffscode holen
        BIT     0,A             ; Datei zum Lesen er√∂ffnen  ?
        RET     NZ              ; ja
        BIT     2,A             ; Datei f√ºr Schreiben/Lesen er√∂ffnen  ?
        JR      NZ,A33F5        ; ja --> RANDOM - Datei
        LD      A,00000110B     ; Code 'letzten Sektor schreiben'
        CALL    A30D7           ; letzten Sektor auf Diskette schreiben
        PUSH    IY              ;! Zeiger auf Datei-Kennung im Dateiverwaltungs-
        POP     HL              ;! Datensatz nach HL
        LD      DE,S1000        ; Zeiger auf Speicher f√ºr Datei-Kennnung
        CALL    A35EA           ; 32 Byte von (HL) nach (DE) √ºbertragen
A33DC:  CALL    A3739           ; alle Inhaltsverzeichnis-Eintr√§ge bereitstellen
        DEFW    A33EC           ; Adresse f√ºr 'Eintrag vorhanden'
        JP      Z,A1F9A         ; Fehler 51  Too many files error
A33E4:  LD      A,1             ; Code 'Datei im Inhaltsverzeichnis eintragen'
        LD      B,(IY+0)        ; Datei - Typ - Modus holen
        JP      A3530           ; Datei im Inhaltsverzeichnis der Diskette eintragen
;
;
;   untersuchen, ob Dateiname (HL) ungleich vorgegebenem Dateinamen ist
;
A33EC:  RET     M               ; SWAP - Eintrag
        RET     Z               ; Datei - Eintrag nicht belegt
        CALL    A1EAF           ; Dateinamen (HL) mit vorgegebenem Dateinamen vergleichen
        RET     NZ              ; Dateinamen nicht gleich
        JP      A1F8E           ; Fehler 42  Already exist error
;
;
;    RANDOM - Datei schlie√üen
;
A33F5:  CALL    A3192           ; RANDOM - Sektor, wenn ge√§ndert, wegschreiben
        LD      A,(IY+70)       ; Flag 'Blocknummernsektor wegschreiben'
        OR      A               ; nicht gesetzt  ?
        RET     Z               ; ja --> fertig
        CALL    A3739           ; alle Inhaltsverzeichnis-Eintr√§ge bereitstellen
        DEFW    A3407           ; Adresse f√ºr 'Eintrag vorhanden'
        JP      Z,A1F9A         ; Fehler 51  Too many files error
        JR      A33E4           ; Datei ins Inhaltsverzeichnis der Diskette eintragen
;
A3407:  RET     M               ; SWAP - Eintrag
        RET     Z               ; Eintrag nicht belegt
        CALL    A1EAF           ; Dateinamen (HL) mit vorgegebenem Dateinamen vergleichen
        RET     NZ              ; Dateinamen nicht gleich
        POP     AF              ; R√ºcksprungadresse verwerfen
        LD      (IY+69),1       ; Flag 'Sektor mit Sektorblocknummern behandeln' eintragen
        LD      A,(HL)          ; Datei-Typ-Modus aus Inhaltsverzeichnis
        CP      (IY+0)          ; mit Datei-Typ der Datei vergleichen
        JP      NZ,A1FB2        ; Fehler 61, Illegal filemode error
        JR      A33E4           ; Daten ins Inhaltsverzeichnis der Diskette eintragen
;
;
;    Datei sch√ºtzen oder freigeben    (Software command code:  63)
;
A341B:  CALL    A00C7           ; Register IX, HL, BC, DE retten
        LD      (D3434+1),A     ; Flag 'Sperren/Freigeben' eintragen
        CALL    A3739           ; alle Inhaltsverzeichnis-Eintr√§ge bereitstellen
        DEFW    A3429           ; Adresse f√ºr 'Eintrag vorhanden'
        JP      A1F88           ; Fehler 40  File not found error
;
A3429:  RET     Z               ; Eintrag nicht belegt
        RET     M               ; SWAP - Eintrag
        CALL    A1EAF           ; Dateinamen (HL) mit vorgegebenem Dateinamen vergleichen
        RET     NZ              ; Dateinamen nicht gleich
        POP     AF              ; R√ºcksprungadresse verwerfen
        LD      BC,18           ; Offset auf Datei-Schutz-Flag
        ADD     HL,BC           ; Zeiger auf Datei-Schutz-Flag errechnen
D3434:
        LD      (HL),-1         ; Flag 'Sperren/Freigeben' eintragen
A3436:  CALL    A3702           ; Inhaltsverzeichnis auf Diskette schreiben
        JP      A34CE           ; nicht mehr ben√∂tigte Diskettendaten im Rechner l√∂schen
;
;
;    Datei l√∂schen     (Software command code: 61)
;
A343C:  CALL    A00C7           ; Register IX, HL, BC, DE retten
        CALL    A1D27           ; aktuelles Ger√§t gleich Diskette  ?
        JR      NZ,A3458        ; ja -->  Datei auf Diskette l√∂schen
        LD      HL,(S1061)      ; Anfangsadresse  'Datei l√∂schen'  holen
        LD      A,L             ;! Adresse vorhanden  ?
        OR      H               ;!
        JR      Z,A3488         ; nein -->  Fehler 58'  Can't execute error
        PUSH    HL              ; Anfangsadresse der Ger√§te - Routine retten
        RST     DO_CMD          ; Software - Kommando aufrufen
        DEFB    47              ; Kommando  47  (Programm-) Datei er√∂ffnen
        LD      A,00000010B     ; Code for 'Datei zum Schreiben er√∂ffnen'
        LD      (S1043),A       ; als Datei - Zugriffscode merken
        CALL    A1C6D           ; testen, ob auf Ger√§t nicht schon Datei zum Schreiben er√∂ffnet
        JR      A349D           ; Datei l√∂schen
;
;
;   Datei auf Diskette l√∂schen
;
A3458:  RST     DO_CMD          ; Software - Kommando ausf√ºhren
        DEFB    47              ; Kommando  47   (Programm-)  Datei er√∂ffnen
        LD      HL,(S33BF)      ; Zeiger auf letzten behandelten Inhaltsverzeichnis-Eintrag
        CALL    A34C1           ; Abfrage, ob Datei schreibgesch√ºtzt ist
        PUSH    HL              ; Zeiger auf Inhaltsverzeichniseintrag retten
        LD      IX,T3471        ; Adresse 'Dateinamen vergleichen'
        CALL    A1C71           ; alle vorhandenen Datei - Datens√§tze √ºberpr√ºfen
        POP     HL              ; Zeiger auf Inhaltsverzeichnis - Eintrag holen
        LD      B,(HL)          ; Datei - Typ - Modus holen
        XOR     A               ; Code for 'Datei gel√∂scht'
        LD      (IY+0),A        ; eintragen
        JP      A3530           ; Datei l√∂schen und ge√§nderte Daten im Inhaltsverzeichnis eintragen
;
T3471:  INC     HL              ;! Zeiger auf Datei-Datensatz auf Dateinamen
        INC     HL              ;! stellen
        INC     HL              ;!
        CALL    A1EAF           ; Dateinamen (HL) mit vorgegebenem Dateinamen vergleichen
        JP      Z,A1F91         ; Fehler 43  Already open error
        RET
;
;
;   Datei umbenennen     (Software command code:  62)
;
A347B:  CALL    A00C7           ; Register IX, HL, BC, DE retten
        CALL    A1D27           ; aktuelles Ger√§t gleich Diskette  ?
        JR      NZ,A34A2        ; ja -->  Datei auf Diskette umbenennen
        LD      HL,(S1063)      ; Anfangsadresse  'Datei umbenennen'  holen
        LD      A,L             ;! Adresse vorhanden  ?
        OR      H               ;!
A3488:  JP      Z,A1FAC         ; nein -->  Fehler 58'  Can't execute error
        PUSH    HL              ; Anfangsadresse der Ger√§te - Routine retten
        RST     DO_CMD          ; Software - Kommando ausf√ºhren
        DEFB    47              ; Kommando  47   (Programm-)  Datei er√∂ffnen
        LD      HL,S1000        ; Zeiger auf Speicher f√ºr Datei - Kennung
        CALL    A1EC9           ; Dateinamen aus Text (HL) nach (DE) bereitstellen
        LD      HL,256 * 2 + 0  ; Code for 'zum Schreiben er√∂ffnen'
        LD      (S1042),HL      ; als Datei - Zugriffscode merken
        CALL    A1C3D           ; pr√ºfen, da√ü nur eine Datei er√∂ffnet/Name noch nicht vorhanden
A349D:  POP     IX              ; Anfangsadresse der Routine nach IX
        JP      A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
;
;
;   Datei auf Diskette umbenennen
;
A34A2:  RST     DO_CMD          ; Software - Kommando ausf√ºhren
        DEFB    47              ; Kommando  47   (Programm-)  Datei er√∂ffnen
        LD      HL,S1000        ; Zeiger auf Speicher f√ºr Dateinamen
        CALL    A1EC9           ; Dateinamen aus Text (HL) nach (DE) bereitstellen
        CALL    A3739           ; alle Inhaltsverzeichnis-Eintr√§ge bereitstellen
        DEFW    A33EC           ; Adresse  'Untersuchen, da√ü Dateinamen ungleich vorgegeb. ist'
        LD      HL,(S33BF)      ; Zeiger auf letzten behandelten Inhaltsverzeichnis-Eintrag
        CALL    A34C1           ; Abfrage, ob Datei schreibgesch√ºtzt ist
        LD      DE,S1001        ; Zeiger auf neuen Dateinamen
        INC     HL              ; Datei - Typ - Flag im Inhaltsverzeichnis √ºberspringen
        LD      B,17            ; maximale L√§nge Dateiname
        CALL    A014A           ; Speicherbereich von (DE) nach (HL) √ºbertragen
        JP      A3436           ; Inhaltsverzeichnis auf Diskette schreiben
;
;
;    Abfrage, ob Datei schreibgesch√ºtzt ist
;
A34C1:  CALL    A00C7           ; Register IX, HL, BC, DE retten
        LD      DE,18           ; Abstand zum Schreib-Schutz-Flag
        ADD     HL,DE           ; Zeiger auf Schreib-Schutz-Flag errechnen
        LD      A,(HL)          ; Schreib-Schutz-Flag holen
        OR      A               ; Schreib-Schutz gesetzt  ?
        RET     Z               ; nein -->  OK
        JP      A1F94           ; Fehler 46  Write protect error
;
;
;    nicht mehr ben√∂tigte Diskettendaten im Rechner l√∂schen
;
A34CE:  CALL    A00BA           ; Register IX, HL, BC, DE retten
        XOR     A               ; Accu auf Null
        LD      (S1FD9),A       ; Ausgabe - Dateinummer l√∂schen
        LD      A,224           ; interne Dateinummer f√ºr verschiedene Speicher vorgeben
A34D7:  PUSH    AF              ; Dateinummer retten
        RST     DO_CMD          ; Software-Kommando ausf√ºhren
        DEFB    43              ; Code 43  Dynamischen Speicherbereich l√∂schen
        POP     AF              ; gerettete Dateinummer holen
        INC     A               ; plus eins
        JR      NZ,A34D7        ; weitere dynamischen Speicherbereich l√∂schen
        LD      HL,(S1044)      ; Zeiger auf aktuelle Ger√§te - Tabelle
        LD      DE,W37C2        ; Zeiger auf Ger√§te - Treiber FDx:
        CALL    A3794           ; HL -  und DE - Register vergleichen
        RET     NZ              ; nicht Diskettenstation
        LD      A,(S1046)       ; Ger√§te - Nummer holen
        EXX                     
        LD      H,A             ; Ger√§te - Nummer merken
        LD      D,0             ; Code 'Keine Diskettenstation mehr im Zugriff'
        LD      B,3             ; vier Diskettenlaufwerke √ºberpr√ºfen
        EXX                     
        XOR     A               ; Accu auf Null
        LD      (S1042),A       ; als interne Ger√§te - Nummer merken
A34F6:  EXX                     
        LD      A,B             ; Ger√§te - Nummer holen
        LD      (S1046),A       ; Ger√§te - Nummer eintragen
        ADD     A,144           ; umrechnen in Datensatznummer f√ºr Sektorverzeichnis
        LD      L,A             ; Datensatznummer f√ºr Sektorverzeichnis merken
        LD      E,0             ; Code 'keine Datei mehr auf Laufwerk er√∂ffnet'
        EXX                     
        LD      IX,T3522        ; Adresse 'merken, da√ü Laufwerk im Zugriff ist'
        CALL    A1C71           ; alle vorhandenen Datei - Datens√§tze durchspielen
        EXX                     
        BIT     7,E             ; Datei auf Laufwerk offen
        LD      A,L             ; Speichernummer des Sektorverzeichnisses holen
        EXX                     
        CALL    Z,A1F06         ; Laufwerk nicht mehr im Zugriff --> Dynamischen Spei-
        EXX                     ;        cher l√∂schen
        DEC     B               ; Laufwerk - Nummer minus eins
        EXX                     
        JP      P,A34F6         ; weitere Laufwerke √ºberpr√ºfen
        EXX                     
        LD      A,H             ; gemerkte Ger√§te - Nummer holen
        LD      (S1046),A       ; und als Ger√§te - Nummer eintragen
        BIT     7,D             ; √ºberhaupt noch Datei auf Diskette offen  ?
        EXX                     
        CALL    Z,A38C2         ; nein --> Disketten - Routinen initialisieren und Motoren
        RET                     ;             ausschalten
;
T3522:  EXX                     
        LD      DE,-1           ; Code 'Laufwerk im Zugriff' merken
        EXX                     
        RET
;
;
;    Zeiger auf Speicher f√ºr Sektorverzeichnis des aktuellen
;    Laufwerks bereitstellen
;
A3528:  LD      A,(S1046)       ; Ger√§te - Nummer holen
        ADD     A,144           ; umrechnen in Datensatz f√ºr Sektorverzeichnis
        RST     DO_CMD          ; Software - Kommando ausf√ºhren
        DEFB    41              ; Code 41  Zeiger auf Datensatz nach Nummer im Accu
        RET                     ;   bereitstellen
;
;
;    Datei l√∂schen oder Datei im Inhaltsverzeichnis eintragen
;
A3530:  LD      (S3595),A       ; Flag 'Sektor sperren / freigeben' merken
        LD      A,B             ; Datei - Typ der Datei holen
        PUSH    AF              ; und merken
        EX      DE,HL           ; Zeiger auf Dateinamen nach DE
        LD      HL,S1000        ; Zeiger auf Speicher f√ºr Datei - Kennung
        CALL    A35EA           ; 32 Byte von (HL) nach (DE) √ºbertragen
        CALL    A35FC           ; Sektorverzeichnis lesen/mit Rechnerverzeichnis vergleichen
        POP     AF              ; geretteten Datei - Typ holen
        CP      _BRD + 1        ; bekannter Datei - Typ  ?
        JR      C,A354E         ; ja
        LD      A,(S1012)       ; Schreib - Schutz - Byte holen
        RLA
        LD      A,_BSD          ; Vorgabe 'Datei in Datenblocks'
        JR      NC,A354E
        LD      A,_OBJ          ; Vorgabe 'Datei als Programmblock'
A354E:  LD      HL,W3564 + -2   ; Anfangsadressen der DELETE - Routinen
        ADD     A,A             ; Datei - Typ mal zwei
        CALL    A0158           ; Wert im Accu zu HL-Register addieren
        CALL    A0151           ; Wert aus Tabelle (HL) nach HL holen
        CALL    A00A7           ; Programm (HL) als Unterprogramm aufrufen
        CALL    A3702           ; Inhaltsverzeichnis auf Diskette schreiben
        CALL    A35F0           ; Sektorverzeichnis auf Diskette schreiben
        JP      A34CE           ; nicht  mehr ben√∂tigte Diskettendaten im Rechner l√∂schen
;
;
;    Tabelle mit Anfangsadressen der DELETE - Routinen der Datei - Typen
;
W3564:  DEFW    A358C           ; Adresse  DELETE OBJ - Datei
        DEFW    A358C           ; Adresse  DELETE BTX - Datei
        DEFW    A356C           ; Adresse  DELETE BSD - Datei
        DEFW    A35A8           ; Adresse  DELETE BRD - Datei
;
;
;    Sequentielle Datei (BSD) auf Diskette l√∂schen
;    Sektoren f√ºr sequentielle Datei auf Diskette sperren
;
A356C:  LD      HL,S1020        ; Zeiger auf Ende Speicher f√ºr Directory-Eintrag
A356F:  DEC     HL              ; Zeiger auf Sektornummer
        LD      B,(HL)          ;! Sektornummer des n√§chsten Sektors
        DEC     HL              ;! holen
        LD      C,(HL)          ;!
        LD      A,B             ;! gleich null  ?
        OR      C               ;!
        RET     Z               ; ja -->  fertig
        LD      DE,256          ; L√§nge ein Sektor auf Diskette
        LD      HL,S11A4        ; Zeiger auf Zwischenspeicher f√ºr Sektor
        PUSH    HL              ; Zeiger auf Speicher f√ºr Sektor merken
        PUSH    DE              ; L√§nge des Sektors merken
        CALL    A379B           ; Sektor von Diskette lesen
        LD      DE,1            ; Anzahl Sektoren vorgeben
        CALL    A358F           ; Sektor sperren oder freigeben
        POP     DE              ; Sektorl√§nge holen
        POP     HL              ; Zeiger auf Anfang Sektor holen
        ADD     HL,DE           ; Zeiger auf Ende Sektor errechnen
        JR      A356F           ; weitere Sektoren freigeben
;
;
;    Maschinensprachendatei (OBJ) oder Basic-Daten (BTX) l√∂schen
;    oder Sektoren f√ºr Datei auf Diskette sperren
;                               
A358C:  CALL    A3596           ; Anzahl Sektoren der Datei errechnen
A358F:  LD      A,(S3595)       ; Flag 'Sektoren sperren/freigeben' holen
        JP      A363D           ; Sektoren sperren oder freigeben
;
;
S3595:  DEFS    1               ; Flag 'Sektor sperren / freigeben' holen
;
;
;    Anzahl der Sektoren der Datei errechnen
;
A3596:  LD      DE,(S1014)      ; Datei - L√§nge holen
        LD      BC,(S101E)      ; Sektornummer erster Sektor holen
A359E:  LD      A,E             ;! Dateil√§nge gleich null  ?
        OR      D               ;!
        JR      Z,A35A3         ; ja
        DEC     DE              ; Dateil√§nge corrigieren
A35A3:  INC     D               ; Anzahl Sektoren corrigieren
        LD      E,D             ; Anzahl Sektoren der Datei
        LD      D,0             ; DE enth√§lt Anzahl Sektoren
        RET
;
;
;    RANDOM - Datei (BRD) auf Diskette l√∂schen oder
;    Sektoren der Datei auf Diskette sperren
;
A35A8:  LD      DE,256          ; Sektorl√§nge
        LD      BC,(S101E)      ; Sektornummer erster Sektor holen
        LD      A,(S3595)       ; Flag 'Sektor sperren / freigeben' holen
        OR      A               ; Datei l√∂schen  ?
        LD      HL,S11A4        ; Zeiger auf Zwischenspeicher
        JR      Z,A35BB         ; Code 'Sektoren freigeben'
        LD      HL,(S180B)      ; Zeiger auf Speicher mit Blocknummern
A35BB:  PUSH    HL              ; Zeiger auf Blocknummernsektor
        PUSH    AF              ; Flag 'Lesen / Schreiben' merken
        CALL    A379C           ; Blocknummernsektor schreiben oder Lesen
        POP     AF              ; Flag 'Lesen / Schreiben' holen
        PUSH    AF              ; und wieder merken
        JR      Z,A35C8         ; Datei l√∂schen
        LD      A,(IY+69)       ; Flag 'Sektor mit Sektorblocknummern behandeln'
        OR      A               ; gesetzt  ?
A35C8:  LD      DE,1            ; ein Sektor  (Blocknummernsektor)
        CALL    Z,A358F         ; ja --> Sektor freigeben oder sperren
        POP     AF              ; Flag 'Lesen / Schreiben' holen
        POP     HL              ; Zeiger auf Blocknummernsektor holen
        JR      Z,A35D9         ; Datei l√∂schen
        LD      E,(IY+66)       ;! Offset auf letzte geschriebene Block-
        LD      D,(IY+67)       ;! nummer holen
        ADD     HL,DE           ; Zeiger auf zu behandelnde Blocknummer errechnen
A35D9:  LD      C,(HL)          ;! Sektornummer Blockanfang holen
        INC     HL              ;!
        LD      B,(HL)          ;!
        INC     HL
        LD      A,B             ;! Sektornummer gleich Null  ?
        OR      C               ;!
        RET     Z               ; ja -->  fertig
        PUSH    HL              ; Zeiger auf Sektornummer retten
        LD      DE,16           ; 16 Sektoren je Block
        CALL    A358F           ; Sektoren sperren oder freigeben
        POP     HL              ; Zeiger auf Sektorblocknummern
        JR      A35D9           ; n√§chsten Block sperren oder freigeben
;
;
;    32 Byte von (HL) nach (DE) √ºbertragen
;
A35EA:  LD      BC,32           ; L√§nge Directory-Eintrag/Random-Datensatz
        LDIR                    ; Directory - Eintrag √ºbertragen
        RET
;
;
;    Sektorverzeichnis auf Diskette schreiben
;
A35F0:  LD      HL,S2FD0        ; Zeiger auf Speicher f√ºr Sektorenverzeichnis
        LD      DE,256          ; 256 Bytes je Sektor
        LD      BC,15           ; Sektornummmer f√ºr Sektorverzeichnis
        JP      B379A           ; Sektor auf Diskette wegschreiben
;
;
;    Sektorverzeichnis lesen und mit Sektorverzeichnis im Rechner vergleichen
;
A35FC:  LD      HL,S2FD0        ; Zeiger auf Speicher f√ºr Sektorverzeichnis
        CALL    A362D           ; Sektor mit Sektorverzeichnis lesen
        PUSH    HL              ; Zeiger auf Speicher f√ºr Sektorverzeichnis
        CALL    A3528           ; Zeiger auf Sektorverzeichnis aktuelles Laufwerk
        EX      DE,HL           ; Zeiger nach DE
        POP     HL              ; Zeiger auf Speicher f√ºr Sektorverzeichnis
        RET     C               ; kein aktuelles Sektorverzeichnis im Rechner
        PUSH    HL              ; Zeiger auf Speicher f√ºr Sektorverzeichnis
        LD      A,(DE)          ;! Volume - Nummern vergleichen
        CP      (HL)            ;!
        JP      NZ,A1F9D        ; nicht gleich -->  Fehler 52  Disk mismatch error
        LD      BC,6            ; Offset auf Sektorbit-Tabelle
        ADD     HL,BC           ; Zeiger auf Sektorbit-Tabelle errechnen
        EX      DE,HL
        ADD     HL,BC           ; Zeiger auf Sektorbit-Tabelle errechnen
        EX      DE,HL
        LD      B,250           ; 250 Bytes vergleichen
A3618:  LD      A,(DE)          ;! untersuchen, ob im Rechner nicht weniger
        CPL                     ;! Bits gesetzt sind
        AND     (HL)            ;!
        JP      NZ,A1F9D        ; Fehler -->  Fehler 52  Disk mismatch error
        INC     HL              ;! Zeiger auf n√§chstes Byte
        INC     DE              ;!
        DJNZ    A3618           ; weitere Bytes untersuchen
        POP     HL              ; Zeiger auf Speicher f√ºr Sektorverzeichnis holen
        RET
;
;
;    Sektorverzeichnis des aktuellen Laufwerks, wenn noch nicht vorhanden, einlesen
;
A3624:  CALL    A3528           ; Zeiger auf Sektorverzeichnis aktuelles Laufwerk
        RET     NC              ; Sektorverzeichnis schon vorhanden
        LD      DE,256          ; 256 Bytes L√§nge
        RST     DO_CMD          ; Software - Kommando ausf√ºhren
        DEFB    42              ; Code 42  Zwischenspeicher bereitstellen
;
;
;    Sektor mit Sektorverzeichnis des aktuellen Laufwerks lesen
;
A362D:  LD      BC,15           ; Sektor 15  (Sektor mit Sektorverzeichnis)
        LD      DE,256          ; 256 Bytes je Sektor
        XOR     A               ; Code 'Sektor lesen'
        CALL    A379F           ; Sektor mit Sektorverzeichnis lesen
        LD      A,(HL)          ; erstes Byte des Sektors holen
        OR      A               ; gr√∂√üer 128  ?
        JP      M,A1F85         ; ja --> Fehler 128  System ID error
        RET
;
;
;    in DE angegebene Anzahl Sektoren sperren oder freigeben
;
;    im aktuellen Sektorverzeichnis und im Sektorverzeichnis
;    des Laufwerks freigeben
;
A363D:  LD      HL,S2FD0        ; Zeiger auf Speicher f√ºr Sektorverzeichnis
        CALL    A364A           ; Sektoren im aktuellen Verzeichnis behandeln
        OR      A               ; Flag 'Sperren / Freigeben'
        RET     NZ              ; Sektoren sperren -->  fertig
        CALL    A3528           ; Zeiger auf Sektorverzeichnis aktuelles Laufwerk
        RET     C               ; kein Sektorverzeichnis im Rechner
        XOR     A               ; Code 'Sektoren freigeben'
;
;
;    Sektoren im Sektorverzeichnis (HL) sperren oder freigeben
;
A364A:  CALL    A00BA           ; Register IX, HL, BC, DE, AF retten
        OR      A               ; Flag 'Sperren / Freigeben'
        PUSH    HL              ; Zeiger auf Sektorverzeichnis retten
        LD      HL,0B600H       ; OR (HL)  NOP    (Z-80 - Befehle)
        LD      A,INC_DE        ; Z-80 - Befehl INC DE  (Anzahl Sektoren plus eins)
        JR      NZ,A365B        ; Sektoren sperren
        LD      HL,0A62FH       ; AND (HL)  CPL   (Z-80 - Befehle)
        LD      A,DEC_DE        ; Z-80 - Befehl DEC DE  (Anzahl Sektoren minus eins)
A365B:  LD      (D3678),A       ; INC DE/DEC DE eintragen
        LD      (D368E),HL      ; Befehle f√ºr sperren oder freigeben eintragen
        POP     HL              ; Zeiger auf Sektorverzeichnis holen
A3662:  CALL    A366A           ; einen Sektor sperren oder freigeben
        INC     BC              ; Sektornummer plus eins
        DEC     E               ; Restanzahl Sektoren minus eins
        JR      NZ,A3662        ; weitere Sektoren behandeln
        RET
;
;
;    einen Sektor sperren oder freigeben
;
A366A:  CALL    A00C7           ; Register IX, HL, BC, DE retten
        INC     HL              ; Volume - Nummer √ºberspringen
        LD      A,C             ;! absolute Sektornummer umrechnen in
        SUB     (HL)            ;! Sektoroffset
        LD      C,A             ;!   Low - Byte Offset merken
        JR      NC,A3674        ;!   kein Unterlauf
        DEC     B               ;!   High - Byte Offset corrigieren
A3674:  INC     HL
        LD      E,(HL)          ;! Anzahl belegte Sektoren holen
        INC     HL              ;!
        LD      D,(HL)          ;!
D3678:  NOP                     ; INC DE/DEC DE  (wird eingetragen)
        DEC     HL
        LD      (HL),E          ;! neue Anzahl belegte Sektoren
        INC     HL              ;! wieder eintragen
        LD      (HL),D          ;!
        INC     HL
        INC     HL              ;! gr√∂√üte m√∂gliche Sektornummer
        INC     HL              ;! √ºberspringen
        LD      A,C             ; Low - Byte Sektornummer merken
        LD      E,3             ;! Sektornummer durch 8  (Offset auf Byte errechnen)
A3683:  SRL     B               ;!
        RR      C               ;!
        DEC     E               ;! Z√§hler minus eins
        JR      NZ,A3683        ;! weiter schieben
        ADD     HL,BC           ; Zeiger auf richtiges Byte errechnen
        CALL    A36F1           ; Bitmaske aus Bitnummer errechnen
D368E:  NOP                     ;! Sektorbit setzen oder zur√ºcksetzen
        NOP                     ;! (Befehle werden eingetragen)
        CP      (HL)            ; neuen Wert mit altem Wert vergleichen
        LD      (HL),A          ; neuen Wert merken
        RET     NZ              ; neuer Wert ist anders als alter Wert
        JP      A1F9D           ; Fehler 52  Disk mismatch error
;
;
;    Sektoren bereitstellen und reservieren
;
A3696:  PUSH    DE              ; Anzahl Sektoren retten
        CALL    A3624           ; Sektorverzeichnis des Laufwerks bereitstellen
        POP     DE              ; gerettete Anzahl Sektoren holen
        PUSH    HL              ; Zeiger auf sektorverzeichnis retten
        CALL    A36A4           ; zusammenh√§ngenden Block freier Sektoren suchen
        POP     HL              ; Zeiger auf sektorverzeichnis holen
        LD      A,1             ; Code 'Sektoren belegen'
        JR      A364A           ; Sektoren im Sektorverzeichnisperren
;
;
;    Zusammenh√§ngenden Block freier Sektoren suchen
;
A36A4:  LD      A,E             ; Anzahl Sektoren holen
        EXX
        LD      E,A             ;! Anzahl zu suchender freier Sektoren
        LD      D,A             ;! merken
        LD      B,00000001B     ; Vorgabe f√ºr Bitmaske
        EXX
        INC     HL              ; Volume - Nummer √ºberspringen
        LD      E,(HL)          ; Low - Byte Offset holen
        LD      D,0             ; High - Byte Vorgabe f√ºr Sektornummer
        INC     HL              ; Offset √ºberspringen
        INC     HL              ;! Anzahl belegte Sektoren √ºberspringen
        INC     HL              ;!
        LD      C,(HL)          ;! Anzahl Sektoren auf Diskette holen
        INC     HL              ;!
        LD      B,(HL)          ;!
        DEC     BC              ; f√ºr gr√∂√üte m√∂gliche Sektornummer corrigieren
        LD      (A36C1+1),BC    ; gr√∂√üte m√∂gliche Sektornummer in Routine eintragen
        INC     HL
        PUSH    HL              ; Zeiger auf Sektorbit - Tabelle auf Stack ablegen
        EXX
        POP     HL              ; Zeiger auf Sektorbit - Tabelle holen
        EXX
        LD      B,D             ;! Sektornummer vorgeben
        LD      C,E             ;!
A36C1:  LD      HL,0            ; gr√∂√üte m√∂gliche Sektornummer holen (wird eingetragen)
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; mit aktueller Sektornummer vergleichen
        JP      C,A1FA0         ; zu gro√ü -->  Fehler 53  No file space error
        EXX
        LD      A,B             ; aktuelle Bitmaske holen
        AND     (HL)            ; Bit in Sektortabelle maskieren
        EXX
        CALL    A36DB           ; untersuchen, ob Sektor noch frei
        INC     DE              ; aktuelle Sektornummer plus eins
        EXX
        RLC     B               ; aktuelle Bitmaske um ein Bit schieben
        JR      NC,A36D8        ; nicht von Bit 7 auf Bit 0 geschoben
        INC     HL              ; Zeiger auf Bittabelle auf n√§chstes Byte
A36D8:  EXX
        JR      A36C1           ; untersuchen, ob Sektornummer nicht schon zu gro√ü
;
A36DB:  JR      NZ,A36EA        ; Sektor nicht frei --> wieder von vorne anfangen
        EXX
        DEC     E               ; Restanzahl Sektoren minus eins
        EXX
        RET     NZ              ; noch nicht genug freie Sektoren
        POP     AF              ; R√ºcksprungadresse verwerfen
        EXX
        LD      A,D             ; Anzahl bereitgestellte Sektoren holen
        EXX
        LD      E,A             ; Anzahl bereitgestellte Sektoren
        LD      D,0             ; High - Byte Anzahl auf Null
        OR      A               ; Carry - Flag zur√ºcksetzen  (Code 'Funktion OK')
        RET
;
A36EA:  EXX
        LD      E,D             ; bereitzustellende Anzahl wieder vorgeben
        EXX
        LD      B,D             ;! erste Sektornummer des Blocks wieder vorgeben
        LD      C,E             ;!
        INC     BC              ; Sektornummer plus eins
        RET
;
;
;    Bitmaske aus Bit - Nummer errechnen
;
A36F1:  PUSH    BC              ; Register - Wert retten
        AND     00000111B       ; Bits f√ºr Bit-Nummer errechnen
        INC     A               ; Z√§hler corrigieren
        LD      B,A             ; Z√§hler merken
        XOR     A               ; Accu auf Null
        SCF                     ; Carry - Flag setzen
A36F8:  ADC     A,A             ; Bit um ein Bit schieben
        DJNZ    A36F8           ; Bit auf richtiges Bit schieben
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;    Inhaltsverzeichnis von Diskette lesen
;
A36FD:  CALL    A44A3           ; warten, bis alle Melodien vollst√§ndig gespielt sind
        XOR     A               ; Code 'Lesen'
        DEFB    LD_HL

;
;
;   Inhaltsverzeichnis auf Diskette schreiben
;
A3702:  OR      0FFH            ; Code for 'Schreiben'
        LD      HL,S27D0        ; Zeiger auf Speicher f√ºr Inhaltsverzeichnis
        LD      DE,2048         ; L√§nge Inhaltsverzeichnis
        LD      BC,16           ; Sektornummer des Inhaltsverzeichnisses
        CALL    A379C           ; Inhaltsverzeichnis schreiben oder lesen
        LD      A,(HL)          ; Kennung des SWAP - Programms holen
        OR      A               ; Wert gr√∂√üer 128  ?
        JP      P,A1F85         ; nein -->  Fehler 28  System ID error
        RET
;
;
;    freie Anzahl Kilobyte der Diskette errechnen
;
T3716:  PUSH    HL              ;! Register retten
        PUSH    DE              ;!
        CALL    A35FC           ; Sektorverzeichnis lesen/mit Rechnerverzeichnis vergleichen
        INC     HL              ; Volume - Nummer √ºberspringen
        INC     HL              ; Offset √ºberspringen
        CALL    A012D           ; Anzahl belegte Sektoren holen
        CALL    A0151           ; Gesamtzahl Sektoren holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Anzahl freie Sektoren errechnen
        JP      C,A1F85         ; Fehler 28  System ID error
        SRL     H               ;! umrechnen in Kilobyte
        RR      L               ;!
        SRL     H               ;!
        RR      L               ;!
        LD      B,H             ;! Anzahl freie Kilobytes nach BC
        LD      C,L             ;!
        POP     DE              ;! gerettete  Register holen
        POP     HL              ;!
        OR      A               ; Carry - Flag zur√ºcksetzen  (Code 'kein Fehler')
        JP      A38C2           ; Disketten-Routinen initialisieren und Motor ausschalten
;
;
;    Alle Inhaltsverzeichnis-Eintr√§ge bereitstellen
;
A3739:  CALL    A1D27           ; l√∂schbares Inhaltsverzeichnis auf Ger√§t  ?
        JP      Z,A1FAC         ; nein -->  Fehler 57  Can't execute error
        POP     HL              ; R√ºcksprungadresse vom Stack holen
        CALL    A012D           ; Adresse bei 'Eintrag vorhanden' holen
        LD      (D377B + 1),HL  ; R√ºcksprung f√ºr 'kein Eintrag' eintragen
        LD      (D3761 + 1),DE  ; R√ºcksprung f√ºr 'Eintrag vorhanden' eintragen
        XOR     A               ; Code 'keinen freien Eintrag gefunden'
        LD      (S378E),A       ; im Flag 'freien Eintrag gefunden' merken
        CALL    A36FD           ; Inhaltsverzeichnis von Diskette lesen
        LD      (S3792),HL      ; Zeiger auf aktuellen Eintrag merken
        LD      A,64            ; 64 Inhaltsverzeichniseintr√§ge
        LD      (S3791),A       ; im Z√§hler 'Restanzahl Inhaltsverzeichnis-Eintr√§ge' merken
A3759:  LD      HL,(S3792)      ; Zeiger auf aktuellen Eintrag
        LD      A,(HL)          ; Datei - Typ - Modus holen
        OR      A               ; Inhaltsverzeichnis - Eintrag frei  ?
        CALL    Z,A377E         ; ja --> Zeiger auf freien Eintrag merken
D3761:  CALL    -1              ; R√ºcksprung f√ºr 'Eintrag vorhanden'
        LD      HL,(S3792)      ; Zeiger auf aktuellen Eintrag
        LD      BC,32           ; L√§nge Inhaltsverzeichnis-Eintrag vorgeben
        ADD     HL,BC           ; Zeiger auf n√§chsten Eintrag errechnen
        LD      (S3792),HL      ; als Zeiger auf aktuellen Eintrag merken
        LD      HL,S3791        ; Z√§hler 'Restanzahl Inhaltsverzeichnis-Eintr√§ge'
        DEC     (HL)            ; Z√§hler minus eins
        JR      NZ,A3759        ; weitere Eintr√§ge --> abarbeiten
        LD      A,(S378E)       ; Flag 'freier Eintrag gefunden'
        LD      HL,(S378F)      ; Zeiger auf freien Eintrag holen
        OR      A               ; freier Eintrag  ?
D377B:  JP      -1              ; R√ºcksprung f√ºr 'kein Eintrag mehr'
;
;
;    Zeiger auf freien Eintrag merken
;
A377E:  PUSH    AF              ; Datei - Typ - Modus merken
        LD      A,(S378E)       ; Flag 'freier Eintrag gefunden' holen
        OR      A               ; schon freier Eintrag gefunden  ?
        JR      NZ,A378C        ; ja --> geretteten Register - Wert holen
        INC     A               ; Flag auf 'freien Eintrag gefunden'
        LD      (S378E),A       ; im Flag 'freier Eintrag gefunden'
        LD      (S378F),HL      ; Zeiger auf freien Eintrag merken
A378C:  POP     AF              ; geretteten Datei - Typ - Modus holen
        RET
;
;
S378E:  DEFS    1               ; Flag 'freier Eintrag gefunden'
S378F:  DEFS    2               ; Zeiger auf freien Eintrag
S3791:  DEFS    1               ; Z√§hler 'Restanzahl Inhaltsverzeichnis-Eintr√§ge'
S3792:  DEFS    2               ; Zeiger auf aktuellen Eintrag
;
;
;    HL - und DE - Register vergleichen
;
A3794:  PUSH    HL              ; Register - Wert retten
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Register vergleichen
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;    Sektor(en) auf Diskette wegschreiben
;
B379A:  DEFB    OR_N            ; Code for 'Sektor wegschreiben'
;
;
;    Sektor(en) von Diskette lesen
;
A379B:  XOR     A               ; Code 'Sektor lesen'
A379C:  CALL    A37B3           ; √ºberpr√ºfen, ob Diskette gewechselt werden
A379F:  CALL    A00C7           ; Register IX, HL, BC, DE retten
        OR      A               ; Lesen oder Schreiben  ?
        LD      IX,(S105D)      ; Anfangsadresse 'Sektor lesen' holen
        JR      Z,A37AD         ; Sektor(en) von Diskette lesen
        LD      IX,(S105F)      ; Anfangsadresse 'Sektor schreiben' holen
A37AD:  LD      A,(S1046)       ; Ger√§te - Nummer holen
        JP      A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
;
;
;    √ºberpr√ºfen, ob Diskette gewechselt wurde
;
A37B3:  CALL    A00BA           ; Register IX, HL, BC, DE, AF retten
        LD      A,(S37EA)       ; Controller - Status - Flag holen
        OR      A               ; Motor an  ?
        RET     M               ; ja --> braucht nicht √ºberpr√ºft zu werden
        CALL    A3528           ; Zeiger auf Sektorverzeichnis aktuelles Laufwerk
        RET     C               ; kein Sektorverzeichnis im Rechner
        JP      A35FC           ; Sektorverzeichnis lesen/mit Rechnerverzeichnis vergleichen
;
;
;    Ger√§te - Tabelle f√ºr Disketten - Stationen  (FDx)
;
W37C2:  DEFW    W3ADA           ; Zeiger auf n√§chste Ger√§te - Tabelle  (QD:)
        DEFM    "FD"            ; Ger√§te - Name
		DEFB    NUL,NUL
        DEFB    00111111B       ; Ger√§te - Typ - Flag
        DEFB    3               ; Ger√§te-Nummern - Flag
        DEFB    63              ; Anzahl freie Inhaltsverzeichnis - Eintr√§ge
        DEFW    A38C2           ; Ger√§t initialisieren
        DEFW    15              ; Sektornummer f√ºr Sektorverzeichnis
        DEFW    256             ; Sektorl√§nge
        DEFW    48              ; Anzahl reservierte Sektoren
        DEFW    254             ; Anzahl Zeichen im Sektor sequentielle Datei
        DEFW    A393A           ; Adresse 'Sektor lesen'
        DEFW    A393D           ; Adresse 'Sektor schreiben'
        DEFW    A1FAC           ; Fehler 57  Can't execute error
        DEFW    A1FAC           ; Fehler 57  Can't execute error
        DEFW    A1FAC           ; Fehler 57  Can't execute error
;
;
;   Storage area for floppy disk read/write routines
;
S37DF:  DEFS    1               ; step rate
S37E0:  DEFS    1               ; 'Read/Write' flag
S37E1:  DEFS    1               ; Drive number/mode
S37E2:  DEFS    1               ; Track number from where to start reading
S37E3:  DEFS    1               ; Sector number from where to start reading
S37E4:  DEFS    1               ; Low - Byte Number of bytes to read
S37E5:  DEFS    1               ; Number of sectors to treat
S37E6:  DEFS    2               ; Pointer to memory area
S37E8:  DEFS    1               ; lane pointer
S37E9:  DEFS    1               ; sector pointer
S37EA:  DEFS    1               ; Controller - Status - Flag
                                ; Bit 7 = engine on
                                ; Bit 6 = second side
                                ; Bit 5 = MZ-80K mode
S37EB:  DEFS    1               ; last command
S37EC:  DEFS    4               ; Drive-flags
S37F0:  DEFS    4               ; last track - numbers
S37F4:  DEFS    1               ; Remaining number of errors
; 
;
;    Calculate track and sector number from absolute sector number
;
A37F5:  PUSH    BC              ; Save register value
        LD      A,L             ; Low - byte remember absolute sector number
        LD      B,4             ;!  Divide sector number by 16
A37F9:  SRL     H               ;!         (16 sectors per track)
        RR      L               ;!
        DJNZ    A37F9           ;!    keep sharing
        AND     00001111B       ; Mask sector number
        INC     A               ; and correct (from 1 to 16)
        LD      H,A             ; Remember sector number
        POP     BC              ; get saved register value
        RET             
;
;
;    Calculate absolute sector number from track and sector number
;
A3805:  LD      A,H             ; Correct sector number
        LD      H,0             ; High - byte track number to zero
        ADD     HL,HL           ;!  Trace - number times two
        ADD     HL,HL           ;!                times four
        ADD     HL,HL           ;!                times eight
        ADD     HL,HL           ;!                times 16 (16 sectors per track)
        DEC     A               ; Correct sector number
        ADD     A,L             ; and add to sector number from track number
        LD      L,A             ; note the result
        RET
;
;
;    Switch on the motors of the drives and select density/side
;
A3810:  CALL    A00C7           ; Save registers IX, HL, BC, DE
        LD      HL,S37EA        ; Pointer to controller - status - flag
        BIT     7,(HL)          ; engine on ?
        JR      NZ,A3820        ; Yes
        CALL    A38B1           ; Switch on engine and clear drive flags
        CALL    A3ACD           ; Time loop approx. 1.35 ms
A3820:  LD      A,(S37E1)       ; drive - get number
        BIT     2,A             ; MZ-80K - Mode ?
        SET     2,A             ; next time try MZ-80K
        JR      Z,A382B         ; still MZ-700
        SET     5,A             ; code 'single density'
A382B:  SET     7,A             ; code 'engine on'
        LD      HL,S37EA        ; Pointer to controller - status - flag
        BIT     6,(HL)          ; second page  ?
        JR      Z,A3836         ; no
        SET     6,A             ; code 'second page'
A3836:  CALL    A3851           ; Output motor flag, side and density
        LD      (HL),A          ; remember new controller status flag
        LD      HL,S37EC        ; Pointers to Drive - Flags
        CALL    A3849           ; Calculate pointer to correct drive flag
        BIT     0,(HL)          ; Drive already mentioned?
        CALL    Z,A38CA         ; no --> Output 'Restore' to the controller
        RET     C               ; Error occurred
        SET     0,(HL)          ; Set code 'Drive addressed'
        RET
;
;
;    Get pointer to memory for current drive
;
A3849:  LD      A,(S37E1)       ; Drive - get number
        AND     00000011B       ; Drive - mask number
        JP      A0158           ; Add value in Accu to HL register 
;
;
;    Output motor flag, side and density 
;
A3851:  OUT     (MO_REG),A      ; Output engine on/off
        PUSH    AF              ; Save status
        RLCA                    ;! Shift page bit to bit zero
        RLCA                    ;!
        OUT     (PG_REG),A      ; Output page to controller
        RLCA                    ; Density - shift bit to bit zero
        OUT     (DE_REG),A      ; Output density to controller
        POP     AF              ; Get saved status 
        RET
;
;
;    Output track and sector number to controller 
;
A385D:  CALL    A00C7           ; Save registers IX, HL, BC, DE
        LD      D,0             ; Default code 'no value changed'
        LD      A,(S37E8)       ; Get marker
        SRL     A               ; divided by two
        CPL                     ; Complement track number
        OUT     (DA_REG),A      ; Output track number
        LD      B,A             ; note the issued track number
        LD      A,(S37EA)       ; Get Controller - Status - Flag
        RES     6,A             ; code 'first page'
        BIT     5,A             ; MZ-80K - Mode ?
        JR      Z,A3875         ; no
        CCF                     ; Invert side flag
A3875:  JR      C,A3879         ; first page
        SET     6,A             ; code 'second page'
A3879:  CALL    A3851           ; Output motor flag, side and density
        LD      HL,S37EA        ; Pointer to controller - status - flag
        CP      (HL)            ; compare new status with old status
        LD      (HL),A          ; remember new status
        JR      Z,A3884         ; Status has not changed
        INC     D               ; Note status change
A3884:  LD      HL,S37F0        ; Pointer to memory for track numbers
        CALL    A3849           ; Pointer to track number of current drive
        LD      A,(HL)          ; get last track number
        OUT     (TR_REG),A      ; output to track
        CP      B               ; compare with new track number
        JR      Z,A389B         ; traces alike
        INC     D               ; Note status change
        CALL    A38A8           ; Output 'SEEK' to floppy controller
        PUSH    AF              ; Result - save flag
        IN      A,(TR_REG)      ; get new track number
        LD      (HL),A          ; and remember
        POP     AF              ; saved result - get flag
        RET     C               ; Error occurred
        RET     NZ              ; Status is not correct
A389B:  LD      A,(S37E9)       ; Get sector pointer
        CPL                     ; complement for output
        OUT     (SC_REG),A      ; Output sector number to controller
        LD      A,D             ; Get status change flag
        OR      A               ; status changed ?
        CALL    NZ,A3AC2        ; yes --> time loop approx. 80 ms
        XOR     A               ; Reset carry flag ('Function OK')
        RET
;
;
;    Output 'SEEK' to floppy controller 
;
A38A8:  LD      A,00011000B     ; Code for 'SEEK'
        CALL    A38F7           ; Output the step rate for the command and wait for 'Not busy'
        RET     C               ; Error occurred
        AND     10011001B       ; mask for 'READY/SEEK ERROR/BUSY'
        RET
;
;
;    Switch on engine and clear drive flags 
;
A38B1:  LD      HL,S37EA        ; Pointer to controller - status - flag
        SET     7,(HL)          ; Set 'motor on' flag
        LD      A,(HL)          ; Controller - get status
        CALL    A3851           ; Output motor flag, side and density
        LD      HL,S37EC        ; Pointers to Drive - Flags
        LD      B,4             ; delete four bytes
        JP      A0137           ; Delete memory area (HL) (B=length) 
;
;
;    Initialize "FDx" device.
;
A38C2:  XOR     A               ; Code for 'Motor off'
        CALL    A3851           ; Output motor flag, side and density
        LD      (S37EA),A       ; Controller - Status - Reset flag 
        RET
;
;
;    Issue 'Restore' to controller
;
A38CA:  CALL    A00C7           ; Save registers IX, HL, BC, DE
        LD      HL,S37F0        ; Pointer to memory for track numbers
        CALL    A3849           ; Pointer to track numbers of current drive
        LD      (HL),-1         ; Note code 'zero track'
        LD      A,00001000B     ; code 'restore'
        CALL    A38F7           ; Output step rate to the command and wait for 'Not busy'
        RET     C               ; Error occurred --> termination
        AND     10000101B       ; Mask 'READY/TRACK 0/BUSY'
        XOR     00000100B       ; TRACK 0 - reverse status
        RET     Z               ; State is OK
        JP      A3A8F           ; Specify error number 
;
;
;    Output 'Force Interrupt' to floppy controller
;
A38E3:  PUSH    AF              ; Save register value
        LD      A,11010000B     ; 'Force interrupt' code
        CALL    A38F0           ; Issue command and wait for 'Not Busy'
        JR      C,A38ED         ; Error occurred --> cancel immediately
        POP     AF              ; get saved register value
        RET                       
;
A38ED:  POP     HL              ; discard saved register
        POP     HL              ; discard a return address
        RET
;
;
;    Issue command and wait for 'Not Busy'
;
A38F0:  CALL    A00C7           ; Save registers IX, HL, BC, DE
        LD      D,0             ; code 'wait for Not Busy'
        JR      A3911           ; Issue command and wait for correct status
;
;
;    Set Steprate and wait for 'Not Busy'
;
A38F7:  CALL    A00C7           ; Save registers IX, HL, BC, DE
        LD      B,A             ; rescue command
        LD      A,(S37DF)       ; Get step rate
        CPL                       
        AND     00000011B       ; Mask step rate
        OR      B               ; plus command
        LD      D,0             ; Code 'Wait for Not Busy'
        JR      A390B           ; Issue command and wait for correct status
;
;
;    Issue command to controller and wait for 'Busy'
;
A3906:  CALL    A00C7           ; Save registers IX, HL, BC, DE
        LD      D,1             ; code 'wait for busy'
A390B:  CALL    A38E3           ; Issue 'force interrupt' to floppy controller
        LD      (S37EB),A       ; remember last command
A3911:  CPL                     ; Complement command for output
        OUT     (CD_REG),A      ; Issue command to controller
        CALL    A3ABC           ; Time loop approx. 0.166 ms
        LD      E,7             ; number of passes
A3919:  LD      HL,10000        ; Default for counter
A391C:  DEC     HL              ; Counter minus one
        LD      A,H             ;!  Counter equal to zero?
        OR      L               ;!
        JP      Z,A392E         ; yes --> examine whether further runs
        IN      A,(ST_REG)      ; Controller - read status
        CPL                     ; all values are complemented
        LD      B,A             ; Controller - remember status
        AND     10000001B       ; Mask READY and BUSY
        CP      D               ; same feedback status?
        JR      NZ,A391C        ; no --> keep waiting
        LD      A,B             ; Controller - get status
        OR      A               ; reset carry flag (code 'no error')
        RET                       
;
A392E:  DEC     E               ; Number of runs minus one
        JP      Z,A3A8F         ; Time - Out --> Specify error number
        LD      A,(S37EB)       ; get last command
        CPL                     ; complement to the output
        OUT     (CD_REG),A      ; and output to controller again
        JR      A3919           ; Query whether correct feedback value

;
;
;    Read sector
;
A393A:  SCF                     ; Code 'read sector'
        JR      A393E           ; read sector
;
;
;    Write sector
;
A393D:  OR      A               ; Code 'Write Sector'
A393E:  EX      AF,AF           ; Remember flag 'Read/Write'
        PUSH    AF              ; Save register value
        EX      AF,AF           ; Get flag 'read/write'
        LD      (S37E6),HL      ; Remember pointer to memory area
        PUSH    HL              ; Save pointer to memory area
        LD      HL,S37E0        ; Pointer to flag 'read/write'
        RL      (HL)            ;! Enter the 'Read/Write' flag
        RRC     (HL)            ;!
        LD      H,(HL)          ; 'Read/Write' flag
        LD      L,A             ; Remember drive number/mode
        AND     00000111B       ; Mask drive number and mode
        LD      (S37E1),A       ; Remember drive number
        CALL    A3810           ; Switch on the motors of the drives and select density/side
        JR      NC,A395D        ; no error --> writing or reading
        POP     HL              ; Get pointer to memory area
        EX      AF,AF           ; Save error status
        POP     AF              ; get saved register value
        EX      AF,AF           ; and again after AF'
        RET                       
;
A395D:  BIT     7,H             ; reading or writing
        LD      A,L             ; Drive number/sector number mode
        POP     HL              ; Get pointer to memory area
        PUSH    HL              ; and save again
        CALL    Z,A3A1C         ; read --> bytes (not) complement
        LD      (S37E4),DE      ; note the number of bytes to be read
        PUSH    DE              ; Number of bytes to read
        OR      A                 
        PUSH    AF              ; save the flag
        LD      H,B             ;! first sector number or track/sector number
        LD      L,C             ;! transfer
        CALL    P,A37F5         ; Calculate track and sector number from absolute sector number
        LD      (S37E2),HL      ; Track/sector number first sector
        LD      A,9             ; a maximum of nine errors
        LD      (S37F4),A       ; note errors as remaining number
        PUSH    IY              ; Save register value
        CALL    A3991           ; Determine format and read or write bytes
        EX      AF,AF           ; Save result flag
        POP     IY              ; get saved register value
        LD      HL,(S37E8)      ; Track pointer/Sector pointer
        POP     AF              ; get rescued flag
        CALL    P,A3805         ; Calculate absolute sector number from track and sector number
        LD      B,H             ;! absolute sector number or track sector
        LD      C,L             ;! remember number again
        POP     DE              ; retrieve saved number of bytes
        POP     HL              ; Retrieve pointer to memory area
        POP     AF              ; retrieve saved register
        EX      AF,AF           ; after AF' / get result flag
        JP      A3A1C           ; Bytes (not) complement
;
;
;    Determine format and read or write bytes
;
A3991:  LD      E,0             ; 256 bytes per sector
        LD      HL,(S37E4)      ; Get number of bytes to read
        LD      A,(S37EA)       ; Get Controller - Status - Flag
        BIT     5,A             ; MZ-80K - Mode ?
        JR      Z,A39A0         ; no
        ADD     HL,HL           ; bytes times two
        LD      E,128           ; 128 bytes per sector
A39A0:  LD      A,L             ; Get low byte count
        OR      A               ; equals zero  ?
        JR      Z,A39A5         ; yes --> number of sectors is correct
        INC     H               ; Correct number of sectors
A39A5:  LD      A,H             ; Get number of sectors
        LD      (S37E5),A       ; and remember
A39A9:  CALL    A3A2F           ; Specify data for sectors still to be treated
        CALL    NC,A385D        ; Output track and sector number to controller
        RET     C               ; Error occurred --> termination
        JR      NZ,A3A16        ; wrong status --> test if try again
        DI                      ; Disable interrupts
        LD      A,(S37E0)       ; 'Read/Write' flag
        BIT     7,A             ; reading or writing ?
        LD      A,10010000B     ; Code 'READ multiple records'
        LD      IY,0A2EDH       ; Z-80 - command INI
        JR      NZ,A39C6        ; read from disk
        LD      A,10110100B     ; Code 'Write Multiple Record'
        LD      IY,0A3EDH       ; Z-80 - command OUTI
A39C6:  LD      (D39DD),IY      ; Enter Z-80 command into routine
        CALL    A3906           ; Issue command and wait for 'Busy'
        RET     C               ; Error occurred --> termination
A39CE:  LD      B,E             ; Get number of bytes per sector
        PUSH    DE              ; Save remaining number of sectors/sector length
        ;LD      DE,256*(NOT  1)+NOT 3
		LD      DE,0xFE7C		; MSB:($FF XOR 1),  LSB:($FF XOR $83)
		
A39D3:  IN      A,(ST_REG)      ; Read the status of the controller
        OR      E               ;! Busy and bytes not ready?
        CP      D               ;!
        JR      Z,A39D3         ; no --> continue querying
        CP      11111100B       ; busy ?
        JR      NZ,A39E2        ; no --> cancel
D39DD:  NOP                     ;! Output byte to controller or byte
        NOP                     ;! get from the controller
        JP      NZ,A39D3        ; read more bytes in this sector
A39E2:  POP     DE              ; Get remaining number of sectors/sector length
        IN      A,(ST_REG)      ; Read the status of the controller
        RRA                     ; Busy - push bit after carry
        JP      C,A3A8F         ; no longer busy --> specify error number
        LD      A,(S37E9)       ; Get sector pointer
        INC     A               ; plus one
        LD      (S37E9),A       ; and remember again
        CP      17              ; right at the end of the track?
        JR      Z,A39F9         ; Yes
        DEC     D               ; Remaining number of sectors minus one
        JR      NZ,A39CE        ; read more sectors
        JR      A39FA             
;
A39F9:  DEC     D               ; Remaining number of sectors minus one
A39FA:  CALL    A38E3           ; Issue 'Force Interrupt' to floppy controller
        EI                      ; Enable interrupt
        IN      A,(ST_REG)      ; Controller - read status
        CPL                     ; Data are complemented
        OR      A               ; Error  ?
        JR      NZ,A3A16        ; yes --> test whether to try again
        LD      A,(S37E0)       ; 'Read/Write' flag
        OR      A               ; To write  ?
        CALL    Z,A3A65         ; yes --> test whether written sectors can be found again
        JR      C,A3A16         ; Error --> test whether to try again
        CALL    A3A4D           ; Update track and sector number
        LD      A,D             ; Get remaining number of sectors
        OR      A               ; equals zero  ?
        JR      NZ,A39A9        ; no --> read/write more sectors
        XOR     A               ; Code 'Function OK'
        RET                       
;
A3A16:  CALL    A3A40           ; examine whether not too many errors
        RET     C               ; Error during restore --> termination
        JR      A39A9           ; try again
;
;
;    Bytes complement (not)
;
A3A1C:  CALL    A00BA           ; Save registers IX, HL, BC, DE, AF
        LD      A,(S37EA)       ; Get Controller - Status - Flag
        BIT     5,A             ; MZ-80K - Mode ?
        RET     Z               ; Do not complement bytes
A3A25:  LD      A,(HL)          ; get a byte
        CPL                     ; complement bytes
        LD      (HL),A          ; and remember again
        INC     HL              ; Pointer to bytes to next byte
        DEC     DE              ; Remaining number of bytes minus one
        LD      A,D             ;! Remaining number of bytes equal to zero ?
        OR      E               ;!
        JR      NZ,A3A25        ; no --> complement further bytes
        RET
;
;
;    Specify data for sectors still to be treated
;
A3A2F:  LD      HL,(S37E2)      ; Get track/sector number of first sector
        LD      (S37E8),HL      ; enter as track pointer/sector pointer
        LD      HL,(S37E6)      ; Get pointer to memory area
        LD      A,(S37E5)       ; Get number of sectors to treat
        LD      D,A             ; and remember
        LD      C,DA_REG        ; Specify data port of the controller
        OR      A               ; reset carry flag (code 'no error')
        RET
;
;
;    Check whether too many errors have already occurred
;
A3A40:  CALL    A00C7           ; Save registers IX, HL, BC, DE
        LD      HL,S37F4        ; Pointer to remaining number of errors
        DEC     (HL)            ; Remaining number of errors minus one
        JP      Z,A3A8F         ; too many errors --> specify error number
        JP      A38CA           ; Issue 'Restore' to controller 
;
;
;    Update track and sector number
;
A3A4D:  LD      (S37E6),HL      ; Pointer to memory area
        LD      A,D             ; remaining number of sectors
        LD      (S37E5),A       ; as the number of sectors to be treated
        LD      HL,(S37E8)      ; Track pointer/Sector pointer
        LD      A,H             ; Get sector pointer
        CP      17              ; end of track ?
        RET     NZ              ; no
        LD      H,1             ; Sector pointer to sector one
        INC     L               ; Lane pointer plus one
        LD      (S37E2),HL      ; Remember track/sector number of last error-free sector
        LD      (S37E8),HL      ; Memorize track and sector pointers 
        RET
;
;
;    Test whether written sectors can be found again
;
A3A65:  LD      A,(S37E3)       ; Sector number from where to start reading
        CPL                     ; comment to the output
        OUT     (SC_REG),A      ; to sector - output register
        LD      A,10010000B     ; Code 'Read multiple sectors'
        CALL    A3906           ; Issue command and wait for 'Busy'
        RET     C               ; Error occurred
        LD      A,(S37E9)       ; Get sector pointer
        LD      B,A             ; and remember
A3A75:  IN      A,(ST_REG)      ; Read the status register of the controller
        CPL                     ; Data are complemented
        AND     10000001B       ; Mask Ready and Busy
        CP      00000001B       ; Controller Busy?
        JR      NZ,A3A87        ; no
        IN      A,(SC_REG)      ; Read the controller's sector register
        CPL                     ; Data are complemented
        CP      B               ; Compare with output sector number
        JR      NZ,A3A75        ; not immediately --> ask again
        CALL    A38E3           ; Issue 'Force Interrupt' to floppy controller
A3A87:  IN      A,(ST_REG)      ; Read the status register of the controller
        CPL                     ; Data are complemented
        AND     10011001B       ; Mask 'READY/RNF ERROR/CRC ERROR/BUSY'
        RET     Z               ; all data OK
        SCF                     ; Set flag: 'Error Occurred'
        RET
;
;
;    Define the error number basing on the status and the last command
;
A3A8F:  LD      A,(S37EB)       ; get last command
        RLA                     ; Shift bit 7 to carry
        IN      A,(ST_REG)      ; Read status value from controller
        CPL                     ; Data are complemented
        JR      NC,A3AAD        ; 'Seek' or 'Restore'
        RLA                     ; Push ready bit after carry
        JR      C,A3AB0         ; Controller or drive not ready
        RLA                     ; Write-Protect - Shift bit after carry
        JR      NC,A3AA5        ; not write protect
        LD      HL,S37E0        ; Pointer to flag 'read/write'
        BIT     7,(HL)          ; read  ?
        JR      Z,A3AB4         ; should be written --> error 46
A3AA5:  AND     11000000B       ; Mask 'Record Type/Record not found'
        JR      NZ,A3AB8        ; is set --> Error 54 unformat
A3AA9:  LD      A,41            ; Error 41 Hardware error
        SCF                     ; Set flag: 'Error Occurred'
        RET
;
A3AAD:  RLA                     ; Write-Protect - Shift bit after carry
        JR      NC,A3AA9        ; not write protect --. Error 41 Hardware error
A3AB0:  LD      A,50            ; Error 50 Not ready error
        SCF                     ; Set flag: 'Error Occurred'
        RET
;
A3AB4:  LD      A,46            ; Error 46 Write protect error
        SCF                     ; Set flag: 'Error Occurred'
        RET
;
A3AB8:  LD      A,54            ; Error 54 Unformat error
        SCF                     ; Set flag: 'Error Occurred'
        RET

;
;
;    Zeitschleife  ca. 0.166 ms
;
A3ABC:  PUSH    DE              ; Register-Wert retten           11 + 2
        LD      DE,15           ; Vorgabe f√ºr Zeitschleife       10 + 2
        JR      A3AC6           ; Einsprung in Zeitschleife      12 + 2
;
;
;    Zeitschleife  ca.  80 ms
;
A3AC2:  PUSH    DE              ; Register-Wert retten           11 + 2
        LD      DE,8230         ; Vorgabe f√ºr Zeitschleife       10 + 2
A3AC6:  DEC     DE              ; Z√§hler minus eins               6 + 2
        LD      A,E             ;! gleich null  ?                 4 + 2
        OR      D               ;!                                4 + 2
        JR      NZ,A3AC6        ; nein --> weiter warten         12 + 2
        POP     DE              ; gerettetes Register holen      10 + 2
        RET                     ;                           17 + 10 + 2
;
;
;    Zeitschleife  ca.  1.35 ms
;
A3ACD:  PUSH    BC              ; Register-Wert retten
        LD      B,17            ; Vorgabe f√ºr Z√§hler
A3AD0:  CALL    A3AC2           ; Zeitschleife ca. 80 ms
        DJNZ    A3AD0           ; weiter warten
        POP     BC              ; geretteten Register-Wert holen
        RET
;
;
;   Pseudo-device table for Cassette Recorder (CMT:)
;
W3AD7:  DEFW    W3C64           ; Pointer to Next Devices - Table (RSx:)
        DEFB    NUL             ; Code 'table does not exist'
;
;
;   Pseudo-device table for Quick Disk
;
W3ADA:  DEFW    W0F7F           ; Pointer to Next Devices Table (USR:)
        DEFB    NUL             ; Code 'table does not exist'
;
;
;   File - write identifier to tape (cassette).
;   File - write data to tape (cassette).
;   Read file identifier from tape (cassette).
;   File - read data from tape (cassette).
;   File - Compare data on BAnd with memory data
;
A3ADD:  XOR     A
        SCF                     ; Set 'Error Occurred' flag
A3ADF:  RET
;
;
;   RAM - Karteninhalt auf Quick - Disk schreiben oder von Quick - Disk lesen
;   (Software  - Kommando  59)
;
A3AE0:  LD      A,1             ; Fehler 1  Syntax error
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        JP      A00ED           ; Fehler nach Nummer im Accu behandeln
;
D3AE6:
;        DEFS    282             ; so you can get 64 Kbytes 
        DEFS 0x3C00-D3AE6
 
;
;   ASCII - Zeichen im Accu umsetzen in Anzeige - Code
;
;   (Software command code:  29)
;
A3C00:  CP      010H            ; bekanntes Zeichen  ?
        JR      C,A3C16         ; nein -->  Code for 'Zeichen nicht bekannt'  vorgeben
        CP      080H            ; geschweifte Klammer zu  ?
        JR      Z,A3C19         ; ja -->  umrechnen in Anzeigecode
        CP      0C0H            ; geschweifte Klammer auf  ?
        JR      Z,A3C19         ; ja -->  umrechnen in Anzeigecode
        DI                      ; Interrupt sperren
        OUT     (_00ROM),A      ; Umschalten auf Monitor-ROM von 00000H-00FFFH
        CALL    _ADCN           ; ASCII-Code umsetzen in Anzeige - Code
        OUT     (_00RAM),A      ; Umschalten auf RAM von 00000 - 00FFFH
        EI                      ; Interrupt wieder freigeben
        RET
;
A3C16:  LD      A,0F0H          ; Code for 'Zeichen nicht bekannt'
        RET
;
A3C19:  SUB     040H            ; geschweifte Klammer umsetzen in Anzeigecode
        RET
;
;
;   Anzeigecodezeichen im Accu in ASCII - Code umsetzen
;
;   (Software command code:  28)
;
A3C1C:  CP      0F0H            ; Pixel - Graphic - Wert  ?
        JR      NC,A3C38        ; ja -->  Leerzeichen  (Space)  vorgeben
        CP      073H
        JR      Z,A3C16         ; ja -->  Code for 'Zeichen nicht bekannt'  vorgeben
        CP      040H            ; geschweifte Klammer zu  ?
        JR      Z,A3C3B         ; ja -->  umrechnen in ASCII - Code
        CP      080H            ; geschweifte Klammer auf  ?
        JR      Z,A3C3B         ; ja -->  umrechnen in ASCII - Code
        DI                      ; Interrupt sperren
        OUT     (_00ROM),A      ; Umschalten auf ROM - Monitor vom 00000H - 00FFFH
        CALL    _DACN           ; Anzeigecode umsetzen in ASCII - Code
        OUT     (_00RAM),A      ; Umschalten auf RAM von 00000H - 00FFFH
        EI                      ; Interrupt wieder freigeben
        CP      0F0H            ; Code for 'Zeichen nicht bekannt'  ?
        RET     NZ              ; nein
A3C38:  LD      A,' '           ; Leerzeichen  (Space)  f√ºr unbekanntes Zeichen vorgeben
        RET
;
A3C3B:  ADD     A,040H          ; geschweifte Klammer umrechnen in ASCII
        RET
;
;
;   Code der Taste nach Tastennummer in HL und Zeiger auf 
;   Tastatur - Decodiertabelle im Monitor - ROM in BC bereitstellen
;
A3C3E:  PUSH    AF              ; Register - Wert retten
        LD      A,L             ; Tastennummer holen
        SUB     8               ; Taste in Spalte 1  ?
        JR      C,A3C48         ; ja -->  nach RAM - Tabelle decodieren
        SUB     48               
        JR      C,A3C4F         ; Taste nach ROM - Tabelle decodieren
A3C48:  ADD     A,8 + 2         ; Offset f√ºr RAM - Tabelle corrigieren
        LD      L,A             ; Low - Byte Offset merken
        ADD     HL,BC           ; Zeiger auf Stelle in RAM - Tabelle errechnen
        LD      C,(HL)          ; Zeichen aus RAM - Tabelle holen
        POP     AF              ; geretteten Register - Wert holen
        RET
;
;
;   Code der Taste nach Monitor - ROM - Tabelle bereitstellen
;
A3C4F:  LD      A,(BC)          ; Low - Byte Anfangsadresse aus Tabelle holen
        PUSH    AF              ; Low - Byte Adresse retten
        INC     BC              ; Zeiger auf High - Byte Adresse
        LD      A,(BC)          ; High - Byte Adresse aus Tabelle holen
        LD      B,A             ; und merken
        POP     AF              ; Low - Byte Adresse holen
        LD      C,A             ; und merken
        ADD     HL,BC           ; Zeiger auf richtiges Zeichen errechnen
        DI                      ; Interrupt sperren
        OUT     (_00ROM),A      ; Umschalten auf ROM - Monitor von 00000H - 00FFFH
        LD      A,(HL)          ; Zeichen aus ROM - Tabelle holen
        OUT     (_00RAM),A      ; Umschalten auf RAM von 00000H - 00FFFH
        EI                      ; Interrupt wieder freigeben
        CALL    A3C1C           ; Anzeigecodezeichen im Accu umsetzen in ASCII - Code
        LD      C,A             ; ASCII - Wert der gedr√ºckte Taste merken
        POP     AF              ; geretteten Register - Wert holen
        RET
;
;
;   devices - table for serial interface (RSx)
;
W3C64:  DEFW    W3EC6           ; Pointer to next devices - table (RAM:)
        DEFM    "RS"            ; Ger√§te - Name
		DEFB    NUL,NUL
        DEFB    10001111B       ; Ger√§te - Typ - Byte
        DEFB    00000001B       ; Ger√§te - Nummern - Flag
        DEFB    0
        DEFW    A3C7D           ; Initialize device
        DEFW    A3CAE           ; Open file for reading
        DEFW    A3CAE           ; Open file for writing
        DEFW    A3CBF            
        DEFW    A3CBF
        DEFW    A3CD0           ; ein Zeichen bereitstellen
        DEFW    A3CFB           ; Output characters in Accu
        DEFW    A00B2           ; RET
;
;
;   Ger√§t  'RSx'  initialisieren
;
A3C7D:  RET     C
        PUSH    IY              ; Register - Wert retten
        CALL    A3D25           ; Zeiger in IY auf richtigen Ger√§te-Datensatz stellen
        CALL    A3C8B           ; Werte zur Initialisierung bereitstellen
        CALL    A3D6E           ; serielle Schnittstelle initialisieren
        JR      A3CE3           ; gerettetes IY - Register wieder holen
;
;
;   Werte zur Initialisierung bereitstellen
;
A3C8B:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    19              ; Code 19   ASCII-Wert (HL) umsetzen in Hex-Wert nach DE
        LD      (IY+-3),E       ; √úberwachungssignale merken
        CALL    A0164           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    ","             ; Komma  ?
        JP      NZ,A1F7F        ; nein -->  Fehler 3  Illegal data error
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    19              ; Code 19   ASCII-Wert (HL) umsetzen in Hex-Wert nach DE
        LD      (IY+-2),E       ; Datenformat merken
        CALL    A0164           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFB    NUL             ; Textendezeichen  ?
        RET     Z               ; ja -->  fertig
        CALL    A0164           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    ","             ; Komma  ?
        JP      NZ,A1F7F        ; nein -->  Fehler 3  Illegal data error
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    19              ; Code 19   ASCII-Wert (HL) umsetzen in Hex-Wert nach DE
        LD      (IY+-8),E       ; Textendezeichen merken
        RET
;
;
;   Datei auf Ger√§t  'RSx'  zum Lesen oder Schreiben er√∂ffnen
;
A3CAE:  PUSH    IY              ; Register - Wert retten
        CALL    A3D25           ; Zeiger in IY auf richtigen Ger√§te-Datensatz stellen
        LD      A,(IY+-1)       ; Schnittstellenstatus holen
        INC     (IY+-1)
        OR      A
        CALL    Z,A3DD0         ; Fehlerstatus der Schnittstelle zur√ºcksetzen
        JR      A3CE3           ; gerettetes IY - Register wieder holen
;
;
;
;
A3CBF:  PUSH    IY              ; Register - Wert retten
        CALL    A3D25           ; Zeiger in IY auf richtigen Ger√§te-Datensatz stellen
        DEC     (IY+-1)
        LD      A,(IY+-1)
        OR      A
        CALL    Z,A3DB8         ; Schnittstelle initialisieren
        JR      A3CE2           ; geretteten IY - Register - Wert holen
;
;
;   ein Zeichen von Ger√§t  'RSx'  lesen
;
A3CD0:  PUSH    IY              ; Register - Wert retten
        CALL    A3D25           ; Zeiger in IY auf richtigen Ger√§te-Datensatz stellen
        CALL    A3CE6           ; ein Zeichen von Schnittstelle holen
        JP      C,A00EB         ; Fehler -->  Fehlernummer und Ger√§tenamen ausgeben
        CP      (IY+-8)         ; mit Textendezeichen vergleichen
        JR      NZ,A3CE2        ; nicht Textende -->  Zeichen durchgeben
        LD      A,CR            ; Textendezeichen vorgeben
A3CE2:  OR      A               ; Carry - Flag zur√ºcksetzen   (Code 'kein Fehler')
A3CE3:  POP     IY              ; geretteten Register - Wert holen
        RET
;
;
;   ein Zeichen von serieller Schnittstelle holen
;
A3CE6:  BIT     6,(IY+-2)       ; Sharp - ASCII - Modus  ?
        JP      Z,A3E1F         ; ja -->  Zeichen von serieller Schnittstelle lesen
        LD      IX,A3E1F        ; Adresse  'Zeichen von Schnittstelle holen'
        PUSH    IY              ;! Zeiger auf aktuellen Schnittstellendatensatz nach HL
        POP     HL              ;!
        LD      DE,-5           ; Offset auf Spaltenz√§hler 'Eingabe'
        ADD     HL,DE           ; Zeiger auf Spaltenz√§hler 'Eingabe' errechnen
        JP      A146C           ; Zeichen bereitstellen und umsetzen in Sharp - ASCII
;
;
;   Zeichen im Accu an Ger√§t  'RSx'  ausgeben
;
A3CFB:  PUSH    IY              ; Register - Wert retten
        CALL    A3D25           ; Zeiger in IY auf richtigen Ger√§te-Datensatz stellen
        CP      CR              ; Textendezeichen  ?
        JR      NZ,A3D07        ; nein -->  Zeichen ausgeben
        LD      A,(IY+-8)       ; vorgegebenes Textendezeichen holen
A3D07:  CALL    A3D0C           ; Accu an serielle Schnittstelle ausgeben
        JR      A3CE3           ; gerettetes IY - Register wieder holen
;
;
;   Accu an serielle Schnittstelle ausgeben
;
A3D0C:  BIT     6,(IY+-2)       ; Sharp - ASCII - Modus  ?
        JP      Z,A3E64         ; ja -->  Zeichen im Accu ausgeben
        LD      IX,A3E64        ; Adresse  'Zeichen an Schnittstelle ausgeben'
        PUSH    IY              ;! Zeiger auf Schnittstellendatensatz nach HL
        POP     HL              ;!
        LD      DE,-7           ; Offset auf Spaltenz√§hler  'Ausgabe'
        ADD     HL,DE           ; Zeiger auf Spaltenz√§hler  'Ausgabe'
        LD      DE,(S1090)      ; Flag  'Steuerzeichen ausf√ºhren'  holen
        JP      A142B           ; Zeichen umsetzen in Standard - ASCII und ausgeben
;
;
;   Zeiger in IY auf richtigen Ger√§te-Datensatz stellen
;
A3D25:  PUSH    AF              ;! Register - Werte retten
        PUSH    DE              ;!
        LD      A,(S1046)       ; Ger√§te - Nummer holen
        INC     A               ; f√ºr Schleife corrigieren
        LD      IY,B3D45 + -21  ; Zeiger auf Ger√§te - Datensatz mit Vorgabe
        LD      DE,21           ; L√§nge  Ger√§te - Datensatz
A3D32:  ADD     IY,DE           ;! Zeiger auf richtigen Ger√§te - Datensatz
        DEC     A               ;! errechnen
        JR      NZ,A3D32        ;!
        LD      C,(IY+0)        ; Statusport - Nummer holen
        POP     DE              ;! gerettete Register - Werte holen
        POP     AF              ;!
        RET
;
;
;   Ger√§te - Datensatz f√ºr serielle Schnittstelle 1
;
        DEFS    1               ; Textendezeichen
        DEFS    1               ; Spaltenz√§hler bei Ausgabe
        DEFS    1  
        DEFS    1               ; Spaltenz√§hler bei Eingabe
        DEFS    1  
        DEFS    1               ; √úberwachungssignale bei Initialisierung
        DEFS    1               ; Datenformat bei Initialisierung
        DEFS    1               ; Schnittstellenstatus
B3D45:  DEFB    SERA_S          ; Status- / Steuerport  RS1
        DEFB    SERA_D          ; Datenport  RS1
        DEFB    00000000B       ; Bitmaske f√ºr Anzahl √ºbertragene Zeichen
        DEFB    00010000B       ; Code for 'Reset EXT/Status Interrupt'
        DEFB    00010000B       ; Code for 'Reset EXT/Status Interrupt'
        DEFB    4               ; Code for 'Write - Register 4'
        DEFB    01000000B       ; Wert f√ºr Write - Register 4   (Clock * 16)
        DEFB    3               ; Code for 'Write - Register 3'
        DEFB    11000000B       ; Wert f√ºr Write - Register 3   (Rx 8 Bit)
        DEFB    5               ; Code for 'Write - Register 5'
        DEFB    01100000B       ; Wert f√ºr Write - Register 5   (Tx 8 Bit)
        DEFB    00110000B       ; Code for 'Error Reset'
        DEFB    3               ; Code for 'Write - Register 3'                
;
;
;   Ger√§te - Tabelle f√ºr serielle Schnittstelle 2
;
        DEFS    1               ; Textendezeichen                           
        DEFS    1               ; Spaltenz√§hler bei Ausgabe                 
        DEFS    1                                                           
        DEFS    1               ; Spaltenz√§hler bei Eingabe                 
        DEFS    1                                                           
        DEFS    1               ; √úberwachungssignale bei Initialisierung   
        DEFS    1               ; Datenformat bei Initialisierung           
        DEFS    1               ; Schnittstellenstatus                      
        DEFB    SERB_S          ; Status- / Steuerport  RS1                 
        DEFB    SERB_D          ; Datenport  RS1                            
        DEFB    00000000B       ; Bitmaske f√ºr Anzahl √ºbertragene Zeichen   
        DEFB    00010000B       ; Code for 'Reset EXT/Status Interrupt'        
        DEFB    00010000B       ; Code for 'Reset EXT/Status Interrupt'        
        DEFB    4               ; Code for 'Write - Register 4'                
        DEFB    01000000B       ; Wert f√ºr Write - Register 4   (Clock * 16)
        DEFB    3               ; Code for 'Write - Register 3'                
        DEFB    11000000B       ; Wert f√ºr Write - Register 3   (Rx 8 Bit)  
        DEFB    5               ; Code for 'Write - Register 5'                
        DEFB    01100000B       ; Wert f√ºr Write - Register 5   (Tx 8 Bit)  
        DEFB    00110000B       ; Code for 'Error Reset'                       
        DEFB    3               ; Code for 'Write - Register 3'                
;
;
;   bei Shift - BREAK -->  Abbruch Programm
;
A3D67:  CALL    A001E           ; Abfrage, ob Shift - BREAK gedr√ºckt ist
        RET     NZ              ; Shift - BREAK nicht gedr√ºckt
        JP      A00E8           ; Programm mit 'BREAK' abbrechen
;
;
;   serielle Schnittstelle initialisieren
;
A3D6E:  LD      A,00011000B     ; Code for 'Chanal Reset'
        OUT     (C),A           ; an Steuerport ausgeben
        LD      A,00110000B     ; Code for 'Error Reset'
        OUT     (C),A           ; an Steuerport ausgeben
        LD      A,(IY+-2)       ; Datenformat holen
        AND     00001100B       ; Anzahl Stopbits maskieren
        JR      NZ,A3D81        ; Stopbits angegeben
        SET     2,(IY+-2)       ; Code for '1 Stopbit'  setzen
A3D81:  LD      A,(IY+-2)       ; Datenformat holen
        LD      B,A             ; und merken
        AND     00001111B       ; Parit√§t und Stopbits maskieren
        OR      01000000B       ; plus Code for 'Clock mal 16'
        LD      (IY+6),A        ; Wert f√ºr Write - Register 4  merken
        LD      A,B             ; Datenformat holen
        AND     10000000B       ; Zeichen maskieren
        OR      01000000B       ; Code  f√ºr  'Rx 7 oder 8 Bit' zusammenstellen
        LD      (IY+8),A        ; Wert f√ºr Write - Register 3  merken
        RRA                     ; um ein Bit nach rechts schieben
        AND     01111111B       ; Empfangsformat maskieren
        OR      00001010B       ; 'RTS' und 'Tx enable'  setzen
        LD      (IY+10),A       ; Wert f√ºr Write - Register 5  merken
        LD      A,B             ; Datenformat holen
        OR      01111111B       ; alle Bits bis auf Zeichenl√§nge setzen
        LD      (IY+2),A        ; Bitmaske f√ºr Anzahl √ºbertragene Bits merken
        CALL    A3DC4           ; √úbertragungsformate an Schnittstelle ausgeben
A3DA5:  IN      A,(C)           ; Statusport der Schnittstelle abfragen
        RRCA                    ; Rx  Character vorhanden  ?
        RET     NC              ; nein
        DEC     C               ; Register - Nummer auf Datenport
        IN      A,(C)           ; ein Zeichen von Datenport lesen
        INC     C               ; Register - Nummer wieder auf Staus-/Steuerport
        LD      A,00000001B     ; Code for 'Register 1'
        OUT     (C),A           ; an Steuerport ausgeben
        IN      A,(C)           ; READ - Register eins abfragen
        AND     01110000B       ; Fehlerbits maskieren
        JR      Z,A3DA5         ; kein Fehler -->  warten bis kein Zeichen vorhanden
        RET
;
;
;   Schnittstelle f√ºr Senden und Empfangen zur√ºcksetzen
;
A3DB8:  RES     0,(IY+8)        ; 'Rx - Enable'  zur√ºcksetzen
        RES     7,(IY+10)       ; 'DTR' zur√ºcksetzen
        LD      (IY+-1),0       ; Schnittstellenstatus zur√ºcksetzen
A3DC4:  LD      B,10            ; 10 Byte ausgeben
        PUSH    IY              ;! Zeiger auf Tabelle zur Initialisierung
        POP     HL              ;! errechnen
        LD      DE,3            ;!
        ADD     HL,DE           ;!
        OTIR                    ; Wertetabelle an serielle Schnittstelle ausgeben
        RET
;
;
;   Fehlerstatus der seriellen Schnittstelle zur√ºcksetzen
;
A3DD0:  LD      A,00110000B     ; Code for 'Error Reset'
        OUT     (C),A           ; an Steuerport der seriellen Schnittstelle ausgeben
        RET
;
;
;   Schnittstelle f√ºr Empfang ein Zeichen vorbereiten
;
A3DD5:  SET     0,(IY+8)        ; Code for 'Rx - Enable'  setzen
        LD      A,00010011B     ; Code for 'Reset EXT/Status Interrupt / Register 3'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        LD      A,(IY+8)        ; Wert f√ºr Write - Register 3 holen
        OUT     (C),A           ; Leseformat an Schnittstelle ausgeben
        LD      A,00110101B     ; Code for 'Error Reset / Register 5'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        LD      A,(IY+10)       ; Wert f√ºr Write - Register 5 holen
        OR      10001000B       ; 'DTR' und 'Send BREAK' setzen
        LD      (IY+10),A       ; neuen Wert f√ºr Write - Register 5  merken
        OUT     (C),A           ; Wert an Write - Register 5  ausgeben
        RET
;
;
;
;
        LD      A,00000011B     ; Code for 'Register 3'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        RES     0,(IY+8)        ; 'Rx - Enable'  zur√ºcksetzen
        LD      A,(IY+8)        ; Wert f√ºr Write - Register 3  holen
        OUT     (C),A           ; Leseformat an Write - Register 3 holen
A3DFE:  RES     7,(IY+10)       ; 'DTR`  zur√ºcksetzen
        JR      A3E14           ; Wert an Write - Register 5  ausgeben
;
;
;   'RTS' an serielle Schnittstelle ausgeben
;
A3E04:  SET     1,(IY+10)       ; 'RTS' setzen
        JR      A3E14           ; Wert an Write - Register 5 ausgeben
;
;
;   'RTS'  zur√ºcknehmen
;
A3E0A:  RES     1,(IY+10)       ; 'RTS' zur√ºcksetzen
        JR      A3E14           ; Wert an Write - Register 5  ausgeben
;
;
;   'DTR' an serielle Schnittstelle ausgeben
;
        SET     7,(IY+10)       ; 'DTR' setzen
A3E14:  LD      A,00000101B     ; Code for 'Write - Register 5'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        LD      A,(IY+10)       ; Wert f√ºr Write - Register 5  holen
        OUT     (C),A           ; an Schnittstelle ausgeben
        OR      A               ; Carry - Flag zur√ºcksetzen   (Code 'kein Fehler')
        RET
;
;
;   ein Zeichen von serieller Schnittstelle holen
;
A3E1F:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      C,(IY+0)        ; Port - Nummer der Schnittstelle holen
A3E25:  CALL    A3D67           ; bei Shift - BREAK -->  Abbruch Programm
        CALL    A3E9D           ; Abfrage, ob DCD - Sognal vorhanden ist
        JR      C,A3E25         ; nicht vorhanden -->  weiter abfragen
        CALL    A3DD5           ; Schnittstelle f√ºr Empfang ein Zeichen vorbereiten
A3E30:  CALL    A3D67           ; bei Shift - BREAK -->  Abbruch Programm
        IN      A,(C)           ; Zeichen von serieller Schnittstelle holen
        RRCA                    ; 'Rx Available' - Bit nach Carry schieben
        JR      NC,A3E30        ; kein Zeichen vorhanden -->  weiter abfragen
        DEC     C               ; Portnummer auf Datenport
        IN      A,(C)           ; Zeichen von serieller Schnittstelle holen
        INC     C               ; Portnummer wieder auf Steuer-/Statusport
        AND     (IY+2)          ; Anzahl √ºbertragene Bits maskieren
        PUSH    AF              ; gelesenes Zeichen retten
        LD      A,00000001B     ; Code for 'Read - Register 1'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        IN      A,(C)           ; 'Read - Register 1'  lesen
        AND     01110000B       ; Fehlerbits maskieren
        JR      NZ,A3E4F        ; Fehler aufgetreten -->  Fehlernummer bereitstellen
        CALL    A3DFE           ; 'DTR' - Signal zur√ºcksetzen
        POP     AF              ; gelesenes Zeichen holen
        RET
;
;
;   Fehlernummer aus Fehlerstatus bereitstellen
;
A3E4F:  LD      B,A             ; Fehlerstatus merken
        POP     AF              ; gelesenes Zeichen vergessen
        PUSH    BC              ; Fehlerstatus retten
        CALL    A3D6E           ; serielle Schnittstelle initialisieren
        POP     BC              ; geretteten Fehlerstatus holen
        LD      A,29            ; Vorgabe f√ºr Fehlernummer
        RLC     B               ;! CRC / Framing - Fehler nach Carry schieben
        RLC     B               ;!
        RET     C               ; ist Fehler -->  Fehlernummer stimmt
        INC     A               ; Fehlernummer auf 30
        RLC     B               ; Rx Overrun - Fehler nach Carry schieben
        RET     C               ; ist Fehler -->  Fehlernummer stimmt
        INC     A               ; Fehlernummer auf 31
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
;
;   Wert im Accu an serielle Schnittstelle ausgeben
;
A3E64:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      C,(IY+0)        ; Portadresse der Schnittstelle holen
        LD      D,A             ; auszugebendes Zeichen merken
        CALL    A3E04           ; 'RTS' - Signal  setzen
A3E6E:  CALL    A3D67           ; bei Shift - BREAK -->  Abbruch Programm
        CALL    A3EA4           ; auf DCD - Signal reagieren  ?
        CALL    NC,A3EB5        ; ja -->  auf CTS - Signal √ºberpr√ºfen
        JR      C,A3E6E         ; liegt noch nicht an -->  weiter abfragen
        IN      A,(C)           ; Status der seriellen Schnittstelle holen
        BIT     2,A             ; Tx - Buffer empty  ?
        JR      Z,A3E6E         ; nein -->  warten, bis letztes Zeichen gesendet
        BIT     7,(IY+-3)       ; keine √úbertragungskontrolle  ?
        JR      Z,A3E8E         ; ja -->  Zeichen ausgeben
        LD      A,00000001B     ; Code for 'Read - Register 1'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        IN      A,(C)           ; 'Read - Register 1'  lesen
        RRCA                    ; All - Send - Bit nach Carry schieben
        JR      NC,A3E6E        ; nicht gesetzt -->  weiter warten
A3E8E:  DEC     C               ; Portnummer auf Datenport der Schnittstelle
        OUT     (C),D           ; Zeichen an serielle Schnittstelle ausgeben
        INC     C               ; Portnummer wieder auf Steuerport
        BIT     6,(IY+-3)       ; aktivieren des RTS - Signals  ?
        JR      Z,A3E9B         ; nein
        CALL    A3E0A           ; 'RTS' - Signal zur√ºcksetzen
A3E9B:  OR      A               ; Carry - Flag zur√ºcksetzen   (Code 'kein Fehler')
        RET
;
;
;   Abfrage, ob DCD - Signal vorhanden ist
;
A3E9D:  OR      A               ; Carry - Flag zur√ºcksetzen   (Code 'kein Fehler')
        BIT     0,(IY+-3)       ; Empfangen des DCD - Signals  ?
        JR      A3EA9           ; eventuell DCD - Signal abfragen
;
;
;
;
A3EA4:  OR      A               ; Carry - Flag zur√ºcksetzen   (Code 'kein Fehler')
        BIT     1,(IY+-3)       ; Senden des DCD - Signals  ?
A3EA9:  RET     Z               ; nicht auf Signal abfragen
        LD      A,00010000B     ; Code for 'Reset EXT/Status Interrupt'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        IN      A,(C)           ; Status der Schnittstelle abfragen
        AND     00001000B       ; DCD - Signal maskieren
        RET     NZ              ; Signal ist gesetzt
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
;
;   auf CTS - Signal testen
;
A3EB5:  OR      A               ; Carry - Flag zur√ºcksetzen   (Code 'kein Fehler')
        BIT     2,(IY+-3)       ; Empfangen des CTS - Signals  ?
        RET     Z               ; nein
        LD      A,00010000B     ; Code for 'Reset EXT/Status Interrupt'
        OUT     (C),A           ; an Steuerport der Schnittstelle ausgeben
        IN      A,(C)           ; Status der seriellen Schnittstelle abfragen
        AND     00100000B       ; CTS - Signal maskieren
        RET     NZ              ; OK
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
;
;   Device Table for additional RAM-card (RAM:) 
;
W3EC6:  DEFW    W37C2           ; Pointer to Next Devices Table (FDx)
        DEFM    "RAM"
		DEFB    NUL             ; Device - name
        DEFB    01011111B       ; Device - Type - Byte
        DEFB    00100000B       ; Devices - numbers - bytes
        DEFB    32              ; maximum number of files on device
        DEFW    A3F14           ; Initialize device
        DEFW    A3FA9           ; Open file for reading
        DEFW    A3FEA           ; Open file for writing
        DEFW    A3F9B           ; Test device readiness
        DEFW    1024            ; maximum number of characters in the sector
        DEFW    A3FD5           ; provide data
        DEFW    A4011           ; output data
        DEFW    A4056           ; delete file
        DEFW    A4083           ; write away changed filename
        DEFW    A3EE3           ; provide free kilobytes 
;
;
;   RAM - file organization
;
;      Byte 0/1    Highest usable RAM address for Basic
;      Byte 2/3    Pointer to next free pointer
;      Byte 8-15   Byte numbers 8 - 15 to determine if already initialized
; from Byte 16     RAM card data 
;

;
;   Provide free kilobytes of the additional RAM card (device 'RAM:'). 
;
A3EE3:  CALL    A3EEF           ; Calculate free bytes of add-on RAM card
        LD      C,H             ; Number of free pages (256 blocks)
        LD      B,0             ; High - byte to zero
        SRL     C               ;!  Pages divided by four (yields kilobytes)
        SRL     C               ;!
        OR      A               ; Reset carry flag 
        RET
;
;
;   Calculate free bytes of additional RAM card
;
A3EEF:  PUSH    DE              ; Save DE
        LD      HL,0            ; Address of the highest usable RAM address
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        PUSH    DE              ; Note the highest usable RAM address
        INC     HL              ;!  address to 'pointer to next free address'
        INC     HL              ;!
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        POP     HL              ; Get the highest usable additional RAM address
        SBC     HL,DE           ; deduct the next free address
        JP      C,A1F8B         ; Addresses overlap --> Error 41 Hardware error
        POP     DE              ; Restore DE
        RET
;
;
;   Delete all files in additional RAM card 
;
A3F04:  LD      DE,16           ; first free address in additional RAM card
;
;
;   Enter pointer to end of user area (in DE) in additional RAM card
;
A3F07:  LD      HL,2            ; Address of 'next free pointer'
        CALL    A40AA           ; Output address in DE after additional RAM after address in HL
        EX      DE,HL           ; Pointer to next free position after HL
        LD      DE,0            ; Code 'End of concatenated offsets'
        JP      A40AA           ; Output address in DE after additional RAM after address in HL 
;
;
;   Initialize device 'RAM:'
;
A3F14:  RET     C               ; Error occurred --> termination
        LD      A,(S13C3)       ; Get flag 'RAM - card present'
        OR      A               ; RAM card present ?
        JP      Z,A1F97         ; not available --> error 50' not ready error
        CALL    A1E8F           ; Query whether you really want to initialize
        CALL    A0164           ; Comparison on byte after CALL call
        DEFM    ","             ; comma ?
        PUSH    HL              ; Save program pointer
        CALL    A3F04           ; delete all files in additional RAM card
        POP     HL              ; get saved program pointer
        CALL    A0164           ; Comparison on byte after CALL call
        DEFB    NUL             ; end of text character ?
        RET     Z               ; yes --> done
        RST     _DOCMD          ; Software - Execute command
        DEFB    19              ; Command 19 convert ASCII value (HL) into hex value after DE
A3F2F:  LD      HL,0            ; 
        DI                      ; Disable interrupts
        LD      B,1             ; code 'no spooler'
        LD      A,D             ; High - Byte Get number of bytes
        AND     11111100B       ; Mask high - byte count for full K - bytes
        CP      63 * 4          ; 63K or more ?
        LD      HL,0FFFFH       ; specify the highest usable RAM address
        JR      Z,A3F48         ; 63K or more --> nothing for spoolers
        LD      B,3             ; Code 'Spooler possible'
        LD      A,D             ; Get high byte count
        OR      A               ; equals zero ?
        LD      HL,32           ; specify minimum address
        JR      NZ,A3F49        ; not zero --> set original value
A3F48:  EX      DE,HL           ; Number of bytes after DE
A3F49:  LD      A,B             ; Spooler - get flag
        LD      (S13C3),A       ; Remember flag 'RAM - card available'
        LD      HL,0            ; Address of the highest usable RAM address
        CALL    A40AA           ; Output address in DE after additional RAM after address in HL
        CALL    A14F4           ; Set spooler data by spooler start address
        EI                      ; Release interrupt again
        RET
;
;
;   determine whether the RAM card has already been initialized
;
A3F58:  LD      HL,8            ; test from byte 8
        LD      B,L             ; test eight bytes
        LD      C,0             ; Default for result value
A3F5E:  CALL    A409F           ; Provide a byte from add-on RAM card from address (HL).
        SUB     L               ; Subtract byte number from value
        OR      C               ; plus old result
        LD      C,A             ; notice new result
        LD      A,L             ; Get low byte address
        CALL    A4094           ; Enter characters in Accu in additional RAM after address (HL).
        INC     L               ; Address to next byte
        DJNZ    A3F5E           ; test more bytes
        LD      A,C             ; get result
        OR      A               ; RAM card initialized ?
        JR      NZ,A3F81        ; no --> test whether it exists at all
        LD      HL,0            ; Address of the highest usable RAM address
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        LD      A,2             ; 
        INC     D               ; High byte address equal to 0FFH?
        JR      Z,A3F7B         ; yes --> no spooler
        INC     A               ; Flag on spooler possible
A3F7B:  LD      (S13C3),A       ; Remember flag 'RAM - card available'
        JP      A14F4           ; Set spooler data by spooler start address 
;
;
;   Initialize RAM card to default values
;
A3F81:  CALL    A3F04           ; delete all files in additional RAM card
        LD      HL,0            ; Address of the first byte in RAM - map
        LD      A,01011010B     ; Specify test bit pattern
        CALL    A4094           ; Enter characters in Accu in additional RAM after address (HL).
        CALL    A409F           ; Provide a byte from add-on RAM card from address (HL).
        SUB     01011010B       ; same test bit pattern ?
        LD      DE,0C000H       ; Specification of the highest additional RAM address that can be used for BASIC
        JR      Z,A3F2F         ; RAM card available --> remember the start address of the spooler
        XOR     A               ; Code 'RAM - card not present'
        LD      (S13C3),A       ; Remember flag 'RAM - card available' 
        RET
;
;
;   Test device readiness and initialize routines
;
A3F9B:  LD      A,(S13C3)       ; Get flag 'RAM - card available'
        OR      A               ; RAM card present ?
        JP      Z,A1F97         ; no --> Error 50' Not ready error
        LD      HL,16           ; Address of the first offset in RAM - card
        LD      (S13C4),HL      ; remember as the address of the next offset 
        RET
;
;
;   Open file on device 'RAM' for reading
;
A3FA9:  LD      B,H             ;!Pointer to location for file - identifier after BC
        LD      C,L             ;!  transfer
        LD      HL,(S13C4)      ; Get address of next offset
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        LD      A,D             ;!  offset equal to zero ?
        OR      E               ;!
        SCF                     ; Set flag: 'Error Occurred'
        RET     Z               ; no more files --> abort
        INC     HL              ;!  RAM card address on top of file entry
        INC     HL              ;!
        PUSH    HL              ; Pointer to start of file - save entry
        ADD     HL,DE           ; Pointer to next file - calculate entry
        JP      C,A1F8B         ; Carry occurred --> Error 41 Hardware error
        LD      (S13C4),HL      ; Note the address of the next offset
        POP     HL              ; saved pointer to file - get entry
        INC     HL              ; Block - skip identifier
        INC     HL              ;!  Block - skip length
        INC     HL              ;!
        LD      D,B             ;!  Pointer to position for identifier after DE
        LD      E,C             ;!
        LD      BC,30           ; length file identifier
        CALL    A40DE           ; Number of bytes specified in BC from RAM card from HL to DE
        LD      BC,34           ; Offset to file data
        ADD     HL,BC           ; Calculate pointer to file data in RAM - card
        EX      DE,HL           ; Pointer to position in identifier after HL
        LD      (HL),E          ;!  Pointer to date data in RAM - card in
        INC     HL              ;!  File - Enter identifier
        LD      (HL),D          ;!
        OR      A               ; Reset carry flag
        RET
;
;
;   provide a block of data from the RAM card
;
A3FD5:  EX      DE,HL           ; Pointer to place for data
        LD      L,(IY+30)       ;!  Start address of the next data block
        LD      H,(IY+31)       ;!  from file - get identifier
        INC     HL              ; Data block - skip identifier
        INC     HL              ;!  Skip data block length
        INC     HL              ;!
        CALL    A40DE           ; Number of bytes specified in BC from RAM card from HL to DE
        LD      (IY+30),L       ;!  Start address of the next data block
        LD      (IY+31),H       ;!  enter in file identifier
        OR      A               ; reset carry flag (code 'no error')
        RET
;
;
;   File on device RAM: open for writing
;
A3FEA:  PUSH    AF              ; Save data block identifier
        CALL    A1C3D           ; check if only one file is opened/name doesn't already exist
        PUSH    HL              ; Pointer to file - save identifier
A3FEF:  LD      HL,2            ; address 'next free pointer'
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        LD      (S13C6),DE      ; Note the start address of the new RAM file
        PUSH    DE              ; Save initial address
        LD      HL,64+3+3+1     ; minimal file - space requirements
        ADD     HL,DE           ; Calculate minimum end-of-file address
        CALL    A4045           ; check if address in HL is still OK for RAM card
        POP     DE              ; Get start address of file in RAM card
        INC     DE              ;!  Skip offset
        INC     DE              ;!
        POP     HL              ; Pointer to file - get handle
        LD      BC,64           ; Length file - identifier in RAM - file
        POP     AF              ; Get data block identifier
        CALL    A40C0           ; Data block (HL) with identification data in RAM data transferred to (DE).
        LD      (S13C8),DE      ; RAM - remember card address for data block
        RET
;
;
;   Write data block in RAM - card 
;
A4011:  PUSH    AF              ; Save block ID
        PUSH    HL              ; Save main memory address
        PUSH    BC              ; Save block length
        LD      HL,(S13C8)      ; RAM - get card address for data block
        INC     BC              ;!  Length for block identifier and block length
        INC     BC              ;!  correct
        INC     BC              ;!
        ADD     HL,BC           ; Calculate end address
        CALL    A4045           ; Check if address in HL is still OK for RAM card
        POP     BC              ; Get saved block length
        POP     HL              ; Get main memory address
        LD      DE,(S13C8)      ; RAM - get card address for data block
        POP     AF              ; rescued block - get identifier
        PUSH    AF              ; and remember again
        OR      00000001B       ; plus code 'data block'
        CALL    A40C0           ; Data block (HL) with identification data in RAM data transferred to (DE).
        LD      (S13C8),DE      ; RAM - remember card address for data block
        POP     AF              ; rescued block - get identifier
        BIT     2,A             ; last block ?
        RET     Z               ; no
        PUSH    DE              ; RAM - remember end address
        CALL    A3F07           ; Enter pointer to end of used area (in DE) in RAM card
        POP     HL              ; RAM - get end address
        LD      DE,(S13C6)      ; Get the start address of the new RAM file
        DEC     HL              ;!   correct for offset
        DEC     HL              ;!
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; File - Length in RAM - Calculate file
        EX      DE,HL           ; Offset to DE / pointer to position for offset to HL
        JP      A40AA           ; Output address in DE after additional RAM after address in HL

;
;
;   Check whether address in HL is still within the usable range for BASIC 
;
A4045:  JR      C,A4053         ; Transfer --> Error 53 No file space error
        PUSH    HL              ; save address to be verified
        LD      HL,0            ; Address of the highest usable RAM address
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        OR      A               ; Reset carry flag
        POP     HL              ; Get address to verify
        SBC     HL,DE           ; compare with maximum address
        RET     C               ; Address is OK
A4053:  JP      A1FA0           ; Error 53 No file space error
;
;
;   Delete file on RAM: device after setting the identification data 
;
A4056:  LD      HL,(S101E)      ; Get pointer to location for data block from file handle
        LD      DE,-(64+3+2)    ; Offset on offset for file - offset
        ADD     HL,DE           ; Calculate pointer to offset for file
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        EX      DE,HL           ; Offset to HL
        ADD     HL,DE           ; Calculate pointer to end of file
        INC     HL              ;!  correct for offset
        INC     HL              ;!
        PUSH    DE              ; Save pointer to start of file
        PUSH    HL              ; Save pointer to end of file
        LD      HL,2            ; address 'next free pointer'
        CALL    A40B5           ; two bytes from additional RAM card from address in HL to DE
        EX      DE,HL           ; End address after HL
        POP     DE              ; Get pointer to end of file
        PUSH    DE              ; and remember again
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; Calculate number of bytes after file
        INC     HL              ;!  correct for last offset
        INC     HL              ;!
        LD      B,H             ;!  Number of bytes to move to BC
        LD      C,L             ;!
        POP     HL              ; Get pointer to end of file
        POP     DE              ; Get pointer to start of file
        CALL    A40EA           ; Move number of bytes specified in BC in additional RAM from (HL) to (DE).
        DEC     DE              ;!  Set address back to last offset
        DEC     DE              ;!
        LD      HL,2            ; address 'next free pointer'
        JP      A40AA           ; Output address in DE after additional RAM after address in HL
;
;
;   Enter the (changed) file identifier back into the RAM card
;
A4083:  LD      HL,(S101E)      ; Get pointer to data block location
        LD      DE,-64          ; Offset to position for file identifier
        ADD     HL,DE           ; Calculate pointer to position for file handle
        EX      DE,HL           ; Address after DE
        LD      HL,S1000        ; Pointer to storage for file handle
        LD      BC,32           ; Length identifier record
        JP      A40D0           ; LDIR from main memory to additional RAM
;
;
;   Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
;
A4094:  PUSH    BC              ; Register - Wert retten
        LD      C,ERAM_A        ; RAM - Karte  Adressen - Port
        LD      B,H             ; High - Byte Adresse in RAM - Karte
        OUT     (C),L           ; Adresse an RAM - Karte ausgeben
        OUT     (ERAM_D),A      ; Zeichen an RAM - Karte ausgeben
        POP     BC              ; geretteten Register - Wert holen
        OR      A               ; Carry - Flag zur√ºcksetzen   (Code for 'Funktion OK')
        RET
;
;
;   ein Byte aus Zusatz - RAM - Karte aus Adresse (HL) bereitstellen
;
A409F:  PUSH    BC              ; Register - Wert retten
        LD      C,ERAM_A        ; RAM - Karte  Adressen - Port
        LD      B,H             ; High - Byte Adresse in RAM - Karte
        OUT     (C),L           ; Adresse an RAM - Karte ausgeben
        IN      A,(ERAM_D)      ; Zeichen von RAM - Karte holen
        POP     BC              ; geretteten Register - Wert holen
        OR      A               ; Carry - Flag zur√ºcksetzen   (Code for 'Funktion OK')
        RET
;
;
;   Adresse in DE nach Zusatz - RAM - Karte  nach Adresse in HL ausgeben
;
A40AA:  LD      A,E             ; Low - Byte Adresse holen
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        INC     HL              ; Zeiger auf RAM - Karte auf n√§chste Speicherzelle
        LD      A,D             ; High - Byte Adresse holen
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        DEC     HL              ; Zeiger auf RAM - Karte wieder corrigieren
        RET
;
;
;   zwei Byte aus Zusatz - RAM - Karte ab Adresse in HL nach DE
;
A40B5:  CALL    A409F           ; ein Byte aus Zusatz-RAM-Karte aus Adresse (HL) bereitstellen
        LD      E,A             ; Low - Byte Wert merken
        INC     HL              ; Zeiger auf RAM - Karte auf n√§chste Speicherzelle
        CALL    A409F           ; ein Byte aus Zusatz-RAM-Karte aus Adresse (HL) bereitstellen
        LD      D,A             ; High - Byte Wert merken
        DEC     HL              ; Zeiger auf RAM - Karte wieder corrigieren
        RET
;
;
;   Datenblock (HL) mit Kennungsdaten in RAM - Datei nach (DE) √ºbertragen
;
A40C0:  EX      DE,HL           ; Zeiger auf RAM - Karte nach HL
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        INC     HL              ; Block - Kennung √ºberspringen
        LD      A,C             ; Low - Byte Block - L√§nge holen
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        INC     HL              ; Low - Byte L√§nge √ºberspringen
        LD      A,B             ; High - Byte Block - L√§nge holen
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        INC     HL              ; High - Byte L√§nge √ºberspringen
        EX      DE,HL           ; RAM - Kartenadresse nach DE
;
;
;   in BC angegebene Anzahl Bytes vom Hauptspeicher ab Adresse (HL)
;   nach Zusatz - RAM - Karte ab Adresse (HL) ablegen
;
A40D0:  EX      DE,HL           ; RAM - Kartenadresse nach HL
A40D1:  LD      A,(DE)          ; ein Byte aus Speicher holen
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        INC     HL              ; Zeiger auf RAM - Karte auf n√§chste Speicherzellen
        INC     DE              ; Zeiger auf Hauptspeicher auf n√§chste Speicherzelle
        DEC     BC              ; Restanzahl Bytes minus eins
        LD      A,B             ;! Restanzahl Bytes gleich Null  ?
        OR      C               ;!
        JR      NZ,A40D1        ; nein -->  weitere Bytes aus Speicher an RAM-Karte ausgeben
        EX      DE,HL           ; RAM - Kartenadresse nach DE
        RET
;
;
;   in BC angegebene Anzahl Bytes von RAM-Karte ab HL nach DE
;
A40DE:  CALL    A409F           ; ein Byte aus Zusatz-RAM-Karte aus Adresse (HL) bereitstellen
        LD      (DE),A          ; gelesenes Byte im Speicher merken
        INC     HL              ; Zeiger auf RAM - Karte auf n√§chstes Byte
        INC     DE              ; Zeiger auf Speicher auf n√§chstes Byte
        DEC     BC              ; Restanzahl Bytes minus eins
        LD      A,B             ;! Restanzahl Bytes gleich Null  ?
        OR      C               ;!
        RET     Z               ; ja -->  fertig
        JR      A40DE           ; weitere Bytes aus RAM - Karte lesen
;
;
;   in BC angegebene Anzahl Bytes in Zusatz - RAM von (HL) nach (DE) verschieben
;
A40EA:  CALL    A409F           ; ein Byte aus Zusatz-RAM-Karte aus Adresse (HL) bereitstellen
        EX      DE,HL           ; Zeiger vertauschen
        CALL    A4094           ; Zeichen im Accu in Zusatz-RAM nach Adresse (HL) eintragen
        EX      DE,HL           ; Zeiger vertauschen
        INC     HL              ; Zeiger auf Quelle plus eins
        INC     DE              ; Zeiger auf Ziel plus eins
        DEC     BC              ; Restanzahl Bytes minus eins
        LD      A,B             ;! Restanzahl Bytes gleich Null  ?
        OR      C               ;!
        RET     Z               ; ja -->  fertig
        JR      A40EA           ; weitere Bytes in Zusatz - RAM - Karte verschieben
 
;   Speicherbereich und Tabellenbereich f√ºr TON - Routinen
;
B40FA:  DEFB    0               ; MUSIC - Status   (0 = inaktiv / 1 = MUSIC / 2 = SOUND)
;
B40FB:  DEFB    0               ; Speicher f√ºr Bits der aktiven Tongeneratorregister
;
        DEFB    0
;
;
;   Tabelle mit aktuellen Werte der programmierbaren Tongeneratoren
;
B40FD:  DEFB    080H,000H       ; Code for 'Frequenz Tongenerator 0 auf Aus'
B40FF:  DEFB    09FH            ; Code for 'Lautst√§rke Tongenerator 0 auf Aus'
;
        DEFB    0A0H,000H       ; Code for 'Frequenz Tongenerator 1 auf Aus'
        DEFB    0BFH            ; Code for 'Lautst√§rke Tongenerator 1 auf Aus'
;
        DEFB    0C0H,000H       ; Code for 'Frequenz Tongenerator 2 auf Aus'
B4105:  DEFB    0DFH            ; Code for 'Lautst√§rke Tongenerator 2 auf Aus'
;
;
;   Speicherbreich f√ºr aktuellen Status Tongenerator Null
;
B4106:  DEFB    0               ; Nummer des Tongenerators
        DEFS    1               ; Wiederholungsz√§hler
        DEFS    1               ; Wiederholungsfaktor
        DEFS    2               ; Zeiger auf Wellenformtabelle
        DEFS    1               ; Lautst√§rkenz√§hler
        DEFS    1               ; Tonl√§ngenz√§hler
        DEFS    1               ; Tempoz√§hler
        DEFS    1               ; Tonl√§ngenverh√§ltnis
        DEFS    1               ; Tempofaktor
        DEFS    2               ; Zeiger auf Rest Wertetabelle
        DEFS    1               ; Wellenformnummer
        DEFS    1               ; Pausennotenflag
        DEFS    1               ; Lautst√§rkenwert
        DEFS    1               ; maximale Lautst√§rke            
;
;
;   Speicherbereich f√ºr aktuellen Status  Tongenerator eins
;
        DEFB    1               ; Nummer des Tongenerators       
        DEFS    1               ; Wiederholungsz√§hler            
        DEFS    1               ; Wiederholungsfaktor            
        DEFS    2               ; Zeiger auf Wellenformtabelle   
        DEFS    1               ; Lautst√§rkenz√§hler              
        DEFS    1               ; Tonl√§ngenz√§hler                
        DEFS    1               ; Tempoz√§hler                    
        DEFS    1               ; Tonl√§ngenverh√§ltnis            
        DEFS    1               ; Tempofaktor                    
        DEFS    2               ; Zeiger auf Rest Wertetabelle   
        DEFS    1               ; Wellenformnummer               
        DEFS    1               ; Pausennotenflag                
        DEFS    1               ; Lautst√§rkenwert                
        DEFS    1               ; maximale Lautst√§rke            
;
;
;   Speicherbereich f√ºr aktuellen Status  Tongenerator zwei
;
        DEFB    2               ; Nummer des Tongenerators       
        DEFS    1               ; Wiederholungsz√§hler            
        DEFS    1               ; Wiederholungsfaktor            
        DEFS    2               ; Zeiger auf Wellenformtabelle   
        DEFS    1               ; Lautst√§rkenz√§hler              
        DEFS    1               ; Tonl√§ngenz√§hler                
        DEFS    1               ; Tempoz√§hler                    
        DEFS    1               ; Tonl√§ngenverh√§ltnis            
        DEFS    1               ; Tempofaktor                    
        DEFS    2               ; Zeiger auf Rest Wertetabelle   
        DEFS    1               ; Wellenformnummer               
        DEFS    1               ; Pausennotenflag                
        DEFS    1               ; Lautst√§rkenwert                
        DEFS    1               ; maximale Lautst√§rke            

;
;
;   Speicherbereich f√ºr aktuelles Status  Tongenerator drei
;
        DEFB    3               ; Nummer des Tongenerators       
        DEFS    1               ; Wiederholungsz√§hler            
        DEFS    1               ; Wiederholungsfaktor            
        DEFS    2               ; Zeiger auf Wellenformtabelle   
        DEFS    1               ; Lautst√§rkenz√§hler              
        DEFS    1               ; Tonl√§ngenz√§hler                
        DEFS    1               ; Tempoz√§hler                    
        DEFS    1               ; Tonl√§ngenverh√§ltnis            
        DEFS    1               ; Tempofaktor                    
        DEFS    2               ; Zeiger auf Rest Wertetabelle   
        DEFS    1               ; Wellenformnummer               
        DEFS    1               ; Pausennotenflag                
        DEFS    1               ; Lautst√§rkenwert                
        DEFS    1               ; maximale Lautst√§rke            
;
;
;   Tabelle mit Umsetzverh√§ltnissen f√ºr Tonl√§ngenz√§hler
;
B4146:  DEFB    1               ; Umsetzverh√§ltnis f√ºr Tonl√§nge  0
        DEFB    2               ; Umsetzverh√§ltnis f√ºr Tonl√§nge  1
        DEFB    3               ; Umsetzverh√§ltnis f√ºr Tonl√§nge  2
        DEFB    4               ; Umsetzverh√§ltnis f√ºr Tonl√§nge  3
        DEFB    6               ; Umsetzverh√§ltnis f√ºr Tonl√§nge  4
        DEFB    8               ; Umsetzverh√§ltnis f√ºr Tonl√§nge  5
        DEFB    12              ; Umsetzverh√§ltnis f√ºr Tonl√§nge  6
        DEFB    16              ; Umsetzverh√§ltnis f√ºr Tonl√§nge  7
        DEFB    24              ; Umsetzverh√§ltnis f√ºr Tonl√§nge  8
        DEFB    32              ; Umsetzverh√§ltnis f√ºr Tonl√§nge  9
;
        DEFB    23              ; Faktor f√ºr Tempo 1
        DEFB    20              ; Faktor f√ºr Tempo 2
        DEFB    17              ; Faktor f√ºr Tempo 3
        DEFB    13              ; Faktor f√ºr Tempo 4
        DEFB    10              ; Faktor f√ºr Tempo 5
        DEFB    7               ; Faktor f√ºr Tempo 6
        DEFB    3               ; Faktor f√ºr Tempo 7
;
;
;   Tabelle f√ºr Wellenformwerte
;
B4157:  DEFB    000H,005H,003H,003H     ; Werte f√ºr Wellenform  0
;
        DEFB    00FH,004H,001H,003H     ; Werte f√ºr Wellenform  1
;
        DEFB    000H,005H,002H,000H     ; Werte f√ºr Wellenform  2
;
        DEFB    00FH,004H,001H,000H     ; Werte f√ºr Wellenform  3
;
        DEFB    000H,005H,002H,003H     ; Werte f√ºr Wellenform  4
;
        DEFB    00FH,004H,003H,003H     ; Werte f√ºr Wellenform  5
;
        DEFB    000H,005H,004H,000H     ; Werte f√ºr Wellenform  6
;
        DEFB    00FH,004H,005H,000H     ; Werte f√ºr Wellenform  7
;
        DEFB    000H,003H,003H,000H     ; Werte f√ºr Wellenform  8
;
;
;   Tabelle mit Teilungsverh√§ltnissen f√ºr Tonh√∂he
;
B417B:  DEFB    000H,03FH               ; Ton  9    110.61  Hz     A
        DEFB    007H,03BH               ; Ton 10    116.65  Hz    #A
        DEFB    002H,038H               ; Ton 11    121.76  Hz     B
        DEFB    00FH,034H               ; Ton 12    130.98  Hz     C
        DEFB    000H,032H               ; Ton 13    138.67  Hz    #C
        DEFB    003H,02FH               ; Ton 14    146.94  Hz     D
        DEFB    009H,02CH               ; Ton 15    155.46  Hz    #D
        DEFB    001H,02AH               ; Ton 16    164.69  Hz     E
        DEFB    00BH,027H               ; Ton 17    174.55  Hz     F
        DEFB    007H,025H               ; Ton 18    185.04  Hz    #F
        DEFB    006H,023H               ; Ton 19    195.83  Hz     G
        DEFB    006H,021H               ; Ton 20    207.57  Hz    #G
;
        DEFB    008H,01FH               ; Ton 21    219.92  Hz     A
        DEFB    00CH,01DH               ; Ton 22    232.86  Hz    #A
        DEFB    001H,01CH               ; Ton 23    246.86  Hz     B
        DEFB    008H,01AH               ; Ton 24    261.42  Hz     C
        DEFB    000H,019H               ; Ton 25    277.10  Hz    #C
        DEFB    009H,017H               ; Ton 26    294.01  Hz     D
        DEFB    004H,016H               ; Ton 27    311.35  Hz    #D
        DEFB    000H,015H               ; Ton 28    329.88  Hz     E
        DEFB    00DH,013H               ; Ton 29    349.65  Hz     F
        DEFB    00CH,012H               ; Ton 30    369.47  Hz    #F
        DEFB    00BH,011H               ; Ton 31    391.66  Hz     G
        DEFB    00BH,010H               ; Ton 32    415.13  Hz    #G
;
        DEFB    00CH,00FH               ; Ton 33    439.84  Hz     A
        DEFB    00EH,00EH               ; Ton 34    465.72  Hz    #A
        DEFB    000H,00EH               ; Ton 35    494.82  Hz     B
        DEFB    004H,00DH               ; Ton 36    522.83  Hz     C
        DEFB    008H,00CH               ; Ton 37    544.20  Hz    #C
        DEFB    00DH,00BH               ; Ton 38    586.46  Hz     D
        DEFB    002H,00BH               ; Ton 39    622.70  Hz    #D
        DEFB    008H,00AH               ; Ton 40    659.76  Hz     E
        DEFB    00FH,009H               ; Ton 41    697.11  Hz     F
        DEFB    006H,009H               ; Ton 42    738.94  Hz    #F
        DEFB    00DH,008H               ; Ton 43    786.10  Hz     G
        DEFB    005H,008H               ; Ton 44    833.39  Hz    #G
;
        DEFB    00EH,007H               ; Ton 45    879.69  Hz     A
        DEFB    007H,007H               ; Ton 46    931.43  Hz    #A
        DEFB    000H,007H               ; Ton 47    989.65  Hz     B
        DEFB    00AH,006H               ; Ton 48   1045.7   Hz     C
        DEFB    004H,006H               ; Ton 49   1108.4   Hz    #C
        DEFB    00EH,005H               ; Ton 50   1179.2   Hz     D
        DEFB    009H,005H               ; Ton 51   1245.4   Hz    #D
        DEFB    004H,005H               ; Ton 52   1319.5   Hz     E
        DEFB    00FH,004H               ; Ton 53   1403.0   Hz     F
        DEFB    00BH,004H               ; Ton 54   1477.9   Hz    #F
        DEFB    007H,004H               ; Ton 55   1561.1   Hz     G
        DEFB    003H,004H               ; Ton 56   1654.3   Hz    #G
;
        DEFB    00FH,003H               ; Ton 57   1759.4   Hz     A
        DEFB    00BH,003H               ; Ton 58   1878.7   Hz    #A
        DEFB    008H,003H               ; Ton 59   1979.3   Hz     B
        DEFB    005H,003H               ; Ton 60   2091.3   Hz     C 
        DEFB    002H,003H               ; Ton 61   2216.3   Hz    #C 
        DEFB    00FH,002H               ; Ton 62   2358.3   Hz     D 
        DEFB    00DH,002H               ; Ton 63   2463.1   Hz    #D
        DEFB    00AH,002H               ; Ton 64   2639.1   Hz     E
        DEFB    008H,002H               ; Ton 65   2771.0   Hz     F
        DEFB    005H,002H               ; Ton 66   2995.7   Hz    #F
        DEFB    003H,002H               ; Ton 67   3166.9   Hz     G
        DEFB    001H,002H               ; Ton 68   3358.8   Hz    #G
;
        DEFB    00FH,001H               ; Ton 69   3575.5   Hz     A
        DEFB    00EH,001H               ; Ton 70   3694.7   Hz    #A
        DEFB    00CH,001H               ; Ton 71   3958.6   Hz     B
        DEFB    00AH,001H               ; Ton 72   4263.1   Hz     C
        DEFB    009H,001H               ; Ton 73   4433.6   Hz    #C
        DEFB    008H,001H               ; Ton 74   4618.4   Hz     D
        DEFB    006H,001H               ; Ton 75   5038.2   Hz    #D
        DEFB    005H,001H               ; Ton 76   5278.1   Hz     E
        DEFB    004H,001H               ; Ton 77   5542.0   Hz     F
        DEFB    003H,001H               ; Ton 78   5833.7   Hz    #F
        DEFB    002H,001H               ; Ton 79   6157.8   Hz     G
        DEFB    001H,001H               ; Ton 80   6520.0   Hz    #G
;
        DEFB    000H,001H               ; Ton 81   6927.5   Hz     A
        DEFB    00FH,000H               ; Ton 82   7389.4   Hz    #A
        DEFB    00EH,000H               ; Ton 83   7917.1   Hz     B
;
;
;   Tabelle mit Werte zum Abschalten aller Tongeneratoren
;
B4211:  DEFB    09FH            ; Lautst√§rke  Tongenerator 0 auf  AUS
        DEFB    0BFH            ; Lautst√§rke  Tongenerator 1 auf  AUS
        DEFB    0DFH            ; Lautst√§rke  Tongenerator 2 auf  AUS
        DEFB    0FFH            ; Lautst√§rke  Rauschgenerator auf AUS
;
;
;   Ausgabetabelle f√ºr Ton nach Notennummer und Dauer    (SOUND)
;
B4215:  DEFB    080H,000H       ; Code for 'Frequenz  Tongenerator 0  auf AUS'
        DEFB    090H            ; Code for 'Lautst√§rke  Tongenerator 0  auf AUS'
;
S4218:  DEFS    2               ; Tonl√§nge   (bei SOUND)
;
;
;   Musik - Interrupt durch Z√§hler 8253 und PIO Kanal A  abarbeiten
;
A421A:  PUSH    IY              ; Register - Wert retten
        CALL    A4224           ; Interrupt f√ºr MUSIC abarbeiten
        POP     IY              ; geretteten Register - Wert holen
        EI                      ; Interrupt freigeben
        RETI                    ; Interrupt - Behandlung abschliessen
;
;
;   Interrupt f√ºr Music abarbeiten
;
A4224:  CALL    A00BA           ; Register IX, HL, BC, DE und AF retten
        CALL    A44CC           ; Bausteine f√ºr 'MUSIC - Interrupt' initialisieren
        LD      A,(B40FA)       ; MUSIC - Status holen
        OR      A               ; Tonausgabe aktiv  ?
        JP      Z,A447E         ; nein -->  Ton abschalten
        DEC     A               ; MUSIC  ?
        JP      NZ,A43B9        ; nein -->  Interrupt bei SOUND bearbeiten
        LD      BC,256*9+PSGOUT ; 9 Werte in Tabelle / Portnummer des Tongenerators
        LD      HL,B40FD        ; Tabelle mit aktuellen Werten der Tongeneratoren
        OTIR                    ; Tabelle mit neuen Werte der Tongeneratoren ausgeben
        LD      B,8             ; acht Register im Tongenerator
        LD      A,(B40FB)       ; Bits der aktiven Tongeneratorregister holen
        OR      A               ; kein Tongenerator aktiv  ?
        JP      Z,A447E         ; ja -->  Ton abschalten
        LD      C,A             ; Bits der Tongeneratoren merken
A4247:  DEC     B               ; Z√§hler minus eins
        RET     M               ; fertig
        RLC     C               ; ein Tongeneratorbit nach Carry schieben
        JR      NC,A4247        ; Bit nicht gesetzt -->  Generatorregister nicht aktiv
        PUSH    BC              ; Z√§hler und Restbits retten
        LD      A,B             ; Z√§hler holen
        CALL    A43FC           ; Zeiger auf Speicher nach Registernummer bereitstellen
        BIT     0,(IY+13)       ; Pausennote  ?
        CALL    Z,A425F         ; nein -->  Lautst√§rke aus Wellenform aufbereiten
        CALL    A42AC           ; Wartez√§hler minus eins,  wenn 0 -->  n√§chster Notenwert
        POP     BC              ; geretteten Z√§hler und Restbits holen
        JR      A4247           ; restliche Tongeneratorregister testen
;
;
;   Lautst√§rke aus Wellenform aufbereiten
;
A425F:  DEC     (HL)            ; Wiederholungsz√§hler minus eins
        RET     NZ              ; noch nicht null -->  fertig
        INC     HL              ; Zeiger auf Wiederholungsfaktor
        LD      A,(HL)          ; Wiederholungsfaktor aus Tabelle holen
        DEC     HL              ; Zeiger wieder auf Wiederholungsz√§hler
        LD      (HL),A          ; Wiederholungsfaktor als Wiederholungsz√§hler eintragen
        INC     HL              ; Zeiger auf Wiederholungsfaktor
        INC     HL              ; Zeiger auf Low - Byte Zeiger auf Wellenformtabelle
        LD      E,(HL)          ;! Zeiger auf Wellenformtabelle aus Generator - Status - 
        INC     HL              ;! Datensatz holen
        LD      D,(HL)          ;!
        EX      DE,HL           ; Zeiger auf Wellenformtabelle nach HL
A426B:  LD      A,(HL)          ; n√§chsten Wert aus Wellenformtabelle holen
        OR      A               ; gleich Null  ?
        JR      NZ,A4273        ; nein -->  auswerten
        DEC     HL              ;! Zeiger auf vorletzten Wert in Tabelle
        DEC     HL              ;!
        JR      A426B           ; erneut untersuchen
;
A4273:  EX      DE,HL           ; Zeiger auf Wellenformtabelle wieder nach DE
        INC     HL              ; Zeiger auf Generatortabelle auf Lautst√§rkenz√§hler
        DEC     A               ; Wert gleich eins  ?
        JR      Z,A4288         ; ja -->  Code for 'kein Ton'  vorgeben
        DEC     A               ; Wert gleich zwei  ?
        JR      Z,A4296         ; ja -->  D√§mpfung 4 dB  merken
        DEC     A               ; Wert gleich drei  ?
        RET     Z               ; ja -->  alte Lautst√§rke
        DEC     A               ; Wert gleich vier  ?
        LD      A,(HL)          ; alten Lautst√§rkewert holen
        JR      Z,A428C         ; ja -->  D√§mpfung erniedrigen  (Lautst√§rke hoch)
        INC     A               ; Lautst√§rkewert plus eins  (Ton wird leiser)
        CP      00001111B       ; Code for 'Ton aus'  ?
        JR      Z,A429A         ; ja -->  eintragen
        JR      C,A429A         ; noch OK -->  neuen Lautst√§rkewert merken
A4288:  LD      A,00001111B     ; Code for 'Ton aus'
        JR      A4299           ; Zeiger aus Tabelle corrigieren und neue Lautst√§rke merken
;
A428C:  DEC     A               ; D√§mpfung minus eins
        JP      M,A4296         ; √úberlauf -->  maximale Lautst√§rke vorgeben
        LD      C,(IY+14)       ; maximalen Lautst√§rkewert holen
        CP      C               ; mit aktuellem Lautst√§rkewert vergleichen
        JR      NC,A429A        ; Wert ist noch OK -->  merken
A4296:  LD      A,(IY+14)       ; maximalen Lautst√§rkewert holen
A4299:  INC     DE              ; Zeiger auf Wellenformtabelle auf n√§chsten Wert
A429A:  LD      (HL),A          ; Lautst√§rkenz√§hler in Statustabelle eintragen
        DEC     HL
        LD      (HL),D          ;! Zeiger auf Wellenformtabelle in Statustabelle
        DEC     HL              ;! des Tongenerators eintragen
        LD      (HL),E          ;!
A429F:  AND     00001111B       ; Lautst√§rke maskieren
        LD      B,A             ; und merken
        LD      A,(IX+2)        ; alten Lautst√§rkewert holen
        AND     11110000B       ; Registermaske des Tongenerators maskieren
        OR      B               ; plus neuen Lautst√§rkewert
        LD      (IX+2),A        ; neuen Lautst√§rkewert f√ºr n√§chsten Ton merken
        RET
;
;
;   Wartez√§hler f√ºr Tongenerator runterz√§hlen, wenn Ton fertig gespielt -->
;   Rest Melodietext f√ºr Tongenerator auswerten   (Zeiger auf Datensatz in IY)
;
A42AC:  DEC     (IY+6)          ; Tonl√§ngenz√§hler minus eins
        RET     NZ              ; noch nicht null
        DEC     (IY+7)          ; Tempoz√§hler minus eins
        LD      A,(IY+8)        ; Tonl√§ngeverh√§ltnis holen
        LD      (IY+6),A        ; und wieder als Tonl√§ngez√§hler merken
        RET     NZ              ; Tempoz√§hler noch nicht null -->  weiter warten
        LD      A,(IY+9)        ; Tempofaktor holen
        LD      (IY+7),A        ; und als Tempoz√§hler merken
        LD      E,(IY+10)       ;! Zeiger auf Rest Wertetabelle f√ºr Tongenerator
        LD      D,(IY+11)       ;! holen
;
;
;   n√§chsten Notenwert in Tabelle  (DE) abarbeiten
;
A42C6:  LD      A,(DE)          ; n√§chsten Tonwert holen
        INC     DE              ; Tonwert √ºberspringen
        CP      -1              ; End of table  ?
        JR      Z,A4331         ; ja -->  Tongenerator abschalten
        CP      0A0H            ; Wiederholungsfaktor  ?
        JR      Z,A432A         ; ja -->  Wiederholungsfaktor auswerten
        CP      090H            ; Wellenform  ?
        JR      NC,A4339        ; ja -->  Wellenform auswerten
        CP      080H            ; Lautst√§rke  ?
        JR      NC,A4340        ; ja -->  Lautst√§rke auswerten
        CP      060H            ; Tonl√§nge  ?
        JR      NC,A434A        ; ja -->  Tonl√§nge auswerten
        SUB     9               ; die ersten neun Noten sind Pausen
        LD      (IY+10),E       ;! Zeiger auf Rest Wertetabelle merken
        LD      (IY+11),D       ;!
        SET     0,(IY+13)       ; Pausenbit setzen
        JR      C,A42F1         ; Note ist Pause
        RES     0,(IY+13)       ; Pausenbit wieder zur√ºcksetzen
        CALL    A4362           ; Frequenzwert der Notennummer bereitstellen
A42F1:  LD      A,(IY+2)        ; Wiederholungsfaktor holen
        LD      (IY+1),A        ; und als Wiederholungsz√§hler merken
        LD      A,(IY+8)        ; Tonl√§ngenverh√§ltnis holen
        LD      (IY+6),A        ; als Tonl√§ngenz√§hler merken
        LD      A,(IY+9)        ; Tempofaktor holen
        LD      (IY+7),A        ; und als Tempoz√§hler merken
        BIT     0,(IY+13)       ; Pausennote  ?
        JR      NZ,A4334        ; ja -->  Code for 'kein Ton'  vorgeben
        LD      A,(IY+12)       ; Wellenformnummer holen
        LD      BC,B4157        ; Zeiger auf Tabelle mit Wellenformwerten
        ADD     A,A             ;! Wellenformnummer mal zwei
        ADD     A,A             ;!                  mal vier   (vier Werte je Nummer)
        LD      H,0             ; High - Byte Offset auf Null
        LD      L,A             ; Low - Byte Offset vorgeben
        ADD     HL,BC           ; Zeiger auf richtige Wellenformwerte errechnen
        LD      A,(HL)          ; ersten Wert aus Tabelle holen
        OR      A               ; gleich Null  ?
        JR      NZ,A431C        ; nein -->  Wert merken
        LD      A,(IY+14)       ; Lautst√§rkewert holen
A431C:  LD      (IY+5),A        ; als Lautst√§rkez√§hler vorgeben
        CALL    A429F           ; Lautst√§rkez√§hler in Ausgabetabelle eintragen
        INC     HL              ; ersten Wert in Wellenformtabelle √ºberspringen
        LD      (IY+3),L        ;! Zeiger auf Wellenformtabelle merken
        LD      (IY+4),H        ;!
        RET
;
;
;   Wiederholungsfaktor aus Wertetabelle auswerten
;
A432A:  LD      A,(DE)          ; Wiederholungsfaktor holen
        INC     DE              ; Wiederholungsfaktor √ºberspringen
        LD      (IY+2),A        ; Wiederholungsfaktor merken
A432F:  JR      A42C6           ; n√§chsten Wert in Ton - Tabelle auswerten
;
;
;   Wertetabelle f√ºr Tongenerator abgearbeitet -->  Code for 'kein Ton'  vorgeben
;
A4331:  CALL    A4464           ; merken, da√ü Tongenerator nicht mehr aktiv ist
A4334:  LD      A,00001111B     ; Code for 'Lautst√§rke AUS'
        JP      A429F           ; Accu als Lautst√§rkenwert f√ºr n√§chsten Ton merken
;
;
;   Wellenform aus Ton - Wertetabelle auswerten
;
A4339:  SUB     090H            ; Code umrechnen in Wellenformnummer
        LD      (IY+12),A       ; Wellenform merken
        JR      A432F           ; n√§chsten Wert in Ton - Tabelle auswerten
;
;
;   Lautst√§rke aus Wertetabelle auswerten
;
A4340:  SUB     080H            ; Code umrechnen in Lautst√§rkewert
        CPL                     ; gr√∂√üter Wert ist kleinste Lautst√§rke
        AND     00001111B       ; Lautst√§rkenbits maskieren
        LD      (IY+14),A       ; Lautst√§rkenwert merken
        JR      A432F           ; n√§chsten Wert in Ton - Tabelle auswerten
;
;
;   Tonl√§nge aus Wertetabelle auswerten
;
A434A:  SUB     060H            ; Code umrechnen in Tonl√§nge
        LD      B,0             ; High - Byte Offset auf Null
        LD      C,A             ; Tonl√§nge als Low - Byte Offset
        LD      HL,B4146        ; Zeiger auf Tabelle mit Tonl√§ngenverh√§ltnissen
        ADD     HL,BC           ; Zeiger auf richtigen Tabellenwert errechnen
        CP      9 + 1           ; Tonl√§nge oder Tempo  ?
        LD      A,(HL)          ; Tonl√§ngenverh√§ltnis aus Tabelle holen
        JR      NC,A435D        ; Tempo
        LD      (IY+8),A        ; Tonl√§ngenverh√§ltnis merken
        JR      A432F           ; n√§chsten Wert in Ton - Tabelle auswerten
;
A435D:  LD      (IY+9),A        ; Tempofaktor merken
        JR      A432F           ; n√§chsten Wert aus Ton - Tabelle auswerten
;
;
;   Frequenzwert der Notennummer aus Tabelle holen
;
A4362:  ADD     A,A             ; Notennummer mal zwei   (zwei Byte je Frequenz)
        LD      HL,B417B        ; Zeiger auf Tabelle mit Frequenzwerten vorgeben
        LD      B,0             ; High - Byte Offset auf Null
        LD      C,A             ; Notennummernwert als Low - Byte Offset
        ADD     HL,BC           ; Zeiger auf Frequenzwert der Note errechnen
        LD      B,(HL)          ; Low - Byte Frequenzwert aus Tabelle holen
        LD      A,(IX+0)        ; Low - Byte Frequenz der alten Note holen
        AND     11110000B       ; Register - Nummer des Tongenerators maskieren
        OR      B               ; plus Low - Byte neuer Frequenzwert
        LD      (IX+0),A        ; Frequenzwert f√ºr n√§chste Note merken
        INC     HL              ; Zeiger auf Frequenztabelle auf High - Byte
        LD      A,(HL)          ; High - Byte Frequenzwet aus Tabelle holen
        LD      (IX+1),A        ; und in Tabelle f√ºr Tongenerator eintragen
        RET
;
;
;   Ton nach Generator - Nummer und Frequenz oder Notennummer und L√§nge spielen
;   
;   (Software command code:  34)
;
A437A:  OR      A               ; Frequenz oder Notennummer  ?
        JP      P,A43C6         ; Notennummer und L√§nge angegeben
        AND     00001111B       ; Tongeneratornummer maskieren
        LD      C,PSGOUT        ; Port - Adresse des Ton - Generators vorgeben
        ADD     A,A             ;! Tongenerator - Nummer mal  2
        ADD     A,A             ;!                       mal  4
        ADD     A,A             ;!                       mal  8
        ADD     A,A             ;!                       mal 16
        OR      10000000B       ; plus Code for 'Steuerwort'
        LD      B,A             ; Tongeneratornummer merken
        BIT     4,A             ; Frequenzregister  ?
        JR      NZ,A43AB        ; nein -->  Lautst√§rke
        CP      11100000B       ; Rauschgenerator  ?
        JR      Z,A43A7         ; ja 
        LD      A,D             ; High - Byte Frequenz holen
        CP      3 + 1           ; mit maximalem High - Byte vergleichen
        JR      NC,A43B6        ; zu gro√ü -->  Fehler 3  Illegal data error
        LD      A,E             ; Low - Byte Frequenz holen
        AND     00001111B       ; niedere 4 Bit maskieren
        OR      B               ; plus Tongenerator - Nummer
        OUT     (C),A           ; erstes Byte f√ºr Frequenz an Tongenerator ausgeben
        LD      A,D             ; High - Byte Frequenzteiler holen
        LD      B,4             ; um vier Bit schieben
A439F:  RL      E               ;! h√∂here 6 Bit der Frequenz auf richtige Bits schieben
        RLA                     ;!
        DJNZ    A439F           ;!
        OUT     (C),A           ; h√∂here 6 Bit der Frequenz ausgeben
        RET
;
A43A7:  BIT     3,E             ; Wert gr√∂√üer  15  ?
        JR      NZ,A43B6        ; ja -->  Fehler 3  Illegal data error
A43AB:  LD      A,E             ;! Lautst√§rkenwert auf Gr√∂√üe √ºberpr√ºfen
        AND     11110000B       ;!
        OR      D               ;!
        JR      NZ,A43B6        ; zu gro√ü -->  Fehler 3  Illegal data error
        LD      A,E             ; Lautst√§rkenwert holen
        OR      B               ; plus Register - Nummer 
        OUT     (C),A           ; und an Tongenerator ausgeben
        RET
;
A43B6:  JP      A1F7F           ; Fehler 3  Illegal data error
;
;
;   Interrupt bei SOUND bearbeiten
;
A43B9:  LD      HL,(S4218)      ; Rest - Tonl√§nge holen
        DEC     HL              ; minus eins
        LD      (S4218),HL      ; und wieder merken
        LD      A,L             ;! Tonl√§nge gleich Null  ?
        OR      H               ;!
        RET     NZ              ; nein -->  fertig mit Interrupt
        JP      A447E           ; alle Tongeneratoren abschalten
;
;
;   Ton nach Notennummer und L√§nge spielen
;
A43C6:  LD      C,A             ; Notennummer merken
        LD      A,D             ;! L√§nge gleich Null  ?
        OR      E               ;!
        RET     Z               ; ja -->  fertig
        LD      A,C             ; Notennummer holen
        LD      IX,B4215        ; Zeiger auf Ausgabetabelle f√ºr Tongenerator
        CP      83 + 1          ; bekannte Notennummer  ?
        RET     NC              ; nein
        SUB     9               ; Pause  ?   (T√∂ne von 0 - 8)
        PUSH    AF              ; Rest  Ton - Nummer merken
        LD      A,10010000B     ; Code for 'maximale Lautst√§rke  Tongenerator 0'
        JR      NC,A43DB        ; keine Pause
        LD      A,10011111B     ; Code for 'Lautst√§rke AUS  Tongenerator 0'
A43DB:  LD      (IX+2),A        ; Lautst√§rkenwert in Ausgabetabelle eintragen
        CALL    A44A3           ; warten, bis alte Melodien vollst√§ndig gespielt sind
        POP     AF              ; Rest  Ton - Nummer holen
        CALL    NC,A4362        ; keine Pause -->  Frequenzwert der Notennummer bereitstellen
        DI                      ; Interrupt sperren
        LD      A,2             ; Code for 'SOUND'
        LD      (B40FA),A       ; als MUSIC - Status merken
        LD      (S4218),DE      ; Tonl√§nge eintragen
        LD      HL,B4215        ; Zeiger auf aufbereitete Ausgabetabelle f√ºr Tongenerator
        LD      BC,256*3+PSGOUT ; 3 Werte ausgeben  / Adresse  Tongenerator
        OTIR                    ; bereitgestellte Werte an Tongenerator ausgeben
        CALL    A44CC           ; Bausteine f√ºr 'MUSIC - Interrupt' initialisieren
        EI                      ; Interrupt wieder freigeben
        RET
;
;
;   Zeiger auf Speicherbereiche nach Tongenerator - Registernummer bereitstellen
;
A43FC:  PUSH    BC              ; Register - Wert retten
        PUSH    AF              ; Tongenerator - Nummer retten
        CP      3               ; Rauschgenerator  ?
        JR      C,A4403         ; nein
        DEC     A               ; f√ºr Tongenerator 2 corrigieren
A4403:  LD      HL,B40FD        ; Zeiger auf Anfang Ausgabetabelle f√ºr Generatoren
        LD      B,A             ; Z√§hler merken
        ADD     A,A             ;! mal zwei   (drei Byte je Ausgabetabelle)
        ADD     A,B             ;! mal drei
        LD      C,A             ; als Low - Byte Offset merken
        LD      B,0             ; High - Byte Offset auf Null
        ADD     HL,BC           ; Zeiger auf Ausgabetabelle des Tongenerators errechnen
        PUSH    HL              ;! und nach IX √ºbertragen
        POP     IX              ;!
        POP     AF              ; Tongenerator - Nummer holen
        ADD     A,A             ;! mal  2   (16 Byte je Tongeneratorstatustabelle)
        ADD     A,A             ;! mal  4
        ADD     A,A             ;! mal  8
        ADD     A,A             ;! mal 16
        LD      HL,B4106        ; Zeiger auf Anfang Tongenerator - Status - Tabelle
        LD      B,0             ; High - Byte Offset auf Null
        LD      C,A             ; Low - Byte Offset vorgeben
        ADD     HL,BC           ; Zeiger auf Datensatz des aktuellen Tongenerators errechnen
        PUSH    HL              ;! und nach IY √ºbertragen
        POP     IY              ;!
        INC     HL              ; Zeiger auf Tabelle auf Wiederholungsfaktor
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Wertetabelle (DE) f√ºr Tongenerator im Accu merken
;   (wenn Accu gleich -1 -->  f√ºr alle Tongeneratoren merken)
;
;   (Software command code:  33)
;
A4422:  CP      -1              ; Tabelle f√ºr alle Tongeneratoren  ?
        JR      NZ,A4435        ; nein -->  neue Wertetabelle merken
        LD      A,3             ; Vorgabe f√ºr Tongenerator - Nummer
A4428:  PUSH    AF              ; Tongenerator - Nummer merken
        PUSH    DE              ; Zeiger auf Wertetabelle f√ºr Tongenerator merken
        CALL    A4435           ; Tabellenwerte (DE) dem Tongenerator im Accu zuweisen
        POP     DE              ; Zeiger auf Wertetabelle holen
        POP     AF              ; Tongenerator - Nummer holen
        DEC     A               ; minus eins
        JP      M,A445A         ; alle Generatoren abgearbeitet -->  Interrupt initialisieren
        JR      A4428           ; Tabelle dem n√§chsten Tongenerator zuweisen
;
A4435:  PUSH    AF              ; Tongenerator - Nummer merken
        LD      HL,B4105        ; Zeiger auf Lautst√§rkenwert  Tongenerator 2
        CP      3               ; Rauschgenerator  ?
        JR      Z,A4441         ; ja 
        LD      A,11011111B     ; Code for 'Lautst√§rke Tongenerator 2 auf AUS'
        JR      A4447           ; merken
;
A4441:  LD      A,11100111B     ; Code for 'wei√ües Rauschen nach Tongenerator zwei'
        OUT     (PSGOUT),A      ; an Tongenerator ausgeben
        LD      A,11111111B     ; Code for 'Rauschlautst√§rke auf AUS'
A4447:  LD      (HL),A          ; Lautst√§rkenwert f√ºr n√§chsten Ton merken
        DI                      ; Interrupt sperren
        LD      A,1             ; Code for 'MUSIC'
        LD      (B40FA),A       ; als MUSIC - Status merken
        POP     AF              ; Tongenerator - Nummer holen
        CALL    A43FC           ; Zeiger auf Speicher nach Registernummer bereitstellen
        CALL    A4468           ; merken, da√ü Tongenerator aktiv ist
        CALL    A42C6           ; n√§chsten Wert in Tabelle (DE) abarbeiten
        EI                      ; Interrupt freigeben
        RET
;
;
;   wenn MUSIC aktiv -->  Interrupt - Bausteine f√ºr Ton - Interrupt aktivieren
;
A445A:  DI                      ; Interrupt sperren
        LD      A,(B40FA)       ; MUSIC - Status holen
        OR      A               ; Tonausgabe aktiv  ?
        CALL    NZ,A44CC        ; ja -->  Bausteine f√ºr 'MUSIC - Interrupt' initialisieren
        EI                      ; Interrupt wieder freigeben
        RET
;
;
;   merken, da√ü Tongenerator nicht mehr aktiv ist
;
A4464:  LD      B,RES_HL        ; Code for 'Res x,(HL)'
        JR      A446A           ; Tongeneratorstatus auf 'nicht aktiv' setzen
;
;
;   merken, da√ü Tongenerator aktiv ist
;
A4468:  LD      B,SET_HL        ; Code for 'Set x,(HL)'
A446A:  LD      HL,B40FB        ; Zeiger auf Bits der aktiven Tongeneratorregister 
        LD      A,(IY+0)        ; Tongenerator - Nummer holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        RLCA                    ;! Tongeneratornummer auf richtige Bits f√ºr
        RLCA                    ;! Wertigkeit in Z-80 - Befehl schieben
        RLCA                    ;!
        OR      B               ; plus Code for 'Set/Res'
        LD      (D4478 + 1),A   ; Rest  Z-80 - Befehl eintragen
D4478:  RLC     B               ; Befehl ausf√ºhren  (Set x,(HL) / Res x,(HL))
        RET
;
;
;   alle Tonausgaben abbrechen     (MUSIC STOP)
;
A447B:  CALL    A00C7           ; Register IX, HL, BC und DE retten
A447E:  XOR     A               ; Accu auf Null
        LD      (B40FA),A       ; als MUSIC - Status merken
        LD      (B40FB),A       ; Bits der aktiven Tongeneratorregister zur√ºcksetzen
        LD      BC,256*4+PSGOUT ; vier Werte in Tabelle / Adresse  Tongenerator - Baustein
        LD      HL,B4211        ; Tabelle mit Werten zum Abschalten aller Tongeneratoren
        OTIR                    ; Werte an Tongeneratoren ausgeben
        LD      B,3             ; drei Tongenerator - Ausgabe - Tabellen
        LD      HL,B40FF        ; Zeiger auf Lautst√§rkenwert f√ºr Tongenerator 1
A4492:  LD      A,(HL)          ; Lautst√§rkenwert aus Ausgabe - Tabelle holen
        AND     11110000B       ; Registernummer des Tongenerators maskieren
        OR      00001111B       ; plus Code for 'Lautst√§rke auf AUS'
        LD      (HL),A          ; neues Wert wieder in Ausgabetabelle eintragen
        INC     HL              ;! Zeiger auf Lautst√§rkenwert des
        INC     HL              ;! n√§chsten Tongenerators
        INC     HL              ;!
        DJNZ    A4492           ; restliche Ausgabe - Tabellenwerte corrigieren
        LD      A,00000011B     ; Code for 'Interrupt nicht m√∂glich'
        OUT     (PIOA_C),A      ; an Kontrollwortregister Z-80 PIO Kanal A ausgeben
        XOR     A               ; Carry - Flag zur√ºcksetzen   (Code 'kein Fehler')
        RET
;
;
;   warten, bis alte Melodien vollst√§ndig gespielt sind
;
A44A3:  LD      A,(B40FA)       ; MUSIC - Status holen
        OR      A               ; inaktiv  ?
        RET     Z               ; ja -->  fertig
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    14              ; Code 14  Abfrage, ob (Shift) - BREAK gedr√ºckt ist
        JR      NZ,A44A3        ; nicht gedr√ºckt -->  weiter warten
        JP      A00E8           ; Programm mit 'BREAK`abbrechen
;
;
;   Musik nach Status in B behandeln     (B = 1 -->  Wertetabelle(n) (DE) spielen
;       (B = 2 -->  Tonausgabe abbrechen)
;       (B = 3 -->  warten, bis alle Melodien gespielt)
;       (B = 4 -->  MUSIC - Routinen initialisieren)
;
;   (Software command code:  35)
;
A44AF:  DEC     B               ; MUSIC nach Tabelle (DE) spielen  ?
        JP      Z,A445A         ; ja -->  Tabelle (DE) abarbeiten
        DEC     B               ; MUSIC STOP  ?
        JR      Z,A447B         ; ja -->  alle Tonausgaben abbrechen
        DEC     B               ; MUSIC WAIT  ?
        JR      Z,A44A3         ; ja -->  warten, bis alte Melodien vollst√§ndig gespielt sind
;
;
;   MUSIC - Routinen initialisieren
;
A44B9:  CALL    A447B           ; alle Tonausgaben abbrechen
        LD      BC,256*5+PIOA_C ; 5 Werte / Kontrollwortregister Z-80 PIO Kanal A
        LD      HL,B44DC        ; Zeiger auf Wertetabelle zur Initialisierung der Z-80 PIO
        OTIR                    ; Wertetabelle an Z-80 PIO ausgeben
        LD      DE,B44ED        ; Zeiger auf Tabelle zur Initialisierung der Tonroutinen
        LD      A,-1            ; Code for 'alle Tongeneratoren'
        JP      A4422           ; Tabelle (DE) den Tongeneratoren zuweisen
;
;
;   Bausteine f√ºr 'MUSIC - Interrupt' initialisieren
;
A44CC:  LD      HL,B44DC        ; Zeiger auf Wertetabelle zur Initialisierung der Z-80 PIO
        LD      BC,256*5+PIOA_C ; 5 Werte / Kontrollwortregister Z-80 PIO Kanal A
        OTIR                    ; Wertetabelle an Z-80 PIO ausgeben
        LD      HL,B44E1        ; Zeiger auf Tabelle zur Initialisierung
        LD      B,6             ; sechs Werte ausgeben
        JP      A0104           ; Wertetabelle (HL) an Ports ausgeben
;
;
;   Werte zur Initialisierung Steuerwortregister Z - 80 - PIO   Kanal A
;
B44DC:  DEFB    (A0FFC)%256       ; Low - Byte Interrupt - Vector
        DEFB    11111111B       ; Mode 3
        DEFB    00111111B       ; Bit 0 - 5 = INPUT / Bit 6 - 7 = OUTPUT
        DEFB    00010111B       ; Interrupt Controll - Wort  (Maske folgt)
        DEFB    11101111B       ; 8253  Interrupt maskieren
;
;
;   Wertetabelle zur Initialisierung der Steuerbausteine f√ºr MUSIC - Interrupt
;
B44E1:  DEFB    00110000B       ; Z√§hler 0/Read'Load 2 Byte/Mode 0/Binary
        DEFB    CTC_53          ; Port - Adresse   Steuerport Z√§hlerbaustein 8253
;
        DEFB    10110000B       ; Low - Byte Teilungsverh√§ltnis f√ºr Interrupt alle 10 ms
        DEFB    CT0_53          ; Port - Adresse   Z√§hler 0  im Z√§hlerbaustein 8253
;
        DEFB    00101010B       ; High - Byte Teilungsverh√§ltnis f√ºr Interrupt alle 10ms
        DEFB    CT0_53          ; Port - Adresse   Z√§hler 0  im Z√§hlerbaustein 8253
;
        DEFB    00000100B       ; Code for 'Z√§hler - Interrupt erlaubt'
        DEFB    KEYP_F          ; Port - Adresse  Steuerbaustein  Ein- Ausgabebaustein 8255
;
        DEFB    00000000B       ; Code for 'Ton - Ausgabe 8253 sperren'
        DEFB    KEYP_F          ; Port - Adresse  Steuerbaustein  Ein- Ausgabebaustein 8255
;
        DEFB    10000011B       ; Code for 'Interrupt m√∂glich'
        DEFB    PIOA_C          ; Port - Adresse  Kontrollwortregister Z-80 PIO Kanal A
;
;
;   Tabelle zur Initialisierung der Tongenerator - Routinen
;
B44ED:  DEFB    065H            ; Code for 'Tonl√§nge 5'
        DEFB    06DH            ; Code for 'Tempo 4'
        DEFB    098H            ; Code for 'Wellenform 8'
        DEFB    0A0H            ; Code for 'Wiederholungsfaktor'
        DEFB    255             ;       'Wiederholungsfaktor'
        DEFB    -1              ; 'End of table'
;
;
;   Referenzton ausgeben     (Software command code:  32)
;
A44F3:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    16              ; Kommando 16   Interrupt sperren
        LD      HL,B4514        ; Zeiger auf Tabelle zur Initialisierung Referenzton
        LD      B,4             ; vier Werte in Tabelle
        CALL    A0104           ; Wertetabelle (HL) an Ports ausgeben
        LD      BC,24           ;! Zeitschleife  ca.  55 msec
A4503:  EX      (SP),HL         ;!        19 Taktzyklen
        DJNZ    A4503           ;!        13    "
        DEC     C               ;!         4    "
        JR      NZ,A4503        ;!        12    "
        LD      HL,B451C        ; Zeiger auf Tabelle zum Abschalten Referenzton
        LD      B,2             ; zwei Werte in Tabelle
        CALL    A0104           ; Wertetabelle (HL) an Ports ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    17              ; Code 17   Interrupt freigeben
        RET
;
;
;   Tabelle zur Initialisierung Referenzton nach MZ-80 K - Modus
;
B4514:  DEFB    00110110B       ; Z√§hler 0/Read'Load 2 Byte/Mode 3/Binary
        DEFB    CTC_53          ; Port - Adresse   Steuerport Z√§hlerbaustein 8253
;
        DEFB    00000001B       ; Code for 'Ton - Ausgabe 8253 erlaubt'
        DEFB    KEYP_F          ; Port - Adresse   Steuerport Ein- Ausgabebaustein 8255
;
        DEFB    11111001B       ; Low - Byte  Teilungsverh√§ltnis f√ºr Ton
        DEFB    CT0_53          ; Port - Adresse   Z√§hler 0  im Z√§hlerbaustein 8253
;
        DEFB    00000011B       ; High - Byte Teilungsverh√§ltnis f√ºr Ton
        DEFB    CT0_53          ; Port - Adresse   Z√§hler 0  im Z√§hlerbaustein 8253
;
;
;    Tabelle zum Abschalten des Referenztons
;
B451C:  DEFB    00110110B       ; Z√§hler 0/Read'Load 2 Byte/Mode 3/Binary
        DEFB    CTC_53          ; Port - Adresse   Steuerport Z√§hlerbaustein 8253
;
        DEFB    00000000B       ; Code for 'Ton - Ausgabe 8253 sperren'
        DEFB    KEYP_F          ; Port - Adresse   Steuerport Ein- Ausgabebaustein 8255
;
;
;   Set tempo according to value in Accu
;
A4520:  CALL    A00BA           ; Save registers IX, HL, BC, DE and AF
        LD      DE,T4538        ; Pointer to space for tempo code
        AND     00001111B       ; Mask tempo value
        ADD     A,069H          ; convert to tempo code
        LD      (DE),A          ; Enter speed code
        LD      B,3             ; Code 'wait for old tune to end'
        RST     _DOCMD          ; Software - Execute command
        DEFB    35              ; Code 35 Treat MUSIC by status in B
        LD      A,-1            ; Code 'Values for all tone generators'
        RST     _DOCMD          ; Software - Execute command
        DEFB    33              ; Assign code 33 value table (DE) to the tone generators
        LD      B,1             ; code 'play melody'
        RST     _DOCMD          ; Software - Execute command
        DEFB    35              ; Code 35 Treat MUSIC by status in B
        RET                       
;
T4538:  DEFS    1               ; Space for speed code
        DEFB    -1              ; end of table
 
;   Initialize device screen ("CRT:")
;
A453A:  CALL    A0164           ; Comparison on byte after CALL call
        DEFM    "M"             ; M (MODE) ?
        JR      Z,A4561         ; yes --> Set screen mode
        OR      A               ; end of table ?
        JR      Z,A458E         ; yes --> no values specified --> initialize with old values
        CP      'B'             ; B (BLOCK) ?
        JP      NZ,A1F7F        ; no --> Error 3 Illegal data error
        XOR     A               ; Accu to zero
        LD      (S137E),A       ; Reset palette block number
        LD      A,(S137A)       ; Screen - Mode - Get number
        CP      2               ; Mode 2 (320 x 200 dots / 16 colors) ?
        JP      NZ,A1FBB        ; no --> Error 68 Dev. mode error
        INC     HL              ; Skip command letters
        LD      B,3 + 1         ; Specify maximum pallet block number
        CALL    A010D           ; Convert ASCII value (HL) to hex/compare with upper limit in B
        LD      (S137E),A       ; Remember palette block number
        RST     _DOCMD          ; Software - Execute command
        DEFB    81              ; Code 81 Remember pallet block number/output to controller
        JR      A4581           ; examine whether additional values are specified
;
;
;   neuen Bildschirm - Modus bestimmen
;
A4561:  LD      B,4 + 1         ; maximale Bildschirm - Modus - Nummer vorgeben
        CALL    A010D           ; ASCII-Wert (HL) umsetzen in Hex/mit Obergrenze in B vergleichen
        OR      A               ; gleich Null  ?
        JR      Z,A458B         ; ja -->  Fehler 3  Illegal data error
        LD      B,A             ; Modus - Nummer merken
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    80              ; Code 80   Bildschirm - Betriebsart setzen
        JP      C,A1FBB         ; Fehler aufgetreten -->  Fehler 68   Dev. mode error
        LD      A,B             ; Modus - Nummer holen
        LD      (S137A),A       ; Bildschirm - Modus - Nummer merken
        XOR     A               ; Accu auf Null
        LD      (S108F),A       ; Parallelausgabeflag Drucker zur√ºcksetzen
        SCF                     ;! Bit nach Bildschirm - Modus - Nummer
A4578:  ADC     A,A             ;! setzen
        DJNZ    A4578           ;!
        LD      (S1379),A       ; Bildschirm - Modus - Bit merken
        CALL    A4593           ; maximalen Palettenwert/aktuelle Farbebenen merken
A4581:  CALL    A0164           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFB    NUL             ; Textendezeichen  ?
        RET     Z               ; ja -->  fertig
        CP      ','             ; Komma als Trennzeichen  ?
        INC     HL              ; Trennzeichen √ºberspringen
        JR      Z,A453A         ; weitere Parameter bein Initialisierung auswerten
A458B:  JP      A1F7F           ; Fehler 3  Illegal data error
;
;
;   Bildschirm initialisieren     (Software command code:  86)
;
A458E:  LD      A,(S137A)       ; Bildschirm - Modus - Nummer holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    80              ; Code 80   Bildschirm - Betriebsart setzen
;
;
;   maximalen Palettenwert und aktuelle Farbebenen merken
;
A4593:  CALL    A459D           ; maximalen Palettenwert/aktuelle Farbebenen setzen
        XOR     A               ; Accu auf Null
        LD      (S137E),A       ; Palettenblocknummer zur√ºcksetzen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    81              ; Code 81   Palettenblock-Nummer merken/an Controller ausgeben
        RET
;
;
;   maximalen Palettenwert bereitstellen und aktuelle benutze Farbebenen setzen
;
A459D:  LD      A,(S1379)       ; Bildschirm - Modus - Bit holen
        LD      B,3             ; Palettenwert 0 - 3 erlaubt
        RRA                     ; ein Bit nach Carry schieben
        JR      C,A45B1         ; Modus eins -->  maximalen Palettenwert merken
        LD      B,15            ; Palettenwert 0 - 15 erlaubt
        RRA                     ; ein Bit nach Carry schieben
        JR      C,A45B1         ; Modus zwei -->  maximalen Palettenwert merken
        LD      B,1             ; Palettenwert 0 und 1 erlaubt
        RRA                     ; ein Bit nach Carry schieben
        JR      C,A45B1         ; Modus drei -->  maximalen Palettenwert merken
        LD      B,3             ; Palettenwert 0 - 3 erlaubt
A45B1:  LD      A,B             ; maximalen Palettenwert holen
        LD      (S137B),A       ; und merken
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    84              ; Code 84  aktuell benutze Farbebenen merken
        RET
;
;
;   Tabelle zum Setzen der rechten Punkte im Graphic - Byte nach Bit - Nummer
;
B45B8:  DEFB    11111111B       ; Pattern for  Bit  0
        DEFB    11111110B       ; Pattern for  Bit  1
        DEFB    11111100B       ; Pattern for  Bit  2
        DEFB    11111000B       ; Pattern for  Bit  3
        DEFB    11110000B       ; Pattern for  Bit  4
        DEFB    11100000B       ; Pattern for  Bit  5
        DEFB    11000000B       ; Pattern for  Bit  6
        DEFB    10000000B       ; Pattern for  Bit  7
;
;
;   Tabelle zum Setzen der linken Punkte im Graphic - Byte nach Bit - Nummer
;
B45C0:  DEFB    00000001B       ; Pattern for  Bit  0
        DEFB    00000011B       ; Pattern for  Bit  1
        DEFB    00000111B       ; Pattern for  Bit  2
        DEFB    00001111B       ; Pattern for  Bit  3
        DEFB    00011111B       ; Pattern for  Bit  4
        DEFB    00111111B       ; Pattern for  Bit  5
        DEFB    01111111B       ; Pattern for  Bit  6
        DEFB    11111111B       ; Pattern for  Bit  7
;
;
;   Tabelle mit Vorgabe f√ºr Bit nach Bit - Nummer
;
B45C8:  DEFB    00000001B       ; Pattern for  Bit  0
        DEFB    00000010B       ; Pattern for  Bit  1
        DEFB    00000100B       ; Pattern for  Bit  2
        DEFB    00001000B       ; Pattern for  Bit  3
        DEFB    00010000B       ; Pattern for  Bit  4
        DEFB    00100000B       ; Pattern for  Bit  5
        DEFB    01000000B       ; Pattern for  Bit  6
        DEFB    10000000B       ; Pattern for  Bit  7
;
;
;   Graphic - Routinen auf 320 x 200 oder 640 x 200 Bildpunkte umstellen
;
A45D0:  LD      BC,256 * 7 + 3  ; 7 zwei - Byte - Werte  /  3 ein - Byte - Werte
        LD      HL,W45D9        ; Zeiger auf Tabelle mit zu √§ndernden Werten
        JP      A0531           ; Programm entsprechend Tabelle (HL) umstellen
;
;
;   Tabelle zum Umsetllen der Graphic - Routine auf Bildschirm - 
;   Ausgabe mit 320 x 200 oder 640 x 200  Bildpunkten
;
W45D9:  DEFW    A4EC7 + 1       ; Adresse
        DEFW    SCREEN + 16000  ; Wert f√ºr 80 Zeichen je Zeile
        DEFW    SCREEN +  8000  ; Wert f√ºr 40 Zeichen je Zeile
;
        DEFW    A46C4 + 1       ; Adresse                     
        DEFW    -640            ; Wert f√ºr 80 Zeichen je Zeile
        DEFW    -320            ; Wert f√ºr 40 Zeichen je Zeile
;
        DEFW    A542F + 1       ; Adresse                     
        DEFW    640             ; Wert f√ºr 80 Zeichen je Zeile
        DEFW    320             ; Wert f√ºr 40 Zeichen je Zeile
;
        DEFW    A4CC0 + 1       ; Adresse                     
        DEFW    80              ; Wert f√ºr 80 Zeichen je Zeile
        DEFW    40              ; Wert f√ºr 40 Zeichen je Zeile
;
        DEFW    A4CD3 + 1       ; Adresse                     
        DEFW    80              ; Wert f√ºr 80 Zeichen je Zeile
        DEFW    40              ; Wert f√ºr 40 Zeichen je Zeile
;
        DEFW    A4CFB + 1       ; Adresse                     
        DEFW    -640            ; Wert f√ºr 80 Zeichen je Zeile
        DEFW    -320            ; Wert f√ºr 40 Zeichen je Zeile
;
        DEFW    A4D02 + 1       ; Adresse                     
        DEFW    640 - 1         ; Wert f√ºr 80 Zeichen je Zeile
        DEFW    320 - 1         ; Wert f√ºr 40 Zeichen je Zeile
;
        DEFW    A460F           ; Adresse                     
        DEFB    ADD_HL          ; Wert f√ºr 80 Zeichen je Zeile
        DEFB    _NOP            ; Wert f√ºr 40 Zeichen je Zeile
;
        DEFW    A4E22 + 1       ; Adresse                     
        DEFB    80              ; Wert f√ºr 80 Zeichen je Zeile
        DEFB    40              ; Wert f√ºr 40 Zeichen je Zeile
;
        DEFW    A4EBD + 1       ; Adresse                     
        DEFB    80              ; Wert f√ºr 80 Zeichen je Zeile
        DEFB    40              ; Wert f√ºr 40 Zeichen je Zeile
;
;
;   absolute Graphic - Speicheradresse und Bitnummer des Bildpunktes aus
;   X- und Y - Koordinaten in DE,HL errechnen
;
A460F:  ADD     HL,HL           ; Y-Koordinate mal 2, wenn im 640 x 200 Modus (oder NOP)
        LD      A,E             ; Low - Byte  X - Koordinate
        AND     00000111B       ; Bits f√ºr Bitnummer  (0 - 7)  maskieren
        LD      B,A             ; Bitnummer merken
        LD      A,E             ; Low - Byte  X - Koordinate holen
        AND     11111000B       ; f√ºr Adresse relevante Bits maskieren
        ADD     A,D             ; plus High - Byte  X - Koordinate
        RRCA                    ;! Bits auf richtige Wertigkeit f√ºr Graphic - 
        RRCA                    ;! Byte schieben   (X - Koordinate durch 8)
        RRCA                    ;!
        LD      C,A             ; Offset aus X - Koordinate merken
        LD      A,B             ; Bitnummer holen
        LD      B,SCREEN/256    ; High - Byte Anfangsadresse Graphic - Speicher vorgeben
        LD      D,H             ;! Y - Koordinate duplizieren
        LD      E,L             ;!
        ADD     HL,HL           ; mal  2
        ADD     HL,HL           ; mal  4
        ADD     HL,DE           ; mal  5
        ADD     HL,HL           ; mal 10
        ADD     HL,HL           ; mal 20
        ADD     HL,HL           ; mal 40
        ADD     HL,BC           ; plus Anfangsadresse und X - Offset
        RET
;
;
;   Abfrage, ob Punkt in einer der Farbebenen gesetzt ist
;   (Koordinaten des Punktes in DE,HL)
;
;   (Software command code:  78)
;
A4629:  CALL    A46B2           ; √ºberpr√ºfen, ob Koordinaten in DE,HL im angezeigten Bereich
        JP      C,A479B         ; nein -->  Code 'Fehler aufgetreten' vorgeben und Abbruch
        CALL    A460F           ; absolute Graphic-Adresse und Bitnr. aus Koordinaten errechnen
        RLCA                    ;! Bit - Nummer auf richtige Wertigkeit
        RLCA                    ;! f√ºr Bit - Nummer schieben
        RLCA                    ;!
        OR      046H            ; plus Code for 'Bit x,(HL)'
        LD      (D464B + 1),A   ; Rest  Z-80 - Befehl in Routine eintragen
        LD      C,CRTCRF        ; Port-Nummer des 'Read-Format-Registers' des Bildschirm-Controllers
        LD      A,(S109D)       ; maximalen Palettenwert holen
        LD      B,A             ; als Z√§hler f√ºr zu testende Ebenen merken
        DI                      ; Interrupt sperren
        IN      A,(_CGVIN)      ; ZeichensatzROM und Video-RAM einschalten
        XOR     A               ; Vorgabe f√ºr Ergebniswert
A4644:  RR      B               ; Palettenwert durch zwei
        JR      C,A4653         ; Carry-Flag gesetzt -->  alle Farb-Ebenen getestet
        OUT     (C),B           ; Farbebene an Bildschirm - Controller ausgeben
        OR      A               ; Carry - Flag zur√ºcksetzen   (Code for 'kein Fehler')
D464B:  BIT     0,(HL)          ; Abfrage, ob Punkt in Farbebene gesetzt ist
        JR      Z,A4650         ; Punkt ist nicht gesetzt
        SCF                     ; Code for 'Punkt ist gesetzt'
A4650:  RLA                     ; Ergebnis einer Farbebene merken
        JR      A4644           ; weitere Farbebenen testen
;
A4653:  LD      B,A             ; Ergebnis merken
        IN      A,(_CGVOT)      ; ZeichensatzROM und Video-RAM ausschalten
        EI                      ; Interrupt wieder freigeben
        LD      A,(S109C)       ; Vorgabe f√ºr benutzte Farbebenen holen
        AND     B               ; gesetzte Punkte in aktuellen Farbebenen maskieren
        LD      B,A             ; Punktwert merken
        LD      A,(S1098)       ; Wert f√ºr 'Display-Mode-Register' des Bildschirm-Controllers
        CP      00000110B       ; 640 x 200 Bildpunkte / einfarbig  ?
        LD      A,B             ; Punktwert holen
        RET     NZ              ; anderer Modus
        CP      4               ; Punkte in Bildschirm zwei gesetzt  ?
        RET     C               ; nein -->  Wert ist OK
        SUB     2               ; f√ºr Punkte in Bildschirm eins corrigieren
        RET
;
;
;   Write - Format - Register f√ºr  'Punkt setzen'  initialisieren
;
A4669:  LD      A,-1            ; Code for 'Punkt setzen'
;
;
;   Write - Format - Register nach Status im Accu setzen
;
A466B:  PUSH    BC              ; Register - Wert retten
        OR      A               ; Punkt setzen oder zur√ºcksetzen  ?
        LD      A,(S109F)       ; aktuellen Graphic - Palettenwert holen
        LD      C,A             ; aktuellen Graphic - Plettenwert merken
        LD      A,(S109A)       ; aktuellen √úberschreib - Modus holen
        JR      Z,A4682         ; Punkt zur√ºcksetzen
        OR      A               ; √úberschreiben oder Farben verkn√ºpfen  ?
        LD      A,11000000B     ; Code for 'PSET'   (Punkt in Farbe setzen)
        JR      Z,A467D         ; √úberschreiben
        LD      A,01000000B     ; Code for 'OR'     (neuen Farbwert mit altem Farbwert verkn√ºpfen)
A467D:  OR      C               ; Kommandowert plus Farbwert
        OUT     (CRTCWF),A      ; an 'Write-Format-Register' Bildschirm-Controller ausgeben
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Write - Format - Register f√ºr 'Punkt zur√ºcksetzen' setzen
;
A4682:  OR      A               ; √úberschreiben oder Farben verkn√ºpfen  ?
        LD      A,01100000B     ; Code for 'RESET'   (Punkt zur√ºcksetzen)
        JR      NZ,A467D        ; √úberschreibmodus  'Oder'
        LD      A,(S109C)       ; Vorgabe f√ºr benutzte Farbebenen holen
        LD      B,A             ; Farbebenen merken
        LD      A,C             ; aktuellen Graphic - Farbwert holen
        CPL                     ; Bits umkehren
        AND     B               ; benutzte Graphic - Farbebenen maskieren
        OR      11000000B       ; Code for 'PSET'   (Punkt in Farbe setzen)
        OUT     (CRTCWF),A      ; an 'Write-Format-Register' Bildschirm-Controller ausgeben
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Punkt mit Koordinaten in DE,HL setzen oder zur√ºcksetzen
;
;   (Software command code:  72)
;
A4694:  CALL    A466B           ; Write - Format - Register nach Status im Accu setzen
A4697:  CALL    A46B2           ; √ºberpr√ºfen, ob Koordinaten in DE,HL im angezeigten Bereich
        JP      C,A479B         ; nein -->  Code 'Fehler aufgetreten' vorgeben und Abbruch
        CALL    A460F           ; absolute Graphic-Adresse und Bitnr. aus Koordinaten errechnen
        EX      DE,HL           ; Graphic - Speicher - Adresse nach DE
        LD      HL,B45C8        ; Zeiger auf Tabelle mit Vorgabe f√ºr Bit nach Bit-Nummer
        LD      B,0             ; High - Byte Offset auf Null
        LD      C,A             ; Bit - Nummer als Low - Byte Offset
        ADD     HL,BC           ; Zeiger auf Bitmuster errechnen
        DI                      ; Interrupt sperren
        IN      A,(_CGVIN)      ; ZeichensatzROM und Video-RAM einschalten
        LDI                     ; Bit pattern for  Punkt an Bildschirm - Controller ausgeben
        IN      A,(_CGVOT)      ; ZeichensatzROM und Video-RAM ausschalten
        EI                      ; Interrupt wieder freigeben
        XOR     A               ; Carry - Flag zur√ºcksetzen   (Code for 'kein Fehler')
        RET
;
;
;   √ºberpr√ºfen, ob Koordinaten in DE,HL im angezeigten Graphic - Bereich liegen
;   (Carry - Flag ist gesetzt, wenn die Koordinaten nicht im angezeigten Bereich)
;
A46B2:  PUSH    BC              ; Register - Wert retten
        PUSH    DE              ; X - Koordinate des Punktes
        PUSH    HL              ; Y - Koordinate des Punktes
        LD      A,H             ; High - Byte Y - Koordinate holen
        RLCA                    ; Koordinate negativ  ?
        JR      C,A46C8         ; ja -->  liegt nicht im angezeigten Bereich
        LD      BC,-200         ; maximale Y - Koordinate vorgeben  (Komplement)
        ADD     HL,BC           ; Y - Koordinate im angezeigten Bereich  ?
        JR      C,A46C8         ; nein
        LD      A,D             ; High - Byte X - Koordinate holen
        RLCA                    ; Koordinate negativ  ?
        JR      C,A46C8         ; ja -->  liegt nicht im angezeigten Bereich
        EX      DE,HL           ; X - Koordinate nach HL
A46C4:  LD      BC,-640         ; maximale X - Koodinate vorgeben  (-320/-640)
        ADD     HL,BC           ; X - Koordinate im angezeigten Bereich  ?
A46C8:  POP     HL              ;! gerettete Register - Werte wieder holen
        POP     DE              ;!
        POP     BC              ;!
        RET
;
;
;   Linie von Koordinate in DE`,HL' nach Koordinate in DE,HL ziehen
;
A46CC:  LD      A,-1            ; Code for 'Linie ziehen'
;
;
;   Linie ziehen oder zur√ºcksetzen
;   (DE' = X - Koordinate Anfang / HL' = Y - Koordinate Anfang)
;   (DE  = X - Koordinate Ende   / HL  = Y - Koordinate Ende  )
;
;     (Software command code:  73)
;
A46CE:  CALL    A466B           ; Write - Format - Register nach Status im Accu setzen
        PUSH    DE              ; X - Koordinate Endpunkt
        PUSH    HL              ; Y - Koordinate Endpunkt
        EXX
        LD      (S11A4),DE      ; X - Koordinate Anfangspunkt
        LD      (S11A9),HL      ; Y - Koordinate Anfangspunkt
        EXX
        PUSH    HL              ; Y - Koordinate Endpunkt
        PUSH    DE              ; X - Koordinate Endpunkt
        EX      DE,HL           ; Y - Koordiante Endpunkt nach DE
        LD      HL,(S11A9)      ; Y - Koordinate Anfangspunkt holen
        CALL    A478B           ; Koordinaten in DE und HL vergleichen
        LD      (S11AD),A       ; Flag  Y - Koordinate Endpunkt kleiner  (<>0)
        LD      (S11AB),HL      ; Y - Koordinaten - Differenz merken
        POP     DE              ; X - Koordinate Endpunkt holen
        JP      NC,A4778        ; Y - Koordinaten sind gleich
        PUSH    HL              ; Y - Koordinatendifferenz merken
        LD      HL,(S11A4)      ; Y - Koordinate Anfangspunt holen
        CALL    A478B           ; Koordinaten in DE und HL vergleichen
        LD      (S11A8),A       ; Flag  X - Koordinate Endpunkt kleiner  (<>0)
        LD      (S11A6),HL      ; X - Koordinatendifferent merken
        POP     BC              ; Y - Koordinatendifferenz holen
        POP     DE              ; Y - Koordinate Endpunkt holen
        JP      NC,A4784        ; X - Koordinaten sind gleich
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; untersuchen, welche Koordinate gr√∂√üer ist
        JR      NC,A4719        ; X-Koordinatendifferenz gr√∂√üer --> X-Koordinate als Z√§hler
        LD      HL,S11A4        ; Zeiger auf  X - Koordinaten - Datensatz
        LD      DE,S11A9        ; Zeiger auf  Y - Koordinaten - Datensatz
        LD      B,5             ; Anzahl Bytes je Datensatz
A470E:  LD      A,(DE)          ;! X -  und Y - Koordinatensatensatz vertauschen
        LD      C,(HL)          ;!
        LD      (HL),A          ;!
        LD      A,C             ;!
        LD      (DE),A          ;!
        INC     HL              ;!
        INC     DE              ;!
        DJNZ    A470E           ;!     weitere Dsatenbytes vertauschen
        LD      A,EX_DE         ; Z-80 Befehl EX DE,HL  um Koordinaten zu vertauschen
A4719:  LD      (A4753),A       ;! EX DE,HL oder NOP in Routine eintragen
        LD      (D475D),A       ;
        LD      A,(S11AD)       ; Flag  'Endpunkt zweite Koordinate kleiner'  holen
        AND     A               ; Endpunkt kleiner  ?
        LD      A,INC_HL        ; INC HL   (Z-80 - Befehl)
        JR      Z,A4729         ; Endpunkt gr√∂√üer -->  hochz√§hlen
        LD      A,DEC_HL        ; DEC HL   (Z-80 - Befehl)
A4729:  LD      (D476F),A       ; Wert f√ºr zweite Koordinate eintragen
        LD      A,(S11A8)       ; Flag  'Endpunkt erste Koordinate kleiner'  holen
        AND     A               ; Endpunkt kleiner
        LD      A,INC_DE        ; INC DE   (Z-80 - Befehl)
        JR      Z,A4736         ; Endpunkt gr√∂√üer -->  hochz√§hlen
        LD      A,DEC_DE        ; DEC DE   (Z-80 - Befehl)
A4736:  LD      (D4763),A       ; Wert f√ºr erste Koordinate in Routine eintragen
        EXX
        LD      HL,(S11A6)      ; erste Koordinaten - Differenz holen
        LD      D,H             ;! nach DE duplizieren
        LD      E,L             ;!
        SRL     H               ;! durch zwei als Vorgabe f√ºr Z√§hler
        RR      L               ;! f√ºr zweite Koordinate
        LD      BC,(S11AB)      ; zweite Koordinatendifferenz holen
        EXX
        LD      HL,(S11A9)      ; zweite Koordinate Anfangspunkt holen
        LD      DE,(S11A4)      ; erste Koordinate Anfangspunkt holen
        LD      BC,(S11A6)      ; erste Koordinatendifferenz holen
A4753:  EX      DE,HL           ; oder NOP, wenn X - Koordinate der Z√§hler ist
        PUSH    HL              ; aktuelle Y - Koordinate retten
        PUSH    DE              ; aktuelle X - Koordinate retten
        PUSH    BC              ; erste Koordinatendifferenz merken
        CALL    A4697           ; Punkt nach Koordinaten setzen oder zur√ºcksetzen
        POP     BC              ; erste Koordinatendifferenz holen
        POP     DE              ; gerettete X - Koordinate holen
        POP     HL              ; gerettete Y - Koordinate holen
D475D:  EX      DE,HL           ; oder NOP, wenn X - Koordinate der Z√§hler ist
        DEC     BC              ; Z√§hler minus eins
        LD      A,B             ;! fertig  ?
        INC     A               ;!
        JR      Z,A4773         ; ja -->  gerettete Koordinate des Endpunktes holen
D4763:  NOP                     ; erste Koordinate f√ºr n√§chsten Punkt √§ndern (INC/DEC DE)
        EXX
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; testen, ob Koordinate ge√§ndert werden mu√ü
        EXX
        JP      NC,A4753        ; nein -->  n√§chsten Punkt zeichnen
        EXX
        ADD     HL,DE           ; Offsetz√§hler plus Koordinatendiffernz
        EXX
D476F:  NOP                     ; zweite Koordinate f√ºr n√§chsten Punkt √§ndern  (INC/DEC HL)
        JP      A4753           ; n√§chsten Punkt zeichnen
;
A4773:  EXX
        POP     HL              ; Y-Koordinate des Endpunktes als aktuelle Graphic-Koordinate
        POP     DE              ; X-Koordinate des Endpunktes als aktuelle Graphic-Koordinate
        EXX
        RET
;
;
;   Y - Koordinaten sind gleich
;
A4778:  POP     HL              ; Y - Koordinate Anfangspunkt holen
A4779:  CALL    A4C16           ; X mit Y-Koord. in DE,HL , DE',HL' tauschen/Y-Max nach HL
        CALL    A4C16           ; X mit Y-Koord. in DE,HL , DE',HL' tauschen/Y-Max nach HL
        CALL    A4C47           ; Linie parallel zu einer Koordinatenachse zeichnen
        JR      A4773           ; gerettete Endpunktkoordinaten holen
;
;
;   X - Koordinaten sind gleich
;
A4784:  EX      DE,HL           ; Y - Koordinate Anfangspunkt nach HL
        LD      DE,(S11A4)      ; X - Koordinate Endpunkt holen
        JR      A4779           ; Linie parallel zur Y - Achse zeichnen
;
;
;   Koordinaten in DE und HL vergleichen   (DE = Anfangspunkt / HL = Endpunkt)
;   (Zero -->  Koordinaten gleich / Accu = 0 und Carry -->  Anfangspunkt gr√∂√üer)
;
A478B:  LD      A,H             ; High - Byte der Koordinate holen
        ADD     A,040H          ; auf jeden Fall umrechnen in positive Koordinate
        LD      H,A             ; Ergebnis merken
        LD      A,D             ; High - Byte der Koordinate holen
        ADD     A,040H          ; auf jeden Fall umrechnen in positive Koordinate
        LD      D,A             ; Ergebnis merken
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Koordinaten in HL und DE vergleichen
        JR      C,A479F         ; Koordinate in DE ist gr√∂√üer
        LD      A,H             ;! Differenz gleich Null  ?
        OR      L               ;!
        RET     Z               ; ja
A479B:  LD      A,-1            ; Code for 'Koordinate in HL ist gr√∂√üer'
        SCF                     ; Code for 'Differenz in Koordinaten'  setzen
        RET
;
A479F:  OR      A               ; Carry - Flag zur√ºcksetzen
        EX      DE,HL           ; negative Differenz nach DE
        LD      HL,0            ;! positive Differenz errechnen
        SBC     HL,DE           ;!
        XOR     A               ; Code for 'Koordinate in DE ist gr√∂√üer'
        SCF                     ; Code for 'Differenz in Koordinaten'  setzen
        RET
;
;
;   Linie vom Anfangspunkt √ºber Mittelpunkt zum Endpunkt des Kreises
;   oder der Ellipse zeichnen
;
A47A9:  CALL    A47BA           ; absolute Kreis- (Ellipsen-)koordinaten aus Kreisoffset 
        LD      HL,(S1088)      ; X - Koordinate Graphic - Cursor holen
        PUSH    HL              ; X - Koordinate Mittelpunkt ablegen
        PUSH    BC              ; Y - Koordinate Mittelpunkt ablegen
        EXX
        CALL    A47BA           ; absolute Kreis- (Ellipsen-)koordinaten aus Kreisoffset
        LD      B,2             ; zwei Linien zeichnen
        JP      A4C08           ; bereitgestellte Koordinaten mit Linine verbinden
;
;
;   absolute Kreis- (Ellipsen-)koordinaten aus Kreisoffset errechnen
;
A47BA:  POP     IX              ; R√ºcksprungadresse vom Stack holen
        EX      DE,HL           ; X - Offset nach HL
        CP      2               ; Radius gleich Y - Radius  ?
        CALL    Z,A47D6         ; ja -->  Offset f√ºr Ellipse corrigieren
        LD      BC,(S1088)      ; X - Koordinate Graphic - Cursor holen
        ADD     HL,BC           ; absolute Koordinate errechnen
        PUSH    HL              ; und auf Stack merken
        EX      DE,HL           ; Y - Offset nach HL
        CP      1               ; Radius gleich X - Radius  ?
        CALL    Z,A47D6         ; ja -->  Offset f√ºr ellipse corrigieren
        LD      BC,(S108A)      ; Y - Koordinate Graphic - Cursor holen
        ADD     HL,BC           ; absolute Koordinate errechnen
        PUSH    HL              ; und auf Stack ablegen
        JP      (IX)            ; R√ºcksprung auf aufrufendes Programmst√ºck
;
;
;   Offset f√ºr Ellipse corrigieren   (wenn Offset negativ -->  erst Vorzeichen umkehren)
;
A47D6:  BIT     7,H             ; Wert positiv  ?
        JP      Z,A4BA7         ; ja -->  Offset f√ºr Ellipse corrigieren
        CALL    A47E1           ; Vorzeichen des Integer - Wertes in HL umkehren
        CALL    A4BA7           ; Offset f√ºr Ellipse corrigieren
A47E1:  EX      AF,AF           ; Register - Wert retten
        CALL    A4B80           ; Vorzeichen des Integer - Wertes in HL umkehren
        EX      AF,AF           ; geretteten Register - Wert holen
        RET
;
;
;   Kreis (-ausschnitt)  zeichnen     (DE  = X - Offset Endpunkt   / HL  = Y - Offset Endpunkt)
;    (DE' = X - Offset Startpunkt / HL' = Y - Offset Startpunkt)
;    (B'  = Radius - Verh√§ltnis   / C'  = Aspekt - Flag)
;    (IX = Radius / A = Winkelflag)
;
;   (Software command code:   77)
;
A47E7:  PUSH    AF              ; Winkelflag merken
        CALL    A4669           ; Write-Format-Register f√ºr 'Punkt setzen' setzen
        POP     AF              ; Winkelflag holen
        PUSH    AF              ; und wieder merken
        LD      (A4873 + 1),IX  ; Radius in Routine eintragen
        LD      (S11C7),DE      ; X - Offset auf Endpunkt merken
        LD      (S11C9),HL      ; Y - Offset auf Endpunkt merken
        EXX
        LD      (S11D3),BC      ; Aspekt - Flag und Verh√§ltnis merken
        LD      (S11C3),DE      ; X - Offset auf Anfangspunkt merken
        LD      (S11C5),HL      ; Y - Offset auf Anfangspunkt merken
        LD      A,C             ; Aspekt - Flag holen
        CALL    C,A47A9         ; Torte -->  Linie vom Anfangs- √ºber Mittel- zum Endpunkt
        LD      HL,(S11C3)      ; X - Offset auf Anfangspunkt holen
        LD      DE,(S11C5)      ; Y - Offset auf Anfangspunkt holen
        CALL    A4B44           ; Octantenflag aus Koordinatenoffset bereitstellen
        LD      (S11AE),A       ; Octantenflag des Anfangspunktes merken
        LD      HL,(S11C7)      ; X - Offset auf Endpunkt holen
        LD      DE,(S11C9)      ; Y - Offset auf Endpunkt holen
        CALL    A4B44           ; Octantenflag aus Koordinatenoffset bereitstellen
        LD      (S11AF),A       ; Octantenflag des Endpunktes merken
        LD      HL,S11BA        ; Zeiger auf Octantentabelle vorgeben
        LD      B,8             ; acht 45 Grad - Winkelteile im Vollkreis
        CALL    A0137           ; Speicherbereich (HL) l√∂schen
        LD      HL,S11AE        ; Zeiger auf Octantenflag des Anfangspunktes
        POP     AF              ; Winkelflag holen
        LD      B,A             ; und merken
        AND     00001111B       ; Anzahl Pi - Winkel maskieren
        JR      Z,A4858         ; Startwinkel gleich Endwinkel
        CP      3               ; zu zeichnender Winkel gr√∂√üer als 2 x Pi  ?
        JR      Z,A4843         ; ja -->  Vollkreis (-ellipse)  zeichnen
        LD      A,(HL)          ; Octantenflag des Anfangspunktes holen
        INC     HL              ; Zeiger auf Octantenflag des Endpunktes
        CP      (HL)            ; Octantenflags Anfangs- und Endpunkt vergleichen
        JR      NZ,A4858        ; kein Vollkreis -->  Octantenflag der zu zeichnenden Octanten
        LD      A,B             ; Winkelflag holen
        CP      081H            ; - Pi  <  Startwinkel - Endwinkel  <  0  ?
        JR      Z,A4858         ; Octantenflags f√ºr Teilkreis  (-ellipse) setzen
        JR      A4848
;
;
;   Vollkreis oder Vollellipse zeichnen
;
A4843:  LD      A,9             ; Code for 'Vollkreis'
        LD      (HL),A          ; als Octantenflag des Anfangspunktes eintragen
        INC     HL              ; Zeiger auf Octantenflag des Endpunktes
        LD      (HL),A          ; als Octantenflag des Endpunktes eintragen
A4848:  LD      B,8             ; acht 45 Grad - St√ºcke
        LD      HL,S11BA        ; Zeiger auf Octantentabelle
        INC     A
        CALL    A0138           ; Speicherbereich (HL) mit Konstante im Acc belegen
        LD      A,OR_B          ; Wert f√ºr 'Punkt auf jeden Fall setzen'
        CALL    A4BD0           ; Routine umstellen
        JR      A4873           ; alle Punkte ausrechnen und setzen
;
;
;   Octantenflags f√ºr Teilkreis oder Teilellipse setzen
;
A4858:  LD      A,AND_B         ; Code for 'testen, ob Punkt gesetzt werden mu√ü'
        CALL    A4BD0           ; Routine umstellen
        LD      D,0             ; High - Byte Offset auf Null
        LD      HL,(S11AE)      ; Octantenflag des Anfangspunktes/Endpunktes
        LD      B,H             ; Octantenflag des Endpunktes holen
        LD      A,L             ; Octantenflag des Anfangspunktes holen
A4864:  LD      HL,S11BA - 1    ; Zeiger auf Octantenbytes vorgeben
        LD      E,A             ; aktuelles Octantenflag als Low - Byte Offset
        ADD     HL,DE           ; Zeiger auf Octantenbyte errechnen
        LD      (HL),1          ; Code for 'Punkt im Octanten setzen'  eintragen
        CP      B               ; aktueller Z√§hler gleich Octantenflag Endpunkt  ?
        JR      Z,A4873         ; ja -->  Punkte errechnen und setzen
        AND     00000111B       ; Octantenflag von 1 bis 8
        INC     A               ; Octantenflag plus eins
        JR      A4864           ; weitere Octanten mit zu setzenden Punkten markieren
;
;
;   alle Punkte f√ºr CIRCLE - Befehl errechnen und setzen
;
A4873:  LD      HL,0            ; Kreis - (Ellipse-) Radius   (wird eingetragen)
        LD      (S11A6),HL      ; als Radius - Offsetz√§hler merken
        LD      (S11A8),HL      ; als Durchlaufz√§hler merken
        LD      HL,1
        LD      (S11A4),HL
        LD      (S11AA),HL
A4885:  LD      HL,(S11A6)      ; Radius - Offsetz√§hler holen
        LD      DE,(S11A4)
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE
        LD      (S11A6),HL      ; neuen Radius - Offsetz√§hler merken
        LD      HL,(S11AA)
        DEC     HL
        LD      (S11AC),HL
        LD      A,(S11D3)       ; Aspekt - Flag holen
        OR      A               ; Kreis  ?
        LD      D,H             ;! Wert nach DE duplizieren
        LD      E,L             ;!
        CALL    NZ,A4BA7        ; nicht Kreis -->  Offset f√ºr Ellipse corrigieren
        CP      1               ; Radius gleich X - Radius  ?
        JR      Z,A48A7         ; ja
        EX      DE,HL           ; X - und Y - Offset vertauschen
A48A7:  LD      (S11D1),DE      ; X - Offset f√ºr 2ten / 7ten Octanten merken
        LD      (S11CD),HL      ; Y - Offset f√ºr 5ten / 8ten Octanten merken
        LD      HL,(S11A8)      ; Durchlaufz√§hler holen
        OR      A               ; Kreis  ?
        LD      D,H             ;! Wert nach DE duplizieren
        LD      E,L             ;!
        CALL    NZ,A4BA7        ; nicht Kreis -->  Offset f√ºr Ellipse corrigieren
        CP      1               ; Radius gleich X - Radius  ?
        JR      Z,A48BC         ; ja
        EX      DE,HL           ; X - und Y - Offset vertauschen
A48BC:  LD      (S11CF),DE      ; X - Offset f√ºr 1ten / 8ten Octanten merken
        LD      (S11CB),HL      ; Y - Offset f√ºr 6ten / 7ten Octanten merken
        LD      HL,(S11CF)      ; X - Offset f√ºr 1ten / 8ten Octanten holen
        CALL    A4B80           ; Vorzeichen des Integer - Wertes in HL umkehren
        LD      (S11B2),HL      ; X - Offset f√ºr 4ten / 5ten Octanten merken
        LD      HL,(S11D1)      ; X - Offset f√ºr 2ten / 7ten Octanten holen
        CALL    A4B80           ; Vorzeichen des Integer - Wertes in HL umkehren
        LD      (S11B0),HL      ; X - Offset f√ºr 3ten / 6ten Octanten merken
        LD      HL,(S11CD)      ; Y - Offset f√ºr 5ten / 8ten Octanten holen
        CALL    A4B80           ; Vorzeichen des Integer - Wertes in HL umkehren
        LD      (S11B4),HL      ; Y - Offset f√ºr 1ten / 4ten Octanten merken
        LD      HL,(S11CB)      ; Y - Offset f√ºr 6ten / 7ten Octanten holen
        CALL    A4B80           ; Vorzeichen des Integer - Wertes in HL umkehren
        LD      (S11B6),HL      ; Y - Offset f√ºr 2ten / 3ten Octanten merken
        LD      HL,(S11AC)
        CALL    A4B80           ; Vorzeichen des Integer - Wertes in HL umkehren
        LD      (S11B8),HL      ; aktuellen Y - Offset Kreispunkt merken
        LD      HL,S11BA        ; Zeiger auf Octantentabelle vorgeben
        LD      A,(HL)          ; Byte f√ºr Octantenwinkel eins holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf n√§chstes Octantenbyte
        JR      Z,A4938         ; Byte nicht gesetzt -->  kein Punkt in diesem Octanten
        EXX
        LD      HL,(S11CF)      ; X - Offset f√ºr 1ten / 8ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      DE,(S11B8)      ; aktuellen Y - Offset Kreispunkt holen
        BIT     7,D             ; negativ  ?
        JR      Z,A491B         ; nein -->  nicht vergleichen
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      1               ; Anfangspunkt im ersten Octanten  ?
        JR      NZ,A491A        ; nein
        LD      HL,(S11C5)      ; Y - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A491A         ; Punkt zeichnen
        JR      C,A491B         ; Punkt nicht zeichnen
A491A:  INC     B               ; Code auf  'Punkt setzen'
A491B:  LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      1               ; Endpunkt im ersten Octanten  ?
        JR      NZ,A492C        ; nein
        LD      HL,(S11C9)      ; Y - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A492C         ; Punkt zeichnen
        JR      NC,A492E        ; Punkt nicht zeichnen
A492C:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A492E:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4937         ; Punkt im ersten Octanten nicht setzen
        LD      HL,(S11B4)      ; Y - Offset f√ºr 1ten / 4ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4937:  EXX
A4938:  LD      A,(HL)          ; Byte f√ºr Octantenwinkel zwei holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf n√§chstes Octantenbyte
        JR      Z,A4979         ; nein
        EXX
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      HL,(S11D1)      ; X - Offset f√ºr 2ten / 7ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11AC)
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      2               ; Anfangspunkt im zweiten Octanten  ?
        JR      NZ,A495B        ; nein
        LD      HL,(S11C3)      ; X - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A495B         ; Punkt zeichnen      
        JR      C,A495C         ; Punkt nicht zeichnen
A495B:  INC     B               ; Code auf  'Punkt setzen'
A495C:  LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      2               ; Endpunkt im zweiten Octanten  ?
        JR      NZ,A496D        ; nein
        LD      HL,(S11C7)      ; X - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A496D         ; Punkt zeichnen      
        JR      NC,A496F        ; Punkt nicht zeichnen
A496D:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A496F:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4978         ; Punkt im zweiten Octanten nicht setzen
        LD      HL,(S11B6)      ; Y - Offset f√ºr 2ten / 3ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4978:  EXX
A4979:  LD      A,(HL)          ; Byte f√ºr Octantenwinkel drei holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf n√§chstes Octantenbyte
        JR      Z,A49BE         ; kein Punkt im Octanten 3 setzen
        EXX
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      HL,(S11B0)      ; X - Offset f√ºr 3ten / 6ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11B8)      ; aktuellen Y - Offset Kreispunkt holen
        BIT     7,D             ; negativ  ?
        JR      Z,A49A1         ; nein -->  nicht vergleichen
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      3               ; Anfangspunkt im dritten Octanten  ?
        JR      NZ,A49A0        ; nein -->  Punkt setzen
        LD      HL,(S11C3)      ; X - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A49A0         ; Punkt zeichnen      
        JR      C,A49A1         ; Punkt nicht zeichnen
A49A0:  INC     B               ; Code auf  'Punkt setzen'
A49A1:  LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      3               ; Endpunkt im dritten Octanten  ?
        JR      NZ,A49B2        ; nein -->  testen, ob Punkt setzen
        LD      HL,(S11C7)      ; X - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A49B2         ; Punkt zeichnen      
        JR      NC,A49B4        ; Punkt nicht zeichnen
A49B2:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A49B4:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A49BD         ; Punkt im dritten Octanten nicht setzen
        LD      HL,(S11B6)      ; Y - Offset f√ºr 2ten / 3ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A49BD:  EXX
A49BE:  LD      A,(HL)          ; Byte f√ºr Octantenwinkel vier holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf n√§chstes Octantenbyte
        JR      Z,A4A04         ; kein Punkt im Octanten 4 -->  n√§chsten Octanten testen
        EXX
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      HL,(S11B2)      ; X - Offset f√ºr 4ten / 5ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11B8)      ; aktuellen Y - Offset Kreispunkt holen
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      4               ; Anfangspunkt im vierten Octanten  ?
        JR      NZ,A49E1        ; nein -->  Punkt setzen
        LD      HL,(S11C5)      ; Y - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A49E1         ; Punkt zeichnen      
        JR      NC,A49E2        ; Punkt nicht zeichnen
A49E1:  INC     B               ; Code auf  'Punkt setzen'
A49E2:  XOR     A               ; Code for 'Punkt setzen nicht erlaubt'
        BIT     7,D             ; aktueller Offset positiv  ?
        JR      Z,A49FA         ; ja -->  gar nicht erst vergleichen
        LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      4               ; Endpunkt im vierten Octanten  ?
        JR      NZ,A49F8        ; nein -->  testen, ob Punkt setzen
        LD      HL,(S11C9)      ; Y - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A49F8         ; Punkt zeichnen      
        JR      C,A49FA         ; Punkt nicht zeichnen
A49F8:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A49FA:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4A03         ; Punkt im vierten Octanten nicht setzen
        LD      HL,(S11B4)      ; Y - Offset f√ºr 1ten / 4ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4A03:  EXX
A4A04:  LD      A,(HL)          ; Byte f√ºr Octantenwinkel f√ºnf holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf n√§chstes Octantenbyte
        JR      Z,A4A45         ; kein Punkt im Octanten 5 -->  n√§chsten Octanten testen
        EXX
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      HL,(S11B2)      ; X - Offset f√ºr 4ten / 5ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11AC)
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      5               ; Anfangspunkt im f√ºnften Octanten  ?
        JR      NZ,A4A27        ; nein -->  Punkt setzen
        LD      HL,(S11C5)      ; Y - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4A27         ; Punkt zeichnen      
        JR      NC,A4A28        ; Punkt nicht zeichnen
A4A27:  INC     B               ; Code auf  'Punkt setzen'
A4A28:  LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      5               ; Endpunkt im f√ºnften Octanten  ?
        JR      NZ,A4A39        ; nein -->  testen, ob Punkt setzen
        LD      HL,(S11C9)      ; Y - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4A39         ; Punkt zeichnen      
        JR      C,A4A3B         ; Punkt nicht zeichnen
A4A39:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A4A3B:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4A44         ; Punkt im f√ºnften Octanten nicht setzen
        LD      HL,(S11CD)      ; Y - Offset f√ºr 5ten / 8ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4A44:  EXX
A4A45:  LD      A,(HL)          ; Byte f√ºr Octantenwinkel sechs holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf n√§chstes Octantenbyte
        JR      Z,A4A8B         ; kein Punkt im Octanten 6 -->  n√§chsten Octanten testen
        EXX
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      HL,(S11B0)      ; X - Offset f√ºr 3ten / 6ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11B8)      ; aktuellen Y - Offset Kreispunkt holen
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      6               ; Anfangspunkt im sechsten Octanten  ?
        JR      NZ,A4A68        ; nein -->  Punkt setzen
        LD      HL,(S11C3)      ; X - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4A68         ; Punkt zeichnen      
        JR      NC,A4A69        ; Punkt nicht zeichnen
A4A68:  INC     B               ; Code auf  'Punkt setzen'
A4A69:  XOR     A               ; Code for 'Punkt setzen nicht erlaubt'
        BIT     7,D             ; Offset positiv  ?
        JR      Z,A4A81         ; ja -->  gar nicht erst vergleichen
        LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      6               ; Endpunkt im sechsten Octanten  ?
        JR      NZ,A4A7F        ; nein -->  testen, ob Punkt setzen
        LD      HL,(S11C7)      ; X - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4A7F         ; Punkt zeichnen      
        JR      C,A4A81         ; Punkt nicht zeichnen
A4A7F:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A4A81:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4A8A         ; Punkt im sechsten Octanten nicht setzen
        LD      HL,(S11CB)      ; Y - Offset f√ºr 6ten / 7ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4A8A:  EXX
A4A8B:  LD      A,(HL)          ; Byte f√ºr Octantenwinkel sieben holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf n√§chstes Octantenbyte
        JR      Z,A4ACC         ; kein Punkt im Octanten 7 -->  n√§chsten Octanten testen
        EXX
        LD      HL,(S11D1)      ; X - Offset f√ºr 2ten / 7ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11AC)
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      7               ; Anfangspunkt im siebten Octanten  ?
        JR      NZ,A4AAE        ; nein -->  Punkt setzen
        LD      HL,(S11C3)      ; X - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4AAE         ; Punkt zeichnen      
        JR      NC,A4AAF        ; Punkt nicht zeichnen
A4AAE:  INC     B               ; Code auf  'Punkt setzen'
A4AAF:  LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      7               ; Endpunkt im siebten Octanten  ?
        JR      NZ,A4AC0        ; nein -->  testen, ob Punkt setzen
        LD      HL,(S11C7)      ; X - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4AC0         ; Punkt zeichnen      
        JR      C,A4AC2         ; Punkt nicht zeichnen
A4AC0:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A4AC2:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4ACB         ; Punkt im siebten Octanten nicht setzen
        LD      HL,(S11CB)      ; Y - Offset f√ºr 6ten / 7ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4ACB:  EXX
A4ACC:  LD      A,(HL)          ; Byte f√ºr Octantenwinkel acht holen
        OR      A               ; Byte gesetzt  ?
        INC     HL              ; Zeiger auf n√§chstes Octantenbyte
        JR      Z,A4B0D         ; kein Punkt im Octanten 8 -->  n√§chsten Punkt durchspielen
        EXX
        LD      HL,(S11CF)      ; X - Offset f√ºr 1ten / 8ten Octanten holen
        LD      (D4B94 + 1),HL  ; X - Offset in Routine eintragen
        LD      DE,(S11AC)
        LD      B,0             ; Code for 'Punkt nicht setzen'
        LD      A,(S11AE)       ; Octantenflag des Anfangspunktes holen
        CP      8               ; Anfangspunkt im achten Octanten  ?
        JR      NZ,A4AEF        ; nein -->  Punkt setzen
        LD      HL,(S11C5)      ; Y - Offset auf Anfangspunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4AEF         ; Punkt zeichnen      
        JR      C,A4AF0         ; Punkt nicht zeichnen
A4AEF:  INC     B               ; Code auf  'Punkt setzen'
A4AF0:  LD      A,(S11AF)       ; Octantenflag des Endpunktes holen
        CP      8               ; Endpunkt im achten Octanten  ?
        JR      NZ,A4B01        ; nein -->  testen, ob Punkt setzen
        LD      HL,(S11C9)      ; Y - Offset auf Endpunkt holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offsets vergleichen
        JR      Z,A4B01         ; Punkt zeichnen      
        JR      NC,A4B03        ; Punkt nicht zeichnen
A4B01:  LD      A,00000001B     ; Code for 'Punkt setzen erlaubt'
A4B03:  AND     B               ; Punkt setzen  ?   (Befehl wird eingetragen)
        JR      Z,A4B0C         ; Punkt im achten Octanten nicht setzen
        LD      HL,(S11CD)      ; Y - Offset f√ºr 5ten / 8ten Octanten holen
        CALL    A4B88           ; Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
A4B0C:  EXX
A4B0D:  LD      HL,(S11A6)      ; Radius - Offsetz√§hler holen
        BIT     7,H             ; Wert positiv  ?
        JR      Z,A4B32         ; ja
        LD      DE,(S11AA)
        LD      HL,(S11A8)      ; Durchlaufz√§hler holen
        DEC     HL              ; minus eins
        LD      (S11A8),HL      ; und wieder merken
        BIT     7,H             ; Wert negativ  ?
        RET     NZ              ; ja -->  fertig
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE   
        RET     C               ; fertig
        LD      HL,(S11A8)      ; Durchlaufz√§hler holen
        ADD     HL,HL
        LD      DE,(S11A6)      ; Radius - Offsetz√§hler holen
        ADD     HL,DE
        LD      (S11A6),HL      ; neuen Radius - Offsetz√§hler merken
A4B32:  LD      HL,(S11AA)
        INC     HL
        LD      (S11AA),HL
        LD      HL,(S11A4)
        INC     HL
        INC     HL
        LD      (S11A4),HL
        JP      A4885           ; neuen Punkt in allen 8 Octanten durchspielen
;
;
;                   !                   Octantenflag aus Koordinatenoffset bereitstellen
;                  3!2
;                   !                           1 = 315 - 360  Grad
;              4    !    1                      2 = 270 - 315  Grad
;          ---------+---------->  +X            3 = 225 - 270  Grad
;              5    !    8                      4 = 180 - 225  Grad
;                   !                           5 = 135 - 180  Grad
;                  6!7                          6 =  90 - 135  Grad
;                   !                           7 =  45 -  90  Grad
;                   !     +Y                    8 =   0 -  45  Grad
;
A4B44:  PUSH    HL              ; X - Offset retten
        PUSH    DE              ; Y - Offset retten
        CALL    A4B7D           ; Absolutbetrag des Integer - Wertes in HL bilden
        EX      DE,HL           ; Offsets vertauschen
        CALL    A4B7D           ; Absolutbetrag des Integer - Wertes in HL bilden
        EX      DE,HL           ; Offsets vertauschen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Punkt n√§her an X- oder an Y - Achse  ?
        POP     DE              ; geretteten Y - Offset holen
        POP     HL              ; geretteten X - Offset holen
        JR      C,A4B69         ; Punkt n√§her an Y - Achse
        BIT     7,H             ; X - Offset negativ  ?
        JR      NZ,A4B61        ; ja
        BIT     7,D             ; Y - Offset negativ  ?
        LD      A,8             ; Code for 'zwischen 0 und 45 Grad'
        RET     Z               ; Y - Offset positiv
        LD      A,1             ; Code for 'zwischen 315 und 360 Grad'
        RET
;
A4B61:  BIT     7,D             ; Y - Offset negativ  ?
        LD      A,5             ; Code for 'zwischen 135 und 180 Grad'
        RET     Z               ; Y - Offset positiv
        LD      A,4             ; Code for 'zwischen 180 und 225 Grad'
        RET
;
A4B69:  BIT     7,H             ; X - Offset positiv  ?
        JR      NZ,A4B75        ; nein
        BIT     7,D             ; Y - Offset negativ  ?
        LD      A,7             ; Code for 'zwischen 45 und 90 Grad'
        RET     Z               ; Y - Offset positiv
        LD      A,2             ; Code for 'zwischen 270 und 315 Grad'
        RET
;
A4B75:  BIT     7,D             ; Y - Offset negativ  ?
        LD      A,6             ; Code for 'zwischen 90 und 135 Grad'
        RET     Z               ; Y - Offset positiv
        LD      A,3             ; Code for 'zwischen 225 und 270 Grad'
        RET
;
;
;   Absolutbetrag des Integer - Wertes in HL bereitstellen
;
A4B7D:  BIT     7,H             ; Wert in HL positiv  ?
        RET     Z               ; ja -->  fertig
;
;
;   Vorzeichen des Integer - Wertes in HL umkehren
;
A4B80:  LD      A,H             ;! 2er Complement des Wertes in HL bilden
        CPL                     ;!
        LD      H,A             ;!
        LD      A,L             ;!
        CPL                     ;!
        LD      L,A             ;!
        INC     HL              ;!
        RET
;
;
;   Punkt nach Y-Offset in HL und eingetragenem X-Offset setzen
;
A4B88:  LD      DE,(S108A)      ; Y - Koordinate Graphic - Cursor holen
        ADD     HL,DE           ; absolute Y - Koordinate errechnen
        LD      DE,-200         ; maximale Y - Koordinate vorgeben
        LD      B,H             ;! Y - Koordinate nach BC merken
        LD      C,L             ;!
        ADD     HL,DE           ; testen, ob Y - Koordinate im angezeigten Bereich
        RET     C               ; nicht im angezeigten Bereich -->  fertig
D4B94:  LD      HL,0            ; X - Offset holen   (wird eingetragen)
        LD      DE,(S1088)      ; X - Koordinate Graphic - Cursor holen
        ADD     HL,DE           ; absolute X - Koordinate errechnen
        EX      DE,HL           ; X - Koordinate nach DE
        LD      HL,-640         ; maximale X - Koordinate vorgeben
        ADD     HL,DE           ; testen, ob X - Koordinate im angezeigten Bereich
        RET     C               ; nicht im angezeigten Bereich -->  fertig
        LD      H,B             ;! Y - Koordinate wieder nach HL
        LD      L,C             ;!
        JP      A4697           ; Punkt nach Koordinaten setzen oder zur√ºcksetzen
;
;
;   Offset f√ºr Ellipse corrigieren
;
A4BA7:  PUSH    AF              ;! Register - Werte retten
        PUSH    DE              ;!
        LD      B,8             ; acht Bit testen
        LD      C,L             ; Low - Byte Offset
        LD      E,H             ; High - Byte Offset
        XOR     A               ; Accu auf Null
        LD      D,A             ;! Null
        LD      H,A             ;!
        LD      L,A             ;!
        EX      AF,AF           ; Null retten
        LD      A,(S11D4)       ; Aspekt - Verh√§ltnis holen
A4BB5:  RRA                     ; ein Bit nach Carry schieben
        JR      NC,A4BBF        ; nicht gesetzt -->  nicht addieren
        ADD     HL,DE           ; High - Bytes der Faktoren addieren
        EX      AF,AF           ; Low - Byte Faktor holen
        ADD     A,C             ; und addieren
        JR      NC,A4BBE        ; kein √úbertrag
        INC     HL              ; √úbertrag corrigieren
A4BBE:  EX      AF,AF           ; Low - Byte Faktor wieder merken
A4BBF:  SLA     C               ;! Multiplikator um eine Stelle schieben
        RL      E               ;!
        RL      D               ;!
        DJNZ    A4BB5           ; weitere Bits multiplizieren
        EX      AF,AF           ; Low - Byte Ergebnisz√§hler holen
        BIT     7,A             ; MSBit gleich Null  ?
        JR      Z,A4BCD         ; ja -->  Ergebnis nicht aufrunden
        INC     HL              ; Ergebnis aufrunden
A4BCD:  POP     DE              ;! gerettete Register - Werte holen
        POP     AF              ;!
        RET
;
;
;   Routine f√ºr 'Punkt auf jeden Fall setzen / testen, ob Punkt setzen' umstellen
;
A4BD0:  LD      (A492E),A       ;! richtigen Z-80 Befehl in Routine eintragen
        LD      (A496F),A       ;!
        LD      (A49B4),A       ;!
        LD      (A49FA),A       ;!
        LD      (A4A3B),A       ;!
        LD      (A4A81),A       ;!
        LD      (A4AC2),A       ;!
        LD      (A4B03),A       ;!
        RET
;
;
;   Rechteck zeichnen     ( DE  = X - Koordinate erster Eckpunkt  /  HL  = Y - Koordinate )
;                         ( DE' = X - Koordinate zweiter Eckpunkt /  HL' = Y - Koordinate )
;                         ( Carry - Flag gesetzt -->  Rechteck ausf√ºllen )
;                         ( Accu = F√ºllpalettencode)
;
;   (Software command code:  75)
;
A4BE9:  LD      (S11A8),SP      ; Stackpointer retten
        EX      AF,AF           ; Flag  'Rechteck ausf√ºllen'  retten
        CALL    A4C16           ; X mit Y-Koord. in DE,HL , DE',HL' tauschen/Y-Max nach HL
        CALL    A4C16           ; X mit Y-Koord. in DE,HL , DE',HL' tauschen/Y-Max nach HL
        EXX
        PUSH    DE              ; X - Koordinate Punkt 1
        PUSH    HL              ; Y - Koordinate Punkt 1
        PUSH    DE              ; X - Koordinate Punkt 1
        EXX
        PUSH    HL              ; Y - Koordinate Punkt 2
        PUSH    DE              ; X - Koordinate Punkt 2
        PUSH    HL              ; Y - Koordinate Punkt 2
        PUSH    DE              ; X - Koordinate Punkt 2
        EXX
        PUSH    HL              ; Y - Koordinate Punkt 1
        PUSH    DE              ; X - Koordinate Punkt 1
        PUSH    HL              ; Y - Koordinate Punkt 1
        EXX
        EX      AF,AF           ; Flag  'Rechteck ausf√ºllen'  holen
        CALL    C,A4C2C         ; gesetzt -->  Rechteck ausf√ºllen
        LD      B,4             ; vier Linienst√ºcke f√ºr ein Rechteck
A4C08:  EXX
        POP     HL              ; Y - Koordinate Anfangspunkt holen
        POP     DE              ; X - Koordinate Anfangspunkt holen
        EXX
A4C0C:  POP     HL              ; Y - Koordinate Endpunkt holen
        POP     DE              ; X - Koordinate Endpunkt holen
        PUSH    BC              ; Restanzahl Linien retten
        CALL    A46CC           ; Linie von Koordinaten in DE,HL nach DE',HL' zeichnen
        POP     BC              ; Restanzahl Linien holen
        DJNZ    A4C0C           ; weitere Linien f√ºr Rechteck zeichnen
        RET
;
;
;   X -Koordinate mit Y - Koordinate vertauschen   (DE<>HL  DE'<>HL')
;   und gr√∂√üere Y - Koordinate nach HL
;
A4C16:  EX      DE,HL           ; X- mit Y - Koordinate vertauschen
        LD      A,H             ; High - Byte Y - Koordinate holen
        EXX                     ; erste mit zweiter Koordinate vertauschen
        EX      DE,HL           ; X- mit Y - Koordinate vertauschen
        CP      H               ; High - Bytes der Y - Koordinaten vergleichen
        EXX
        JR      Z,A4C21         ; High - Bytes gleich -->  Low - Bytes vergleichen
        RET     P               ; gr√∂√üere Y - Koordinate ist in HL
        JR      A4C26           ; Y - Koordinaten vertauschen
;
A4C21:  LD      A,L             ; Low - Byte Y - Koordinate holen
        EXX
        CP      L               ; mit Low - Byte Y - Koordinate vergleichen
        EXX
        RET     NC              ; Y - Koordinate in HL ist gr√∂√üer
A4C26:  PUSH    HL              ; Y - Koordinate ablegen
        EXX                     ; umschalten auf andere Koordinate
        EX      (SP),HL         ; Y - Koordinate mit Koordinate auf Stack vertauschen
        EXX                     ; wieder umschalten auf erste Koordinate
        POP     HL              ; gr√∂√üere Y - Koordinate wieder holen
        RET
;
;
;   Rechteck mit Palettencode im Accu ausf√ºllen
;
A4C2C:  CALL    A049C           ; Palettenwert f√ºr maximale Aufl√∂sung corrigieren
        LD      B,A             ; Palettenwert zum Ausf√ºllen merken
        LD      A,(S109F)       ; aktuellen Graphic - Palettenwert holen
        CP      B               ; gleich Ausf√ºllpalettenwert  ?
        JR      NZ,A4C3A        ; nein -->  Rand mu√ü noch gezeichnet werten
        LD      SP,(S11A8)      ; Stackpointer bei Anfang Routine holen  (Rand nicht zeichnen)
A4C3A:  LD      A,(S109A)       ; aktuellen √úberschreib - Modus holen
        OR      A               ; √úberschreiben  ?
        LD      A,11000000B     ; Code for 'PSET'   (Punkt in Farbe setzen)
        JR      Z,A4C44         ; Fl√§che in Farbe ausmalen
        LD      A,01000000B     ; Code for 'OR'     (neuen Farbwert mit altem Farbwert verkn√ºpfen)
A4C44:  OR      B               ; plus Palettenwert
        OUT     (CRTCWF),A      ; an 'Write-Format-Register' Bildschirm-Controller ausgeben
;
;
;   Linie(n) parallel zu einer Koordinatenachse zeichnen
;
A4C47:  LD      A,H             ; High - Byte Y - Koordinate
        OR      D               ; und High - Byte X - Koordinate
        RET     M               ; mindestens eine der Koordinaten ist au√üerhalb Anzeigebereich
        CALL    A4CEC           ; wenn Koordinaten au√üerhalb Graphic -->  Maximum vorgeben
        LD      A,L             ; Low - Byte Y - Koordinate holen
        EXX
        BIT     7,H             ; Y-Koordinate im negativen Nicht - Anzeige - Bereich  ?
        JR      Z,A4C56         ; nein
        LD      HL,0            ; kleinste anzeigbare Koordinate vorgeben
A4C56:  BIT     7,D             ; X-Koordinate im negativen Nicht - Anzeige - Bereich  ?
        JR      Z,A4C5D         ; nein
        LD      DE,0            ; kleinste anzeigbare Koordinate vorgeben
A4C5D:  EX      AF,AF           ; Low - Byte Y - Koordinate retten
        CALL    A4CEC           ; wenn Koordinaten au√üerhalb Graphic -->  Maximum vorgeben
        RET     C               ; Fehler aufgetreten -->  Abbruch
        EX      AF,AF           ; Low - Byte gr√∂√üere Y - Koordinate wieder holen
        INC     A               ; plus eins  (Anzahl ist um eins gr√∂√üer als Differenz)
        SUB     L               ; Low - Byte kleinere Koordinate abziehen
        RET     C               ; Fehler aufgetreten -->  Abbruch
        RET     Z               ; nichts zeichnen
        EX      AF,AF           ; Anzahl Graphic - Zeilen merken
        PUSH    HL              ; Y - Koordinate merken
        CALL    A460F           ; absolute Graphic-Adresse und Bitnr. aus Koordinaten errechnen
        LD      (S11A4),HL      ; Graphic - Adresse der linken Ecke merken
        EXX
        POP     HL              ; Y - Koordinate wieder holen
        LD      B,A             ; Bit - Nummer der linken Ecke
        PUSH    BC              ; Bit - Nummer der linken Ecke merken
        CALL    A460F           ; absolute Graphic-Adresse und Bitnr. aus Koordinaten errechnen
        POP     BC              ; Bit - Nummer der linken Ecke holen
        LD      (S11A6),HL      ; Graphic - Adresse der rechten Ecke merken
        LD      C,A             ; Bit - Nummer der rechten Ecke
        LD      DE,(S11A4)      ; Graphic - Adresse der linken Ecke holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Graphic - Adressen vergleichen
        JR      Z,A4CAA         ; beide Ecken liegen im gleichen Graphic-Byte
        DEC     HL              ; Differenz corrigieren
        INC     DE              ; Zeiger auf Graphic - Speicher corrigieren
        LD      A,L             ; Anzahl vollst√§ndige 8ter Spalten holen
        OR      A               ; gleich Null  ?
        CALL    NZ,A4CCD        ; nein -->  Punkte in vollst√§ndigen 8ter Spalten setzen
        LD      HL,B45C0        ; Tabelle zum Setzen der linken Punkte nach Bit-Nummer
        LD      A,B             ; Bitnummer der linken Ecke merken
        LD      B,0             ; High - Byte Offset auf Null
        ADD     HL,BC           ; Zeiger auf richtigen Tabellenwert
        LD      L,(HL)          ; Setzmaske aus Tabelle holen
        LD      C,A             ; Bitnummer der linken Ecke als Low - Byte Ofset
        LD      A,L             ; Bitmaske f√ºr rechte Ecke merken
        LD      HL,B45B8        ; Tabelle zum Setzen der rechten Punkte nach Bit-Nummer
        ADD     HL,BC           ; Zeiger auf richtigen Tabellenwert errechnen
        LD      B,(HL)          ; Bitmasken f√ºr linkes Byte aus Tabelle holen
        LD      DE,(S11A6)      ; Graphic - Adresse der rechten Ecke holen
        PUSH    BC              ; Bitmaske der linken Ecke merken
        CALL    A4CBA           ; Punkte nach Muskermaske im Accu in Graphic setzen
        POP     BC              ; gerettete Bitmaske holen
        LD      DE,(S11A4)      ; Graphic - Adresse der linken Ecke holen
        LD      A,B             ; neuen Setzwert vorgeben
        JR      A4CBA           ; Punkte nach Mustermaske im Accu in Graphic setzen
;
;
;   zwei Punkte im gleichen Graphic - Byte mit Linie verbinden
;
A4CAA:  LD      HL,B45C0        ; Tabelle zum Setzen der linken Punkte nach Bit-Nummer
        LD      A,B             ; Bit - Nummer der linken Ecke retten
        LD      B,0             ; High - Byte Offset auf Null
        ADD     HL,BC           ; Zeiger auf Tabelle auf richtige Maske
        LD      C,A             ; Bit - Nummer der linken Ecke
        LD      A,11111111B     ; erst einmal alle Bits vorgeben
        AND     (HL)            ; zu setzende Bits maskieren  (LD A,(HL) macht das Gleiche)
        LD      HL,B45B8        ; Tabelle zum Setzen der rechten Punkte nach Bit-Nummer
        ADD     HL,BC           ; Zeiger auf richtigen Tabellenwert f√ºr linke Ecke
        AND     (HL)            ; noch zu setzende Bits maskieren
;
;
;   Punkte nach Mustermaske in Accu in Graphic setzen
;
A4CBA:  LD      C,A             ; neuen Setzwert merken
        EX      AF,AF           ; Anzahl Graphic - Zeilen holen
        LD      B,A             ; und f√ºr Schleife vorgeben
        EX      AF,AF           ; Anzahl Graphic - Zeilen merken
        EX      DE,HL           ; Zeiger auf Graphic - Speicher nach HL
        DI                      ; Interrupt sperren
A4CC0:  LD      DE,80           ; Offset auf n√§chste Graphic-Zeile   (wird eingetragen)
        IN      A,(_CGVIN)      ; ZeichensatzROM und Video-RAM einschalten
A4CC5:  LD      (HL),C          ; neues Muster in Graphic - Speicher eintragen
        ADD     HL,DE           ; Zeiger auf n√§chste Graphic - Zeile
        DJNZ    A4CC5           ; weitere Graphic - Zeilen beeinflussen
        IN      A,(_CGVOT)      ; ZeichensatzROM und Video-RAM ausschalten
        EI                      ; Interrupt wieder freigeben
        RET
;
;
;   Punkte in vollst√§ndigen 8ter Zeilen setzen
;   (Komplette Bytes im Graphic - Speicher)
;
A4CCD:  PUSH    BC              ; Register - Wert retten
        EX      DE,HL           ; Zeiger auf Graphic - Speicher nach HL
        LD      B,A             ; Anzahl vollst√§ndige 8ter Spalten merken
        EX      AF,AF           ; Anzahl Graphic - Zeilen holen
        LD      C,A             ; und f√ºr Schleife merken
        EX      AF,AF           ; Anzahl Graphic - Zeilen wieder merken
A4CD3:  LD      DE,80           ; Offset auf n√§chste Graphic-Zeile   (wird eingetragen)
        DI                      ; Interrupt sperren
A4CD7:  PUSH    HL              ; Zeiger auf Graphic - Speicher merken
        PUSH    BC              ; Restanzahl Zeilen merken
        IN      A,(_CGVIN)      ; ZeichensatzROM und Video-RAM einschalten
        LD      A,11111111B     ; Code for 'alle Punkte in diesem Byte beeinflussen'
A4CDD:  LD      (HL),A          ; an Graphic ausgeben   (Punkte nach Palettenwert setzen)
        INC     HL              ; Zeiger auf Graphic - Speicher auf n√§chste 8ter Spalte
        DJNZ    A4CDD           ; Punkte in weiteren 8ter - Spalten setzen
        IN      A,(_CGVOT)      ; ZeichensatzROM und Video-RAM ausschalten
        POP     BC              ; Restanzahl Zeilen holen
        POP     HL              ; Zeiger auf Graphic - Speicher holen
        ADD     HL,DE           ; Zeiger auf n√§chste Zeile errechnen
        DEC     C               ; Restanzahl Zeilen minus eins
        JR      NZ,A4CD7        ; Punkte in weiteren Zeilen setzen
        EI                      ; Interrupt wieder freigeben
        POP     BC              ; geretteten Register - Wert wieder holen
        RET
;
;
;   tesen, ob Graphic - Koordinaten innerhalb des angezeigten Graphic-Bereichs
;   wenn nicht -->  die jeweilige maximal - Koordinate vorgeben
;
A4CEC:  LD      A,H             ; High - Byte  Y - Koordinate holen
        OR      A               ; gleich Null  ?
        JR      NZ,A4CF5        ; nein -->  maximale Y - Koordinate vorgeben
        LD      A,199           ; maximale Y - Koordinate im Anzeigebereich
        CP      L               ; mit aktueller Y - Koordinate vergleichen
        JR      NC,A4CF9        ; Y - Koordinate liegt im angezeigten Bereich
A4CF5:  LD      HL,199          ; maximale Y - Koordinate vorgeben
        SCF                     ; Code for 'Koordinate nicht im Bereich'
A4CF9:  RRA                     ; eventuellen Fehler bei Y - Koordinate merken
        PUSH    HL              ; Y - Koordinate retten
A4CFB:  LD      HL,-640         ; maximale negative X - Koordinate vorgeben
        ADD     HL,DE           ; X - Koordinate testen
        POP     HL              ; gerettete Y - Koordinate wieder holen
        JR      NC,A4D06        ; X - Koordinate ist OK
A4D02:  LD      DE,639          ; maximale X - Koordinate vorgeben   (wird eingetragen)
        RET
;
A4D06:  RLA                     ; eventuellen Fehler aus Y - Koordinate wieder vorgeben
        RET
;
;
;   √úberpr√ºfen, ob Graphic-Koordinate in DE',HL' im angezeigten Graphic-Bereich liegt
;
;   (Software command code:  70)
;
A4D08:  EXX                     ; Graphic - Koordinaten in Erstregistersatz holen
        CALL    A46B2           ; √ºberpr√ºfen, ob Koordinaten in DE,HL im angezeigten Bereich
        EXX                     ; Graphic - Koordinaten wieder in Zweitregistersatz stecken
        RET     NC              ; Koordinaten sind OK
        LD      A,3             ; Fehler 3   Illegal data error
        JP      A00ED           ; Fehler mit Nummer im Accu behandeln
;
;
;   aktuelle Graphic - Cursor - Koordinaten im Zweitregistersatz merken
;
;   (Software command code:  71)
;
A4D13:  EXX                     ; Graphic - Koordinaten in Erstregistersatz holen
        LD      (S1088),DE      ; X - Koordinate Graphic - Cursor merken
        LD      (S108A),HL      ; Y - Koordinate Graphic - Cursor merken
        EXX                     ; Graphic - Koordinaten wieder in Zweitregistersatz stecken
        RET
;
S4D1D:  DEFS    8               ; Speicher f√ºr aktuelles Zeichen   (SYMBOL)
;
;
;   Tabelle mit Anfangsadressen der Teilroutine f√ºr verschiedene Zeichenrichtungen
;
W4D25:  DEFW    A4EE1           ; Standardlage  (0 Grad)
        DEFW    A4EED           ; Rotation um  90 Grad
        DEFW    A4F03           ; Rotation um 180 Grad
        DEFW    A4F1C           ; Rotation um 270 Grad
;
;
;   Output text with magnification     (DE = pointer to text)
;     (H  = Y - enlargement)
;     (L  = X - enlargement)
;     (A  = direction)
;     (B  = number of characters)
;
;   (Software command code:  87)
;
A4D2D:  PUSH    BC              ; Save number of characters
        PUSH    DE              ; Save pointer to text
        LD      BC,S1218        ; Specify pointer to memory for current X reference position
        LD      D,L             ; Horizontal magnification
        LD      E,H             ; Vertical Magnification
        BIT     0,A             ; Horizontal writing direction ?
        JR      Z,A4D3B         ; yes --> character is in the X direction
        EX      DE,HL           ; Swap X and Y magnification
        INC     BC              ;! Pointer to memory for current Y - reference position
        INC     BC              ;! to pretend
A4D3B:  LD      (D4DB3 + 1),BC  ; Enter pointer in routine
        LD      (S1212),HL      ; remember horizontal and vertical magnification
        LD      H,0             ; High - byte increase to zero
        ADD     HL,HL           ;! times two (8 rows of dots on top of each other)
        ADD     HL,HL           ;! times four
        ADD     HL,HL           ;! times eight
        LD      (S1214),HL      ; Number of points per character in the X character direction
        LD      L,E             ; Y - magnification
        LD      H,0             ; High - byte to zero
        ADD     HL,HL           ;! times two (8 points next to each other)
        ADD     HL,HL           ;! times four
        ADD     HL,HL           ;! times eight
        LD      (S1216),HL      ; Number of points per character in the Y character direction
        LD      DE,0            ; EN to zero
        EX      DE,HL           ; swap values
        SBC     HL,DE           ; Calculate the negative value of the number of points in the Y direction
        LD      (S1221),HL      ; Offset from end character to start next character
        BIT     1,A             ; Output text in Y - direction ?
        JR      Z,A4D64         ; no
        LD      (S1221),DE      ; Offset from end character to start next character
A4D64:  OR      A               ; drawing direction flag
        JP      PO,A4D6B        ; Characters in the direction of the Y - axis
        LD      HL,0            ; Default zero as offset for X - axis
A4D6B:  LD      DE,(S108A)      ; Y - Coordinate Graphic - Cursor
        ADD     HL,DE           ; Calculate reference coordinates
        LD      (S121A),HL      ; current Y - reference position for SYMBOL
        LD      DE,(S1214)      ; Number of points per character in the X character direction
        LD      HL,0            ; Default zero
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; Calculate complement
        BIT     0,A             ; Drawing direction parallel to the X - axis ?
        JR      NZ,A4D8C        ; Drawing direction in Y - axis
        BIT     1,A             ; Rotate character 270 degrees ?
        LD      (S1221),DE      ; Offset from end character to start next character
        JR      Z,A4D8C         ; Yes
        LD      (S1221),HL      ; Offset from end character to start next character
A4D8C:  EX      DE,HL             
        LD      HL,(S1088)      ; X - Coordinate Graphic - Get cursor
        BIT     1,A             ; Drawing direction along positive axis ?
        JR      Z,A4D95         ; Yes
        ADD     HL,DE             
A4D95:  LD      (S1218),HL      ; current X - reference position for SYMBOL
        ADD     A,A             ; character position times two (two bytes per address)
        LD      HL,W4D25        ; Starting address table to reverse byte by character position
        LD      D,0             ; High - byte offset to zero
        LD      E,A             ; Specify low - byte offset
        ADD     HL,DE           ; Calculate pointer to correct address
        LD      E,(HL)          ;! Get address from table
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      (D4DE9 + 1),DE  ; and enter into routine
        CALL    A4669           ; Write - Set format register for 'set point'
        POP     HL              ; Get pointer to text to output
        POP     BC              ; Get number of characters to be output
A4DAC:  DEC     B               ; Number of characters to print minus one
        RET     M               ; done
        PUSH    HL              ; Save pointer to text to be output
        PUSH    BC              ; Save remaining number of characters to be output
        CALL    A4DC8           ; output a character according to the magnification factor
D4DB3:  LD      HL,S1218        ; Pointer to current reference position
        LD      E,(HL)          ;! fetch current reference position from memory
        INC     HL              ;!
        LD      D,(HL)          ;!
        PUSH    HL              ; Remember pointer to memory for position
        LD      HL,(S1221)      ; Offset from end character to start next character
        ADD     HL,DE           ; Calculate pointer to next position
        EX      DE,HL           ; Result after DE
        POP     HL              ; Get pointer to memory for reference position
        LD      (HL),D          ;! enter the new reference position back into the memory
        DEC     HL              ;!
        LD      (HL),E          ;!
        POP     BC              ; Get remaining number of characters to be output
        POP     HL              ; Get pointer to rest of text
        INC     HL              ; Pointer to text on next character
        JR      A4DAC           ; display additional characters enlarged
;
;
;   Output a character according to the magnification factor
;
A4DC8:  LD      IY,S1208        ; Pointer to memory containing characters
        LD      A,(HL)          ; get the character to be output
        RST     _DOCMD          ; Software - Execute command
        DEFB    29              ; Convert Code 29 ASCII characters in Accu to display code
        LD      H,0             ; High - byte value to zero
        LD      L,A             ; Character code as low - byte value
        ADD     HL,HL           ;! offset times two (8 bytes per character in ROM)
        ADD     HL,HL           ;!            four
        ADD     HL,HL           ;!            eight
        LD      A,010H          ; High - byte starting address of the character ROM
        ADD     A,H             ; add to the previous high byte
        LD      H,A             ; note the result
        LD      DE,S4D1D        ; Pointer to memory for current character (SYMBOL)
        LD      BC,8            ; Number of bytes for a character in the character - ROM
        DI                      ; Disable interrupts
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        LDIR                    ; Get Bit pattern for characters from Character - ROM
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Release interrupt again
        LD      B,8             ; 8 bytes per character
D4DE9:  CALL    A4EE1           ; Prepare characters according to angle (address is entered)
        LD      HL,256 * 8 + 8  ; Original character consists of 8 x 8 matrix
        LD      (S1209),HL      ; specify horizontal and vertical loop counters
        LD      DE,(S1212)      ; get horizontal / vertical magnification
        LD      (S121F),DE      ; Enter horizontal / vertical enlargement counter
        LD      HL,(S1218)      ; current X - reference position for SYMBOL
        BIT     7,H             ; value positive ?
        JR      Z,A4E16         ; yes --> output characters
        CALL    A4F32           ; test whether coordinates are positive at some point in the case of characters
        RET     C               ; all characters in the negative graphic area --> finished
A4E05:  EXX                       
        LD      B,8             ; eight bytes per character
        LD      HL,S1200        ; Pointer to in-place character pattern memory
A4E0B:  RLC     (HL)            ; shift a byte of the character by one bit
        INC     HL              ; Pointer to character to next byte
        DJNZ    A4E0B           ; shift more bytes of the character
        EXX                       
        DJNZ    A4E05           ; further investigate whether parts need to be issued
        LD      HL,0            ; Specification for the current X - position
A4E16:  LD      (D4E45 + 1),HL  ; Enter current X position in routine
        LD      A,11111000B     ; Mask for bit number in graphic byte
        AND     L               ; Hide the bit number of the graphic byte
        OR      H               ; plus high-order bits of the coordinate
        RRC     A               ;! Bits to correct value for
        RRC     A               ;! Slide Column Offset (by 8)
        RRC     A               ;!
A4E22:  SUB     80              ; compare with number of bytes per line (is entered)
        RET     NC              ; X - coordinate is outside the displayed range
        LD      L,A             ; Remember low - byte address
        LD      H,0+(S1200-1)/256 ; Specify high byte address
        LD      (S1210),HL      ; Remember pointers for provided byte masks of a row
        LD      HL,(S121A)      ; current Y - reference position for SYMBOL
        XOR     A               ; Accu to zero
        BIT     7,H             ; Y - coordinate positive ?
        JR      Z,A4E42         ; yes --> enlarge characters
        INC     IY              ; Correct base address for Y - values
        CALL    A4F32           ; test whether coordinates are positive at some point in the case of characters
        DEC     IY              ; Base address back to X values
        RET     C               ; Error occurred --> termination
        LD      HL,0            ; Specify Y coordinate
        LD      A,8             ;! calculate from which character position
        SUB     B               ;! is only issued.
A4E42:  LD      (D4E61 + 1),A   ; Enter offset to character in routine
D4E45:  LD      DE,0            ; current X - coordinate (is entered)
        PUSH    HL              ; Y - save coordinate
        PUSH    DE              ; X - save coordinate
        CALL    A46B2           ; check whether coordinates in DE,HL are in the displayed range
        POP     DE              ; Retrieve saved X coordinate
        POP     HL              ; retrieve saved Y coordinate
        RET     C               ; Error occurred --> termination
        CALL    A460F           ; absolute graphic address and bit no. calculate from coordinates
        LD      (S121C),HL      ; Pointer to graphic memory at SYMBOL
        LD      HL,B45C8        ; Table with specifications for bit by bit number
        LD      D,0             ; High - byte offset to zero
        LD      E,A             ; Bit number as low byte offset
        ADD     HL,DE           ; Calculate pointer to correct table value
        LD      A,(HL)          ; Get bit mask from table
        LD      (S121E),A       ; and remember
D4E61:  LD      HL,S1200        ; Pointer to the bit pattern of the character (is entered)
A4E64:  LD      DE,(S1210)      ; Pointer to provided byte masks of a row
        LD      BC,(S121E)      ; Get the start bit and the number of bits to be processed in the character
        XOR     A               ; Accu to zero
        EXX                       
        LD      B,(IY+1)        ; get second magnification factor
A4E71:  EXX                       
        LD      (DE),A          ; specify a byte for expanded characters
        XOR     A               ; Code 'NOP'
        RRC     (HL)            ; fetch a bit of character
        JR      NC,A4E7A        ; Point not set --> NOP
        LD      A,OR_C          ; Z-80 - Command OR C
A4E7A:  LD      (A4E7E),A       ; Z-80 - enter command in routine
        LD      A,(DE)          ; get default result
A4E7E:  OR      C               ; possibly plus new point
        RLC     C               ; Shift bit for next bit
        JR      NC,A4E88        ; not published yet
        LD      (DE),A          ; remember one byte of result
        INC     E               ; Result pointer to next byte
        JR      Z,A4E93         ; Offset reached at the end of the screen
        XOR     A               ; Default for result back to zero
A4E88:  DJNZ    A4E7E           ; more bits for magnification factor
        LD      B,(IY+10)       ; Remainder Get magnification factor
        EXX                       
        DJNZ    A4E71           ; prepare further values ??for horizontal enlargement
        EXX                       
        LD      (DE),A          ; Remember last edited value
        INC     E               ; Correct offset for loop end
A4E93:  DEC     E               ; Correct the offset of the provided data
        INC     L               ; Pointer to character default to next byte
        LD      (S120E),HL      ; Remember pointer to next byte of character
        LD      HL,(S1210)      ; Pointer to provided byte masks of a row
        EX      DE,HL           ; Swap pointers
        XOR     A               ; Reset carry flag
        SBC     HL,DE           ;! calculate how much values ??provided
        INC     HL              ;!
        LD      (S1223),HL      ; Note the number of values ??provided
        LD      A,(S1220)       ; get vertical magnification factor
        LD      B,A             ; and remember for loop
A4EA7:  EXX
        LD      DE,(S121C)      ; Pointer to graphic memory at SYMBOL
        LD      HL,(S1210)      ; Pointer to provided byte masks of a row
        LD      BC,(S1223)      ; Get number of provided values
        DI                      ; Disable interrupts
        IN      A,(_CGVIN)      ; Turn on character set rom and video ram
        OUT     (_00RAM),A      ; Switch to RAM from 00000H - 00FFFH
        LDIR                    ; Output values for a graphic series
        IN      A,(_CGVOT)      ; Turn off character set rom and video ram
        EI                      ; Release interrupt again
A4EBD:  LD      DE,80           ; Number of bytes per graphic line (is entered)
        LD      HL,(S121C)      ; Pointer to graphic memory at SYMBOL
        ADD     HL,DE           ; Calculate pointer to next graphic line
        LD      (S121C),HL      ; and remember
A4EC7:  LD      DE,SCREEN+16000 ; Specify end of used color memory (is entered)
        OR      A               ; Reset carry flag
        SBC     HL,DE           ; Graphic - check memory address
        RET     NC              ; from the graphic memory --> stop
        EXX                       
        DJNZ    A4EA7           ; Output characters more times for vertical enlargement
        LD      A,(S1213)       ; get vertical magnification factor
        LD      (S1220),A       ; and pretend again
        LD      HL,(S120E)      ; Get pointer to remainder bit pattern of character
        DEC     (IY+2)          ; horizontal loop counter minus one
        JP      NZ,A4E64        ; more layers
        RET
;
;
;   Output characters in standard position
;
A4EE1:  LD      HL,S4D1D        ; Pointer to memory for current character (SYMBOL)
        LD      DE,S1200        ; Pointer to in-place character pattern memory
        LD      C,B             ; Eight bytes for characters
        LD      B,0             ; High - byte count to zero
        LDIR                    ; Transfer character pattern 1 / 1 to memory
        RET
;
;
;   Zeichen um 90 Grad gedreht ausgeben
;
A4EED:  LD      DE,S1200        ; Zeiger auf Speicher f√ºr Zeichenmuster in richtiger Lage
A4EF0:  EXX
        LD      HL,S4D1D        ; Zeiger auf Speicher f√ºr aktuelles Zeichen  (SYMBOL)
        LD      B,8             ; acht Bit je Byte
        XOR     A               ; Vorgabe f√ºr Ergebnisbyte
A4EF7:  RLC     (HL)            ; Originalzeichen um ein Bit schieben
        RRA                     ; ein Bit des Bytes des Originalzeichens merken
        INC     HL              ; Zeiger auf Originalzeichen auf n√§chstes Byte
        DJNZ    A4EF7           ; weitere Bits aus Originalzeichen holen
        EXX
        LD      (DE),A          ; ein Byte des gedrehten Zeichens merken
        INC     DE              ; Zeiger auf Speicher auf n√§chstes Byte
        DJNZ    A4EF0           ; weitere Bytes gedrehtes Zeichen bereitstellen
        RET
;
;
;   Zeichen um 180 Grad gedreht ausgeben
;
A4F03:  LD      DE,S1200 + 7    ; Zeiger auf Speicher f√ºr Zeichenmuster in richtiger Lage
        LD      HL,S4D1D        ; Zeiger auf Speicher f√ºr aktuelles Zeichen  (SYMBOL)
A4F09:  LD      A,(HL)          ; ein Byte Originalzeichen holen
        EXX
        LD      C,A             ; Byte des Originalzeichens
        LD      B,8             ; acht Bit je Byte
        XOR     A               ; Vorgabe f√ºr Ergebnis
A4F0F:  RR      C               ;! Bits im Byte des Zeichens umkehren
        RL      A               ;!
        DJNZ    A4F0F           ;!
        EXX
        LD      (DE),A          ; ein Byte des gedrehten Zeichens merken
        INC     HL              ; Zeiger auf Original auf n√§chstes Byte
        DEC     DE              ; Zeiger f√ºr gedrehtes Zeichen auf n√§chstes Byte
        DJNZ    A4F09           ; weitere Bytes umkehren
        RET
;
;
;   Zeichen um 270 Grad gedreht ausgeben
;
A4F1C:  LD      DE,S1200 + 7    ; Zeiger auf Speicher f√ºr Zeichenmuster in richtiger Lage
A4F1F:  EXX
        LD      HL,S4D1D        ; Zeiger auf Speicher f√ºr aktuelles Zeichen  (SYMBOL)
        XOR     A               ; Vorgabe f√ºr Ergebnis
        LD      B,8             ; acht Bit je Byte
A4F26:  RLC     (HL)            ; ein Byte Originalzeichen um ein Bit schieben
        RLA                     ; ein Bit des Originalzeichens merken
        INC     HL              ; Zeiger auf Originalzeichen auf n√§chstes Byte
        DJNZ    A4F26           ; ein Byte gedrehtes Zeichen zusammenstellen
        EXX
        LD      (DE),A          ; ein Byte des gedrehten Zeichens merken
        DEC     DE              ; Zeiger auf Speicher f√ºr gedrehtes Zeichen auf n√§chstes Byte
        DJNZ    A4F1F           ; Vollst√§ndiges gedrehtes Zeichen bereitstellen
        RET
;
;
;   testen, ob Koordinate irgendwann einmal bei Zeichen positiv
;
A4F32:  LD      B,8             ; acht Punktreihen in Zeichenrichtung
        LD      E,(IY+10)       ; Vergr√∂√üerung der Richtung holen
        LD      D,0             ; High - Byte Vergr√∂√üerung auf Null
A4F39:  ADD     HL,DE           ; Vergr√∂√üerung ein mal zur Koordinate addieren
        BIT     7,H             ; Koordinate positiv  ?
        JR      Z,A4F42         ; ja -->  Werte merken
        DJNZ    A4F39           ; weiter testen
A4F40:  SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET
;
A4F42:  LD      A,H             ;! Koordinate gleich Null  ?
        OR      L               ;!
        JR      NZ,A4F4A        ; nein -->  merken
        LD      L,E             ; Vergr√∂√üerung als Koordinate vorgeben
        DEC     B               ; Z√§hler minus eins
        JR      Z,A4F40         ; gleich null -->  Fehler setzen
A4F4A:  LD      (IY+23),L       ; Koordinate merken
        LD      (IY+1),B        ; Restanzahl abzuarbeitende Punktreihen merken
        OR      A               ; Carry - Flag zur√ºcksetzen   (Code 'kein Fehler')
        RET
;
;
;   Graphic - Bitmuster in Bildspeicher eintragen     (A  = Anzahl Lagen)
;                    (B  = Textl√§nge)
;                    (DE = Zeiger auf Text)
;                    (H  = 0 -->  Lagen psoitiv)
;   (Software - Kommanod  74)
;
A4F52:  OR      A               ; Anzahl Lagen gleich Null  ?
        RET     Z               ; ja -->  alles vergessen
        LD      (S11A6),DE      ; Zeiger auf Graphic - Text merken
        LD      E,A             ;! Anzahl Lagen merken
        LD      C,A             ;!
        LD      A,H             ; Flag  'Lagen positiv'  holen
        OR      A               ; Lagen positiv  ?
        LD      A,INC_HL        ; Vorgabe  INC HL     (Z-80 - Befehl)
        JR      NZ,A4F62        ; Anzahl Lagen negativ
        LD      A,DEC_HL        ; Vorgabe  DEC HL     (Z-80 - Befehl)
A4F62:  LD      (D4FF5),A       ;! richtigen Befehl in Routine eintragen
        LD      (D4FE1),A       ;!
        LD      A,B             ; Anzahl Bytes Graphic-Text holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  fertig
        LD      HL,(S1088)      ; X - Koordinate Graphic - Cursor holen
        LD      A,00000111B     ; acht Punkte je Byte = 3 Bit in Koordinate
        AND     L               ; Bit - Nummer im Graphic - Byte maskieren
        LD      D,A             ; Anfangsbitnummer in Koordinate merken
        EXX
        LD      HL,B45B8        ; Tabelle zum Setzen der rechten Punkte nach Bit - Nummer
        LD      D,0             ; High - Byte Offset auf Null
        LD      E,A             ; Anfangsbitnummer in Koordinate
        ADD     HL,DE           ; Zeiger auf richtigen Maskenwert errechnen
        LD      A,(HL)          ; Maskenwert aus Tabelle holen
        LD      (D4F84 + 1),A   ; und in Routine eintragen
A4F7E:  LD      HL,(S108A)      ; Y - Koordinate Graphic - Cursor
A4F81:  LD      (S11A4),HL      ; aktuelle Y - Koordinate Graphic bei PATTERN
D4F84:  LD      C,11111111B     ; Vorgabe f√ºr zu setzendes Punktmuster in Byte   (wird eingetragen)
        LD      HL,(S11A6)      ; Zeiger auf Graphic - Text holen
        LD      A,(HL)          ; ein Byte des Graphic - Textes holen
        EXX
        LD      H,A             ; Byte des auszugebenden Graphic - Text - Musters
        LD      A,D             ; Anfangsbitnummer in Koordinate holen
        OR      A               ; gleich Null  ?
        JR      Z,A4F95         ; ja -->  Graphic-Text-Byte deckt sich mit Graphic-Speicher
A4F90:  RRC     H               ; Graphic - Text - Byte um ein Bit schieben
        DEC     A               ; Z√§hler minus eins
        JR      NZ,A4F90        ; weiter schieben
A4F95:  LD      A,H             ; Graphic - Text - Byte holen
        EXX
        LD      HL,S129E        ; Zeiger auf Speicher f√ºr aufbereitetes Punktmuster
        LD      B,8             ; acht Bit im Byte
        LD      D,A             ; Graphic - Textmuster merken
A4F9D:  SRL     D               ;! Graphic - Textmuster umkehren
        RLA                     ;!
        DJNZ    A4F9D           ; weiter schieben
        LD      D,A             ; Graphic - Text - Bit - Muster merken
        AND     C               ; Bits im ersten Byte maskieren
        LD      (HL),A          ; Pattern for  erstes Byte Betriebsart 1 merken
        LD      A,D             ;! Bits im Graphic - Text - Byte umkehren
        CPL                     ;!
        LD      B,A             ;!
        AND     C               ; relevante Bits im ersten Byte maskieren
        INC     HL              ; Zeiger auf Speicher f√ºr Muster auf n√§chste Stelle
        LD      (HL),A          ; Pattern for  erstes Byte Betriebsart 0 merken
        LD      A,C             ;! Bitmaske f√ºr zweites Byte  (Restbits)  errechnen
        CPL                     ;!
        LD      C,A             ;!
        AND     D               ; zu setzende Bits maskieren
        INC     HL              ; Zeiger auf Speicher f√ºr Muster auf n√§chste Stelle
        LD      (HL),A          ; Pattern for  zweites Byte Betriebsart 1 merken
        LD      A,C             ; Bitmaske holen
        AND     B               ; Bits f√ºr zweites Byte maskieren
        INC     HL              ; Zeiger auf Speicher f√ºr Muster auf n√§chste Stelle
        LD      (HL),A          ; Pattern for  zweites Byte Betriebsart 0 merken
        LD      DE,(S1088)      ; X - Koordinate Graphic - Cursor holen
        LD      HL,(S11A4)      ; aktuelle Y - Koordinate Graphic bei PATTERN
        PUSH    DE              ; X - Koordinate Graphic merken
        PUSH    HL              ; Y - Koordinate Graphic merken
        EX      DE,HL           ; X - Koordinate und Y - Koordinate vertauschen
        LD      BC,8            ; Anzahl Punkte in einer Lage
        ADD     HL,BC           ; X - Koordinate der n√§chsten Lage errechnen
        EX      DE,HL           ; X - Koordinate wieder nach DE
        LD      A,1             ; Code for 'zweites Byte behandeln'
        CALL    A5003           ; aufbereitetes Bitmuster in Graphic-Speicher √ºbertragen
        POP     HL              ; Y - Koordinate Graphic holen
        POP     DE              ; X - Koordinate Graphic holen
        XOR     A               ; Code for 'erstes Byte behandeln'
        CALL    A5003           ; aufbereitetes Bitmuster in Graphic-Speicher √ºbertragen
        LD      HL,(S11A6)      ; aktuelle Y - Koordinate Graphic bei PATTERN
        INC     HL              ; plus eins
        LD      (S11A6),HL      ; und wieder merken
        EXX
        DJNZ    A4FE7           ; weitere Graphic - Text - Zeichen ausgeben
        DEC     C               ; Anzahl Lagen minus eins
        EXX
        JP      Z,A4FF8         ; X - Koordinate Graphic f√ºr eine Lage corrigieren
        LD      HL,(S11A4)      ; aktuelle Y - Koordinate Graphic bei PATTERN
D4FE1:  INC     HL              ; f√ºr n√§chste LAge corrigieren  (Befehl wird eingetragen)
        LD      (S108A),HL      ; Y - Koordinate Graphic - Cursor merken
        XOR     A
        RET
;
A4FE7:  DEC     C               ; Anzahl Lagen minus eins
        JR      NZ,A4FF1        ; weitere Lagen
        LD      C,E             ; Anzahl Lagen wieder vorgeben
        EXX
        CALL    A4FF8           ; X - Koordinate Graphic f√ºr eine Lage corrigieren
        JR      A4F7E           ; Rest Graphic - Text ausgeben
;
A4FF1:  EXX
        LD      HL,(S11A4)      ; aktuelle Y - Koordinate Graphic bei PATTERN
D4FF5:  INC     HL              ; f√ºr n√§chste Lage corrigieren
        JR      A4F81
;
;
;   X - Koordinate Graphic f√ºr eine Lage corrigieren
;
A4FF8:  LD      HL,(S1088)      ; X - Koordinate Graphic - Cursor holen
        LD      BC,8            ; acht Punkte je Lage
        ADD     HL,BC           ; X - Koordinate corrigieren
        LD      (S1088),HL      ; X - Koordinate Graphic - Cursor merken
        RET
;
;
;   ein Byte aufbereitetes Bit pattern for  PATTERN in Graphic-Speicher √ºbertragen
;
A5003:  EX      AF,AF           ; Flag 'erstes/zweites Byte' merken
        CALL    A46B2           ; √ºberpr√ºfen, ob Koordinaten in DE,HL im angezeigten Bereich liegen
        RET     C               ; Fehler aufgetreten -->  Abbruch
        CALL    A460F           ; absolute Graphic-Adresse und Bitnr. aus Koordinaten errechnen
        LD      B,A             ; Bit - Nummer merken
        LD      DE,S129E        ; Zeiger auf Speicher f√ºr aufbereitetes Punktmuster
        EX      AF,AF           ; Flag 'erstes/zweites Byte' holen
        OR      A               ; erstes Byte  ?
        JR      Z,A5018         ; ja -->  auf jeden Muster ausgeben
        LD      A,B             ; Bit - Nummer holen
        OR      A               ; gleich null  ?
        RET     Z               ; ja -->  alle Bits im ersten Byte
        INC     DE              ;! Zeiger auf Bit pattern for  zweites Byte
        INC     DE              ;!
A5018:  CALL    A4669           ; Write - Format Register f√ºr 'Punkt setzen' setzen
        DI                      ; Interrupt sperren
        IN      A,(_CGVIN)      ; Zeichensatzrom und Video-Ram einschalten
        OUT     (_00RAM),A      ; Umschalten auf RAM von 00000H - 00FFFH
        LD      A,(DE)          ; ein Byte des Bitmusters holen
        LD      (HL),A          ; und in Graphic - Speicher eintragen
        LD      A,(S109A)       ; aktuellen √úberschreibmodus holen
        OR      A               ; Farbwerte addieren  ?
        JR      NZ,A5032        ; ja
        LD      A,(S109C)       ; Vorgabe f√ºr benutzte Farbebenen holen
        OR      01100000B       ; Code for 'RESET
        OUT     (CRTCWF),A      ; Steuerwort an Graphic-Controller ausgeben
        INC     DE              ; Zeiger auf richtiges Bitmuster
        LD      A,(DE)          ; Bit pattern for  Graphic-Byte holen
        LD      (HL),A          ; und in Graphic-Speicher eintragen
A5032:  IN      A,(_CGVOT)      ; Zeichensatzrom und Video-Ram ausschalten
        EI                      ; Interrupt wieder freigeben
        RET
;
;
;   Fl√§che ausf√ºllen      (HL = Zeiger auf Palettencodes f√ºr Rand)
;                         (B  = Anzahl Palettencodes)
;
;   (Software command code:  76)
;
A5036:  LD      A,(S109F)       ; aktuellen Graphic - Palettenwert holen
        OR      11000000B       ; plus Code for 'PSET
        OUT     (CRTCWF),A      ; an 'Write-Format-Register' des Bildschirm-Controllers ausgeben
        EXX
        LD      DE,S27D0        ; Zeiger auf Speicher f√ºr Routinenst√ºck
        LD      HL,T5556        ; Zeiger auf ersten Teil Routinenst√ºck zur Punktabfrage
        LD      BC,9            ; L√§nge erstes Teilst√ºck
        LDIR                    ; Routinenst√ºck in Speicher √ºbertragen
        EXX
A504A:  LD      A,(HL)          ; einen Palettencodewert f√ºr Rand holen
        CALL    A049C           ; Wert eventuell f√ºr Bildschirm II corrigieren
        OR      10000000B       ; plus Code for 'COLOR SEARCH'
        LD      (D555F + 1),A   ; f√ºr Read - Format - Register in Routine eintragen
        INC     HL              ; Zeiger auf n√§chsten Palettenwert 
        EXX
        LD      HL,D555F        ; Zeiger auf Routinenst√ºck zur Abfrage einer Palettencodeebene
        LD      BC,5            ; L√§nge Routinenst√ºck
        LDIR                    ; Routinest√ºck f√ºr einen Palettenwert bereitstellen
        EXX
        DJNZ    A504A           ; Routinenst√ºcke f√ºr weitere Palettenwerte bereitstellen
        EXX
        LD      BC,7            ; L√§nge Routinenst√ºck zum Wegschalten der Graphic-Speicher
        LDIR                    ; Routinenst√ºck hinter Rest Routine eintragen
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich  (Anfang freier Speicher)  holen
        LD      (S11A6),HL      ; als aktuellen Zeiger f√ºr PAINT - Werte merken
        LD      (A51CD + 2),HL  ; und als Zeiger auf Anfang PAINT-Werte in Routine eintragen
        LD      HL,(S137C)      ; Ende Arbeitsbereich f√ºr PAINT - Routine holen
        LD      DE,-6           ;! noch ein bischen Sicherheit dazupacken
        ADD     HL,DE           ;!
        LD      (D54D9 + 1),HL  ; und als maximale nutzbare Adresse in Routine eintragen
        LD      HL,(S1088)      ; X - Koordinate Graphic - Cursor holen
        DEC     HL              ; minus eins
        LD      (S11B1),HL      ; als linke X - Koordinate merken
        INC     HL              ; Wert wieder auf Originalkoordinate
        INC     HL              ; X - Koordinate plus eins
        LD      (S11B3),HL      ; als rechte X - Koordinate merken
        DEC     HL              ; Wert wieder auf Originalkoordinate
        EX      DE,HL           ; X - Koordinate nach DE
        LD      HL,0            ; HL auf Null
        LD      (S11A4),HL      ; als Anzahl noch zu testende Koordinaten merken
        LD      HL,(S108A)      ; Y - Koordinate Graphic - Cursor holen
        LD      (S11AF),HL      ; als Y - Koordinate f√ºr PAINT - Routine merken
        CALL    A46B2           ; √ºberpr√ºfen, ob Koordinaten in DE,HL im angezeigten Bereich liegen
        CCF                     ; Ergebnis umkehren
        RET     NC              ; Graphic - Koordinaten liegen nicht im angezeigten Bereich
        LD      (A54E1 + 1),SP  ; Stackpointer f√ºr Fehlerabbruch merken
        LD      SP,S2ED0        ; neuen Stackpointer vorgeben
        CALL    A460F           ; absolute Graphic-Adresse und Bitnr. aus Koordinaten errechnen
        LD      DE,B45C8        ; Tabelle mit Vorgabe f√ºr Bit nach Bit - Nummer
        PUSH    HL              ; Graphic - Speicheradresse errechnen
        LD      H,0             ; High - Byte Offset auf Null
        LD      L,A             ; Bit - Nummer als Low - Byte Offset merken
        ADD     HL,DE           ; Zeiger auf Bitwert in Tabelle errechnen
        LD      C,(HL)          ; Bitmaske aus Tabelle holen
        POP     HL              ; Graphic - Speicheradresse wieder holen
        CALL    S27D0           ; Abfrage, ob Punkt in angegebenen Palettenfarben gesetzt 
        AND     C               ; richtiges Bit im Byte maskieren
        JP      NZ,A5163        ; PAINT - Punkt ist gesetzt -->  fertig
        CALL    A5425           ; ausgehend von vorgegeb. Koord. rechte X - Koordinate  suchen
        LD      (S11B3),IX      ; rechte X - Koordinate PAINT merken
        CALL    A53F5           ; ausgehend von vorgegeb. Koord. linke X - Koordinate  suchen
        LD      (S11B1),IX      ; als linke X - Koordinate merken
        LD      A,11111111B
        LD      (S11B5),A       ; PAINT - Wert - Status merken
        CALL    A54D5           ; bereitgestellten PAINT - Datensatz merken
        LD      HL,S12A0
        LD      (S11A9),HL
        XOR     A               ; Accu auf Null
        LD      (S11B5),A       ; PAINT - Wert - Status zur√ºcksetzen
        LD      (S11A8),A
A50D6:  LD      A,(S11B5)       ; PAINT - Wert - Status holen
        CALL    A53C4           ; Y - Koordinate entsprechend Status √§ndern
        LD      A,199           ; maximale Y - Koordinate vorgeben
        CP      L               ; mit Y - Koordinate vergleichen
        JR      C,A5115         ; Richtung bis Bildschirmende abgearbeitet
        CALL    A539D
        JR      C,A5115
        LD      (S11B6),A
        AND     00001001B
        CALL    NZ,A518A
        CALL    A51CD
        LD      A,(S11B7)
        OR      A
        JR      NZ,A5115
A50F7:  CALL    A54FA           ; Punkte von rechter Koordinate bis Grenze setzen
        JR      Z,A50D6         ; Punkte bis zur linken X - Koordinate gesetzt -->  n√§chste Zeile
        LD      HL,(S11B3)      ; rechte X - Koordinate PAINT holen
        PUSH    HL              ; X - Koordinate merken
        PUSH    DE              ; linke Koordinate, bis wohin gezeichnet wurde
        CALL    A5429           ; rechte X - Koordinate ab Punkt suchen
        LD      (S11B3),IX      ; rechte X - Koordinate PAINT merken
        CALL    A54D5           ; bereitgestellten PAINT - Datensatz merken
        POP     HL              ; linke Koordinate, bis wohin gezeichnet wurde
        LD      (S11B1),HL      ; als linke X - Koordinate merken
        POP     HL              ; X - Koordinate holen
        LD      (S11B3),HL      ; als rechte X - Koordinate PAINT merken
        JR      A50D6           ; n√§chste Zeile untersuchen
;
A5115:  LD      HL,(S11A6)      ; aktuellen Zeiger f√ºr PAINT - Werte holen
        DEC     HL              ; Zeiger auf letztes Byte des letzten Wertes
        LD      DE,-7           ; L√§nge eines PAINT - Wertsatzes   (Complement)
        LD      BC,(S11A4)      ; aktuelle Anzahl PAINT - Werte holen
A5120:  LD      A,B             ;! Restanzahl Werte gleich Null  ?
        OR      C               ;!
        JR      Z,A515C         ; ja -->  untersuchen, ob noch weitere PAINT - Werte
        LD      A,00001111B
        DEC     BC              ; Restanzahl Datens√§tze minus eins
        CP      (HL)            ; Status vergleichen
        ADD     HL,DE           ; Zeiger auf Ende des vorherigen Datensatzes
        JR      Z,A5120         ; falscher Status -->  untersuchen, ob weitere Datens√§tze
        INC     HL              ; Zeiger auf Anfang PAINT - Wertsatz
        PUSH    HL              ; Zeiger auf Anfang PAINT - Wertsatz merken
        LD      (D5148 + 1),HL  ; und in Routine eintragen
        LD      DE,S11AF        ; Zeiger auf Speicher f√ºr PAINT - Datensatz
        LD      BC,7            ; L√§nge PAINT - Datensatz
        LDIR                    ; PAINT - Wertsatz in Speicher f√ºr PAINT - Datensatz √ºbertragen
        EX      DE,HL           ; Zeiger auf Ende PAINT - Wertsatz nach DE
        LD      HL,(S11A6)      ; aktuellen Zeiger f√ºr PAINT - Werte holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        POP     BC              ; Zeiger auf Anfang PAINT - Wertsatz holen
        LD      (S11A6),BC      ; als aktuellen Zeiger f√ºr PAINT - Werte merken
        SBC     HL,DE           ; aktueller PAINT - Wertsatz gleich letzter Wertsatz  ?
        JR      Z,A5152         ; ja -->  nur Anzahl PAINT - Werts√§tze corrigieren
        LD      B,H             ;! Anzahl Bytes der PAINT - Werts√§tze, die noch 
        LD      C,L             ;! dahinter liegen, nach BC √ºbertragen
D5148:  LD      HL,0            ; Zeiger auf PAINT - Wertsatz  (wird eingetragen)
        EX      DE,HL           ; Zeiger vertauschen
        LDIR                    ; restliche PAINT - Werts√§tze verschieben
        LD      (S11A6),DE      ; aktuellen Zeiger f√ºr PAINT - Werte holen
A5152:  LD      HL,(S11A4)      ; Anzahl PAINT - Werte holen
        DEC     HL              ; minus eins 
        LD      (S11A4),HL      ; und wieder merken
        JP      A50F7           ; bereitgestellten PAINT - Datensatz abarbeiten
;
A515C:  LD      HL,(S11A4)      ; Anzahl PAINT - Werte holen
        LD      A,L             ;! Anzahl gleich Null  ?
        OR      H               ;!
        JR      NZ,A5168        ; nein -->  n√§chsten bereitgestellten PAINT - Wert abarbeiten
A5163:  LD      SP,(A54E1 + 1)  ; Stackpointer wieder richtig setzen
        RET
;
A5168:  DEC     HL              ; Anzahl PAINT - Werte minus eins
        LD      (S11A4),HL      ; Restanzahl PAINT - Werte merken
        LD      HL,(S11A6)      ; aktuellen Zeiger f√ºr PAINT - Werte holen
        DEC     HL              ; Zeiger auf letztes Byte im letzten Datensatz
        LD      DE,S11B5        ; Zeiger auf Ende Speicher f√ºr PAINT - Datensatz
        LD      BC,7            ; L√§nge PAINT - Datensatz
        LDDR                    ; PAINT - Datensatz vorgeben
        INC     HL              ; Zeiger wieder corrigieren
        LD      (S11A6),HL      ; aktuellen Zeiger f√ºr PAINT - Werte merken
A517C:  CALL    A54FA           ; Punkte von rechter Koordinate bis Grenze setzen
        JR      Z,A515C         ; bis zur linken Koordinate gezeichnet -->  testen, ob fertig
        CALL    A5429           ; rechte X - Koordinate ab Punkt suchen
        LD      (S11B3),IX      ; rechte X - Koordinate PAINT merken
        JR      A517C           ; weiter zeichnen
;
;
;
;
A518A:  LD      HL,S11AB
        LD      DE,S11B9
        CALL    A51C7           ; 11 Byte vom (HL) nach (DE) √ºbertragen
        LD      A,(S11B6)
        BIT     0,A
        JR      Z,A51B2
A519A:  LD      HL,(S11AB)
        LD      (S11B3),HL      ; rechte X - Koordinate PAINT merken
        CALL    A53D1
        JR      C,A51A9
        BIT     0,A
        JR      NZ,A519A
A51A9:  CALL    A51C1
        LD      A,(S11B6)
        CP      9
        RET     NZ
A51B2:  LD      HL,(S11AD)
        LD      (S11B1),HL      ; als linke X - Koordinate merken
        CALL    A53D1
        JR      C,A51C1
        BIT     3,A
        JR      NZ,A51B2
A51C1:  LD      HL,S11B9
        LD      DE,S11AB
A51C7:  LD      BC,11
        LDIR
        RET
;
;
;
;
;
A51CD:  LD      IY,0            ; Zeiger auf Anfang PAINT - Werte   (wird eingetragen)
        LD      BC,(S11A4)      ; Anzahl PAINT - Werte holen
        LD      HL,0
        LD      (S11B7),HL
A51DB:  CALL    A5203
        LD      A,(S11A8)
        OR      A
        RET     Z
        DEC     A
        LD      (S11A8),A
        LD      (D51FE + 1),SP
        LD      SP,(S11A9)
        POP     IY
        POP     BC
        POP     HL
        LD      (S11B3),HL      ; rechte X - Koordinate aus PAINT - Datensatz merken
        POP     HL
        LD      (S11B1),HL      ; linke X - Koordinate aus PAINT - Datensatz merken
        LD      (S11A9),SP
D51FE:  LD      SP,0
        JR      A51DB
;
;
;
;
A5203:  LD      A,B             ;! Anzahl PAINT - Werte gleich Null  ?
        OR      C               ;!
        LD      (D528D + 1),BC  ; Anzahl PAINT - Werte in Routine eintragen
        JP      Z,A5294
        LD      HL,(S11AF)      ; Y - Koordinate Graphic (PAINT) holen
        LD      E,(IY+0)        ;! X - Koordinate aus PAINT - Wert - Datensatz holen
        LD      D,(IY+1)        ;!
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Y - Koordinaten vergleichen
        JR      NZ,A5288        ; nicht gleich -->  Zeiger auf n√§chsten Datensatz vorgeben und erneut testen
        CALL    A556B           ; X - Koordinaten im PAINT - Datensatz mit Wertsatz vergleichen
        CP      00000101B
        JR      Z,A5258
        CP      00001111B
        JR      NZ,A529C
        LD      L,(IY+2)        ;! linke X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+3)        ;!
        LD      DE,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Koordinaten vergleichen
        JR      NC,A5288        ;              -->  Zeiger auf n√§chsten Datensatz vorgeben und erneut testen
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL              ; und merken
        LD      L,(IY+2)        ;! linke X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+3)        ;!
        PUSH    HL              ; und merken
        LD      (S11B1),HL      ; als linke X - Koordinate PAINT - Datensatz vorgeben
        LD      A,00000011B
        CALL    A5334
        POP     HL              ; gemerkte linke X - Koordinate aus PAINT - Wertsatz
        LD      (S11B3),HL      ; rechte X - Koordinate aus PAINT - Datensatz holen
        POP     HL              ; gemerkte linke X - Koordinate aus PAINT - Wertsatz
        LD      (S11B1),HL      ; linke X - Koordinate aus PAINT - Datensatz holen
        CALL    A5425           ; ausgehend von vorgegeb. Koord. rechte X - Koordinate suchen
        LD      (S11B3),IX      ; rechte X - Koordinate aus PAINT - Datensatz holen
        JR      A5288           ; Zeiger auf n√§chsten Datensatz vorgeben und erneut testen
;
A5258:  LD      E,(IY+4)        ;! rechte X - Koordinate aus PAINT - Wertsatz holen
        LD      D,(IY+5)        ;!
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE
        JR      NC,A5288        ;        Zeiger auf n√§chsten Datensatz vorgeben und erneut testen
        LD      HL,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL              ; und merken
        LD      L,(IY+4)        ;! rechte X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+5)        ;!
        PUSH    HL              ; und merken
        LD      (S11B3),HL      ; als rechte X - Koordinate in PAINT - Datensatz eintragen
        LD      A,00000100B
        CALL    A5334
        POP     HL              ; gerettete rechte X - Koordinate au PAINT - Wertsatz
        LD      (S11B1),HL      ; als linke X - Koordinate in PAINT - Datensatz eintragen
        POP     HL              ; gerettete rechte X - Koordinate aus PAINT - Datensatz
        LD      (S11B3),HL      ; wieder als rechte X - Koordinate in PAINT - Datensatz 
        CALL    A53F5           ; ausgehend von vorgegebenen Koordinaten linke X - Koordinate suchen
        LD      (S11B1),IX      ; linke X - Koordinate in PAINT - Datensatz merken
A5288:  LD      DE,7            ; L√§nge PAINT - Wertsatz
        ADD     IY,DE           ; Zeiger auf n√§chsten PAINT - Wertsatz errechnen
D528D:  LD      BC,0            ; Restanzahl PAINT - Werte   (wird eingetragen)
        DEC     BC              ; minus eins
        JP      A5203           ; n√§chsten Datensatz testen
;
;
;
;
A5294:  LD      A,(S11B8)
        OR      A
        CALL    NZ,A54D5        ; einen Koordinatensatz als PAINT - Werte merken
        RET
;
;
;
;
A529C:  EX      AF,AF 
        LD      A,00001111B
        LD      (S11B7),A
        EX      AF,AF 
        OR      A
        JR      NZ,A52AC
        LD      A,00001111B
        LD      (IY+6),A
        RET
;
A52AC:  CP      00000001B
        JR      NZ,A52C2
        LD      L,(IY+4)        ;! rechte X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+5)        ;!
        LD      (S11B1),HL      ; linke X - Koordinate aus PAINT - Datensatz holen
        CALL    A53F5           ; ausgehend von vorgegebenen Koordinaten linke X - Koordinate suchen
        LD      (S11B1),IX      ; linke X - Koordinate aus PAINT - Datensatz holen
        JR      A52D6
;
A52C2:  CP      00001100B
        JR      NZ,A52E0
A52C6:  LD      L,(IY+2)        ;! linke X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+3)        ;!
        LD      (S11B3),HL      ; rechte X - Koordinate aus PAINT - Datensatz holen
        CALL    A5425           ; ausgehend von vorgegeb. Koord. rechte X - Koordinate suchen
        LD      (S11B3),IX      ; rechte X - Koordinate aus PAINT - Datensatz holen
A52D6:  LD      A,00001111B
        LD      (IY+6),A        ; Status in PAINT - Wertsatz merken
        LD      (S11B8),A
        JR      A5288
;
A52E0:  CP      00001101B
        JP      NZ,A5334
        LD      A,(S11A8)
        INC     A
        CP      01BH
        CCF
        JP      C,A54E1
        LD      (S11A8),A
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL              ; Koordinate retten
        LD      L,(IY+4)        ;! rechte X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+5)        ;!
        LD      (S11B1),HL      ; linke X - Koordinate aus PAINT - Datensatz holen
        CALL    A53F5           ; ausgehend von vorgegebenen Koordinaten linke X - Koordinate suchen
        LD      (D5329 + 2),IY
        LD      DE,7            ; L√§nge PAINT - Wertsatz
        ADD     IY,DE           ; Zeiger auf n√§chsten PAINT - Wertsatz errechnen
        LD      BC,(D528D + 1)
        DEC     BC
        LD      (D5326 + 1),SP
        LD      SP,(S11A9)
        PUSH    IX
        LD      DE,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        PUSH    DE
        PUSH    BC
        PUSH    IY
        LD      (S11A9),SP
D5326:  LD      SP,0
D5329:  LD      IY,0
        POP     HL
        LD      (S11B1),HL      ; linke X - Koordinate aus PAINT - Datensatz merken
        JP      A52C6
;
A5334:  EX      AF,AF 
        CALL    A54D5           ; einen Koordinatensatz als PAINT - Werte merken
        DEC     DE
        LD      A,00001111B
        LD      (DE),A
        EX      AF,AF 
        CP      00000011B
        JR      NZ,A535D
A5341:  LD      HL,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        LD      (S11B1),HL      ; linke X - Koordinate aus PAINT - Datensatz holen
        LD      L,(IY+4)        ;! rechte X - Koordinate aus PAINT - Wertdatensatz holen
        LD      H,(IY+5)        ;!
        LD      (S11B3),HL      ; rechte X - Koordinate aus PAINT - Datensatz holen
        CALL    A53F5           ; ausgehend von vorgegebenen Koordinaten linke X - Koordinate suchen
        PUSH    IX              ;! bereitgestellte linke X - Koordinate nach HL
        POP     HL              ;!
        LD      (IY+2),L        ;! linke X - Koordinate in PAINT - Wertsatz eintragen
        LD      (IY+3),H        ;!
        RET
;
A535D:  CP      00000100B
        JR      Z,A5381
        LD      HL,(S11A6)      ; Zeiger auf aktuelle PAINT - Werte holen
        PUSH    HL
        LD      (A54E6 + 1),IY
        CALL    A54D5           ; einen Koordinatensatz als PAINT - Werte merken
        LD      HL,S11AF
        LD      (A54E6 + 1),HL
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL
        CALL    A5341
        POP     HL
        LD      (S11B3),HL      ; rechte X - Koordinate im PAINT - Datensatz merken
        POP     IY
        JR      A5387
;
A5381:  LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        LD      (S11B3),HL      ; als rechte X - Koordinate in PAINT - Datensatz merken
A5387:  LD      L,(IY+2)        ;! linke X - Koordinate aus PAINT - Wertsatz holen
        LD      H,(IY+3)        ;!
        LD      (S11B1),HL      ; linke X - Koordinate im PAINT - Datensatz merken
        CALL    A5425           ; ausgehend von vorgegeb. Koord. rechte X - Koordinate suchen
        PUSH    IX              ;! herausgesuchte rechte X - Koordinate nach HL
        POP     HL              ;!
        LD      (IY+4),L        ;! rechte X - Koordinate im PAINT - Wertsatz merken
        LD      (IY+5),H        ;!
        RET
;
;
;
;
A539D:  LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        LD      (S11AB),HL      ; im Speicher f√ºr linke X - Koordinate merken
        LD      HL,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        LD      (S11AD),HL      ; im Speicher f√ºr rechte X - Koordinate merken
        CALL    A53F5           ; ausgehend von vorgegebenen Koordinaten linke X - Koordinate suchen
        RET     C
        LD      (S11B1),IX      ; linke X - Koordinate aus PAINT - Datensatz holen
        CALL    A5425           ; ausgehend von vorgegeb. Koord. rechte X - Koordinate suchen
        LD      (S11B3),IX      ; rechte X - Koordinate aus PAINT - Datensatz holen
        CALL    A54B1
        LD      A,B
        RET
;
;
;   Paint - Status umkehren und Y - Koordinate entsprechend PAINT - Status √§ndern
;
A53BD:  LD      A,(S11B5)       ; PAINT - Status aus PAINT - Datensatz holen
        CPL                     ; Status umkehren
        LD      (S11B5),A       ; und neuen Datensatz merken
;
; 
;   Y - Koordinate entsprechend Status √§ndern
;
A53C4:  LD      HL,(S11AF)      ; Y - Koordinate Graphic (PAINT) holen
        INC     L               ; Y - Koordinate plus eins
        OR      A               ; Status abfragen
        JR      NZ,A53CD        ; Koordinate ist OK
        DEC     L               ; Y - Koordinate wieder auf alten Wert
        DEC     L               ; Y - Koordinate minus eins
A53CD:  LD      (S11AF),HL      ; Y - Koordinate Graphic (PAINT) holen
        RET
;
;
;
;
A53D1:  CALL    A53BD           ; Status umkehren und Y - Koordinate entsprechend Status √§ndern
        CALL    A539D
        RET     C
        PUSH    AF
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL              ; und merken
        LD      HL,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL              ; und merken
        CALL    A51CD
        LD      A,(S11B7)
        OR      A
        CALL    Z,A54D5         ; einen Koordinatensatz als PAINT - Werte merken
        POP     H               ; gerettete rechte X - Koordinate holen
        LD      (S11B3),HL      ; rechte X - Koordinate wieder im PAINT - Datensatz merken
        POP     HL              ; gerettete linke X - Koodinate holen
        LD      (S11B1),HL      ; linke X - Koordinate wieder im PAINT - Datensatz merken
        POP     AF
        RET
;
;
;   ausgehend von vorgegebenen Koordinaten linke X - Koordinate suchen
;
A53F5:  LD      DE,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        PUSH    HL              ; Koordinate, von der ausgesucht werden soll, merken
        LD      (D54A8 + 1),DE  ; rechte Koordinate in Routine eintragen
        LD      HL,0            ; minimale Koordinate vorgeben
        LD      (D547C + 1),HL  ; und in Routine eintragen
        LD      A,DEC_HL        ; Z-80 - Befehl  DEC HL
        LD      (D546E + 1),A   ; in Routine eintragen
        LD      A,_CPL           ; Z-80 - Befehl  CPL
        LD      (D54A0),A       ; in Routine eintragen
        XOR     A               ; Z-80 - Befehl  NOP
        LD      (D548A),A       ; in Routine eintragen
        LD      HL,A5471
        LD      (D5468 + 1),HL
        LD      HL,A5490
        LD      (D546B + 1),HL
        POP     DE              ; Koordinate, von der ausgegangen werden soll, holen
        INC     DE              ; Koordinate corrigieren
        JR      A5450           ; linke X - Koordinate suchen
;
;
;    ausgehend von vorgegebenen Koordinaten rechte X - Koordinate suchen
;
A5425:  LD      DE,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
A5429:  LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        LD      (D547C + 1),HL  ; linke Koordinate in Routine eintragen
A542F:  LD      HL,SCREEN+2
        LD      (D54A8 + 1),HL
        LD      A,INC_HL        ; Z-80 - Befehl  INC HL
        LD      (D546E + 1),A   ; in Routine eintragen
        LD      A,_CPL           ; Z-80 - Befehl  CPL
        LD      (D548A),A       ; in Routine eintragen
        XOR     A               ; Z-80 - Befehl  NOP
        LD      (D54A0),A       ; in Routine eintragen
        LD      HL,A5490
        LD      (D5468 + 1),HL
        LD      HL,A5471
        LD      (D546B + 1),HL
        DEC     DE              ; X - Koordinate corrigieren
A5450:  LD      HL,(S11AF)      ; Y - Koordinate Graphic (PAINT) holen
        PUSH    DE              ;! aktuelle X - Koordinate als Ergebniskoordinate vorgeben
        POP     IX              ;!
        CALL    A460F           ; absolute Graphic-Adresse und Bit-Nr. aus Koordinaten errechnen
        LD      DE,B45C8        ; Tabelle f√ºr Bit - Maske nach Bit - Nummer
        PUSH    HL              ; Graphic - Koordinate merken
A545B:  ;=??
        LD      H,0             ; High - Byte Offset auf Null
        LD      L,A             ; Bit - Nummer als Low - Byte Offset vorgeben
        ADD     HL,DE           ; Zeiger auf Tabelle auf richtiges Muster
        LD      C,(HL)          ; Pattern for  Bitnummer aus Tabelle holen
        POP     HL              ; Zeiger auf Graphic - Speicher holen
        CALL    S27D0           ; Abfrage, ob Punkte mit Palettenfarben gesetzt sind
        LD      E,A             ; Ergebnis merken
        AND     C               ; richtiges Bits maskieren
D5468:  JP      Z,A5471         ; Punkt in angegebenen Palettenfarben nicht gesetzt
D546B:  CALL    A5490
D546E:  DEC     IX              ; X - Koordinate Ergebnis corrigieren
        RET
;
A5471:  DEC     IX              ; X - Koordinate minus eins
        RRC     C               ; ein Bit Abfrage - Ergebnis
        JR      NC,A5489        ; keine Umrandung gefunden
        PUSH    IX              ; bisher gefundene X - Koordinate
        EXX
        POP     DE              ; nach DE holen
        INC     DE              ; Umrandung nicht mitz√§hlen
D547C:  LD      HL,0
        INC     HL
        SBC     HL,DE           ; Differenz errechnen
        EXX
        RET     NC
        DEC     HL              ; Zeiger auf Graphic - Speicher auf voriges Byte
        CALL    S27D0           ; Abfrage, ob Punkte mit Palettenfarben gesetzt sind
        LD      E,A             ; Ergebnis der Abfrage merken
A5489:  LD      A,E
D548A:  NOP
        AND     C
        JP      Z,A5471
        RET
;
A5490:  INC     IX              ; X - Koordinate plus eins
        RLC     C
        JR      NC,A549F
        CALL    A54A4
        RET     C
        INC     HL              ; Zeiger auf Graphic - Speicher auf n√§chstes Byte
        CALL    S27D0           ; Abfrage, ob Punkte mit Palettenfarben gesetzt sind
        LD      E,A             ; Ergebnis der Abfrage merken
A549F:  LD      A,E
D54A0:  CPL
        AND     C
        JR      Z,A5490
A54A4:  PUSH    IX
        EXX
        POP     HL
D54A8:  LD      DE,S11B3
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Differenz errechnen
        EXX
        CCF                     ; Ergebnis umkehren
        RET
;
A54B1:  LD      B,0             ; Vorgabe f√ºr Ergebnis
        LD      HL,(S11AD)      ; Wert aus Speicher f√ºr rechte X - Koordinate holen
        LD      DE,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        CALL    A54C6           ; Koordinaten vergleichen und Ergebnis merken
        LD      HL,(S11AB)      ; Wert aus Speicher f√ºr linke X - Koordinate holen
        LD      DE,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        INC     HL
        INC     DE
A54C6:  PUSH    HL              ; Koordinate retten
        XOR     A               ; Carry - Flag zur√ºcksetzen
        INC     HL
        SBC     HL,DE           ; Koordinaten vergleichen
        POP     HL              ; gerettete Koordinate holen
        RL      B               ; Ergebnis merken
        INC     DE
        EX      DE,HL
        SBC     HL,DE           ; Koordinaten vergleichen
        RL      B               ; Ergebnis merken
        RET
;
;
;   testen, ob noch Platz vorhanden und bereitgestellten PAINT - Datensatz merken
;
A54D5:  LD      DE,(S11A6)      ; Zeiger auf aktuelle PAINT - Werte holen
D54D9:  LD      HL,0            ; maximal nutzbare Adresse f√ºr Paint  (wird eingetragen)
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; mit aktueller Adresse vergleichen
        JR      NC,A54E6        ; Adresse ist OK -->  Datensatz merken
A54E1:  LD      SP,0            ; Stackpointer neu setzen   (Adresse wird eingetragen)
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET                     ; Kommando abbrechen
;
;
;   bereitgestellten Koordinaten - Datensatz f√ºr PAINT merken
;
A54E6:  LD      HL,S11AF        ; Zeiger auf Speicher mit PAINT - Datensatz
        LD      BC,7            ; Datensatzl√§nge 
        LDIR                    ; einen PAINT - Datensatz merken
        LD      (S11A6),DE      ; Zeiger auf aktuellen Speicher f√ºr PAINT - Werte merken
        LD      HL,(S11A4)      ; Anzahl PAINT - Werte holen
        INC     HL              ; plus eins
        LD      (S11A4),HL      ; und wieder merken
        RET
;
;
;   Punkte von rechts bis Randpunkt setzen 
;
A54FA:  LD      HL,(S11AF)      ; Y - Koordinate Graphic (PAINT) holen
        LD      DE,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        DEC     DE              ; X - Koordinate minus eins
        CALL    A460F           ; absolute Graphic-Adresse und Bit-Nr. aus Koordinaten errechnen
        LD      DE,B45C0        ; Tabelle zum Setzen der rechten Bits nach Bit-Nummer
        PUSH    HL              ; Zeiger auf Graphic - Speicher merken
        LD      H,0             ; High - Byte Offset auf Null
        LD      L,A             ; Bit - Nummer im Graphic - Byte
        ADD     HL,DE           ; Zeiger auf richtiges Bitmuster errechnen
        INC     C               ; Differenz f√ºr Anzahl Bytes corrigieren
        LD      B,C             ; Anzahl zu testende Bytes merken
        LD      C,(HL)          ; Maske aus Tabelle holen
        POP     HL              ; Zeiger auf Graphic - Speicher holen
A5511:  CALL    S27D0           ; Abfrage, ob Punkte mit Palettenfarben gesetzt sind
        AND     C               ; testen, ob Rand im Byte liegt
        JR      NZ,A5528        ; Rand im Byte -->  nur fehlende Punkte setzen
        DI                      ; Interrupt sperren
        IN      A,(_CGVIN)      ; Zeichensatzrom und Video-RAM einschalten
        LD      (HL),C          ; Bits setzen
        IN      A,(_CGVOT)      ; Zeichensatzrom und Video-RAM ausschalten
        EI                      ; Interrupt wieder freigeben
        LD      C,11111111B     ; neue Setzmaske vorgeben
        DEC     HL              ; Zeiger auf Graphic - Speicher auf voriges Byte
        DJNZ    A5511           ; weitere Bytes behandeln
        LD      DE,-1
        JR      A554F
;
A5528:  LD      E,B             ; Restanzahl zu testende Bytes merken
        LD      B,7             ; maximal sieben Bit schieben
        LD      D,0             ; Vorgabe f√ºr Setzmaske
A552D:  RLC     A               ; ein Bit nach Carry schieben
        JR      C,A5536         ; Rand gefunden
        SCF                     ; Carry - Bit setzen
        RR      D               ; ein Bit f√ºr Setzmaske merken
        DJNZ    A552D           ; weiter nach Rand suchen
A5536:  IN      A,(_CGVIN)      ; Zeichensatzrom und Video-RAM einschalten
        LD      A,C             ; Originalsetzmaske holen
        AND     D               ; richtige Setzmaske errechnen
        LD      (HL),A          ; und nach Graphic - Speicher ausgeben
        IN      A,(_CGVOT)      ; Zeichensatzrom und Video-RAM ausschalten
        LD      A,E             ; Restanzahl zu testende Bytes holen
        DEC     A               ; corrigieren
        RLC     A
        RLC     A
        RLC     A
        LD      C,A
        LD      A,00000111B
        AND     C
        LD      D,A
        LD      A,11111000B
        AND     C
        OR      B
        LD      E,A
A554F:  XOR     A               ; Carry - Flag zur√ºcksetzen
        LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        SBC     HL,DE
        RET
;
;
;   Programmvorgaben zur Abfrage, ob Punkte mit speziellem Palettenwert im Graphic-Speicher gesetzt sind
;
T5556:  PUSH    HL              ; Bildspeicheradresse auf Stack ablegen
        EXX
        POP     HL              ; Bildspeicheradresse holen
        DI                      ; Interrupt sperren
        IN      A,(_CGVIN)      ; Zeichensatzrom und Video-RAM einschalten
        LD      C,CRTCRF        ; Portnummer des Read-Format-Registers vorgeben
        XOR     A               ; Vorgabe f√ºr Ergebniswert
;
D555F:  LD      B,0             ; abzufragender Palettencode  (wird eingetragen)
        OUT     (C),B           ; an Bildschirm - Controller ausgeben
        OR      (HL)            ; merken, ob Punkt mit Palettencodewert gesetzt ist
;
        LD      E,A             ; Ergebnis merken
        IN      A,(_CGVOT)      ; Zeichensatzrom und Video-RAM ausschalten
        EI                      ; Interrupt sperren
        LD      A,E             ; gerettetetes Ergebnis holen
        EXX
        RET
;
;
;   X - Koordinaten im PAINT - Datensatz mit X - Koordinaten im PAINT - Wertsatz vergleichen
;
A556B:  LD      HL,(S11B1)      ; linke X - Koordinate aus PAINT - Datensatz holen
        LD      E,(IY+2)        ;! linke X - Koordinate aus PAINT - Wert - Satz holen
        LD      D,(IY+3)        ;!
        INC     HL              ; PAINT - Datensatzkoordinate plus eins
        INC     DE              ; PAINT - Wert - Satzkoordinate plus eins
        XOR     A               ; Vorgabe f√ºr Ergebnis
        CALL    A5583           ; Koordinaten vergleichen
        LD      HL,(S11B3)      ; rechte X - Koordinate aus PAINT - Datensatz holen
        LD      E,(IY+4)        ;! rechte X - Koordinate aus PAINT - Wert - Satz holen
        LD      D,(IY+5)        ;!
A5583:  SBC     HL,DE           ; Koordinaten vergleichen
        RLA                     ;! Ergebnis nach Accu retten
        RLA                     ;!
        RET     Z               ; Ergebnis gleich Null
        OR      00000001B       ; Code for 'Ergebnis <> 0' merken
        RET
;
        DEFS    629             ; kann nur von einem miserablem Linker kommen  (ist nicht genutzt)
 
;   Kaltstart  BASIC - Interpreter
;
A5800:  PUSH    BC              ; Auto - Run - Flag retten
        CALL    A585D           ; Bildschirm auf Standardwerte initialisieren
        POP     BC              ; Auto - Run - Flag holen
        LD      HL,SA473        ; Zeiger auf Ende Basic - Interpreter
        LD      (S1070),HL      ; als Anfangsadresse f√ºr BASIC - Programm merken
        LD      HL,T586F        ; Warmstartadresse  BASIC
        LD      (W004D),HL      ; als Start - Adresse f√ºr Basic - Interpreter merken
        LD      A,B             ; Auto - Run - Flag holen
        OR      A               ; gesetzt  ?
D5813:  JP      Z,A5825         ; nein -->  kein Auto - Run
        CP      1
        JR      Z,A5825
        LD      HL,B584D        ; Text  'RUN "AUTO RUN"'
        LD      DE,S1353        ; Zeiger auf Speicher f√ºr Funktionstastentext
        LD      BC,16           ; L√§nge Text
        LDIR                    ; Text √ºbertragen
A5825:  LD      DE,M9EB5        ; Zeiger auf Copyright - Meldung
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    5               ; Code 5  Text (DE) mit Gro√ü-/Kleinschreibung ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    32              ; Code 32  Referenzton ausgeben
        LD      A,_JP           ; JP nn   (Z-80 - Befehl)
        LD      (D5813),A       ; in Routine eintragen
        LD      HL,T5837        ; Adresse f√ºr Start ohne Auto - Run
        LD      (D5813 + 1),HL  ; in Routine eintragen
T5837:  LD      HL,SA473        ; Zeiger auf Anfang Speicher f√ºr Basic - Programm
A583A:  LD      (HL),0          ; ein Byte Speicher l√∂schen
        INC     HL              ; Zeiger auf Speicher auf n√§chstes Byte
        LD      A,H             ; High - Byte Speicheradresse holen
        CP      XFF00/256       ; gleich High - Byte Speicherende  ?
        JR      C,A583A         ; nein -->  Rest Speicher l√∂schen
        CALL    A616E           ; Zeiger auf Rechenspeicher merken
        CALL    A6180           ; alle BASIC - Werte l√∂schen
        CALL    A755E           ; Cassettenroutinen und RS232 initialisieren
        JR      A5872           ; Warmstart  BASIC - Interpreter
;
;
;   Funktionstastentextvorgabe f√ºr Auto - Start
;
B584D:  DEFB    15
        DEFM    "RUN "
		DEFB    '"'
		DEFM    "AUTO RUN"
		DEFB    '"',CR
;
;
;   Bildschirm auf Standardwerte initialisieren
;
A585D:  LD      A,1             ; Bildschirm-Modus 1   (320 x 200 Punkte/4 Farben)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    80              ; Code 80  Bildschirmbetriebsart setzen
        XOR     A               ; Code for 'Punkte in angegebener Farbe setzen'
        LD      (S109A),A       ; als aktuellen √úberschreibmodus merken
        INC     A               ; Accu auf eins
        LD      (S137A),A       ; Bildschirm - Modus - Nummer setzen
        LD      (S1379),A       ; Bildschirm - Modus - Bit setzen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    86              ; Code 86   Bildschirm initialisieren
        RET
;
;
;   Warmstart  BASIC - Interpreter
;
T586F:  CALL    A585D           ; Bildschirm auf Standardwerte initialisieren
;
;
;   Interpreter  Eingabe - Schleife
;
A5872:  LD      HL,A6403        ;  Anfangsadresse  BASIC - Fehlerbehandlung
        LD      (S004F),HL      ; als Fehlerbehandlungsadresse eintragen
A5878:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    2               ; Code 2  Zeilenvorschub, wenn Cursor nicht auf Anfang Zeile
        LD      DE,M63F0        ; Text  'Ready'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    5               ; Code 5  Text (DE) mit Gro√ü-/Kleinschreibung ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    1               ; Code 1  Zeilenvorschub auf Bildschirm ausgeben
;
;
;   n√§chste Zeile von Tastatur holen und abarbeiten
;
A5881:  LD      A,(M63F6)       ; CONT - Flag holen
        OR      A               ; CONT m√∂glich  ?
        JR      NZ,A5893        ; ja -->  Stack nicht ver√§ndern
        LD      SP,(S107C)      ; h√∂chste nutzbare Basic - Adresse holen
        LD      HL,-1           ; Code for 'keine Werte auf Stack'
        PUSH    HL              ; auf Stack ablegen
        LD      (S9E64),SP      ; Stackpointer bei Anfang Befehl merken
A5893:  LD      HL,0            ; Code for 'in direkter Programmierung'
        LD      (S9E51),HL      ; als aktuelle Zeilennummer merken
        XOR     A               ; Accu auf Null
        LD      (S108E),A       ; Textausgabeflag f√ºr Cassette zur√ºcksetzen
        CALL    A611D           ; wenn im AUTO-Modus -->  Zeilennummer (und Zeile) ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    67              ; Code 67  Datei-Daten der Ausgabe-Datei bei Fehler l√∂schen
        LD      DE,S11A4        ; Zeiger auf Speicher f√ºr Zeile vorgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    12              ; Code 12  Zeile von Tastatur nach Speicher (DE) holen
        JR      NC,A58B4        ; Eingabe nicht geBREAKt -->  Zeile abarbeiten
A58A9:  LD      HL,S611C        ; Zeiger auf AUTO - Flag
        LD      A,(HL)          ; AUTO - Flag holen
        OR      A               ; im AUTO - Modus  ?
        LD      (HL),0          ; AUTO - Flag zur√ºcksetzen
        JR      NZ,A5878        ; AUTO-Modus -->  Ready ausgeben und n√§chste Zeile abarbeiten
        JR      A5881           ; n√§chste Zeilen von Tastatur holen
;
;
;   eingegebenen Text auswerten und abarbeiten
;
A58B4:  CALL    A79BC           ; Zeiger in DE auf n√§chstes relevantes Zeichen
        OR      A               ; Zeilenendezeichen  ?
        JR      Z,A5881         ; ja -->  n√§chste Zeilen von Tastatur holen
        CALL    A79F6           ; testen, ob Zeichen im Accu gleich Ziffer ist
        JP      NC,A5FAD        ; Ziffer -->  Zeile umsetzen in Zwischencode und merken
        LD      HL,M9EB5        ; Zeiger auf Speicher f√ºr Zeile im Zwischencode
        PUSH    HL              ; Zeiger auf Anfang Speicher merken
        CALL    A8216           ; ASCII - Text - Zeile (DE) umsetzen in Zwischencode
        INC     HL              ; Zeilenendezeichen √ºberspringen
        LD      (S9E4B),HL      ; Zeiger auf n√§chste Programmzeile merken
        CALL    A61C5           ; (HL)  Bereichsende  (00 00)  eintragen
        POP     HL              ; Zeiger auf Zwischencodezeile holen
        JR      A58D4           ; Zeile abarbeiten
;
T58D1:  CALL    A797A           ; auf Syntax 'Befehlsende' √ºberpr√ºfen
;
;
;   Process intermediate code line (HL).
;
A58D4:  LD      (S9E64),SP      ; Remember stack pointer at start of command
A58D8:  LD      DE,T58D1        ; Return address for end of command
        PUSH    DE              ; put on stack
A58DC:  LD      (S9E66),HL      ; Remember program pointer at start of command
        CALL    A001E           ; Query whether Shift - BREAK is pressed
        JP      Z,A00E8         ; yes --> interrupt program
A58E5:  LD      A,(HL)          ; fetch next program byte
        INC     HL              ; Skip program byte
        CP      080H            ; intermediate code ?
        JR      NC,A593F        ; yes --> Call command routine
        CP      '\''             ; comment ?
        JP      Z,A67FE         ; yes --> search for the end of the comment
        CP      ' '             ; spaces ?
        JR      Z,A58E5         ; yes --> get the next character and process it
        CP      ':'             ; colon ?
        JR      Z,A58DC         ; yes --> process next command
        OR      A               ; newline character ?
        JR      Z,A5906         ; yes --> fetch and process the next line
        DEC     HL              ; Set pointer back to program byte
        SUB     'A'             ;! Letter  ?
        CP      26              ;!
        JP      C,A650D         ; yes --> LET - routine
        JP      A6364           ; Error 1 Syntax error
;
;
;   n√§chste BASIC - Programm - Zeile holen und abarbeiten
;
A5906:  LD      HL,(S9E4B)      ; Get pointer to next program line
A5909:  LD      E,(HL)          ;! Get offset to next line
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      A,D             ;! Offset to next line equal to zero ?
        OR      E               ;!
        JR      Z,A5928         ; yes --> output any pending errors
        LD      (S108E),A       ; Set text output flag cassette to output
        EX      DE,HL           ; Pointer to current line after DE
        ADD     HL,DE           ;! Calculate pointer to next program line
        DEC     HL              ;!
        LD      (S9E4B),HL      ; Remember pointer to next program line
        EX      DE,HL           ; Pointer to current line after HL
        INC     HL              ; Skip remainder offset
        CALL    A012D           ; Get line number of line from program text
        LD      (S9E51),DE      ; remember as the current line number
        CALL    A61E4           ; if TRON --> output line number
        POP     DE              ; Discard return address
        JR      A58D4           ; process line
;
;
;   Program ended --> check whether there are still errors
;
A5928:  POP     HL              ; R√ºcksprungadresse vom Stack holen
        CALL    A596B           ; Abfrage, ob in direkter Programmierung
        JP      Z,A5878         ; ja -->  n√§chste Zeile von Tastatur holen
        XOR     A               ; Code for 'kein CONT m√∂glich'
        LD      (M63F6),A       ; CONT - Flag zur√ºcksetzen
        LD      A,(S9E54)       ; ON - ERROR - GOTO - Status holen
        CP      2               ; Code for 'Fehler aufgetreten'  ?
        JP      Z,A6391         ; ja -->  Fehler 20  Can't RESUME error
        PUSH    HL              ; R√ºcksprungadresse wieder ablegen
        JP      A60B9           ; END - Routine aufrufen
;
;
;   einen BASIC - Befehl abarbeiten
;
A593F:  CP      0FFH            ; prebyte table three ?
        JP      Z,A653F         ; yes --> examine for command in table three
        LD      DE,W5D1B        ; Pointer to address table commands table two
        CP      0FEH            ; prebyte table two ?
        JR      NZ,A594F        ; no --> process command from table one
        LD      A,(HL)          ; get actual intermediate code
        INC     HL              ; Skip intermediate code
        JR      A5957           ; Get the start address of the command from the table
;
A594F:  CP      0E0H            ; largest command in table one
        JP      NC,A6364        ; Function --> Error 1 Syntax error
        LD      DE,W5C5B        ; Pointer to address table commands table one
A5957:  ADD     A,A             ; intermediate code times two
        PUSH    HL              ; Save program pointer
        EX      DE,HL           ; Pointer to address table according to HL
        LD      E,A             ;! Load DE with offset on table
        LD      D,0             ;!
        ADD     HL,DE           ; Calculate pointer to start address of command
        LD      A,(HL)          ;! Get the start address of the command from the table
        INC     HL              ;!
        LD      H,(HL)          ;!
        LD      L,A             ;!
        EX      (SP),HL         ; Get address on stack/program pointer
;
;
;   testen, ob n√§chstes Byte Befehlsendezeichen ist   (wenn ja -->  Zero gesetzt)
;
A5963:  CALL    A015E           ; Leerzeichen  (Spaces)  (HL) √ºberspringen
A5966:  OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja
        CP      ':'             ; Befehlsendezeichen  ?
        RET
;
;
;   Query whether in direct programming (if yes --> zero flag set)
;
A596B:  PUSH    HL              ; Register - Wert retten
        LD      HL,(S9E51)      ; aktuelle Zeilennummer holen
        LD      A,L             ;! Zeilennummer gleich Null  (in direkter
        OR      H               ;!                            Programmierung)  ?
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;	Tables for converting the BASIC command words into the intermediate code (TOKEN)
;
M5973:  DEFM    "GOT"           ; 128  GOTO
        DEFB    'O'+0x80
        DEFM    "GOSU"          ; 129  GOSUB
        DEFB    'B'+0x80
        DEFB    _free           ; 130  (free for GO)

        DEFM    "RU"            ; 131  RUN
        DEFB    'N'+0x80
        DEFM    "RETUR"         ; 132  RETURN
        DEFB    'N'+0x80
        DEFM    "RESTOR"        ; 133  RESTORE
        DEFB    'E'+0x80
        DEFM    "RESUM"         ; 134  RESUME
        DEFB    'E'+0x80
        DEFM    "LIS"           ; 135  LIST
        DEFB    'T'+0x80
        DEFB    _free           ; 136

        DEFM    "DELET"         ; 137  DELETE
        DEFB    'E'+0x80
        DEFM    "RENU"          ; 138  RENUM
        DEFB    'M'+0x80
        DEFM    "AUT"           ; 139  AUTO
        DEFB    'O'+0x80
        DEFM    "EDI"           ; 140  EDIT
        DEFB    'T'+0x80
        DEFM    "FO"            ; 141  FOR
        DEFB    'R'+0x80
        DEFM    "NEX"           ; 142  NEXT
        DEFB    'T'+0x80
        DEFM    "PRIN"          ; 143  PRINT
        DEFB    'T'+0x80
        DEFB    _free           ; 144

        DEFM    "INPU"          ; 145  INPUT
        DEFB    'T'+0x80
        DEFB    _free           ; 146

        DEFM    "I"             ; 147  IF
        DEFB    'F'+0x80
        DEFM    "DAT"           ; 148  DATA
        DEFB    'A'+0x80
        DEFM    "REA"           ; 149  READ
        DEFB    'D'+0x80
        DEFM    "DI"            ; 150  DIM
        DEFB    'M'+0x80
        DEFM    "RE"            ; 151  REM
        DEFB    'M'+0x80
        DEFM    "EN"            ; 152  END
        DEFB    'D'+0x80
        DEFM    "STO"           ; 153  STOP
        DEFB    'P'+0x80
        DEFM    "CON"           ; 154  CONT
        DEFB    'T'+0x80
        DEFM    "CL"            ; 155  CLS
        DEFB    'S'+0x80
        DEFB    _free           ; 156

        DEFM    "O"             ; 157  ON
        DEFB    'N'+0x80
        DEFM    "LE"            ; 158  LET
        DEFB    'T'+0x80
        DEFM    "NE"            ; 159  NEW
        DEFB    'W'+0x80
        DEFM    "POK"           ; 160  POKE
        DEFB    'E'+0x80
        DEFM    "OF"            ; 161  OFF
        DEFB    'F'+0x80
        DEFM    "PMOD"          ; 162  PMODE    (MODE on MZ-700)
        DEFB    'E'+0x80
        DEFM    "PSKI"          ; 163  PSKIP    (SKIP on MZ-700)
        DEFB    'P'+0x80
        DEFM    "PLO"           ; 164  PLOT
        DEFB    'T'+0x80
        DEFM    "PLIN"          ; 165  PLINE    (LINE on MZ-700)
        DEFB    'E'+0x80
        DEFM    "RLIN"          ; 166  RLINE
        DEFB    'E'+0x80
        DEFM    "PMOV"          ; 167  PMOVE    (MOVE on MZ-700)
        DEFB    'E'+0x80
        DEFM    "RMOV"          ; 168  RMOVE
        DEFB    'E'+0x80
        DEFM    "TRO"           ; 169  TRON
        DEFB    'N'+0x80
        DEFM    "TROF"          ; 170  TROFF
        DEFB    'F'+0x80
        DEFM    "INP"           ; 171  INP@
        DEFB    '@'+0x80
        DEFM    "DEFAUL"        ; 172  DEFAULT
        DEFB    'T'+0x80
        DEFM    "GE"            ; 173  GET
        DEFB    'T'+0x80
        DEFM    "PCOLO"         ; 174  PCOLOR
        DEFB    'R'+0x80
        DEFM    "PHOM"          ; 175  PHOME
        DEFB    'E'+0x80
        DEFM    "HSE"           ; 176  HSET
        DEFB    'T'+0x80
        DEFM    "GPRIN"         ; 177  GPRINT
        DEFB    'T'+0x80
        DEFM    "KE"            ; 178  KEY
        DEFB    'Y'+0x80
        DEFM    "AXI"           ; 179  AXIS      
        DEFB    'S'+0x80
        DEFM    "LOA"           ; 180  LOAD
        DEFB    'D'+0x80
        DEFM    "SAV"           ; 181  SAVE
        DEFB    'E'+0x80
        DEFM    "MERG"          ; 182  MERGE
        DEFB    'E'+0x80
        DEFM    "CHAI"          ; 183  CHAIN
        DEFB    'N'+0x80
        DEFM    "CONSOL"        ; 184  CONSOLE
        DEFB    'E'+0x80
        DEFM    "SEARC"         ; 185  SEARCH
        DEFB    'H'+0x80
        DEFM    "OUT"           ; 186  OUT@
        DEFB    '@'+0x80
        DEFM    "PCIRCL"        ; 187  PCIRCLE  (CIRCLE on MZ-700)
        DEFB    'E'+0x80
        DEFM    "PTES"          ; 188  PTEST    (TEST on MZ-700)
        DEFB    'T'+0x80
        DEFM    "PAG"           ; 189  PAGE
        DEFB    'E'+0x80
        DEFM    "WAI"           ; 190  WAIT
        DEFB    'T'+0x80
        DEFM    "SWA"           ; 191  SWAP
        DEFB    'P'+0x80
        DEFB    _free           ; 192

        DEFM    "ERRO"          ; 193  ERROR     
        DEFB    'R'+0x80
        DEFM    "ELS"           ; 194  ELSE
        DEFB    'E'+0x80
        DEFM    "US"            ; 195  USR
        DEFB    'R'+0x80
        DEFM    "BY"            ; 196  BYE
        DEFB    'E'+0x80
        DEFB    _free           ; 197

        DEFB    _free           ; 198

        DEFM    "DE"            ; 199  DEF
        DEFB    'F'+0x80
        DEFB    _free           ; 200

        DEFB    _free           ; 201

        DEFM    "LABE"          ; 202  LABEL
        DEFB    'L'+0x80
        DEFB    _free           ; 203

        DEFB    _free           ; 204

        DEFB    _free           ; 205

        DEFM    "WOPE"          ; 206  WOPEN
        DEFB    'N'+0x80
        DEFM    "CLOS"          ; 207  CLOSE
        DEFB    'E'+0x80
        DEFM    "ROPE"          ; 208  ROPEN
        DEFB    'N'+0x80
        DEFM    "XOPE"          ; 209  XOPEN
        DEFB    'N'+0x80
        DEFB    _free           ; 210

        DEFB    _free           ; 211

        DEFB    _free           ; 212

        DEFM    "DI"            ; 213  DIR
        DEFB    'R'+0x80
        DEFB    _free           ; 214

        DEFB    _free           ; 215

        DEFM    "RENAM"         ; 216  RENAME
        DEFB    'E'+0x80
        DEFM    "KIL"           ; 217  KILL
        DEFB    'L'+0x80
        DEFM    "LOC"           ; 218  LOCK
        DEFB    'K'+0x80
        DEFM    "UNLOC"         ; 219  UNLOCK
        DEFB    'K'+0x80
        DEFM    "INI"           ; 220  INIT   
        DEFB    'T'+0x80
        DEFB    _free           ; 221

        DEFB    _free           ; 222

        DEFB    _free           ; 223           (RMOV on MZ-700)

        DEFM    "T"             ; 224  TO
        DEFB    'O'+0x80
        DEFM    "STE"           ; 225  STEP
        DEFB    'P'+0x80
        DEFM    "THE"           ; 226  THEN
        DEFB    'N'+0x80
        DEFM    "USIN"          ; 227  USING
        DEFB    'G'+0x80
        DEFB    _free           ; 228  (free for PI)

        DEFM    "AL"            ; 229  ALL
        DEFB    'L'+0x80
        DEFM    "TA"            ; 230  TAB
        DEFB    'B'+0x80
        DEFM    "SP"            ; 231  SPC
        DEFB    'C'+0x80
        DEFB    _free           ; 232

        DEFB    _free           ; 233

        DEFM    ".XO"           ; 234  XOR
        DEFB    'R'+0x80
        DEFM    ".O"            ; 235  OR
        DEFB    'R'+0x80
        DEFM    ".AN"           ; 236  AND
        DEFB    'D'+0x80
        DEFM    ".NO"           ; 237  NOT
        DEFB    'T'+0x80
        DEFM    ">"             ; 238  ><
        DEFB    '<'+0x80
        DEFM    "<"             ; 239  <>
        DEFB    '>'+0x80
        DEFM    "="             ; 240  =<
        DEFB    '<'+0x80
        DEFM    "<"             ; 241  <=
        DEFB    '='+0x80
        DEFM    "="             ; 242  =>
        DEFB    '>'+0x80
        DEFM    ">"             ; 243  >=
        DEFB    '='+0x80
        DEFB    '='+0x80        ; 244  =

        DEFB    '>'+0x80        ; 245  >

        DEFB    '<'+0x80        ; 246  <

        DEFB    '+'+0x80        ; 247  +

        DEFB    '-'+0x80        ; 248  -

        DEFB    0x7D+0x80       ; 249  (Backslash)

        DEFM    ".MO"           ; 250  MOD
        DEFB    'D'+0x80
        DEFB    '/'+0x80        ; 251  /

        DEFB    '*'+0x80        ; 252  *

        DEFB    '^'+0x80        ; 253  ^
        DEFB    -1              ; 'End of table'
;
;
;   Tabelle mit BASIC - Befehlsw√∂rtern mit Vorbyte 0FEH im Zwischencode
;
M5B16:  DEFB    _free           ; 254 128

        DEFM    "CSE"           ; 254 129  CSET     (SET   on MZ-700)
        DEFB    'T'+0x80
        DEFM    "CRESE"         ; 254 130  CRESET   (RESET on MZ-700)
        DEFB    'T'+0x80
        DEFM    "CCOLO"         ; 254 131  CCOLOR   (COLOR on MZ-700)
        DEFB    'R'+0x80
        DEFB    _free           ; 254 132

        DEFB    _free           ; 254 133

        DEFB    _free           ; 254 134  (free for VARLEN)

        DEFB    _free           ; 254 135  (free for MAXDIM)

        DEFB    _free           ; 254 136

        DEFB    _free           ; 254 137

        DEFM    "SOUN"          ; 254 138  SOUND
        DEFB    'D'+0x80
        DEFB    _free           ; 254 139

        DEFM    "NOIS"          ; 254 140  NOISE
        DEFB    'E'+0x80
        DEFM    "BEE"           ; 254 141  BEEP
        DEFB    'P'+0x80
        DEFB    _free           ; 254 142  (free for VOICE)

        DEFB    _free           ; 254 143  (free for BORDER)

        DEFM    "COLO"          ; 254 144  COLOR 
        DEFB    'R'+0x80
        DEFB    _free           ; 254 145  (free for PRTY)

        DEFM    "SE"            ; 254 146  SET
        DEFB    'T'+0x80
        DEFM    "RESE"          ; 254 147  RESET
        DEFB    'T'+0x80
        DEFM    "LIN"           ; 254 148  LINE
        DEFB    'E'+0x80
        DEFM    "BLIN"          ; 254 149  BLINE
        DEFB    'E'+0x80
        DEFM    "PA"            ; 254 150  PAL
        DEFB    'L'+0x80
        DEFM    "CIRCL"         ; 254 151  CIRCLE
        DEFB    'E'+0x80
        DEFM    "BO"            ; 254 152  BOX
        DEFB    'X'+0x80
        DEFM    "PAIN"          ; 254 153  PAINT
        DEFB    'T'+0x80
        DEFM    "POSITIO"       ; 254 154  POSITION
        DEFB    'N'+0x80
        DEFM    "PATTER"        ; 254 155  PATTERN
        DEFB    'N'+0x80
        DEFM    "HCOP"          ; 254 156  HCOPY
        DEFB    'Y'+0x80
        DEFB    _free           ; 254 157  (free for KPATTERN)

        DEFB    _free           ; 254 158  (free for FPRINT)

        DEFB    _free           ; 254 159  (free for TCOPY)

        DEFM    "SYMBO"         ; 254 160  SYMBOL
        DEFB    'L'+0x80
        DEFB    _free           ; 254 161

        DEFM    "MUSI"          ; 254 162  MUSIC
        DEFB    'C'+0x80
        DEFM    "TEMP"          ; 254 163  TEMPO
        DEFB    'O'+0x80
        DEFM    "CURSO"         ; 254 164  CURSOR
        DEFB    'R'+0x80
        DEFM    "VERIF"         ; 254 165  VERIFY
        DEFB    'Y'+0x80
        DEFM    "CL"            ; 254 166  CLR
        DEFB    'R'+0x80
        DEFM    "LIMI"          ; 254 167  LIMIT
        DEFB    'T'+0x80
        DEFB    _free           ; 254 168

        DEFB    _free           ; 254 169

        DEFB    _free           ; 254 170

        DEFB    _free           ; 254 171

        DEFB    _free           ; 254 172

        DEFB    _free           ; 254 173

        DEFM    "BOO"           ; 254 174  BOOT
        DEFB    'T'+0x80
        DEFB    -1              ; 'End of table'

;
;
;   Tabelle mit BASIC - Befehlsw√∂rtern mit Vorbyte 0FFH im Zwischencode
;
M5BAD:  DEFM    "IN"            ; 255 128  INT
        DEFB    'T'+0x80
        DEFM    "AB"            ; 255 129  ABS
        DEFB    'S'+0x80
        DEFM    "SI"            ; 255 130  SIN
        DEFB    'N'+0x80
        DEFM    "CO"            ; 255 131  COS
        DEFB    'S'+0x80
        DEFM    "TA"            ; 255 132  TAN
        DEFB    'N'+0x80
        DEFM    "L"             ; 255 133  LN
        DEFB    'N'+0x80
        DEFM    "EX"            ; 255 134  EXP
        DEFB    'P'+0x80
        DEFM    "SQ"            ; 255 135  SQR
        DEFB    'R'+0x80
        DEFM    "RN"            ; 255 136  RND
        DEFB    'D'+0x80
        DEFM    "PEE"           ; 255 137  PEEK
        DEFB    'K'+0x80
        DEFM    "AT"            ; 255 138  ATN
        DEFB    'N'+0x80
        DEFM    "SG"            ; 255 139  SGN
        DEFB    'N'+0x80
        DEFM    "LO"            ; 255 140  LOG
        DEFB    'G'+0x80
        DEFM    "FRA"           ; 255 141  FRAC
        DEFB    'C'+0x80
        DEFM    "PA"            ; 255 142  PAI
        DEFB    'I'+0x80
        DEFM    "RA"            ; 255 143  RAD
        DEFB    'D'+0x80
        DEFB    _free           ; 255 144

        DEFB    _free           ; 255 145

        DEFB    _free           ; 255 146

        DEFB    _free           ; 255 147

        DEFB    _free           ; 255 148

        DEFB    _free           ; 255 149

        DEFB    _free           ; 255 150

        DEFB    _free           ; 255 151

        DEFB    _free           ; 255 152

        DEFB    _free           ; 255 153

        DEFB    _free           ; 255 154

        DEFB    _free           ; 255 155

        DEFM    "STIC"          ; 255 156  STICK
        DEFB    'K'+0x80
        DEFM    "STRI"          ; 255 157  STRIG
        DEFB    'G'+0x80
        DEFB    _free           ; 255 158  (free for JOY)

        DEFB    _free           ; 255 159

        DEFM    "CHR"           ; 255 160  CHR$
        DEFB    '$'+0x80
        DEFM    "STR"           ; 255 161  STR$
        DEFB    '$'+0x80
        DEFM    "HEX"           ; 255 162  HEX$
        DEFB    '$'+0x80
        DEFB    _free           ; 255 163

        DEFB    _free           ; 255 164

        DEFB    _free           ; 255 165

        DEFB    _free           ; 255 166

        DEFB    _free           ; 255 167

        DEFM    "SPACE"         ; 255 168  SPACE$
        DEFB    '$'+0x80
        DEFB    _free           ; 255 169  (free for ASCCHR$)

        DEFB    _free           ; 255 170

        DEFM    "AS"            ; 255 171  ASC
        DEFB    'C'+0x80
        DEFM    "LE"            ; 255 172  LEN
        DEFB    'N'+0x80
        DEFM    "VA"            ; 255 173  VAL
        DEFB    'L'+0x80
        DEFB    _free           ; 255 174

        DEFB    _free           ; 255 175

        DEFB    _free           ; 255 176

        DEFB    _free           ; 255 177

        DEFB    _free           ; 255 178  (free for HEXCHR$)

        DEFM    "ER"            ; 255 179  ERN
        DEFB    'N'+0x80
        DEFM    "ER"            ; 255 180  ERL
        DEFB    'L'+0x80
        DEFM    "SIZ"           ; 255 181  SIZE
        DEFB    'E'+0x80
        DEFM    "CSR"           ; 255 182  CSRH
        DEFB    'H'+0x80
        DEFM    "CSR"           ; 255 183  CSRV
        DEFB    'V'+0x80
        DEFM    "POS"           ; 255 184  POSH
        DEFB    'H'+0x80
        DEFM    "POS"           ; 255 185  POSV
        DEFB    'V'+0x80
        DEFM    "LEFT"          ; 255 186  LEFT$
        DEFB    '$'+0x80
        DEFM    "RIGHT"         ; 255 187  RIGHT$
        DEFB    '$'+0x80
        DEFM    "MID"           ; 255 188  MID$
        DEFB    '$'+0x80
        DEFB    _free           ; 255 189  (free for FONT$)

        DEFB    _free           ; 255 190

        DEFB    _free           ; 255 191

        DEFB    _free           ; 255 192

        DEFB    _free           ; 255 193

        DEFB    _free           ; 255 194

        DEFB    _free           ; 255 195

        DEFM    "TI"            ; 255 196  TI$
        DEFB    '$'+0x80
        DEFM    "POIN"          ; 255 197  POINT
        DEFB    'T'+0x80
        DEFM    "EO"            ; 255 198  EOF
        DEFB    'F'+0x80
        DEFM    "F"             ; 255 199  FN    
        DEFB    'N'+0x80
        DEFB    -1              ; 'End of table'
;
;
;   Tabelle mit Anfangsadressen der Befehle ohne Vorbyte
;
W5C5B:  DEFW    A69AF           ; 128  GOTO
        DEFW    A692A           ; 129  GOSUB
        DEFW    A6364           ; 130  (frei f√ºr GO)
        DEFW    A606E           ; 131  RUN
        DEFW    A68F9           ; 132  RETURN 
        DEFW    A6E9E           ; 133  RESTORE
        DEFW    A64B6           ; 134  RESUME
        DEFW    A6A9D           ; 135  LIST
        DEFW    A6364           ; 136                     
        DEFW    A620C           ; 137  DELETE
        DEFW    A62AB           ; 138  RENUM 
        DEFW    A60CA           ; 139  AUTO  
        DEFW    A6125           ; 140  EDIT  
        DEFW    A6602           ; 141  FOR   
        DEFW    A6699           ; 142  NEXT  
        DEFW    A6C9F           ; 143  PRINT 
        DEFW    A6364           ; 144        
        DEFW    A6DD4           ; 145  INPUT 
        DEFW    A6364           ; 146        
        DEFW    A69C2           ; 147  IF    
        DEFW    A67FE           ; 148  DATA
        DEFW    A6DCD           ; 149  READ
        DEFW    A8DCC           ; 150  DIM 
        DEFW    A67FE           ; 151  REM 
        DEFW    A60B9           ; 152  END 
        DEFW    A6468           ; 153  STOP
        DEFW    A6499           ; 154  CONT
        DEFW    A7972           ; 155  CLS 
        DEFW    A6364           ; 156      
        DEFW    A6952           ; 157  ON  
        DEFW    A650D           ; 158  LET 
        DEFW    A618E           ; 159  NEW 
        DEFW    A68A1           ; 160  POKE
        DEFW    A6364           ; 161  OFF 
        DEFW    AA017           ; 162  PMODE    (MODE bei MZ-700)       
        DEFW    AA07C           ; 163  PSKIP    (SKIP bei MZ-700)
        DEFW    AA42A           ; 164  PLOT
        DEFW    AA0BE           ; 165  PLINE    (LINE bei MZ-700)
        DEFW    AA0C1           ; 166  RLINE     
        DEFW    AA0C4           ; 167  PMOVE    (MOVE bei MZ-700)
        DEFW    AA0C7           ; 168  RMOVE     
        DEFW    A61CC           ; 169  TRON      
        DEFW    A61DF           ; 170  TROFF        
        DEFW    A681F           ; 171  INP@      
        DEFW    A6F41           ; 172  DEFAULT     
        DEFW    A686C           ; 173  GET       
        DEFW    AA12C           ; 174  PCOLOR          
        DEFW    AA161           ; 175  PHOME         
        DEFW    AA164           ; 176  HSET           
        DEFW    AA16F           ; 177  GPRINT     
        DEFW    A6B84           ; 178  KEY             
        DEFW    AA1D7           ; 179  AXIS      
        DEFW    A6FFD           ; 180  LOAD        
        DEFW    A73C0           ; 181  SAVE        
        DEFW    A7068           ; 182  MERGE           
        DEFW    A7053           ; 183  CHAIN     
        DEFW    A6A61           ; 184  CONSOLE   
        DEFW    A6A9B           ; 185  SEARCH    
        DEFW    A680A           ; 186  OUT@           
        DEFW    AA217           ; 187  PCIRCLE  (CIRCLE bei MZ-700)
        DEFW    AA3E5           ; 188  PTEST    (TEST bei MZ-700)
        DEFW    AA3F3           ; 189  PAGE
        DEFW    A67EE           ; 190  WAIT
        DEFW    A74A6           ; 191  SWAP       
        DEFW    A6364           ; 192             
        DEFW    A63F8           ; 193  ERROR     
        DEFW    A69E4           ; 194  ELSE  
        DEFW    A67A4           ; 195  USR   
        DEFW    A6A59           ; 196  BYE         
        DEFW    A6364           ; 197                  
        DEFW    A6364           ; 198                 
        DEFW    A6C31           ; 199  DEF   
        DEFW    A6364           ; 200                
        DEFW    A6364           ; 201               
        DEFW    A67FE           ; 202  LABEL        
        DEFW    A6364           ; 203        
        DEFW    A6364           ; 204       
        DEFW    A6364           ; 205              
        DEFW    A6F59           ; 206  WOPEN       
        DEFW    B6F8A           ; 207  CLOSE  
        DEFW    A6F56           ; 208  ROPEN  
        DEFW    A6F5C           ; 209  XOPEN   
        DEFW    A6364           ; 210           
        DEFW    A6364           ; 211          
        DEFW    A6364           ; 212         
        DEFW    A7424           ; 213  DIR     
        DEFW    A6364           ; 214            
        DEFW    A6364           ; 215            
        DEFW    A744B           ; 216  RENAME 
        DEFW    A6F8B           ; 217  KILL      
        DEFW    A7418           ; 218  LOCK     
        DEFW    A7416           ; 219  UNLOCK     
        DEFW    A6F47           ; 220  INIT
        DEFW    A6364           ; 221
        DEFW    A6364           ; 222
        DEFW    A6364           ; 223
;
;
;   Tabelle mit Anfangsadressen der Routinen mit Vorbyte 0FEH
;
W5D1B:  DEFW    A6364           ; 254 128        
        DEFW    A6364           ; 254 129  CSET  
        DEFW    A6364           ; 254 130  CRESET
        DEFW    A6364           ; 254 131  CCOLOR
        DEFW    A6364           ; 254 132        
        DEFW    A6364           ; 254 133        
        DEFW    A6364           ; 254 134        
        DEFW    A6364           ; 254 135        
        DEFW    A6364           ; 254 136        
        DEFW    A6364           ; 254 137       
        DEFW    A9BAC           ; 254 138  SOUND 
        DEFW    A6364           ; 254 139        
        DEFW    A9BE3           ; 254 140  NOISE      
        DEFW    A6A56           ; 254 141  BEEP   
        DEFW    A6364           ; 254 142  
        DEFW    A6364           ; 254 143             
        DEFW    A7675           ; 254 144  COLOR       
        DEFW    A6364           ; 254 145  
        DEFW    B7592           ; 254 146  SET       
        DEFW    A7593           ; 254 147  RESET     
        DEFW    B75A1           ; 254 148  LINE      
        DEFW    A75A2           ; 254 149  BLINE    
        DEFW    A7619           ; 254 150  PAL       
        DEFW    A774C           ; 254 151  CIRCLE        
        DEFW    A7648           ; 254 152  BOX       
        DEFW    A76FD           ; 254 153  PAINT        
        DEFW    A75F5           ; 254 154  POSITION                       
        DEFW    A75C4           ; 254 155  PATTERN   
        DEFW    A7968           ; 254 156  HCOPY     
        DEFW    A6364           ; 254 157  
        DEFW    A6364           ; 254 158  
        DEFW    A6364           ; 254 159           
        DEFW    A790F           ; 254 160  SYMBOL   
        DEFW    A6364           ; 254 161           
        DEFW    A9BE6           ; 254 162  MUSIC    
        DEFW    A9BD9           ; 254 163  TEMPO    
        DEFW    A683B           ; 254 164  CURSOR   
        DEFW    A73A9           ; 254 165  VERIFY   
        DEFW    A619B           ; 254 166  CLR      
        DEFW    A68B5           ; 254 167  LIMIT    
        DEFW    A6364           ; 254 168           
        DEFW    A6364           ; 254 169           
        DEFW    A6364           ; 254 170           
        DEFW    A6364           ; 254 171           
        DEFW    A6364           ; 254 172           
        DEFW    A6364           ; 254 173           
        DEFW    A6A95           ; 254 174  BOOT     
;
;
;   Tabelle mit Anfangsadressen der Routinen f√ºr Funktionen mit Vorbyte 0FFH
;
W5D79:  DEFW    A95C2           ; 255 128  INT     
        DEFW    A95BD           ; 255 129  ABS     
        DEFW    A9709           ; 255 130  SIN     
        DEFW    A96F9           ; 255 131  COS     
        DEFW    A97E8           ; 255 132  TAN     
        DEFW    A9A4F           ; 255 133  LN      
        DEFW    A992B           ; 255 134  EXP     
        DEFW    A961F           ; 255 135  SQR     
        DEFW    A98E6           ; 255 136  RND     
        DEFW    A98DA           ; 255 137  PEEK    
        DEFW    A963D           ; 255 138  ATN     
        DEFW    A98A0           ; 255 139  SGN     
        DEFW    A9A43           ; 255 140  LOG     
        DEFW    A7BC0           ; 255 141  FRAC    
        DEFW    A98B8           ; 255 142  PAI     
        DEFW    A98B3           ; 255 143  RAD     
        DEFW    A6364           ; 255 144          
        DEFW    A6364           ; 255 145          
        DEFW    A6364           ; 255 146          
        DEFW    A6364           ; 255 147          
        DEFW    A6364           ; 255 148          
        DEFW    A6364           ; 255 149          
        DEFW    A6364           ; 255 150          
        DEFW    A6364           ; 255 151          
        DEFW    A6364           ; 255 152          
        DEFW    A6364           ; 255 153          
        DEFW    A6364           ; 255 154          
        DEFW    A6364           ; 255 155          
        DEFW    A9060           ; 255 156  STICK   
        DEFW    A907F           ; 255 157  STRIG   
        DEFW    A6364           ; 255 158  
        DEFW    A6364           ; 255 159          
        DEFW    A6364           ; 255 160  CHR$    
        DEFW    A8931           ; 255 161  STR$    
        DEFW    A88F0           ; 255 162  HEX$    
        DEFW    A6364           ; 255 163          
        DEFW    A6364           ; 255 164          
        DEFW    A6364           ; 255 165          
        DEFW    A6364           ; 255 166          
        DEFW    A6364           ; 255 167          
        DEFW    A8913           ; 255 168  SPACE$  
        DEFW    A6364           ; 255 169  
        DEFW    A6364           ; 255 170          
        DEFW    A8992           ; 255 171  ASC     
        DEFW    A899C           ; 255 172  LEN     
        DEFW    A89A4           ; 255 173  VAL     
        DEFW    A6364           ; 255 174          
        DEFW    A6364           ; 255 175          
        DEFW    A6364           ; 255 176          
        DEFW    A6364           ; 255 177          
        DEFW    A6364           ; 255 178  
        DEFW    A887A           ; 255 179  ERN     
        DEFW    A8888           ; 255 180  ERL     
        DEFW    A8852           ; 255 181  SIZE    
        DEFW    A8864           ; 255 182  CSRH    
        DEFW    A8869           ; 255 183  CSRV    
        DEFW    A886E           ; 255 184  POSH    
        DEFW    A8874           ; 255 185  POSV    
        DEFW    A89B6           ; 255 186  LEFT$   
        DEFW    A89D3           ; 255 187  RIGHT$  
        DEFW    A89F0           ; 255 188  MID$    
        DEFW    A6364           ; 255 189  
        DEFW    A6364           ; 255 190        
        DEFW    A6364           ; 255 191        
        DEFW    A6364           ; 255 192        
        DEFW    A6364           ; 255 193        
        DEFW    A6364           ; 255 194        
        DEFW    A6364           ; 255 195        
        DEFW    A8A46           ; 255 196  TI$   
        DEFW    A896C           ; 255 197  POINT 
        DEFW    A893F           ; 255 198  EOF   
        DEFW    A8FBF           ; 255 199  FN    
        DEFW    A6364           ; 255 200
        DEFW    A6364           ; 255 201
        DEFW    A6364           ; 255 202
        DEFW    A6364           ; 255 203
        DEFW    A6364           ; 255 204
        DEFW    A6364           ; 255 205
        DEFW    A6364           ; 255 206
        DEFW    A6364           ; 255 207
;
;
;   Zeiger auf Zeile nach Programmtext (HL) nach DE bereitstellen
;
A5E19:  CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    _LIN_P          ; Code for 'Zeiger auf Zeile'  ?
        JR      NZ,A5E25        ; nicht Zeiger auf Zeile
        CALL    A012D           ; Zeiger auf Zeile aus Programmtext nach DE holen
        OR      0FFH            ; Carry- und Zero - Flag zur√ºcksetzen
        RET
;
A5E25:  INC     HL              ; Programmbyte √ºberspringen
        CP      _LINNO          ; Code for 'Integer - Zeilennummer'  ?
        JR      NZ,A5E49        ; nein -->  auf Labelnamen testen
        LD      E,(HL)          ;! Zeilennummer aus Programmtext holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL              
        LD      A,E             ;! Zeilennummer gleich Null  ?
        OR      D               ;!
        RET     Z               ; ja
        EX      DE,HL           ; Zeilennummer nach HL
        CALL    A5E78           ; Zeiger auf Zeile nach Zeilennummer in HL bereitstellen
        JP      C,A6385         ; Zeile nicht gefunden -->  Fehler 16  Un def. line error
        EX      DE,HL           ; Zeiger auf Zeile nach DE
        DEC     HL              ; Programmzeiger auf Stelle f√ºr Zeiger auf Zeile
        LD      (HL),D          ;! Zeiger auf Zeile anstatt Zeilennummer im 
        DEC     HL              ;! Programmtext eintragen (braucht beim n√§chsten
        LD      (HL),E          ;!                         mal nicht mehr gesucht werden)
        DEC     HL              
        LD      (HL),_LIN_P     ; Code for 'Zeiger auf Zeile'  in Programmtext eintragen
        INC     HL              ; Code √ºberspringen
        INC     HL              ;! Zeiger auf Zeile √ºberspringen
        INC     HL              ;!
        OR      0FFH            ; Carry - und Zero - FLag zur√ºcksetzen
        LD      (S5FAC),A       ; Zeilen-Nummern-Flag auf 'Zeiger auf Zeile vorhanden'
        RET
;
A5E49:  CP      '\"'            ; Code for 'Label'  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
        LD      (D5EBE + 1),HL  ; Zeiger auf Label in Routine eintragen
        LD      B,0             ; Vorgabe f√ºr Labell√§nge
A5E53:  LD      A,(HL)          ; ein Zeichen Labelname holen
        OR      A               ; Zeilenendezeichen  ?
        JR      Z,A5E5F         ; ja -->  L√§nge Labelname untersuchen
        INC     HL              ; Zeichen des Labelnamens √ºberspringen
        CP      '\"'            ; Labelendezeichen  ?
        JR      Z,A5E5F         ; ja -->  L√§nge Labelname untersuchen
        INC     B               ; L√§nge Labelname plus eins
        JR      A5E53           ; Ende Labelname suchen
;
A5E5F:  LD      A,B             ; L√§nge Labelname holen
        OR      A               ; gleich Null  ?
        JP      Z,A6364         ; ja -->  Fehler 1  Syntax error
        LD      (D5EBC + 1),A   ; L√§nge Labelname in Routine eintragen
        EX      DE,HL           ; Programmzeiger nach DE
        CALL    A5E72           ; Zeiger auf Zeile nach Labelnamen bereitstellen
        JP      C,A6385         ; Zeile nicht gefunden -->  Fehler 16   Un def. line error
        EX      DE,HL           ; Programmzeiger nach HL/Zeiger auf Zeile nach DE
        OR      0FFH            ; Carry- und Zero - Flag zur√ºcksetzen
        RET
;
;
;   Zeiger auf Zeile nach bereitgestelltem Labelnamen bereitstellen
;
A5E72:  PUSH    BC              ; Register - Wert retten
        LD      BC,T5EAB        ; Adresse  'auf LABEL - Namen vergleichen'
        JR      A5E7C           ; richtige Zeile suchen
;
;
;   Zeiger auf Zeile nach Zeilennummer in HL bereitstellen
;
A5E78:  PUSH    BC              ; Register - Wert retten
        LD      BC,T5E9F        ; Adresse  'auf Zeilennummer vergleichen'
A5E7C:  LD      (D5E91 + 1),BC  ; Adresse in Routine eintragen
        PUSH    DE              ; Register - Wert retten
        EX      DE,HL           ; zu suchende Zeilennummer nach DE
        LD      HL,(S1070)      ; Anfangsadresse f√ºr BASIC - Programm holen
A5E85:  LD      C,(HL)          ;! Offset auf n√§chste Zeile aus Basic - Programm
        INC     HL              ;! holen
        LD      B,(HL)          ;!
        LD      A,B             ;! Offset gleich Null  ?
        OR      C               ;!
        SCF                     ; Code for 'Zeile nicht gefunden'  setzen
        JR      Z,A5E9C         ; Programmende -->  gerettete Register - Werte holen
        DEC     HL              ; Zeiger wieder auf Anfang Zeile
        PUSH    HL              ; Zeiger auf Anfang Zeile merken
        ADD     HL,BC           ; Zeiger auf n√§chste Zeile errechnen
        EX      (SP),HL         ; Zeiger merken / Zeiger auf aktuelle Zeile holen
D5E91:  CALL    0               ; auf Zeilennummer oder Label vergleichen
        JR      C,A5E9B         ; Zeilennummer gr√∂√üer als zu suchende Zeilennummer
        JR      Z,A5E9B         ; Zeile gefunden -->  gerettete Register - Werte holen
        POP     HL              ; Zeiger auf n√§chte Zeile holen
        JR      A5E85           ; n√§chste Zeile untersuchen
;
A5E9B:  POP     DE              ; Zeiger auf n√§chste Zeile verwerfen
A5E9C:  POP     DE              ;! gerettete Register - Werte holen
        POP     BC              ;!
        RET
;
;
;   auf zu suchende Zeilennummer vergleichen
;
T5E9F:  INC     HL              ;! Offset auf n√§chste Zeile √ºberspringen
        INC     HL              ;!
        INC     HL              ; Zeiger auf High - Byte Zeilennummer
        LD      A,D             ; High - Byte zu suchende Zeilennummer
        CP      (HL)            ; mit High - Byte aktuelle Zeilennummer vergleichen
        RET     NZ              ; Bytes nicht gleich
        DEC     HL              ; Zeiger auf Low - Byte Zeilennummer
        LD      A,E             ; Low - Byte zu suchende Zeilennummer holen
        CP      (HL)            ; mit Low - Byte aktueller Zeilennummer vergleichen
        DEC     HL              ;! Zeiger auf Zeile wieder auf Anfang Zeile
        DEC     HL              ;!
        RET
;
;
;   auf LABEL und Labelnamen vergleichen
;
T5EAB:  PUSH    HL              ; Zeiger auf Anfang Zeile retten
        INC     HL              ;! Offset auf n√§chste Zeile √ºberspringen
        INC     HL              ;!
        INC     HL              ;! Zeilennummer √ºberspringen
        INC     HL              ;!
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    _LABEL          ; LABEL   (Zwischencode)  ?
        JR      NZ,A5ECF        ; nicht LABEL -->  geretteten Register - Wert holen
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    '\"'            ; Anfang Labelname  ?
        JR      NZ,A5ECF        ; kein Label - Namen - Anfangszeichen
D5EBC:  LD      B,0             ; L√§nge Labelname   (wird eingetragen)
D5EBE:  LD      DE,0            ; Zeiger auf Labelnamen   (wird eingetragen)
A5EC1:  LD      A,(DE)          ; ein Zeichen vorgegebener Labelname
        CP      (HL)            ; mit einem Zeichen Labelname in Zeile vergleichen
        JR      NZ,A5ECF        ; Zeichen nicht gleich -->  geretteten Register - Wert holen
        INC     HL              ; Zeiger auf Labelnamen in Programmzeile
        INC     DE              ; Zeiger auf vorgegebenen Labelnamen
        DJNZ    A5EC1           ; weitere Zeichen Labelname vergleichen
        LD      A,(HL)          ; letztes Zeichen Labelname aus Programmzeile holen
        CP      '\"'            ; gleich  'Ende  Labelname'  ?
        JR      Z,A5ECF         ; ja -->  geretteten Register - Wert holen
        OR      A               ; Zero-Flag zur√ºcksetzen, wenn nicht Zeilenendezeichen
A5ECF:  SCF                     ;! Carry - Flag zur√ºcksetzen
        CCF                     ;!
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;   Anfangs- und Endzeilennummer aus Programmtext bereitstellen
;
A5ED3:  LD      DE,0            ; Vorgabe f√ºr Anfangszeilennummer
        LD      BC,65535        ; Vorgabe f√ºr Endzeilennummer
        CALL    A5F15           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        RET     Z               ; keine Zeilennummer angegeben
        CP      '-'             ; -   (bis)
        JR      Z,A5EFD         ; ja -->  keine Anfangszeilennummer angegeben
        CP      '.'             ; .   (letzte Zeilennummer)  ?
        LD      DE,(S9E4D)      ; Editor Zeilennummer holen
        JR      Z,A5EF0         ; ja -->  noch auf Endzeilennummer untersuchen
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    _LINNO          ; Code for 'Integer - Zeilennummer'
        LD      E,(HL)          ;! Anfangszeilennummer aus Programmtext holen
        INC     HL              ;!
        LD      D,(HL)          ;!
A5EF0:  INC     HL              ; ausgewertetes Programmbyte √ºberspringen
        CALL    A5F15           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A5EFA         ; Befehlsende -->  Anfangszeilennr. als Endzeilennummer
        CP      '-'             ; -   (bis)   ?
        JR      Z,A5EFD         ; ja -->  untersuchen, ob Endzeilennummer 
A5EFA:  LD      C,E             ;! Anfangszeilennummer als Endzeilennummer
        LD      B,D             ;!
        RET
;
A5EFD:  INC     HL              ; ausgewertetes Programmbyte √ºberspringen
        CALL    A5F15           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        RET     Z               ; ja -->  fertig
        CP      '.'             ; .   (letzte Zeilennummer)  ?
        JR      NZ,A5F0C        ; nein
        LD      BC,(S9E4D)      ; Editor Zeilennummer holen
        INC     HL              ; Punkt √ºberspringen
        RET
;
A5F0C:  CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    _LINNO          ; Code for 'Integer - Zeilennummer'  ?
        LD      C,(HL)          ;! Endzeilennummer aus Programmtext holen
        INC     HL              ;!
        LD      B,(HL)          ;!
        INC     HL              ;!
        RET
;
;
;   √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsende oder Ende Zeilennummer ist
;
A5F15:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        RET     Z               ; Befehlsendezeichen
        CP      ','             ; Komma  ?
        RET
;
;
;   Zeilennummern im Programm in Zeiger auf Zeile umsetzen
;
A5F1C:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      A,-1            ; Code for 'Zeiger auf Zeile im Text'
        LD      (S5FAC),A       ; im Zeilen - Nummer - Flag merken
        LD      HL,T5F72        ; Adresse  'Zeilennummer umsetzen in Zeiger auf Zeile'
        JR      A5F3B           ; Programm durchforsten und Zeilennummern umsetzen
;
;
;   Zeiger auf Zeilen im Programm in Zeilennummern umsetzen
;
A5F29:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        CALL    A60A2           ; alle Statusflags zur√ºcksetzen
A5F2F:  LD      A,(S5FAC)       ; Zeilen - Nummern - Flag holen
        OR      A               ; nur Zeilennummern  ?
        RET     Z               ; ja -->  fertig
        XOR     A               ; Code for 'nur Zeilennummern'
        LD      (S5FAC),A       ; im Zeilen - Nummern - Flag merken
        LD      HL,T5F58        ; Adresse  'Zeiger umsetzen in Zeilennummer'
A5F3B:  LD      (D5F55 + 1),HL  ; Adresse in Routine eintragen
        LD      HL,(S1070)      ; Anfangsadresse des BASIC - Programms holen
        DEC     HL
A5F42:  INC     HL
        LD      A,(HL)          ;! Offset auf n√§chste Zeile vorhanden  ?
        INC     HL              ;! 
        OR      (HL)            ;!
        RET     Z               ; nein -->  Programmende -->  Fertig
        INC     HL               
        LD      E,(HL)          ;! Zeilennummer der aktuelle Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      (D5FA0 + 1),DE  ; und in Routine eintragen
A5F4F:  CALL    A6A0A           ; Zeiger in HL auf n√§chstes relevantes Programmbyte
        OR      A               ; Zeilenendezeichen  ?
        JR      Z,A5F42         ; ja -->  untersuchen, ob weitere Zeilen
D5F55:  JP      0               ; richtiges Umsetzprogramm aufrufen
;
;
;   Zeiger auf Zeile umsetzen in Zeilennummer
; 
T5F58:  CP      _LIN_P          ; Code for 'Zeiger auf Zeile'   ?
        JR      NZ,A5F4F        ; nein -->  n√§chstes Byte untersuchen
        DEC     HL              
        LD      E,(HL)          ;! Zeiger auf Zeile aus Programm holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        PUSH    HL              ; Stelle f√ºr Zeilennummer merken
        EX      DE,HL           ; Zeiger auf Zeile nach HL
        INC     HL              ;! Offset auf n√§chste Zeile √ºberspringen
        INC     HL              ;!
        LD      E,(HL)          ;! Zeilennummer der Zeile aus Programm holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        POP     HL              ; Zeiger auf Stelle f√ºr Zeilennummer holen
        LD      (HL),D          ;! Zeilennummer in Programm eintragen
        DEC     HL              ;!
        LD      (HL),E          ;!
        DEC     HL
        LD      (HL),_LINNO     ; Code for 'Integer - Zeilennummer'  eintragen
        INC     HL
        INC     HL
        JR      A5F4F           ; Restprogramm untersuchen und umsetzen
;
;
;   Zeilennummer im Programm umsetzen in Zeiger auf Zeile
;
T5F72:  CP      _LINNO          ; Code for 'Integer - Zeilennummer'  ?
        JR      NZ,A5F4F        ; nein -->  n√§chstes Byte untersuchen
        DEC     HL              ; Zeiger auf Stelle f√ºr Zeiger auf Zeile
        PUSH    HL              ; Zeiger merken
        CALL    A0151           ; Offset auf n√§chste Zeile nach HL holen
        LD      E,L             ;! Zeilennummer nach DE
        LD      D,H             ;!
        LD      A,L             ;! Zeilennummer gleich Null  ?
        OR      H               ;!
        JR      Z,A5FA8         ; ja -->  Zeilennummer stehen lassen
        CALL    A5E78           ; Zeiger auf Zeile nach Zeilennummer in HL bereitstellen
        JR      C,A5F91         ; Zeile nicht vorhanden -->  Fehler ausgeben
        EX      DE,HL           ; Zeiger auf Zeile nach DE
        POP     HL              ; Zeiger auf Stelle f√ºr Zeiger auf Zeile
        DEC     HL              ; Zeiger auf Stelle f√ºr Code
        LD      (HL),_LIN_P     ; Code for 'Zeiger auf Zeile'  eintragen
        INC     HL              ; Code  √ºberspringen
        LD      (HL),E          ;! Zeiger auf Zeile anstatt Zeilennummer
        INC     HL              ;! in Programmtext eintragen
        LD      (HL),D          ;!
        JR      A5F4F           ; Restprogramm umsetzen
;
;
;   Zeile nicht gefunden -->  Fehlermeldung ausgeben
;
A5F91:  PUSH    DE              ; Zeilennummer retten
        LD      A,16            ; Fehler 16  Un def. line error
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    27              ; Code 27  Fehlertext nach Fehlernummer in A ausgeben
        LD      A,' '           ; Leerzeichen  (Space)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausf√ºhrung Steuerzeichen)
        POP     HL              ; Zeilennummer holen
        CALL    A7998           ; Hex-Wert in HL umsetzen in Dezimal nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    5               ; Code 5  Text (DE) mit Gro√ü-/Kleinschreibung ausgeben
D5FA0:  LD      HL,0            ; Zeilennummer der aktuellen Zeile   (wird eingetragen)
        CALL    A63D6           ; Text 'in' und Zeilennummer ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    2               ; Code 2  Zeilenvorschub, wenn Cursor nicht auf Anfang Zeile
A5FA8:  POP     HL              ; Zeiger auf Stelle f√ºr Zeile holen
        INC     HL
        JR      A5F4F           ; Restprogramm umsetzen
;
S5FAC:  DEFS    1               ; Zeilen - Nummern - Flag   (=0 -->  nur Zeilennummern)
;
;
;   ASCII - Zeile (DE) umsetzen in Zwischencode und in Programmspeicher eintragen
;
A5FAD:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    40              ; Code 40   alle Datei - Daten im Rechner l√∂schen
        CALL    A5F29           ; Zeiger auf Zeilen im Programm in Zeilennummern umsetzen
        CALL    A8532           ; ASCII-Wert (DE) umsetzen in Hex-Wert nach BC
        LD      A,B             ;! Zeilennummer gleich Null  ?   (direkte
        OR      C               ;!                                Programmierung)
        JP      Z,A5881         ; ja -->  Zeile ausf√ºhren
        LD      (S9E4D),BC      ; als Editor Zeilennummer merken
        LD      A,(DE)          ; n√§chstes Textzeichen holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      NZ,A5FC4        ; nein -->  relevantes Zeichen
        INC     DE              ; Leerzeichen √ºberspringen
A5FC4:  PUSH    AF              ; Zeichen merken
        LD      HL,M9EB5        ; Zeiger auf Speicher f√ºr Zeile im Zwischencode
        CALL    A8216           ; ASCII - Text - Zeile (DE) umsetzen in Zwischencode
        PUSH    HL              ; Zeiger auf Ende Zwischencodezeile merken
        LD      HL,(S9E4D)      ; Editor Zeilennummer holen
        LD      E,L             ;! auch als Endzeilennummer vorgeben
        LD      D,H             ;!
        CALL    A622C           ; eventuell vorhanden alte Zeile(n) l√∂schen
        POP     HL              ; Zeiger auf Ende Zwischencodezeile holen
        POP     AF              ; erstes Textzeichen holen
        OR      A               ; gleich Zeilenendezeichen  ?
        JR      Z,A5FEB         ; ja -->  Zeile nur l√∂schen
        LD      DE,M9EB5        ; Zeiger auf Speicher mit Zeile im Zwischencode
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; L√§nge der Zwischencodezeile errechnen
        LD      DE,5            ; 5 Byte f√ºr Zeilenverwaltung
        ADD     HL,DE           ; Speicherl√§nge f√ºr Zeile errechnen
        LD      B,H             ;! L√§nge der Zeile nach BC √ºbertragen
        LD      C,L             ;!
        LD      HL,M9EB5        ; Zeiger auf Speicher mit Zeile im Zwischencode
        CALL    A6003           ; Zeile in Programmspeicher eintragen
A5FEB:  LD      A,(S611C)       ; AUTO - Flag holen
        OR      A               ; im AUTO - Modus  ?
        JP      Z,A5881         ; nein -->  n√§chste Zeile von Tastatur holen
        LD      DE,(S9E4F)      ; Offset f√ºr AUTO holen
        LD      HL,(S9E4D)      ; Editor Zeilennummer holen
        ADD     HL,DE           ; n√§chste Zeilennummer errechnen
        LD      (S9E4D),HL      ; neue Editor Zeilennummer merken
        JP      NC,A5881        ; kein √úbertrag -->  n√§chste Zeile von Tastatur holen
        JP      A58A9           ; AUTO - Modus aufheben
;
;
;   Zwischencodezeile (HL) mit L√§nge in BC in Programmspeicher eintragen
;
A6003:  LD      (D6064 + 1),HL  ; Zeiger auf Zwischencodezeile eintragen
        PUSH    BC              ; L√§nge der Zeile retten
        LD      BC,(S9E4D)      ; Editor Zeilennummer holen
        LD      HL,(S1070)      ; BASIC - Programmanfang holen
        JR      A6014           ; Stelle f√ºr Zeile suchen und Zeile eintragen
;
A6010:  CALL    A0132           ; Offset auf n√§chste Zeile holen
        ADD     HL,DE           ; Zeiger auf n√§chste Zeile errechnen
A6014:  CALL    A0132           ; Offset auf n√§chste Zeile holen
        LD      A,D             ;! Offset gleich Null  ?
        OR      E               ;!
        JR      Z,A6028         ; ja -->  letzte Programmzeile
        INC     HL              ;! Zeiger auf Zeilennummer der Zeile
        INC     HL              ;! setzen
        CALL    A0132           ; Zeilennummer der Zeile holen
        EX      DE,HL           ; Zeilennummer nach HL
        SBC     HL,BC           ; testen, ob Zeilennummern gleich
        DEC     DE              ;! Zeiger wieder auf Anfang Zeile
        DEC     DE              ;!
        EX      DE,HL           ; und nach HL
        JR      C,A6010         ; Zeilennummer ist kleiner als einzuf√ºgende Zeilennummer
A6028:  POP     DE              ; L√§nge der neuen Zeile holen
        PUSH    HL              ; Zeiger auf Stelle f√ºr Zeile merken
        PUSH    DE              ; L√§nge der neuen Zeile merken
        LD      HL,40           ;! Vorgabe f√ºr freien Bereich
        ADD     HL,DE           ;!
        LD      BC,(S1078)      ; Anfang Stringarbeitsbereich holen
        LD      (S107A),BC      ; als Ende Stringarbeitsbereich merken
        ADD     HL,BC           ; Ende benutzter Speicher errechnen
        JP      C,A63A7         ; √úbertrag -->  Fehler 6  Memory error
        EX      DE,HL           ; Adresse nach DE
        CALL    A8C08           ; √úberpr√ºfen, ob Adresse in DE mit Stack collidiert
        POP     DE              ; L√§nge der neuen Zeile holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    24              ; Code 24  Zeiger auf I/O-Work-Area,Basic-Var.,Strings corrigieren
        POP     HL              ; Zeiger auf Stelle f√ºr neue Zeile holen
        PUSH    DE              ; L√§nge der neuen Zeile merken
        PUSH    BC              ; Anfang Stringarbeitsbereich ablegen
        EX      (SP),HL         ; mit Zeiger auf Stelle f√ºr Zeile vertauschen
        POP     BC              ; Zeiger auf Stelle f√ºr neue Zeile
        PUSH    HL              ; Anfang Stringarbeitsbereich merken
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; Anzahl zu verschiebende Bytes errechnen
        LD      B,H             ;! Anzahl nach BC
        LD      C,L             ;!
        POP     HL              ; alten Stringarbeitsbereichanfang holen
        LD      DE,(S1078)      ; Anfang Stringarbeitsbereich holen
        INC     BC              ; L√§nge corrigieren
        LDDR                    ; Platz f√ºr neue Zeile schaffen
        INC     HL               
        POP     BC              ; L√§nge der neuen Zeile holen
        LD      (HL),C          ;! L√§nge der Zeile als Offset auf n√§chste
        INC     HL              ;! Zeile eintragen
        LD      (HL),B          ;!
        INC     HL
        LD      DE,(S9E4D)      ; Editor Zeilennummer holen  (Zeilennummer neue Zeile)
        LD      (HL),E          ;! Zeilennummer der neuen Zeile in 
        INC     HL              ;! Programmspeicher eintragen
        LD      (HL),D          ;!
        INC     HL
        EX      DE,HL           ; Zeiger auf Stelle f√ºr Zeile nach DE
D6064:  LD      HL,M9EB5        ; Zeiger auf Speicher mit Zwischencodezeile
        DEC     BC              ;! Zeilenl√§nge f√ºr Offset auf Zeile und
        DEC     BC              ;! Zeilennummer corrigieren
        DEC     BC              ;!
        DEC     BC              ;!
        LDIR                    ; neue Zeile in Programmspeicher eintragen
        RET
;
;
;   Basic - Befehl   RUN     (Zwischencode  131 / 083H)
;
A606E:  JR      Z,A6079         ; Ende Befehl -->  Programm starten
        CALL    A69DE           ; Accu gleich Kennung f√ºr Zeilennummer   ?
        JP      Z,A69AF         ; ja -->  GOTO - Routine
        JP      A716B           ; Programm laden und starten
;
;
;   Basic - Programm starten
;
A6079:  CALL    A619B           ; Variable l√∂schen   (CLR - Routine)
A607C:  CALL    A6090           ; alle Flags auf Anfangsbedingungen setzen
        LD      DE,(S1070)      ; Basic - Programmanfang holen
        LD      SP,(S107C)      ; h√∂chste nutzbare Basic - Adresse holen
        LD      HL,-1           ; Code for 'keine Werte auf Stack'
        PUSH    HL              ; auf Stack ablegen
        PUSH    HL
        EX      DE,HL           ; Zeiger auf Programm nach HL
        JP      A5909           ; Programm abarbeiten
;
;
;   alle Flags auf Anfangsbedingungen setzen
;
A6090:  PUSH    HL              ; Register - Wert retten
        CALL    A60A2           ; alle Statusflags zur√ºcksetzen
        LD      (S611C),A       ; AUTO - Flag zur√ºcksetzen
        LD      HL,10           ; Vorgabe f√ºr Anfangszeilennummer und Offset
        LD      (S9E4D),HL      ; als Anfangszeilennummer merken
        LD      (S9E4F),HL      ; Offset f√ºr AUTO merken
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;   alle Statusflags zur√ºcksetzen
;
A60A2:  LD      HL,0            ; Null
        LD      (S9E55),HL      ; als Fehlerzeilennummer merken
        XOR     A               ; Accu auf Null
        LD      (S9E5D),A       ; DATA - Status zur√ºcksetzen
        LD      (M63F6),A       ; CONT - Flag zur√ºcksetzen
        LD      (S9E54),A       ; ON - ERROR - GOTO - Status l√∂schen
        LD      (S9E53),A       ; Fehlernummer l√∂schen
        LD      (S9E68),A       ; Code for 'nicht im SWAP - Programm'
        RET
;
;
;   Basic - Befehl   END     (Zwischencode  152 / 098H)
;
A60B9:  LD      A,(S9E68)       ; SWAP - Flag holen
        OR      A               ; im SWAP - Programm  ?
        ;JP      NZ,A748B        ; ja -->  Hauptprogramm wieder laden
		JP      NZ,A750C        ; ja -->  Hauptprogramm wieder laden
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    40              ; Code 40   alle Datei - Daten im Rechner l√∂schen
        XOR     A               ; Code for 'kein CONT m√∂glich'
        LD      (M63F6),A       ; CONT - Flag zur√ºcksetzen
        POP     BC              ; R√ºcksprungadresse vergessen
        JP      A5878           ; n√§chste Zeile von Tastatur holen und abarbeiten
;
;
;   Basic - Befehl   AUTO     (Zwischencode  139 / 08BH)
;
A60CA:  CALL    A7340           ; wenn im Programm-Modus -->  Fehler 19  Instruction error
        LD      DE,10           ; Vorgabe f√ºr Anfangszeilennummer
        LD      BC,10           ; Vorgabe f√ºr Offset
        JR      Z,A6103         ; keine Werte angegeben -->  Vorgaben merken
        CP      ','             ; Komma  ?
        JR      NZ,A60E4        ; nein -->  Anfangszeilennummer auswerten
        INC     HL              ; Komma √ºberspringen
        CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        LD      B,D             ;! angegebenen Offset nach BC √ºbertragen
        LD      C,E             ;!
        LD      DE,10           ; Anfangszeilennummer 10 vorgeben
        JR      A6103           ; Anfangszeilennummer und Offset merken
;
A60E4:  CP      '.'             ; .   (letzte Zeilennummer)  ?
        LD      DE,(S9E4D)      ; Editor - Zeilennummer holen
        JR      Z,A60F5         ; ja -->  noch auf Offset untersuchen
        CP      _LINNO          ; Code for 'Integer - Zeilennummer'  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
        INC     HL              ; Code √ºberspringen
        LD      E,(HL)          ;! Zeilennumer aus Programmtext holen
        INC     HL              ;!
        LD      D,(HL)          ;!
A60F5:  INC     HL
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      NZ,A6103        ; nein -->  kein Offset angegeben
        PUSH    DE              ; Anfangszeilennummer merken
        CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        LD      C,E             ;! Offset f√ºr AUTO nach BC √ºbertragen
        LD      B,D             ;!
        POP     DE              ; Anfangszeilennummer f√ºr AUTO holen
A6103:  CALL    A797A           ; auf Syntax 'Befehlsende' √ºberpr√ºfen
        LD      A,C             ;! Offset gleich Null  ?
        OR      B               ;!
        JP      Z,A636A         ; ja -->  Fehler 3  Illegal data error
        LD      (S9E4D),DE      ; Editor - Zeilennummer merken   (Anfangszeilennummer AUTO)
        LD      (S9E4F),BC      ; Offset f√ºr AUTO merken
        LD      A,1             ; Code for 'im AUTO - Modus'
        LD      (S611C),A       ; als AUTO - Flag merken
        POP     AF              ; R√ºcksprungadresse vergessen
        JP      A5881           ; n√§chste Zeile von Tastatur holen
;
S611C:  DEFS    1               ; AUTO - Flag   (<>0 -->  AUTO - Modus)
;
;
;   √úberpr√ºfen, ob im AUTO - Modus. Wenn ja -->  Zeilennummer
;   oder wenn vorhanden komplette Zeile ausgeben
;
A611D:  LD      A,(S611C)       ; AUTO - FLag holen
        OR      A               ; AUTO - Modus  ?
        RET     Z               ; nein -->  ferig
        XOR     A               ; Code for 'Editor - Zeile'
        JR      A612B           ; Zeile aufbereiten, ausgeben, Cursor auf Anfang
;
;
;   Basic - Befehl   EDIT     (Zwischencode  140 / 08CH)
;
A6125:  CALL    A612B           ; Zeile aufbereiten, ausgeben, Cursor auf Anfang
        JP      A5881           ; Zeile von Tastatur holen
;
;
;   Zeilennummer  (und wenn vorhanden komplette Zeile)  f√ºr AUTO oder EDIT
;   aufbereiten und ausgeben, Cursor auf Anfang Zeile stellen
;
A612B:  LD      DE,(S9E4D)      ; Editor - Zeilennummer holen
        CALL    NZ,A5ED3        ; Zeilennummer aus Eingabe bereitstellen
        PUSH    DE              ; Zeilennummer merken
        EX      DE,HL           ; Zeilennummer nach HL
        CALL    A5E78           ; Zeiger auf Zeile nach Zeilennummer in HL bereitstellen
        POP     DE              ; Zeilennummer der Zeile holen
        INC     HL              ;! Offset auf n√§chste Zeile und
        INC     HL              ;! Zeilennummer √ºberspringen
        INC     HL              ;!
        INC     HL              ;!
        JR      NC,A6141        ; Zeile gefunden
        LD      HL,S00A6        ; Zeiger auf Text  NUL
A6141:  EX      DE,HL           ; Zeiger auf Zeile nach DE
        PUSH    DE              ; Zeiger merken
        LD      (S9E4D),HL      ; Zeilennummer als Editor - Zeilennummer merken
        CALL    A7998           ; Hex-Wert in HL umsetzen in Dezimal nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    5               ; Code 5  Text (DE) mit Gro√ü-/Kleinschreibung ausgeben
        LD      A,' '           ; Leerzeichen  (Space)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausf√ºhrung Steuerzeichen)
        POP     HL              ; Zeiger auf Zwischencodezeile holen
        LD      DE,S11A4        ; Zeiger auf Speicher f√ºr ASCII-Text vorgeben
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
		CALL    A8401           ; Zwischencodezeile (HL) umsetzen in ASCII nach (DE)
        POP     DE              ; Zeiger auf Anfang ASCII-Zeile holen
        LD      B,0             ; Vorgabe f√ºr L√§nge der Zeile
A615A:  LD      A,(DE)          ; ein Zeichen Text der aufbereiteten Zeile
        OR      A               ; Textendezeichen  ?
        JR      Z,A6164         ; ja -->  Cursor wieder auf Anfang Zeile stellen
        INC     B               ; Z√§hler  'Anzahl Zeichen'  plus eins
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    4               ; Code 4  Accu auf Bildschirm ausgeben  (Anzeige Steuerzeichen)
        INC     DE              ; Zeiger auf ASCII-Text-Zeile auf n√§chstes Zeichen
        JR      A615A           ; Rest der Zeile ausgeben
;
;
;   Cursor auf Anfang des ausgegebenen Zeilentextes stellen
;
A6164:  LD      A,B             ; Anzahl Zeichen Zeilentext holen
        OR      A               ; Anzahl gleich Null  ?
        RET     Z               ; ja -->  fertig
A6167:  LD      A,C_LEFT        ; Steuerzeichen  'Cursor links'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausf√ºhrung Steuerzeichen)
        DJNZ    A6167 + 1       ; weitere 'Cursor links' ausgeben   (Sprung falsch)
        RET
;
;
;   Zeiger auf Rechenspeicher merken
;
A616E:  PUSH    DE              ; Register - Wert retten
        LD      DE,-16          ; Vorgabe f√ºr Sicherheitsbereich
        ADD     HL,DE           ; Ende Rechenspeicher errechnen
        POP     DE              ; geretteten Register - Wert holen
        LD      (S107E),HL      ; Ende Rechenspeicherbereich merken
        DEC     H               ; 256 Bytes f√ºr Rechenspeicher reservieren
        LD      (S107C),HL      ; h√∂chste nutzbare Basic - Adresse merken
        XOR     A               ; Code for 'nicht SWAP'
        LD      (S9E68),A       ; im SWAP - Flag merken
        RET
;
;
;   alle BASIC - Werte l√∂schen
;
A6180:  LD      HL,(S1070)      ; Basic - Programmanfang holen
        CALL    A61C5           ; (HL)  Bereichsende  (00 00)  eintragen
        LD      (S1072),HL      ; Zeiger auf Ein- Ausgabe - Arbeitsbereich merken (I/O-Work-Area)
        CALL    A6090           ; alle Flags auf Anfangsbedingungen setzen
        JR      A619B           ; Variable l√∂schen   (CLR - Routine)
;
;
;   Basic - Befehl   NEW     (Zwischencode  159 / 09FH)
;
A618E:  CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    ____ON          ; ON   (Zwischencode)  ?
        ;CALL    Z,A9FCF         ; NEW ON -->  Plotter - Routinen l√∂schen
		CALL    Z,A9FD1         ; NEW ON -->  Plotter - Routinen l√∂schen
        CALL    A6180           ; alle BASIC - Werte l√∂schen
        JP      A5872           ; Warmstart  BASIC - Interpreter
;
;
;   Basic - Befehl   CLR     (Zwischencode  254 166 / 0FEH 0A6H)
;
A619B:  PUSH    HL              ; Programmzeiger retten
        CALL    A61AC           ; I/O-Work-Area und BASIC-Variable/Funktionen l√∂schen
        POP     HL              ; geretteten Programmzeiger holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    40              ; Code 40   alle Datei - Daten im Rechner l√∂schen
        RET
;
;
;   Basic - Programm, Ein- Ausgabe - Arbeitsbereich  (I/O - Work - Area) und
;   Basic - Variable / Funktionen l√∂schen
;
A61A3:  LD      HL,(S1070)      ; Basic - Programmanfang holen
        CALL    A61C5           ; (HL)  Bereichsende  (00 00)  eintragen
        LD      (S1072),HL      ; Zeiger auf Ein- Ausgabe - Arbeitsbereich merken (I/O-Work-Area)
;
;
;   Ein- Ausgabe - Arbeitsbereich und BASIC - Variable/-Funktionen l√∂schen
;
A61AC:  LD      HL,(S1072)      ; Zeiger auf Ein- Ausgabe - Arbeitsbereich holen (I/O-Work-Area)
        LD      (HL),0          ; Code for 'Bereichsende eintragen'
        INC     HL              ; Code √ºberspringen
        LD      (S1074),HL      ; Anfang BASIC - Variable merken
        LD      (HL),0          ; Code for 'Bereichsende'  eintragen
        INC     HL              ; Code √ºberspringen
        LD      (S1076),HL      ; Anfang Stringtextbereich merken
        CALL    A61C5           ; (HL)  Bereichsende  (00 00)  eintragen
        LD      (S1078),HL      ; Anfang Stringarbeitsbereich merken
        LD      (S107A),HL      ; als Ende Stringarbeitsbereich merken
        RET
;
;
;   (HL)  Bereichsende  (00 00)  eintragen
;
A61C5:  LD      (HL),0          ;! Bereichsende eintragen
        INC     HL              ;!
        LD      (HL),0          ;!
        INC     HL              ;!
        RET
;
;
;   Basic - Befehl   TRON     (Zwischencode  169 / 0A9H)
;
A61CC:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        LD      A,1             ; Code for 'Trace auf Bildschirm'
        JR      Z,A61E0         ; Befehlsende -->  Trace - Flag merken
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    ___DIV          ; /   (Zwischencode)  ?
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "P"             ; P   (Printer)  ?
        LD      A,2             ; Code for 'Trace auf Drucker'
        JR      A61E0           ; Trace - Flag merken
;
;
;   Basic - Befehl   TROFF     (Zwischencode  170 / 0AAH)
;
A61DF:  XOR     A               ; Code for 'kein Trace'
A61E0:  LD      (A61E4 + 1),A   ; Code im Trace - Flag merken
        RET
;
;
;   wenn TRON -->  Zeilennummer ausgeben
;
A61E4:  LD      A,0             ; Trace - Flag   (0=TROFF / 1=CRT / 2=LPT)
        OR      A               ; Trace  ?
        RET     Z               ; nein -->  fertig
        DEC     A               ; Flag f√ºr Bildschirm oder Drucker corrigieren
        LD      (S1091),A       ; Ausgabeflag  CRT/LPT  setzen
        JR      Z,A61F5         ; Zeilennummer auf Bildschirm ausgeben
        LD      A,(S1097)       ; Drucker - Modus - Flag holen
        CP      2               ; im Graphic - Modus  ?
        JR      Z,A6207         ; ja -->  Zeilennummer nicht ausgeben
A61F5:  PUSH    HL              ; Programmzeiger retten
        LD      A,'['           ; Eckige Klammer auf  (Sharp - Zeichensatz)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker  (Ausf√ºhrung Steuerzeichen)
        LD      HL,(S9E51)      ; aktuelle Zeilennummer holen
        CALL    A7998           ; Hex-Wert in HL umsetzen in Dezimal nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    11              ; Code 11  Text (DE) auf Bildschirm oder Drucker ausgeben
        LD      A,']'           ; Eckige Klammer zu   (Sharp - Zeichensatz)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    9               ; Code 9  Accu auf Bildschirm oder Drucker  (Ausf√ºhrung Steuerzeichen)
        POP     HL              ; geretteten Programmzeiger holen
A6207:  XOR     A               ; Code for 'Ausgabe auf Bildschirm'
        LD      (S1091),A       ; Ausgabeflag  CRT/LPT  zur√ºcksetzen
        RET
;
;
;   Basic - command DELETE (intermediate code 137 / 089H)
;
A620C:  CALL    A5F15           ; test whether character (HL) equals end-of-command character
        JP      Z,A6364         ; yes --> Error 1 Syntax error
        CALL    A69DE           ; Accu same identifier for line number ?
        JR      Z,A6220         ; yes --> delete program lines
        CP      '-'             ; -   (until)  ?
        JR      Z,A6220         ; yes --> delete program lines
        CP      '.'             ; . (last line number) ?
		JP      NZ,A7443        ; no --> delete file
A6220:  CALL    A5ED3           ; Provide line numbers from input
        EX      DE,HL           ; Starting line number after HL
        LD      E,C             ;!  End line number after DE
        LD      D,B             ;!
        CALL    A622C           ; delete any existing old line(s).
        JP      A5878           ; Get next line from keyboard and execute
;
;
;   Delete any existing old lines.
;   Beginning of line number in HL / end of line number in DE 
;
A622C:  PUSH    AF              ;! Register - Werte retten
        PUSH    BC              ;!
        PUSH    HL              ; Anfangszeilennummer retten
        PUSH    DE              ; Endzeilennummer retten
        CALL    A5F29           ; Zeiger auf Zeilen im Programm in Zeilennummern umsetzen
        LD      C,L             ;! Anfangszeilennummer nach BC
        LD      B,H             ;!
        LD      HL,(S1070)      ; Basic - Programmanfang holen
A6238:  CALL    A012D           ; Offset auf n√§chste Zeile holen
        LD      A,E             ;! Offset gleich Null  ?
        OR      D               ;!
        JR      NZ,A6247        ; nein -->  noch Programm vorhanden
A623F:  POP     DE              ; gerettete Endzeilennummer holen
        POP     HL              ; gerettete Anfangszeilennummer holen
        POP     BC              ;! gerettete Register - Werte holen
        POP     AF              ;!
        RET
;
A6244:  POP     DE              ; Zeiger auf n√§chste Zeile vergessen
        JR      A623F           ; gerettete Register - Werte holen
;
A6247:  EX      DE,HL           ; Zeiger auf aktuelle Zeile nach DE
        ADD     HL,DE           ;! Zeiger auf n√§chste Zeile errechnen
        DEC     HL              ;!
        DEC     HL              ;!
        EX      DE,HL           ; Zeiger auf aktuelle Zeile nach HL
        PUSH    DE              ; Zeiger auf n√§chste Zeile retten
        LD      E,(HL)          ;! Zeilennummer der aktuellen Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        EX      DE,HL
        LD      (D6260 + 1),HL  ; Zeilennummer in Routine eintragen
        SBC     HL,BC           ; Zeilennummer mit Anfangszeilennummer vergleicen
        POP     HL              ; Zeiger auf n√§chste Zeile holen
        JR      C,A6238         ; Zeile ist kleiner als Anfangszeile
        DEC     DE              ;! Zeiger wieder auf Anfang der Zeile stellen
        DEC     DE              ;!
        DEC     DE              ;!
        POP     BC              ; Endzeilennummer holen
        PUSH    BC              ; und wieder merken
        PUSH    DE              ; Zeiger auf Anfang zu l√∂schende Zeilen
        PUSH    HL              ; Zeiger auf Ende merken
D6260:  LD      HL,0            ; Zeilennummer der aktuellen Zeile  (wird eingetragen)
        SBC     HL,BC           ; mit Endzeilennummer vergleichen
        POP     HL              ; Zeiger auf Ende Zeile holen
        JR      Z,A6286         ; Ende des zu l√∂schenden Bereichs gefunden -->  l√∂schen
        JR      NC,A6244        ; Endzeilennummer kleiner als aktuelle Zeilennummer
A626A:  CALL    A012D           ; Offset auf n√§chste Zeile holen
        LD      A,D             ;! Offset gleich Null  ?
        OR      E               ;!
        JR      Z,A6284         ; ja -->  Programm zu Ende
        EX      DE,HL            
        ADD     HL,DE           ;! Zeiger auf folgende Zeile errechnen
        EX      DE,HL
        DEC     DE              ;!
        DEC     DE              ;!
        PUSH    DE              ;!
        LD      E,(HL)          ;! Zeilennummer der Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        EX      DE,HL           ; und nach HL
        SBC     HL,BC           ; mit Endzeilennummer vergleichen
        POP     HL              ; Zeiger auf folgende Zeile holen
        JR      C,A626A         ; Endzeile suchen
        JR      Z,A6286         ; Endzeile gefunden
        EX      DE,HL
        DEC     HL              ;! Zeiger wieder auf Anfang Zeile
A6284:  DEC     HL              ;!
        DEC     HL              ;!
A6286:  POP     DE              ; Zeiger auf Anfang des zu l√∂schenden Bereichs holen
        PUSH    DE              ; und wieder merken
        PUSH    HL              ; Zeiger auf Ende des zu l√∂schenden Bereichs
        OR      A               ; Carry - Flag zur√ºcksetzen
        EX      DE,HL   
        SBC     HL,DE           ; zu l√∂schende Anzahl Bytes errechnen
        EX      DE,HL
        LD      BC,(S1078)      ; Anfang Stringarbeitsbereich holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    24              ; Code 24  Zeiger auf I/O-Work-Area,Basic-Var.,Strings corrigieren
        POP     DE              ; Zeiger auf Ende des zu l√∂schenden Bereichs
        LD      H,B             ;! alten Anfang Stringarbeitsbereich nach HL
        LD      L,C             ;!
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; zu verschiebende Anzahl Bytes errechnen
        LD      B,H             ;! Anzahl nach BC √ºbertragen
        LD      C,L             ;!
        EX      DE,HL           ; Zeiger auf Anfang zu verschiebender Bereich nach HL
        POP     DE              ; Zeiger auf Anfang L√∂schbereich
        LDIR                    ; Rest Programm. I/O-Work-Area und Variable verschieben
        JR      A623F           ; gerettete Register - Werte holen
;
;
;   zwei - Byte - Wert ungleich Null bereitstellen
;
A62A2:  CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        LD      A,D             ;! Wert gleich Null  ?
        OR      E               ;!
        RET     NZ              ; nein -->  OK
        JP      A636A           ; Fehler 3  Illegal data error
;
;
;   Basic - Befehl   RENUM     (Zwischencode  138 / 08AH)
;
A62AB:  CALL    A7340           ; wenn im Programm-Modus -->  Fehler 19  Instruction error
        LD      DE,10           ; Vorgabe 10
        LD      (D6329 + 1),DE  ; als neue Anfangszeilennummer merken
        LD      (D6340 + 1),DE  ; als neuen Offset merken
        LD      E,0             ; Null
        LD      (D6318 + 1),DE  ; als alte Anfangszeilennummer merken
        JR      Z,A62F4         ; keine Zahlen angegeben -->  Standardwerte benutzen
        CP      ','             ; Komma  ?
        JR      Z,A62D5         ; ja -->  keine neue Anfangszeilennummer angegeben
        CALL    A62A2           ; zwei - Byte - Wert ungleich Null bereitstellen
        LD      (D6329 + 1),DE  ; als neue Anfangszeilennummer merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A62F4         ; keine weiteren Werte angegeben
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        DEC     HL              ; Programmzeiger corrigieren
A62D5:  CALL    A015D           ; HL + 1, Leerzeichen  (Spaces)  (HL) √ºberspringen
        CP      ','             ; Komma  ?
        JR      Z,A62EC         ; ja -->  keine alte Zeilennummer angegeben
        CALL    A62A2           ; zwei - Byte - Wert ungleich Null bereitstellen
        LD      (D6318 + 1),DE  ; alte Anfangszeilennummer merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A62F4         ; ja -->  Offset nicht angegeben
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        DEC     HL              ; Programmzeiger corrigieren
A62EC:  INC     HL              ; Trennzeichen √ºberspringen
        CALL    A62A2           ; zwei - Byte - Wert ungleich Null bereitstellen
        LD      (D6340 + 1),DE  ; neuen Offset merken
A62F4:  PUSH    HL              ; Programmzeiger retten
        LD      HL,(D6318 + 1)  ; alte Anfangszeilennummer holen
        EX      DE,HL           ; und nach DE
        LD      HL,(D6329 + 1)  ; neue Anfangszeilennummer holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; neue Anfangszeilennummer gr√∂√üer alte Anfangszeilennr.  ?
        JP      C,A636A         ; nein -->  Fehler 3  Illegal data error
        CALL    A5F1C           ; Zeilennummern im Programm in Zeiger auf Zeilen umsetzen
        LD      HL,(S1070)      ; Basic - Programmanfang holen
A6308:  LD      E,(HL)          ;! Offset auf n√§chste Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      A,D             ;! Offset gleich Null  ?
        OR      E               ;!
        JR      Z,A634A         ; ja -->  Ende Programm gefunden
        EX      DE,HL
        ADD     HL,DE           ;! Zeiger auf n√§chste Zeile errechnen
        DEC     HL              ;!
        EX      DE,HL           ; Zeiger auf n√§chste Zeile nach DE
        INC     HL
        LD      C,(HL)          ;! Zeilennummer der Zeile holen
        INC     HL              ;!
        LD      B,(HL)          ;!
        PUSH    HL              ; Zeiger auf Zeile merken
D6318:  LD      HL,0            ; alte Anfangszeilennummer holen  (wird eingetragen)
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; √ºberpr√ºfen, ob Zeilennummer ge√§ndert werden mu√ü
        POP     HL              ; Zeiger auf Zeile holen
        JR      Z,A6326         ; Zeilennummer √§ndern
        JR      C,A6326         ; Zeilennummer √§ndern
        EX      DE,HL           ; Zeiger auf n√§chste Zeile nach HL
        JR      A6308           ; n√§chste Zeile testen
;
A6326:  DEC     HL              ;! Zeiger wieder auf Anfang Zeile
        DEC     HL              ;!
        DEC     HL              ;!
D6329:  LD      BC,0            ; neue Anfangszeilennummer holen   (wird eingetragen)
        OR      A               ; Carry - Flag zur√ºcksetzen   (Code for 'kein Fehler')
        PUSH    AF              ; Fehlerflag merken
A632E:  LD      E,(HL)          ;! Offset auf n√§chste Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      A,D             ;! Offset auf n√§chste Zeile gleich Null  ?
        OR      E               ;!
        JR      Z,A634A         ; ja -->  Ende Programm gefunden
        EX      DE,HL
        ADD     HL,DE           ;! Zeiger auf folgende Zeile errechnen
        DEC     HL              ;!
        EX      DE,HL           ; Zeiger in DE merken / Zeiger aktuelle Zeile nach HL
        POP     AF              ; Fehlerflag holen
        JR      C,A6350         ; Fehler aufgetreten -->  Standardwerte vorgeben
        INC     HL
        LD      (HL),C          ;! neue Zeilennummer in Zeile eintragen
        INC     HL              ;!
        LD      (HL),B          ;!
D6340:  LD      HL,0            ; neuen Offset holen   (wird eingetragen)
        ADD     HL,BC           ; Zeilennummer der n√§chsten Zeile errechnen
        PUSH    AF              ; Fehlerflag merken
        LD      C,L             ;! neue Zeilennummer nach BC √ºbertragen
        LD      B,H             ;!
        EX      DE,HL           ; Zeiger auf n√§chste Zeile nach HL
        JR      A632E           ; n√§chste Zeile √§ndern
;
A634A:  POP     AF              ; Fehlerflag vergessen
        CALL    A5F2F           ; Zeiger auf Zeilen im Programm in Zeilennummern umsetzen
        POP     HL              ; Programmzeiger holen
        RET
;
;
;   bei Fehler bei  RENUM -->  Programm mit Standardwerten durchnumerieren
;
A6350:  LD      HL,10           ; Vorgabe 10
        LD      (D6340 + 1),HL  ; als Offset merken
        LD      (D6329 + 1),HL  ; als neue Anfangszeilennummer merken
        LD      L,0             ; Vorgabe Null
        LD      (D6318 + 1),HL  ; als alte Anfangszeilennummer merken
        CALL    A62F4           ; Programm mit Standardwerten durchnumerieren
        JP      A636A           ; Fehler 3  Illegal data error
;
;
;   Tabelle mit Fehlereinspr√ºngen
;
A6364:  LD      A,1             ; Fehler  1   Syntax error
        DEFB    LD_HL
A6367:  LD      A,2             ; Fehler  2   Over flow error
        DEFB    LD_HL
A636A:  LD      A,3             ; Fehler  3   Illegal data error
        DEFB    LD_HL
A636D:  LD      A,4             ; Fehler  4   Type mismatch error
        DEFB    LD_HL
A6370:  LD      A,5             ; Fehler  5   String length error
        DEFB    LD_HL
A6373:  LD      A,6             ; Fehler  6   Memory capacity error
        DEFB    LD_HL
A6376:  LD      A,7             ; Fehler  7   Array def. error
        DEFB    LD_HL
A6379:  LD      A,8             ; Fehler  8   Line length error
        DEFB    LD_HL
A637C:  LD      A,13            ; Fehler 13   NEXT error
        DEFB    LD_HL
A637F:  LD      A,14            ; Fehler 14   RETURN error
        DEFB    LD_HL
A6382:  LD      A,15            ; Fehler 15   Un def. function error
        DEFB    LD_HL
A6385:  LD      A,16            ; Fehler 16   Un def. line error
        DEFB    LD_HL
A6388:  LD      A,17            ; Fehler 17   Can't CONT error
        DEFB    LD_HL
A638B:  LD      A,18            ; Fehler 18  Memory protection error
        DEFB    LD_HL
A638E:  LD      A,19            ; Fehler 19  Instruction error
        DEFB    LD_HL
A6391:  LD      A,20            ; Fehler 20  Can't RESUME error
        DEFB    LD_HL
A6394:  LD      A,21            ; Fehler 21  RESUME error
        DEFB    LD_HL
A6397:  LD      A,22            ; Fehler 22  PAL error
        DEFB    LD_HL
A639A:  LD      A,24            ; Fehler 24  READ error
        DEFB    LD_HL
A639D:  LD      A,25            ; Fehler 25  SWAP error
        DEFB    LD_HL
A63A0:  LD      A,58            ; Fehler 58  Dev. name error
        DEFB    LD_HL
A63A3:  LD      A,64            ; Fehler 64  Logical number error
        JR      A63B5           ; Fehler behandeln
;
A63A7:  LD      A,6             ; Fehler  6  Memory capacity error
A63A9:  LD      SP,(S107C)      ; h√∂chste nutzbare Basic - Adresse holen
        LD      HL,-1           ; Code for 'keine Werte auf Stack'
        PUSH    HL              ; auf Stack ablegen
        LD      (S9E64),SP      ; Stackpointer bei Anfang Befehl merken
A63B5:  JR      A63D3           ; Fehler behandeln
;
;
;   Standard  - Ger√§te vorgeben und Programm abbrechen
;
A63B7:  LD      HL,(W106E)      ; Adresse  'Ger√§te - Tabelle  Drucker'  holen
        LD      IX,(W106C)      ; Adresse  'Ger√§te - Tabelle  Bildschirm'  holen
        LD      (S1044),HL      ; Zeiger auf aktuelle Ger√§te - Tabelle merken
        XOR     A               ; Accu auf Null
        LD      (S1051),A       ; Ger√§te - Nummern - Flag zur√ºcksetzen
        LD      A,68 + 128      ; Fehler 68  Dev. mode error
        DEFB    LD_HL
        LD      A,59 + 128      ; Fehler 59  Can't execute error
        DEFB    LD_HL
T63CB:  LD      A,59            ; Fehler 59  Can't execute error
        DEFB    LD_HL
A63CE:  LD      A,60 + 128      ; Fehler 60  Illegal filename error
        DEFB    LD_HL
A63D1:  LD      A,61 + 128      ; Fehler 61  Illegal filemode error
A63D3:  JP      A00ED           ; Fehler behandeln
;
;
;   wenn Zeilennummer in HL ungleich Null -->  Text 'in' und Zeilennummer ausgeben
;
A63D6:  LD      A,L             ;! Zeilennummer gleich Null  ?
        OR      H               ;!
        RET     Z               ; ja -->  fertig
        LD      DE,M63E4        ; Text  'in'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    5               ; Code 5  Text (DE) mit Gro√ü-/Kleinschreibung ausgeben
        CALL    A7998           ; Hex-Wert in HL umsetzen in Dezimal nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    5               ; Code 5  Text (DE) mit Gro√ü-/Kleinschreibung ausgeben
        RET
;
;
;   allgemeine Texte f√ºr Basic - Interpreter
;
M63E4:  DEFM    " IN "          ; Text  ' in '
        DEFB    NUL
M63E9:  DEFM    "B"             ; Text  'Break'
        DEFB    _SML
        DEFM    "REAK"
		DEFB    NUL
;
M63F0:  DEFM    "R"             ; Text  'Ready'
        DEFB    _SML
        DEFM    "EADY"
M63F6:  DEFB    NUL             ; CONT - Flag   (NUL oder .)
        DEFB    NUL             ; Textendezeichen
;
;
;   Basic - Befehl   ERROR     (Zwischencode 193 / 0C1H)
;
A63F8:  CALL    A853D           ; ein - Byte - Wert nach DE / Accu bereitstellen
        DEC     A               ;! bekannte Fehlernummer  ?
        CP      70              ;!
        JR      C,A6402         ; ja -->  Fehlernummer wieder corrigieren
        LD      A,69 -1         ; Fehler 69  Unprintable error
A6402:  INC     A               ; Fehlernummer wieder corrigieren
;
;
;   Fehler mit Fehlernummer im Accu behandeln
;
A6403:  LD      SP,(S9E64)      ; Stackpointer bei Anfang Befehl holen
        PUSH    AF              ; Fehlernummer retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    67              ; Code 67  Datei-Daten der Ausgabedatei bei Fehler l√∂schen
        CALL    A737C           ; Zwischenspeicher f√ºr Programmladeroutine l√∂schen
        POP     AF              ; Fehlernummer holen
        OR      A               ; Programmende  ?
        JR      Z,A6463         ; ja -->  'kein CONT m√∂glich'  merken
        CP      080H            ; Code for 'BREAK'  ?
        JR      Z,A6461         ; ja -->  Daten f√ºr 'CONT' retten
        LD      C,A             ; Fehlernummer merken
        LD      HL,0            ; HL auf Null
        LD      (S9048),HL      ; Zeiger auf Parameter bei FN zur√ºcksetzen
        CALL    A596B           ; Abfrage, ob in direkter Programmierung
        LD      A,C             ; Fehlernummer holen
        JR      Z,A644C         ; direkte Programmierung -->  Fehler ausgeben
        LD      HL,(S9E51)      ; aktuelle Zeilennummer holen
        LD      (S9E55),HL      ; als Fehlerzeilennummer merken
        LD      (S9E4D),HL      ; als Editor - Zeilennummer merken
        LD      HL,(S9E4B)      ; Zeiger auf n√§chste Programmzeile holen
        LD      (S9E57),HL      ; Zeiger auf n√§chste Zeile bei Fehler merken
        LD      HL,(S9E66)      ; Programmzeiger bei Anfang Befehl holen
        LD      (S9E59),HL      ; als Programmzeiger bei Fehler merken
        AND     01111111B       ; eigentliche Fehlernummer maskieren
        LD      (S9E53),A       ; Fehlernummer merken
        LD      A,(S9E54)       ; ON - ERROR - GOTO - Status holen
        INC     A               ; plus eins
        CP      2               ; Code for 'Fehler aufgetreten'  ?
        JR      Z,A6457         ; ja -->  merken und Fehlerbehandlung aufrufen
        XOR     A               ; Code for 'kein CONT m√∂glich'
        LD      (M63F6),A       ; als CONT - Flag merken
        LD      (S9E68),A       ; SWAP - Flag zur√ºcksetzen
        LD      A,C             ; Fehlernummer holen
A644C:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    27              ; Code 27  Fehlertext nach Fehlernummer in A ausgeben
A644E:  LD      HL,(S9E51)      ; aktuelle Zeilennummer holen
        CALL    A63D6           ; wenn Zeilennummer ungleich Null -->  ausgeben
        JP      A5878           ; Ready ausgeben und n√§chste Zeile von Tastatur holen
;
A6457:  LD      (S9E54),A       ; neuen ON - ERROR - GOTO - Status merken
        LD      HL,(S9E5B)      ; Zeiger auf Fehlerbehandlungsprogramm holen
        PUSH    HL              ; auf Stack ablegen
        JP      A5909           ; Zeile abarbeiten
;
;
;   Programm mit Shift - BREAK abgebrochen
;
A6461:  LD      A,'.'           ; Code for 'CONT m√∂glich'
A6463:  LD      HL,(S9E66)      ; Programmzeiger bei Anfang Befehl holen
        JR      A646B           ; aktuelle Programmdaten f√ºr CONT merken
;
;
;   Basic - Befehl   STOP     (Zwischencode  153 / 099H)
;
A6468:  LD      A,'.'           ; Code for 'CONT m√∂glich'
        POP     DE              ; R√ºcksprungadresse vergessen
A646B:  PUSH    AF              ; Flag  'CONT m√∂glich/nicht m√∂glich'
        PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    2               ; Code 2  Zeilenvorschub, wenn Cursor nicht auf Anfang Zeile
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    32              ; Code 32  Referenzton ausgeben
        LD      DE,M63E9        ; Text  'Break'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    5               ; Code 5  Text (DE) mit Gro√ü-/Kleinschreibung ausgeben
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A596B           ; Abfrage, ob in direkter Programmierung
        JR      Z,A6495         ; ja -->  Stack corrigieren und Zeile von Tastatur holen
        LD      (D64B0 + 1),HL  ; Programmzeiger f√ºr CONT merken
        LD      HL,(S9E4B)      ; Zeiger auf n√§chste Programmzeile holen
        LD      (D64AA + 1),HL  ; f√ºr CONT merken
        LD      HL,(S9E51)      ; aktuelle Zeilennummer holen
        LD      (D64A4 + 1),HL  ; und f√ºr CONT merken
        LD      (S9E4D),HL      ; als Editor - Zeilennummer merken
        POP     AF              ; CONT - Status holen
        LD      (M63F6),A       ; als CONT - Flag merken
        JP      A644E           ; Zeilennummer ausgeben
;
A6495:  POP     AF              ; CONT - Status holen
        JP      A5878           ; Ready ausgeben und n√§chste Zeile von Tastatur
;
;
;   Basic - Befehl   CONT     (Zwischencode  154 / 09AH)
;
A6499:  POP     DE              ; R√ºcksprungadresse holen
        LD      HL,M63F6        ; Zeiger auf CONT - FLag
        LD      A,(HL)          ; CONT - Flag holen
        OR      A               ; gesetzt  ?
        JP      Z,A6388         ; nein -->  Fehler 17  Can't CONT error
        LD      (HL),0          ; CONT - Flag zur√ºcksetzen
D64A4:  LD      HL,0            ; Zeilennummer holen   (wird eingetragen)
        LD      (S9E51),HL      ; als aktuelle Zeilennummer merken
D64AA:  LD      HL,0            ; Zeiger auf Zeile holen   (wird eingetragen)
        LD      (S9E4B),HL      ; als Zeiger auf n√§chste Programmzeile merken
D64B0:  LD      HL,0            ; Programmzeiger f√ºr CONT holen   (wird eingetragen)
        JP      A58D4           ; Rest der Zeile bearbeiten
;
;
;   Basic - Befehl   RESUME     (Zwischencode  134 / 086H)
;
A64B6:  LD      A,(S9E54)       ; ON - ERROR - GOTO - Status holen
        CP      2               ; Code for 'Fehler aufgetreten'  ?
        JP      C,A6394         ; nein -->  Fehler 21  RESUME error
        DEC     A               ; Code wieder auf  'ON ERROR GOTO gesetzt'
        LD      (S9E54),A       ; ON - ERROR - GOTO - Status merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        EX      DE,HL           ; Programmzeiger nach DE retten
        LD      HL,(S9E55)      ; Fehlerzeilennummer holen
        LD      (S9E51),HL      ; als aktuelle Zeilennummer merken
        LD      HL,(S9E57)      ; Zeiger auf n√§chste Zeile bei Fehler holen
        LD      (S9E4B),HL      ; als Zeiger auf n√§chste Programmzeile merken
        LD      HL,(S9E59)      ; Programmzeiger bei Fehler holen
        JR      NZ,A64DB        ; nicht Befehlsende -->  untersuchen, welcher RESUME
        POP     BC              ; R√ºcksprungadresse verwerfen
        JP      A58D8           ; Befehl noch einmal abarbeiten
;
A64DB:  CP      __NEXT          ; RESUME NEXT  ?
        JP      Z,A67FE         ; ja -->  Anfang des n√§chsten Befehls suchen
        EX      DE,HL           ; Programmzeiger auf Zeilennummer nach HL
        JP      A69AF           ; GOTO   (RESUME Zeilennummer)
;
;
;   Basic - Befehl   ON ERROR GOTO
;
A64E4:  CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    __GOTO          ; GOTO  (Zwischencode)  ?
        CALL    A5E19           ; Zeiger auf Zeile nach Programmtext (HL) bereitstellen
        JR      Z,A64F7         ; Zeilennummer gleich Null -->  ON ERROR GOTO zur√ºcksetzen
        LD      (S9E5B),DE      ; Zeiger auf Fehlerbehandlungsprogramm merken
        LD      A,1             ; Code for 'ON ERROR GOTO'  gesetzt
A64F3:  LD      (S9E54),A       ; ON - ERROR - GOTO - Status merken
        RET
;
A64F7:  LD      A,(S9E54)       ; ON - ERROR - GOTO - Status holen
        DEC     A               ; ON ERROR GOTO gesetzt  ?
        JR      Z,A64F3         ; ja -->  zur√ºcksetzen
        XOR     A               ; Accu auf Null
        LD      (S9E54),A       ; ON - ERROR - GOTO - Status zur√ºcksetzen
        LD      HL,(S9E55)      ; Fehlerzeilennummer holen
        LD      (S9E51),HL      ; als aktuelle Zeilennummer merken
        LD      A,(S9E53)       ; Fehlernummer holen
        JP      A6403           ; Fehler mit Nummer im Accu behandeln
;
;
;   Basic - Befehl   LET     (Zwischencode  158 / 09EH)
;
A650D:  CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    0FFH            ; Vorbyte Tabelle drei  ?
        JP      Z,A653F         ; ja -->  auf TI$ untersuchen
        CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        PUSH    BC              ;! Zeiger auf Variable merken
        PUSH    BC              ;!
        PUSH    AF              ; Variablenartcode merken
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    ____EQ          ; =   (Zwischencode)  ?
        CALL    A857C           ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
        POP     BC              ; Variablenartcode holen
        LD      A,(S9E9C)       ; Wertartflag holen
        CP      B               ; gleich Variablenartcode  ?
        JP      NZ,A636D        ; nein -->  Fehler 4  Type mismatch error
        EX      (SP),HL         ; Programmzeiger retten / Variablenzeiger holen
        EX      DE,HL           ; Variablenzeiger nach HL
        CP      5               ; Zahlvariable  ?
        JR      Z,A6537         ; ja -->  Zahlwert der Variablen zuweisen
        PUSH    BC              ; Variablenarttyp merken
        CALL    A654A           ; String mit Descriptor (HL) der Variablen (DE) zuweisen
        POP     AF              ; Variablenartcode holen
        POP     HL              ; Programmzeiger holen
        POP     BC              ; Zeiger auf Variable holen
        RET
;
A6537:  LD      C,A             ; Wertl√§nge merken
        LD      B,0             ; High - Byte L√§nge auf Null
        LDIR                    ; Zahlwert der Variablen zuweisen
        POP     HL              ; Programmzeiger holen
        POP     BC              ; Zeiger auf Variable holen
        RET
;
;
;   Basic - Befehl aus Tabelle drei abarbeiten
;
A653F:  CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    ____TI          ; TI$   (Zwischencode)  ?
        JP      A8AE2           ; Uhrzeit bereitstellen und zuweisen
;
;
;   Zeichenkette (HL) der Variablen (DE) zuweisen
;
A6546:  PUSH    DE              ; Zeiger auf Variable retten
        EX      DE,HL           ; Zeiger auf Zeichenkette nach DE
        JR      A654E           ; Zeichenkette der Variable zuweisen
;
;
;   Zeichenkette mit Descriptor (HL) der Variablen mit
;   Descriptor (DE) zuweisen
;
A654A:  PUSH    DE              ; Zeiger auf Variablendescriptor retten
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
A654E:  LD      HL,S11A3        ; Zeiger auf Zwischenspeicher vorgeben
        LD      (HL),A          ; Zeichenkettenl√§nge eintragen
        LD      B,A             ;! Zeichenkettenl√§nge
        LD      C,A             ;!
        INC     HL              ; Zeichenkettenl√§nge √ºberspringen
        CALL    A014A           ; Speicherbereich von (DE) nach (HL) verschieben
        POP     HL              ; Zeiger auf Variablendescriptor holen
        LD      A,(HL)          ; L√§nge Variablentext holen
        CP      C               ; gleich neuer L√§nge  ?
        JR      Z,A659F         ; L√§nge gleich -->  kann direkt zugewiesen werden
        PUSH    HL              ; Zeiger auf Variablendescriptor wieder retten
        OR      A               ; alte L√§nge gleich Null  ?
        CALL    NZ,A65AF        ; nein -->  alten Variablentext l√∂schen
        POP     HL              ; Zeiger auf Variablendescriptor holen
        LD      A,(S11A3)       ; neue Textl√§nge holen
        OR      A               ; gleich Null  ?
        JR      Z,A659C         ; ja -->  L√§nge in Descriptor eintragen
        PUSH    HL              ; Zeiger auf Variablendescriptor merken
        LD      BC,(S1074)      ; Anfang BASIC - Variable holen
        SBC     HL,BC           ; Offset auf Descriptor errechnen
        EX      DE,HL           ; Offset nach DE
        LD      HL,(S1078)      ; Anfang Stringarbeitsbereich holen
        DEC     HL              ;! corrigieren auf Ende Stringtextbereich
        DEC     HL              ;!
        LD      (HL),E          ;! Offset auf Variable eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL
        LD      BC,(S1076)      ; Anfang Stringtextbereich holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        POP     DE              ; Zeiger auf Variablendescriptor holen
        PUSH    HL              ; Zeiger f√ºr Stringtext retten
        SBC     HL,BC           ; Offset auf Stringtext errechnen
        EX      DE,HL
        LD      (HL),A          ; Stringl√§nge in Descriptor eintragen
        LD      B,A             ; L√§nge des neuen Strings
        INC     HL              ; Stringl√§nge in Descriptor √ºberspringen
        LD      (HL),E          ;! Offset auf Stringtext in Descriptor eintrgen
        INC     HL              ;!
        LD      (HL),D          ;!
        POP     HL              ; Zeiger f√ºr Stringtext holen
        LD      DE,S11A3        ; Zeiger auf Speicher mit String vorgeben
        INC     DE              ; L√§nge √ºberspringen
        CALL    A8BFC           ; Zeichenkette mit L√§nge in B von (DE) nach (HL) √ºbertragen
        CALL    A61C5           ; (HL)  Bereichsende  (00 00)  eintragen
        LD      (S107A),HL      ; als Ende Stringarbeitsbereich merken
        LD      (S1078),HL      ; Anfang Stringarbeitsbereich merken
        RET
;
A659C:  LD      (HL),0          ; L√§nge Null in Variablendescriptor eintragen
        RET
;
;
;   Stringtext in Stringtextbereich eintragen
;
A659F:  INC     HL              ; Stringl√§nge √ºberspringen
        LD      E,(HL)          ;! Offset auf String aus Variablendescriptor holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      HL,(S1076)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf Stringtext errechnen
        LD      DE,S11A3        ; Zeiger auf Zwischenspeicher mit neuem String
        LD      B,C             ; Textl√§nge des neuen Strings
        INC     DE              ; Textl√§nge √ºberspringen
        JP      A8BFC           ; Zeichenkette mit L√§nge in B von (DE) nach (HL) √ºbertragen
;
;
;   Zeichenkette mit Variablendescriptor (HL) l√∂schen
;
A65AF:  LD      C,(HL)          ; Stringl√§nge aus Descriptor holen
        LD      B,0             ; High - Byte L√§nge auf Null
        INC     BC              ;! L√§nge f√ºr Offset auf Variablendescriptor
        INC     BC              ;! corrigieren
        INC     HL              ; Stringl√§nge in Descriptor √ºberspringen
        LD      E,(HL)          ;! Offset auf Stringtextanfang holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      HL,(S1076)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf Stringtext errechnen
        DEC     HL              ;! auf Offset auf Variablendescriptor
        DEC     HL              ;! corrigieren
        LD      E,L             ;! Zeiger auf Offset nach DE
        LD      D,H             ;!
        ADD     HL,BC           ; Zeiger auf Ende String errechnen
        PUSH    BC              ; Anzahl zu l√∂schende Bytes merken
        PUSH    DE              ; Zeiger auf Offset auf Variablendescriptor merken
        EX      DE,HL           ; Zeiger auf Ende zu l√∂schender String nach DE
        LD      HL,(S1078)      ; Anfang Stringarbeitsbereich holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Restl√§nge Stringtextbereich errechnen
        LD      C,L             ;! Restl√§nge Stringtextbereich nach BC
        LD      B,H             ;!
        EX      DE,HL           ; Zeiger auf Anfang zu verschiebender Bereich nach HL
        POP     DE              ; Zeiger auf neuen Anfang holen
        PUSH    DE              ; und wieder merken
        JR      Z,A65D3         ; Restl√§nge gleich Null -->  nicht verschieben
        LDIR                    ; Rest Stringtextbereich verschieben
A65D3:  POP     DE              ; Zeiger auf Offset holen
        POP     BC              ; gel√∂schte L√§nge holen
        LD      HL,(S1078)      ; Anfang Stringarbeitsbereich holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; neues Ende Stringtextbereich errechnen
        LD      (S1078),HL      ; Anfang Stringarbeitsbereich merken
        EX      DE,HL           ; Zeiger auf Offset nach HL
A65DF:  LD      E,(HL)          ;! Offset auf Variablendescriptor holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      A,D             ;! gleich Null  ?
        OR      E               ;!
        RET     Z               ; ja -->  fertig
        LD      HL,(S1074)      ; Anfang BASIC - Variable holen
        ADD     HL,DE           ; Zeiger auf Variablendescriptor errechnen
        LD      A,(HL)          ; L√§nge Stringtext holen
        INC     HL              ; L√§nge in Descriptor √ºberspringen
        LD      E,(HL)          ;! Offset auf Stringtext aus Variablen-
        INC     HL              ;! descriptor holen
        LD      D,(HL)          ;!
        OR      A               ; Carry - Flag zur√ºcksetzen
        EX      DE,HL
        SBC     HL,BC           ; Offset f√ºr Stringtext corrigieren
        EX      DE,HL
        LD      (HL),D          ;! corrigierten Offset wieder in Variablen-
        DEC     HL              ;! descriptor eintragen
        LD      (HL),E          ;!
        PUSH    BC              ; gel√∂schte L√§nge retten
        LD      C,A             ; Stringl√§nge
        LD      B,0             ; High - Byte L√§nge auf Null
        LD      HL,(S1076)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf Anfang String errechnen
        ADD     HL,BC           ; Zeiger auf n√§chsten String errechnen
        POP     BC              ; gel√∂schte L√§nge holen
        JR      A65DF           ; untersuchen, ob weitere Descriptoren corrigiert werden m√ºssen
;
;
;   Basic - Befehl   FOR     (Zwischencode  141 / 08DH)
;
A6602:  POP     BC              ; R√ºcksprungadresse holen
        LD      (D6696 + 1),BC  ; und in Routine eintragen
        CALL    A650D           ; Schleifenvariable Anfangswert zuweisen
        LD      IX,0            ;! Stackpointer nach IX holen
        ADD     IX,SP           ;!
        LD      (D6678 + 1),HL  ; Programmzeiger in Routine eintragen
        CALL    A6772           ; Offset auf Variablen errechnen
        LD      (D6674 + 1),BC  ; Offset auf Variable in Routine eintragen
A661A:  LD      E,(IX+0)        ;! ersten Wert vom Stack holen
        LD      D,(IX+1)        ;!
        LD      HL,256*0FFH+18  ; Code for 'FOR - Daten'
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; gleich Code for 'FOR - Daten'  ?
        JR      NZ,A6642        ; nein -->  keine weiteren Schleifen √ºberpr√ºfen
        LD      E,(IX+6)        ;! Offset auf Schleifenvariable
        LD      D,(IX+7)        ;! aus vorhandenen Werte holen
        EX      DE,HL           ; nach HL √ºbertragen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; gleiche Variable  ?
        JR      Z,A663B         ; ja -->  alte Daten vergessen
        LD      DE,18           ; L√§nge FOR - Datensatz
        ADD     IX,DE           ; Zeiger auf n√§chsten Datensatz errechnen
        JR      A661A           ; n√§chsten Datensatz √ºberpr√ºfen
;
A663B:  LD      DE,18           ; L√§nge FOR - Datensatz
        ADD     IX,DE           ; Zeiger auf Ende Datensatz errechnen
        LD      SP,IX           ; alle Datens√§tze davor vergesen
A6642:  LD      HL,(D6678 + 1)  ; Programmzeiger holen
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    ____TO          ; TO   (Zwischencode)  ?
        CALL    A857C           ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger merken
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        LD      DE,S677E        ; Zeiger auf Speicher f√ºr Schleifenende
        CALL    A79C5           ; Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; n√§chstes Programmbyte holen
        CP      __STEP          ; Zwischencode STEP  ?
        LD      DE,B7C45        ; Zeiger auf +1   (Real - Format)
        JR      NZ,A6662        ; kein STEP angegeben
        INC     HL              ; Zwischencode STEP √ºberspringen
        CALL    A857C           ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
A6662:  LD      (D6678 + 1),HL  ; Programmzeiger merken
        LD      HL,-10          ; Offset f√ºr Schleifenende
        ADD     HL,SP           ; Zeiger auf Stelle f√ºr Schleifenende errechnen
        LD      SP,HL           ; Zeiger auf Stelle setzen
        EX      DE,HL           ; Zeiger auf Zahlwert nach HL
        CALL    A79C5           ; Zahlwert von (HL) nach (DE) √ºbertragen
        LD      HL,S677E        ; Zeiger auf Speicher f√ºr Schleifenende
        CALL    A79C5           ; Zahlwert von (HL) nach (DE) √ºbertragen
D6674:  LD      HL,0            ; Offset auf Schleifenvariable   (wird eingetragen)
        PUSH    HL              ; f√ºr NEXT auf Stack merken
D6678:  LD      HL,0            ; Programmzeiger auf Anfang Schleife  (wird eingetragen)
        PUSH    HL              ; f√ºr NEXT auf Stack merken
        LD      HL,(S9E4B)      ; Zeiger auf n√§chste Programmzeile holen
        PUSH    HL              ; und f√ºr NEXT auf Stack merken
        LD      HL,256*0FFH+18  ; Code for 'FOR - Datensatz'
        PUSH    HL              ; auf Stack ablegen
        LD      HL,-512         ; Vorgabe f√ºr freien Arbeitsbereich
        ADD     HL,SP           ; kleinste Stackadresse errechnen
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        SBC     HL,DE           ; Adressen vergleichen
        LD      A,11            ; Fehler 11  FOR nesting error
        JP      C,A63A9         ; Adressen √ºberschneiden sich -->  Fehler behandeln
        LD      HL,(D6678 + 1)  ; Programmzeiger holen
D6696:  JP      0               ; n√§chsten Befehl abarbeiten   (Adresse wird eingetragen)
;
;
;   Basic - Befehl   NEXT     (Zwischencode  142 / 08EH)
;
A6699:  LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; im Wertartflag merken
        POP     BC              ; R√ºcksprungadresse holen
        LD      (A670D + 1),BC  ; und in Routine eintragen
A66A3:  PUSH    AF              ;! Befehlsendeflag merken
        POP     BC              ;!
        LD      (D6678 + 1),HL  ; Programmzeiger merken
        LD      IX,0            ;! Stackpointer holen
        ADD     IX,SP           ;!
        LD      (D66FC + 1),IX  ; und merken
        LD      E,(IX+0)        ;! Steuerwort vom Stack holen
        LD      D,(IX+1)        ;!
        LD      HL,256*0FFH+18  ; Code for 'FOR - Datensatz'
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; gleich Steuerwort  'FOR - Daten'  ?
        JP      NZ,A637C        ; nein -->  Fehler 13  Next without FOR error
        PUSH    BC              ;! Befehlsendeflag wieder ins Flag - Register
        POP     AF              ;!
        JR      NZ,A6724        ; nicht Befehlsende -->  auf Namen untersuchen
        LD      E,(IX+4)        ;! Programmzeiger auf Anfang Schleife aus
        LD      D,(IX+5)        ;! Datensatz holen
        EX      DE,HL           ; nach HL
        LD      (D670A + 1),HL  ; und in Routine eintragen
        LD      E,(IX+6)        ;! Offset auf Laufvariable der Schleife holen
        LD      D,(IX+7)        ;!
        LD      HL,(S1074)      ; Anfang BASIC - Variable holen
        ADD     HL,DE           ; Zeiger auf Variablenwert errechnen
        LD      BC,8            ; Offset zur Schrittweite
        ADD     IX,BC           ; Zeiger auf Schrittweite errechnen
        PUSH    IX              ;! und nach DE √ºbertragen
        POP     DE              ;!
        CALL    A90BC           ; Schrittweite zur Laufvariablen addieren
        INC     DE              ; Zeiger auf MSByte Mantisse Schrittweite
        LD      A,(DE)          ; MSByte Mantisse der Schrittweite holen
        LD      IX,(D66FC + 1)  ; Zeiger auf Anfang FOR - Datensatz holen
        LD      DE,13           ; Offset zum Schleifenende 
        ADD     IX,DE           ; Zeiger auf Schleifenende errechnen
        PUSH    IX              ;! nach DE √ºbertragen
        POP     DE              ;!
        BIT     7,A             ; Vorzeichen Schrittweite abfragen
        JR      NZ,A66F7        ; Schrittweite negativ
        EX      DE,HL           ; Zeiger auf Zahlen vertauschen
A66F7:  CALL    A9153           ; Wert Laufvariable und Schleifenende vergleichen
        JR      C,A6710         ; Schleife beenden
D66FC:  LD      SP,0            ; Stackpointer setzen   (wird eingetragen)
        LD      HL,2            ; Offset zum Zeiger auf n√§chste Zeile
        ADD     HL,SP           ; Zeiger auf Zeilenzeiger errechnen
        LD      A,(HL)          ;! Zeiger auf n√§chste Zeile aus
        INC     HL              ;! FOR - Datensatz holen
        LD      H,(HL)          ;!
        LD      L,A             ;!
        LD      (S9E4B),HL      ; Zeiger auf n√§chste Programmzeile merken
D670A:  LD      HL,0            ; Programmzeiger holen   (wird eingetragen)
A670D:  JP      0               ; n√§chsten Befehl ausf√ºhren   (Adresse wird eingetragen)
;
;
;   Schleife beenden
;
A6710:  LD      DE,18           ; Anzahl Bytes FOR - Datensatz
        LD      HL,(D66FC + 1)  ; Zeiger auf Anfang FOR - Datensatz holen
        ADD     HL,DE           ; neuen Zeiger errechnen
        LD      SP,HL           ; Stackpointer neu setzen
        LD      HL,(D6678 + 1)  ; Programmzeiger holen
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      NZ,A670D        ; keine weiteren Schleifen -->  n√§chsten Befehl
        LD      (D6678 + 1),HL  ; Programmzeiger wieder merken
A6724:  LD      IX,0            ;! Zeiger auf Datens√§tze holen
        ADD     IX,SP           ;!
        LD      (D66FC + 1),IX  ; und in Routine eintragen
        LD      HL,(D6678 + 1)  ; Programmzeiger holen
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JP      Z,A66A3         ; n√§chste Schleife √ºberpr√ºfen
        CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        LD      (D6678 + 1),HL  ; Programmzeiger wieder merken
        CALL    A6772           ; Offset auf Variable errechnen
        LD      IX,(D66FC + 1)  ; Stackpointer holen
A6745:  LD      E,(IX+0)        ;! Steuerwort vom Stack holen
        LD      D,(IX+1)        ;!
        LD      HL,256*0FFH+18  ; Code for 'FOR - Datensatz'  vorgeben
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; FOR - Datensatz  ?
        JP      NZ,A637C        ; nein -->  Fehler 13  NEXT without FOR error
        LD      L,(IX+6)        ;! Offset auf Schleifenvariable holen
        LD      H,(IX+7)        ;!
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; Offset's vergleichen
        LD      HL,(D6678 + 1)  ; Programmzeiger holen
        JP      Z,A66A3         ; Schleife gefunden -->  testen, ob Ende
        LD      DE,18           ; L√§nge FOR - Datensatz
        ADD     IX,DE           ; Zeiger auf n√§chsten FOR - Datensatz errechnen
        LD      (D66FC + 1),IX  ; und als Zeiger auf Stack merken
        LD      SP,(D66FC + 1)  ; Stackpointer neu setzen
        JR      A6745           ; n√§chsten Datensatz √ºberpr√ºfen
;
;
;   Offset auf Basic - Variable nach Zeiger auf Variable in BC nach BC errechnen
;
A6772:  LD      H,B             ;! Zeiger auf Schleifenvariable nach HL
        LD      L,C             ;!
        LD      BC,(S1074)      ; Anfang BASIC - Variable holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; Offset auf Basic - Variable errechnen
        LD      B,H             ;! und nach BC √ºbertragen
        LD      C,L             ;!
        RET
;
S677E:  DEFS    5               ; Speicher f√ºr Schleifenende
;
;
        DEFS    1  
S6784:  DEFS    2               ; Zeilennummer der Zeile
S6786:  DEFS    1               ; Offset auf n√§chste Zeile
                                ;  (sollten eigentlich 2 Byte sein)
;
;
;   das folgende Programmst√ºck ist kaputt und wird auch nicht gebraucht
;
A6787:  CALL    A6A0A           ; Zeiger in HL auf n√§chstes relevantes Programmbyte
        OR      A               ; Zeilenende  ?
        RET     NZ              ; nein
        INC     HL              ; Zeiger auf Anfang n√§chste Zeile
        PUSH    DE              ; Register - Wert retten
        LD      E,(HL)          ;! Offset auf n√§chste Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      A,D             ;! Offset gleich Null ?
        OR      E               ;!
        INC     HL
        LD      (S6786),DE      ;! Offset auf n√§chste Zeile merken
                                ;! (√úberschreibt Programm und ist schon seit MZ-700 falsch)
        LD      E,(HL)          ;! Zeilennummer der Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      (S6784),DE      ; und merken
        POP     DE              ; geretteten Register - Wert holen
        SCF                     ; Code for 'Ende Programm'
        RET     Z               ; Programmende gefunden
        JR      A6787           ; n√§chstes relevante Byte suchen
;
;
;   Basic - Befehl   USR     (Zwischencode  195 / 0C3H)
;
A67A4:  CALL    A79A6           ; Syntax 'Klammer auf'
        CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        LD      (D67DC + 1),DE  ; USR - Adresse in Routine eintragen
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      NZ,A67CF        ; nein -->  keine Variable angegeben
        CALL    A857C           ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
        CALL    A9036           ; Syntaxuntersuchung auf Zeichenkettenergebnis
        LD      (D67D1 + 1),DE  ; Zeiger auf Eingangswert merken
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      NZ,A67CF        ; nein -->  keine Ausgangsvariable angegeben
        CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        CALL    A9036           ; Syntaxuntersuchung auf Zeichenkettenergebnis
        LD      (D67E4 + 1),BC  ; Zeiger auf Ausgangsvariable merken
        XOR     A               ; Code for 'Ausgangsvariable angegeben'
A67CF:  PUSH    HL              ; Programmzeiger retten
        PUSH    AF              ; Code f√ºr Ausgangsvariable retten
D67D1:  LD      HL,0            ; Zeiger auf Eingangswert - Descriptor  (wird eingetragen)
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
        LD      IX,A00ED        ; R√ºcksprungadresse f√ºr Fehler vorgeben
        XOR     A               ; Code for 'kein Fehler'  vorgeben
D67DC:  CALL    0               ; Maschinenprogramm aufrufen   (Adresse wird eingetragen)
        POP     AF              ; Code der Ausgangsvariable holen
        JR      NZ,A67EA        ; keine Ausgangsvariable angegeben
        LD      A,B             ; L√§nge des √ºbergebenen Textes holen
        EX      DE,HL           ; Zeiger auf Text nach HL
D67E4:  LD      DE,0            ; Zeiger auf Ausgangsvariable  (wird eingetragen)
        CALL    A6546           ; Zeichenkette der Variablen zuweisen
A67EA:  POP     HL              ; geretteten Programmzeiger holen
        JP      A79AA           ; auf Syntax 'Klammer zu' √ºberpr√ºfen
;
;
;   Basic - Befehl   WAIT     (Zwischencode  190 / 0BEH)
;
A67EE:  CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
A67F1:  LD      A,D             ;! Wartez√§hler gleich Null  ?
        OR      E               ;!
        RET     Z               ; ja -->  fertig
        LD      B,251           ;! Zeitschleife  ca. 0.1 sec
A67F6:  DJNZ    A67F6           ;!
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    14              ; Code 14  Abfrage, ob (Shift) - BREAK gedr√ºckt ist
        RET     Z               ; ja -->  fertig
        DEC     DE              ; Wartez√§hler minus eins
        JR      A67F1           ; untersuchen, ob fertig
;
;
;   Basic - Befehl   DATA      (Zwischencode  148 / 094H)
;   Basic - Befehl   REM       (Zwischencode  151 / 097H)
;   Basic - Befehl   LABEL     (Zwischencode  202 / 0CAH)
;
A67FE:  DEC     HL              ; Programmzeiger corrigieren
A67FF:  CALL    A6A0A           ; Zeiger in HL auf n√§chstes relevantes Programmbyte
        OR      A               ; Zeilenendezeichen  ?
        SCF                     ; Code for 'Zeilenende'  setzen
        RET     Z               ; ja -->  fertig
        CP      ':'             ; Befehlsende  ?
        RET     Z               ; ja -->  fertig
        JR      A67FF           ; Ende des Befehls suchen
;
;
;   Basic - Befehl   OUT@     (Zwischencode  186 / 0BAH)
;
A680A:  CALL    A853D           ; ein - Byte - Wert nach DE / Accu bereitstellen
        SUB     0E0H            ; Anfang Umschaltports
        CP      7               ; Anzahl Umschaltports
        JP      C,A636A         ; Umschaltport -->  Fehler 3  Illegal data error
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        PUSH    DE              ; Port - Nummer retten
        CALL    A853D           ; ein - Byte - Wert nach DE / Accu bereitstellen
        POP     BC              ; Port - Nummer holen
        OUT     (C),A           ; ein Byte an Port ausgeben
        RET
;
;
;   Basic - Befehl   INP@     (Zwischencode  171 / 0BBH)
;
A681F:  CALL    A853D           ; ein - Byte - Wert nach DE / Accu bereitstellen
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        PUSH    DE              ; Port - Nummer retten
        CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        CP      5               ; Real - Zahlvariable  ?
        JP      NZ,A636D        ; nein -->  Fehler 4  Type mismatch error
        EX      (SP),HL         ; Programmzeiger retten / Port - Nummer holen
        PUSH    BC              ; Zeiger auf Variable retten
        EX      (SP),HL         ; Portnummer retten / Zeiger auf Variable holen
        POP     BC              ; Port - Nummer holen
        IN      E,(C)           ; Wert vom Port holen
        LD      D,0             ; High - Byte Wert auf Null
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   CURSOR     (Zwischencode  254 164 / 0FEH 0A4H)
;
A683B:  CALL    A6843           ; angegebene Cursor - Koordinaten bereitstellen
        EX      DE,HL           ; Cursor-Koordinaten nach HL / Programmzeiger nach DE
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    18              ; Code 18  Cursor auf Koordinaten in HL setzen
        EX      DE,HL           ; Programmzeiger nach HL
        RET
;
;
;   Grenzen f√ºr Cursor - Befehl vorgeben und angegebene Werte bereitstellen
;
A6843:  LD      B,24            ; maximale Y - Koordinate Cursor
        LD      C,39            ; maximale X - Koordinate bei 40 Zeichen/Zeile
        LD      A,(S137A)       ; Bildschirm - Modus - Nummer holen
        CP      3               ; Modus eins oder zwei  ?
        JR      C,A6850         ; ja -->  40 Zeichen je Zeile
        LD      C,79            ; maximale X - Koordinate bei 80 Zeichen/Zeile
A6850:  CALL    A6857           ; zwei Werte bereitstellen und auf Grenzen untersuchen
        JP      C,A636A         ; Wert(e) zu gro√ü -->  Fehler 3  Illegal data error
        RET
;
;
;   zwei Werte aus Ausdruck (HL) bereitstellen und auf Grenzen √ºberpr√ºfen
;
A6857:  PUSH    BC              ; Wertgrenzen retten
        CALL    A853D           ; ein - Byte - Wert nach DE / Accu bereitstellen
        PUSH    AF              ; ersten Wert retten
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A853D           ; ein - Byte - Wert nach DE / Accu bereitstellen
        LD      D,E             ; zweiten Wert merken
        POP     AF              ; ersten Wert holen
        LD      E,A             ; und merken
        POP     BC              ; gerettete Grenzen holen
        LD      A,C             ; Grenze f√ºr ersten Wert holen
        CP      E               ; und mit Wert vergleichen
        RET     C               ; Wert zu gro√ü -->  Abbruch
        LD      A,B             ; Grenze f√ºr zweiten Wert holen
        CP      D               ; und mit zweitem Wert vergleichen
        RET
;
;
;   Basic - Befehl   GET     (Zwischencode  173 / 0ADH)
;
A686C:  CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        LD      (S9E9C),A       ; Variablenartcode im Wertartflag merken
        CP      5               ; Zahlvariable  ?
        JR      Z,A688B         ; ja -->  auf Zahlwert untersuchen
        PUSH    HL              ; Programmzeiger retten
        PUSH    BC              ; Zeiger auf Variable retten
        LD      A,-1            ; Code for 'Tastaturabfrage mit Entprellen'
                                ; (wenn 0 -->  immer wenn Taste gedr√ºckt -->  Ergebnis)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    13              ; Code 13  Tastaturabfrage nach Status im Accu
        OR      A               ; Taste gedr√ºckt  ?
        JR      Z,A6885         ; nein 
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        LD      (HL),A          ; gedr√ºckte Taste eintragen
        LD      A,1             ; Stringl√§nge  'ein Zeichen'  vorgeben
A6885:  POP     DE              ; Zeiger auf Variable holen
        CALL    A6546           ; Zeichenkette der Variablen zuweisen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   GET  Zahlvariable
;
A688B:  PUSH    HL              ; Programmzeiger retten
        PUSH    BC              ; Zeiger auf Variable retten
        LD      A,-1            ; Code for 'Tastaturabfrage mit Entprellen'  (0=mit Repeat)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    13              ; Code 13  Tastaturabfrage nach Status im Accu
        SUB     '0'             ; ASCII umsetzen in Dezimalwert
        CP      10              ; Ziffer  ?
        JR      C,A6898         ; ja
        XOR     A               ; Vorgabe 'Null'  (0)
A6898:  LD      E,A             ; Wert der Taste merken
        LD      D,0             ; High - Byte Wert auf Null
        POP     HL              ; Zeiger auf Variable holen
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   POKE     (Zwischencode  160 / 0A0H)
;
A68A1:  CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        CALL    A79B4           ; auf Syntax 'Komma' untersuchen
A68A7:  PUSH    DE              ; POKE - Adresse merken
        CALL    A853D           ; ein - Byte - Wert nach DE / Accu bereitstellen
        POP     DE              ; POKE - Adresse holen
        LD      (DE),A          ; Wert im Speicher eintragen
        INC     DE              ; Zeiger auf Speicher auf n√§chstes Byte
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        RET     NZ              ; keine weiteren Werte
        JR      A68A7           ; n√§chsten Wert bereitstellen und in Speicher eintragen
;
;
;   Basic - Befehl   LIMIT     (Zwischencode  254 167 / 0FEH 0A7H)
;
A68B5:  PUSH    HL              ; Programmzeiger bei Anfang Befehl retten
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    "M"             ; M  (Max)  ?
        JR      NZ,A68CE        ; nicht MAX -->  Wert bereitstellen
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    "A"             ; A  (mAx)  ?
        JR      NZ,A68CE        ; nicht MAX -->  Wert bereitstellen
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    "X"             ; X  (maX)  ?
        JR      NZ,A68CE        ; nicht MAX -->  Wert bereitstellen
        EX      (SP),HL         ; Programmzeiger retten / alten Zeiger verwerfen
        LD      HL,(W1080)      ; maximal erlaubte RAM - Adresse holen
        JR      A68EA           ; LIMIT - Wert setzen
;
;
;   LIMIT mit Angabe der Speicheradresse 
;
A68CE:  POP     HL              ; alten Programmzeiger holen
        CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        PUSH    HL              ; Programmzeiger retten
        LD      HL,(W1080)      ; maximal erlaubte RAM - Adresse holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Adressen vergleichen
        JP      C,A63A7         ; LIMIT - Adresse zu gro√ü -->  Fehler 6  Memory capacity error
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        INC     H               ;! ein KByte als Arbeitsspeicher reservieren
        INC     H               ;!
        INC     H               ;!
        INC     H               ;!
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Adressen vergleichen
        JP      NC,A636A        ; LIMIT-Adresse zu klein -->  Fehler 3  Illegal data error
        EX      DE,HL           ; LIMIT - Adresse nach DE
A68EA:  CALL    A616E           ; Zeiger auf Rechenspeicher merken
        POP     HL              ; Programmzeiger holen
        POP     DE              ; R√ºcksprungadresse holen
        LD      SP,(S107C)      ; h√∂chste nutzbare Basic - Adresse holen
        LD      BC,-1           ; Code for 'keine Werte auf Stack'
        PUSH    BC              ; Steuerwort auf Stack ablegen
        PUSH    DE              ; R√ºcksprungadresse wieder auf Stack ablegen
        RET
;
;
;   Basic - Befehl   RETURN     (Zwischencode  132 / 084H)
;
A68F9:  POP     IX              ; R√ºcksprungadresse vom Stack holen
A68FB:  POP     BC              ; Steuerwort vom Stack holen
        PUSH    BC              ; und wieder merken
        LD      A,B             ; High - Byte Steuerwort holen
        INC     A               ; Kennung Steuerwort  (0FFH)  ?
        JP      NZ,A637F        ; nein -->  Fehler 14  RETURN error
        LD      A,C             ; Low - Byte Steuerwort holen
        CP      18              ; Code for 'FOR - Daten'  ?
        JR      Z,A6921         ; ja -->  n√§chsten Datensatz vergleichen
        CP      0FEH            ; Code for 'RETURN - Daten'  ?
        JP      NZ,A637F        ; nein -->  Fehler 14  RETURN error
        POP     BC              ; Steuerwort vom Stack holen
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        EX      DE,HL           ; Programmzeiger nach DE
        POP     HL              ; Zeilennummer vom Stack holen
        LD      (S9E51),HL      ; als aktuelle Zeilennummer merken
        POP     HL              ; Zeiger auf n√§chste Zeile vom Stack holen
        LD      (S9E4B),HL      ; Zeiger auf n√§chste Programmzeile merken
        POP     HL              ; Programmzeiger vom Stack holen
        PUSH    IX              ; R√ºcksprungadresse wieder auf Stack ablegen
        RET     Z               ; Befehlsende -->  n√§chster Befehl
        EX      DE,HL           ; Programmzeiger bei RETURN wieder nach HL
        JP      A69AF           ; GOTO - Routine   (RETURN Zeilennummer)
;
A6921:  EX      DE,HL           ; Programmzeiger nach DE retten
        LD      HL,18           ; L√§nge FOR - Datensatz
        ADD     HL,SP           ; Zeiger auf n√§chsten Datensatz errechnen
        LD      SP,HL           ; Stackpointer neu setzen
        EX      DE,HL           ; Programmzeiger wieder nach HL
        JR      A68FB           ; n√§chsten Datensatz √ºberpr√ºfen
;
;
;   Basic - Befehl   GOSUB     (Zwischencode  129 / 081H)
;
A692A:  PUSH    HL              ; Programmzeiger retten
        CALL    A67FE           ; Zeiger in HL auf Ende Befehl stellen
        EX      DE,HL           ; Zeiger in DE merken
        POP     HL              ; geretteten Programmzeiger holen
        POP     BC              ; R√ºcksprungadresse holen
        PUSH    DE              ; Zeiger auf n√§chsten Befehl merken
        EXX
        LD      HL,(S9E4B)      ; Zeiger auf n√§chste Programmzeile holen
        PUSH    HL              ; f√ºr RETURN auf Stack merken
        LD      HL,(S9E51)      ; aktuelle Zeilennummer holen
        PUSH    HL              ; f√ºr RETURN auf Stack merken
        LD      HL,0FFFEH       ; Code for 'RETURN - Daten'
        PUSH    HL              ; auf Stack ablegen
        LD      HL,-512         ; Vorgabe f√ºr Arbeitsspeicherl√§nge
        ADD     HL,SP           ; minimale Stackadresse errechnen
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        SBC     HL,DE           ; Adresse √ºberpr√ºfen
        LD      A,10            ; Fehler 10  GOSUB nesting error
        JP      C,A63A9         ; Adressen √ºberschneiden sich -->  Fehler ausgeben
        EXX
        PUSH    BC              ; R√ºcksprungadresse wieder auf Stack ablegen
        JR      A69AF           ; GOTO - Routine
;
;
;   Basic - Befehl   ON     (Zwischencode  157 / 09DH)
;
A6952:  CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    _ERROR          ; ERROR  (Zwischencode)  ?
        JP      Z,A64E4         ; ja -->  ON ERROR GOTO
        CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        LD      C,E             ;! Z√§hler nach BC √ºbertragen
        LD      B,D             ;!
        CP      087H            ; mit maximalem Befehl f√ºr ON ___  vergleichen
        JP      NC,A6364        ; Fehler 1  Syntax error
        CP      ____GO          ; Zwischencode  GO  ?
        JR      NZ,A6977        ; nein
        CALL    A015D           ; HL + 1, Leerzeichen  (Spaces)  (HL) √ºberspringen
        LD      E,_GOSUB        ; ZwischenCode for 'GOSUB'  vorgeben
        CP      ____PI          ; Zwischencode PI   (hier sollte wohl SUB stehen)
        JR      Z,A6976         ; ja -->  GOSUB
        CP      ____TO          ; Zwischencode  TO  ?
        JP      NZ,A6364        ; Fehler 1  Syntax error
        DEC     E               ; Zwischencode auf 'GOTO'
A6976:  LD      A,E             ; Zwischencode des Befehls holen
A6977:  PUSH    HL              ; Programmzeiger retten
        LD      HL,W5C5B        ; Zeiger auf Tabelle mit Anfangsadressen der Befehle
        SUB     080H            ; Zwischencode in Z√§hler umrechnen
        ADD     A,A             ; mal zwei   (zwei Byte je Adresse)
        LD      E,A             ; Low - Byte Offset vorgeben
        LD      D,0             ; High - Byte Offset auf Null
        ADD     HL,DE           ; Zeiger auf richtige Adresse errechnen
        CALL    A0151           ; Offset auf n√§chste Zeile nach HL holen
        EX      (SP),HL         ; Anfangsadresse retten / Programmzeiger holen
        INC     HL              ; Zwischencode des Befehls √ºberspringen
        LD      A,B             ; High - Byte Z√§hler holen
        OR      A               ; gleich Null  ?
        JR      NZ,A69AB        ; nein -->  n√§chsten Befehl ausf√ºhren
        LD      A,C             ; Low - Byte Z√§hler holen
        OR      A               ; gleich Null  ?
        JR      Z,A69AB         ; ja -->  n√§chsten Befehl ausf√ºhren
        LD      B,A             ; Z√§hler merken
A6990:  DEC     B               ; Z√§hler minus eins
        RET     Z               ; Zeiger steht auf richtiger Zeilennummer
        CALL    A015E           ; Leerzeichen  (Spaces)  (HL) √ºberspringen
        CALL    A69DB           ; Zeichen im Accu gleich Kennung Sprungadresse  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
        CALL    A6A10           ; Sprungadresse (HL) √ºberspringen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja 
        INC     HL              ; Trennzeichen √ºberspringen
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      Z,A6990         ; ja -->  auf richtige Adresse √ºberpr√ºfen
        POP     DE              ; Anfangsadresse der Routine verwerfen
        JP      A797A           ; auf Syntax 'Befehlsende' √ºberpr√ºfen
;
A69AB:  POP     DE              ; Anfangsadresse der Routine verwerfen
        JP      A67FE           ; Zeiger in HL auf Ende Befehl stellen
;
;
;   Basic - Befehl   GOTO    (Zwischencode  128 / 080H)
;
A69AF:  CALL    A5E19           ; Zeiger auf Zeile nach Programmtext (HL) bereitstellen
        EX      DE,HL           ; Programmzeiger nach DE / Zeiger auf Zeile nach HL
        JR      NZ,A69B8        ; Zeilennummer war nicht Null
        LD      HL,(S1070)      ; Basic - Programmanfang holen
A69B8:  LD      (S9E4B),HL      ; als Zeiger auf n√§chste Programmzeile merken
        XOR     A               ; Code for 'kein CONT m√∂glich'
        LD      (M63F6),A       ; CONT - Flag zur√ºcksetzen
        JP      A5909           ; Programm ab Zeile (HL) abarbeiten
;
;
;   Basic - Befehl   IF     (Zwischencode  147 / 093H)
;
A69C2:  CALL    A857C           ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
        EX      AF,AF           ; n√§chstes Programmbyte retten
        LD      A,(DE)          ; Exponent Ergebnis holen
        OR      A               ; gleich Null  ?
        JR      Z,A69EA         ; ja -->  Bedingung nicht erf√ºllt
        EX      AF,AF           ; n√§chstes Programmbyte holen
        CP      __THEN          ; Zwischencode  THEN  ?
        JR      NZ,A69D7        ; nein -->  n√§chsten Befehl abarbeiten
A69CF:  CALL    A015D           ; HL + 1, Leerzeichen  (Spaces)  (HL) √ºberspringen
        CALL    A69DB           ; Zeichen im Accu gleich Kennung Sprungadresse  ?
        JR      Z,A69AF         ; ja -->  GOTO ausf√ºhren
A69D7:  POP     AF              ; R√ºcksprungadresse vom Stack holen
        JP      A58D4           ; n√§chsten Befehl abarbeiten
;
;
;   testen, ob Zeichen im Accu gleich Kennung Sprungadresse ist
;
A69DB:  CP      '\"'            ; Kennung  Label  ?
        RET     Z               ; ja
;
;
;   testen, ob Zeichen im Accu gleich Kennung f√ºr Zeilennummer ist
;
A69DE:  CP      _LINNO          ; Code for 'Integer - Zeilennummer'  ?
        RET     Z               ; ja
        CP      _LIN_P          ; Code for 'Zeiger auf Zeile'  ?
        RET
;
;
;   Basic - Befehl   ELSE     (Zwischencode  194 / 0C2H)
;
A69E4:  CALL    A69F3           ; zum IF geh√∂riges ELSE suchen
        JR      NC,A69E4        ; nicht Zeilenende -->  Zeilenende suchen
        RET
;
;
;   IF mit nicht erf√ºllter Bedingung
;
A69EA:  DEC     HL              ; Programmzeiger f√ºr Schleife corrigieren
        CALL    A69F3           ; zum IF geh√∂riges ELSE suchen
        JR      NC,A69CF        ; nicht Zeilenende -->  Anweisung abarbeiten
        JP      A5906           ; n√§chste Basic - Zeile abarbeiten
;
;
;   zum IF geh√∂riges ELSE suchen
;
A69F3:  CALL    A6A0A           ; Zeiger in HL auf n√§chstes relevantes Programmbyte
        OR      A               ; Zeilenende  ?
        SCF                     ; Code for 'Zeilenende'  setzen
        RET     Z               ; Zeilenende
        CP      __ELSE          ; Zwischencode  ELSE  ?
        RET     Z               ; ja
        CP      ____IF          ; Zwischencode  IF  ?
        JR      NZ,A69F3        ; nein -->  weiter suchen
        CALL    A69F3           ; zum IF geh√∂riges ELSE suchen
        RET     C               ; Zeilenende
        JR      A69F3           ; zum IF geh√∂riges ELSE suchen
;
A6A06:  INC     HL              ; Trennungszeichen √ºberspringen
        LD      A,(HL)          ; n√§chstes Programmbyte holen
        JR      A6A10           ; Sprungadresse (HL) √ºberspringen
;
;
;   Zeiger in HL auf n√§chstes relevantes Programmbyte stellen
;
A6A0A:  INC     HL              ; Programmzeiger auf n√§chstes Programmbyte
        LD      A,(HL)          ; n√§chstes Programmbyte holen
        CP      __DATA          ; Zwischencode  DATA  ?
        JR      Z,A6A2F         ; ja -->  DATA - Statement √ºberspringen
A6A10:  OR      A               ; Zeilenendecode  ?
        RET     Z               ; ja 
        CP      '\"'            ; Textkonstante  ?
        JR      Z,A6A4D         ; ja -->  Ende der Textkonstanten suchen
        CP      0FEH            ; Vorbyte f√ºr Tabellen zwei und drei  ?
        JR      NC,A6A2D        ; Befehl aus Tabelle zwei oder drei
        CP      ___REM          ; Zwischencode  REM  ?
        JR      Z,A6A2F         ; ja -->  Kommentar √ºberspringen
        CP      '\''            ; Code for 'Kommentar'  ?
        JR      Z,A6A2F         ; ja -->  Kommentar √ºberspringen
        CP      ' '             ; Steuerzeichen  ?
        RET     NC              ; nein
        CP      _LINNO
        RET     C               ; ein - Byte - Steuerzeichen  
        CP      __REAL          ; Real - Zahlwert  ?
        JR      NC,A6A44        ; ja
        INC     HL              ;! Integer - Wert / - Zeiger √ºberspringen
A6A2D:  INC     HL              ;!
        RET
;
A6A2F:  LD      A,(HL)          ; n√§chstes Programmbyte holen
        OR      A               ; Zeilenendezeichen ?
        RET     Z               ; ja
        CP      ':'             ; Befehlsendezeichen  ?
        RET     Z               ; ja
        CP      '\"'            ; Anfang Textkonstante  ?
        JR      Z,A6A3C         ; ja -->  Ende der Textkonstanten suchen
        INC     HL              ; Zeichen √ºberspringen
        JR      A6A2F           ; Ende des Befehls suchen
;
A6A3C:  CALL    A6A4D           ; Zeiger in HL auf Ende Textkonstante stellen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja
        INC     HL              ; Textendezeichen √ºberspringen
        JR      A6A2F           ; Befehlsende suchen
;
A6A44:  AND     00001111B       ; L√§nge des Zahlwertes maskieren
        ADD     A,L             ; zum Low - Byte Programmzeiger addieren
        LD      L,A             ; neues Low - Byte Zeiger merken
        LD      A,' '           ; Space  (Leerzeichen)  vorgeben
        RET     NC              ; kein √úbertrag
        INC     H               ; High - Byte Programmzeiger corrigieren
        RET
;
A6A4D:  INC     HL              ; Programmzeiger auf n√§chstes Byte stellen
        LD      A,(HL)          ; n√§chstes Programmbyte holen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja 
        CP      '\"'            ; Textendezeichen ?
        RET     Z               ; ja
        JR      A6A4D           ; Ende der Textkonstanten suchen
;
;
;   Basic - Befehl   BEEP     (Zwischencode  254 141 / 0FEH 08DH)
;
A6A56:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    32              ; Code 32  Referenzton ausgeben
        RET
;
;
;   Basic - Befehl   BYE     (Zwischencode  196 / 0C4H)
;
A6A59:  CALL    A797A           ; auf Syntax 'Befehlsende' √ºberpr√ºfen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    40              ; Code 40   alle Datei - Daten im Rechner l√∂schen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    0               ; Code 0   BASIC - Monitor aufrufen
        RET
;
;
;   Basic - Befehl   CONSOLE     (Zwischencode  184 / 0B8H)
;
A6A61:  JR      Z,A6A8D         ; keine Parameter -->  Ausschnitt aufheben
        LD      A,(S136F)       ; aktuelle minimale Y - Koordinate holen
        LD      D,0             ; High - Byte auf Null
        LD      E,A             ; minimale Y - Koordinate merken
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      Z,A6A75         ; keine minimale Y - Koordinate angegeben
        CALL    A853D           ; ein - Byte - Wert nach DE / Accu bereitstellen
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
A6A75:  LD      C,E             ; minimale Y - Koordinate 
        PUSH    BC              ; merken
        CALL    A853D           ; ein - Byte - Wert nach DE / Accu bereitstellen
        POP     BC              ; minimale Y - Koordinate holen
        DEC     A               ; Anzahl Zeilen gleich Null  ?
        JP      M,A636A         ; ja -->  Fehler 3  Illegal data error
        ADD     A,C             ; maximale Y - Koordinate errechnen
        CP      25              ; mit maximal m√∂glicher Y - Koordinate vergleichen
        JP      NC,A636A        ; zu gro√ü -->  Fehler 3  Illegal data error
        LD      B,A             ; maximale Y - Koordinate merken
        PUSH    HL              ; Programmzeiger retten
        LD      H,B             ; maximale Y - Koordinate
        LD      L,C             ; minimale Y - Koordinate
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    83              ; Code 83  Bildschirmausschnitt nach Daten in HL setzen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Bildschirmausschnitt aufheben
;       
A6A8D:  PUSH    HL              ; Programmzeiger retten
        LD      HL,256 * 24 + 0 ; Y - Koordinate minimal / maximal vorgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    83              ; Code 83  Bildschirmausschnitt nach Daten in HL setzen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   BOOT     (Zwischencode  254 174 / 0FEH 0AEH)
;
A6A95:  DI                      ; Interrupt sperren
        OUT     (_KMODE),A      ; Umschalten auf MZ-80 - K - Modus
        JP      A0000           ; Kaltstart Monitor
;
;
;   Basic - Befehl   SEARCH     (Zwischencode  185 / 0B9H)
;
A6A9B:  XOR     A               ; Code for 'SEARCH'
        DEFB    LD_BC
;
;
;   Basic - Befehl   LIST     (Zwischencode  135 / 087H)
;
A6A9D:  LD      A,1             ; Code for 'LIST'
        LD      (S6B83),A       ; im Flag  SEARCH/LIST/SAVE  merken
        PUSH    AF              ; Flag  'SEARCH/LIST'  merken
        CALL    A6EF9           ; Datei- oder Ger√§tenummer bereitstellen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    46              ; Code 46  Datei-Verwaltungssatz nach Nr. bereitstellen
        JP      C,A63A3         ; nicht gefunden -->  Fehler 64  Logical number error
        BIT     1,A             ; Datei/Ger√§t zum Schreiben ge√∂ffnet  ?
        JP      Z,A63A3         ; nein -->  Fehler 64  Logical number error
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        POP     AF              ; Flag  'SEARCH/LIST'  holen
        OR      A               ; SEARCH oder LIST - Befehl
        JR      NZ,A6ACD        ; LIST - Befehl
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        LD      A,B             ; Stringl√§nge holen
        LD      (S6B7E),A       ; und f√ºr Vergleich merken
        LD      (S6B7F),DE      ; Zeiger auf Suchstring merken
        CALL    A797A           ; auf Syntax 'Befehlsende' √ºberpr√ºfen
        JR      A6ACD           ; Anfangs- und Endzeilennummer bereitstellen
;
;
;   Programmzeilen aufbereiten in ASCII und an Datei ausgeben
;
A6AC8:  LD      A,2             ; Code for 'SAVE'
        LD      (S6B83),A       ; im Flag  SEARCH/LIST/SAVE  merken
A6ACD:  CALL    A5ED3           ; Zeilennummern aus Eingabe bereitstellen
        LD      (D6AF3 + 1),DE  ; Anfangszeilennummer in Routine eintragen
        LD      (A6B01 + 1),BC  ; Endzeilennummer in Routine eintragen
        LD      A,-1            ; Code for 'Steuerzeichen anzeigen'
        LD      (S1090),A       ; im Flag  'Steuerzeichen anzeigen'  eintragen
        CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      HL,(S1070)      ; Basic - Programmanfang holen
A6AE3:  CALL    A012D           ; Offset auf n√§chste Zeile nach DE holen
        LD      A,D             ;! Offset gleich Null  ?
        OR      E               ;!
        RET     Z               ; ja -->  fertig
        EX      DE,HL           ;! Zeiger auf n√§chste Zeile errechnen
        ADD     HL,DE           ;! 
        DEC     HL              ;!
        DEC     HL              ;!
        EX      DE,HL           ; Zeiger auf n√§chste Zeile nach DE
        PUSH    DE              ; Zeiger auf n√§chste Zeile merken
        CALL    A012D           ; Zeilennummer der Zeile nach DE holen
        PUSH    HL              ; Zeiger auf Zeile retten
D6AF3:  LD      HL,0            ; Anfangszeilennummer holen   (wird eingetragen)
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Zeilennummern vergleichen
        JR      C,A6B01         ; OK -->  auf Endzeilennummer untersuchen
        JR      Z,A6B01         ; OK -->  auf Endzeilennummer untersuchen
        POP     HL              ; Zeiger auf Zeile verwerfen
        POP     HL              ; Zeiger auf n√§chste Zeile holen
        JR      A6AE3           ; n√§chste Zeile √ºberpr√ºfen
;
A6B01:  LD      HL,0            ; Endzeilennummer holen   (wird eingetragen)
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Zeilennummern vergleichen
        JR      NC,A6B0C        ; Zeile mu√ü bearbeitet werden
        POP     HL              ; Zeiger auf Zeile verwerfen
        POP     HL              ; Zeiger auf n√§chste Zeile verwerfen
        RET
;
A6B0C:  EX      DE,HL           ; Zeilennummer nach HL
        CALL    A7998           ; Hex-Wert in HL umsetzen in Dezimal nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    23              ; Code 23  L√§nge des Textes (DE) ausz√§hlen
        LD      HL,S11A4        ; Zeiger auf Zwischenspeicher vorgeben
        CALL    A014A           ; Speicherbereich von (DE) nach (HL) verschieben
        LD      (HL),' '        ; Leerzeichen nach Zeilennummer eintragen
        INC     HL              ; Leerzeichen √ºberspringen
        EX      DE,HL           ; Zeiger auf Speicher nach DE
        POP     HL              ; Zeiger auf Zwischencodezeile holen
		CALL    A8401           ; Zwischencodezeile (HL) umsetzen in ASCII nach (DE)
        LD      A,(S6B83)       ; Flag  SEARCH/LIST/SAVE  holen
        OR      A               ; SEARCH  ?
        JR      NZ,A6B2B        ; nein -->  Zeile ausgeben
        CALL    A6B41           ; vergleichen, ob Zeile f√ºr SEARCH ausgegeben werden mu√ü
        JR      NC,A6B35        ; Text nicht gefunden -->  Zeile nicht ausgeben
A6B2B:  LD      DE,S11A4        ; Zeiger auf Text der aufbereiteten Zeile
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    23              ; Code 23  L√§nge des Textes (DE) ausz√§hlen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    55              ; Code 55  Text (DE) auf angew√§hltem Ger√§t/Datei ausgeben
        CALL    A6DB1           ; Zeilenvorschub auf angew√§hltem Ger√§t/Datei ausgeben
A6B35:  POP     HL              ; Zeiger auf n√§chste Zeile holen
        LD      A,(S6B83)       ; Flag  SEARCH/LIST/SAVE  holen
        CP      2               ; SAVE  ?
        JR      Z,A6AE3         ; ja -->  n√§chste Zeile √ºberpr√ºfen   (und ausgeben)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    15              ; Code 15  wenn Sapce gedr√ºckt -->  warten bis andere Taste
        JR      A6AE3           ; n√§chste Zeile √ºberpr√ºfen (und ausgeben)
;
;
;   vergleichen, ob Zeile f√ºr SEARCH ausgegeben werden mu√ü
;
A6B41:  EX      DE,HL           ; Zeiger auf ASCII - Text - Zeile nach HL
A6B42:  PUSH    HL              ; Zeiger auf Stelle der Zeile retten
        CALL    A6B4C           ; auf Suchtext vergleichen
        POP     HL              ; geretteten Zeiger auf Textstelle holen
        RET     C               ; Text gefunden
        RET     Z               ; Zeilenende gefunden
        INC     HL              ; Zeiger auf Text auf n√§chstes Zeichen
        JR      A6B42           ; Text ab neuer Anfangsstelle vergleichen
;
A6B4C:  LD      A,(S6B7E)       ; Textl√§nge des Suchstrings holen
        LD      B,A             ; und merken
        LD      DE,(S6B7F)      ; Zeiger auf Suchstring holen
A6B54:  LD      A,(HL)          ; ein Zeichen Text holen
        INC     HL              ; Zeiger auf Text auf n√§chstes Zeichen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja
        CP      _SML            ; Umschalten auf Kleinschrift  ?
        JR      Z,A6B60         ; ja -->  n√§chstes Zeichen holen
        CP      _CAP            ; Umschalten auf Gro√üschrift  ?
        JR      NZ,A6B62        ; nein -->  Zeichen vergleichen
A6B60:  JR      A6B54           ; n√§chstes Zeichen holen und vergleichen
;
A6B62:  PUSH    HL              ; Zeiger auf Text retten
        LD      C,A             ; Zeichen merken
A6B64:  LD      A,(DE)          ; ein Zeichen Textvorgabe holen
        INC     DE              ; Zeiger auf n√§chstes Zeichen 
        CP      _SML            ; Umschalten auf Kleinschrift  ?
        JR      Z,A6B6E         ; ja -->  nicht vergleichen
        CP      _CAP            ; Umschalten auf Gro√üschrift  ?
        JR      NZ,A6B75        ; nein -->  Zeichen vergleichen
A6B6E:  DEC     B               ; Z√§hler  'Restanzahl'  minus eins
        SCF                     ; Code for 'Text gefunden'  setzen
        POP     HL              ; Zeiger auf Zeile holen
        RET     Z               ; alle Zeichen verglichen
        PUSH    HL              ; Zeiger auf Zeile retten
        JR      A6B64           ; n√§chstes Zeichen vergleichen
;
A6B75:  SUB     C               ; Zeichen vergleichen
        POP     HL              ; Zeiger auf Zeile holen
        OR      A               ; Zeichen gefunden  ?
        RET     NZ              ; nein
        DEC     B               ; Z√§hler  'Restanzahl'  minus eins
        SCF                     ; Code for 'Text gefunden'  setzen
        RET     Z               ; alle Zeichen verglichen
        JR      A6B54           ; n√§chstes Zeichen vergleichen
;
;
;   Speicher f√ºr SEARCH - Befehl
;
S6B7E:  DEFS    1               ; Textl√§nge Suchstring
;
S6B7F:  DEFS    2               ; Zeiger auf Suchstring
;
        DEFS    2  
;
S6B83:  DEFS    1               ; Flag  SEARCH/LIST/SAVE
;
;
;   Basic - Befehl   KEY     (Zwischencode  178 / 092H)
;
A6B84:  CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    __LIST          ; LIST   (Zwischencode)   ?
        CALL    A7981           ; auf /P untersuchen und Ausgabeger√§t vorgeben
        PUSH    HL              ; Programmzeiger retten
        LD      C,0             ; Z√§hler f√ºr Tastennummer auf Null
A6B8E:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    8               ; Code 8  Zeilenvorschub auf Bildschirm oder Drucker ausgeben
        LD      A,C             ; Tastenz√§hler holen
        ADD     A,'1'           ; umsetzen in ASCII
        LD      D,A             ; und merken
        LD      E,' '           ; Leerzeichen  (Space)  f√ºr erste Stelle vorgeben
        CP      '9' + 1         ; gr√∂√üer als 9 ?
        JR      NZ,A6B9D        ; nein
        LD      DE,'0'*256+'1'  ; 10 vorgeben
A6B9D:  LD      (M6C20),DE      ; Tastennummer in Text eintragen
        LD      DE,M6C18        ; Text  'DEF KEY(xx)='
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    11              ; Code 11  Text (DE) auf Bildschirm oder Drucker ausgeben
        LD      A,C             ; Tastenz√§hler holen
        CALL    A6C77           ; Zeiger auf Tastentextspeicher nach Nummer in A stellen
        LD      B,(HL)          ; Textl√§nge holen
        INC     HL              ; Textl√§nge √ºberspringen
        PUSH    BC              ; Tastenz√§hler merken
        CALL    A6BBB           ; Text der Taste aufbereiten und ausgeben
        POP     BC              ; Tastenz√§hler holen
        INC     C               ; plus eins
        LD      A,C             ; neuen Wert holen
        CP      10              ; alle Tastentexte ausgegeben  ?
        JR      NZ,A6B8E        ; nein -->  weitere Tastentexte ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    8               ; Code 8  Zeilenvorschub auf Bildschirm oder Drucker ausgeben
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Tastentext (HL) aufbereiten und ausgeben
;
A6BBB:  LD      A,B             ; Textl√§nge holen
        OR      A               ; gleich Null  ?
        LD      C,0             ; Code for 'nicht im Text'
        JR      NZ,A6BC8        ; Textl√§nge ungleich Null -->  ausgeben
        LD      A,'\"'          ; Anf√ºhrungszeichen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    10              ; Code 10  Accu auf Bildschirm oder Drucker (Anzeige Steuerzeichen)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    10              ; Code 10  Accu auf Bildschirm oder Drucker (Anzeige Steuerzeichen)
        RET
;
A6BC8:  LD      A,(HL)          ; ein Zeichen Text holen
        CP      ' '             ; Steuerzeichen  ?
        JR      C,A6BED         ; ja -->  als CHR$  ausgeben
        CP      '\"'            ; Anf√ºhrungszeichen ?
        JR      Z,A6BED         ; ja -->  als CHR$  ausgeben
        LD      A,C             ; Textcodeflag holen
        CP      1               ; Code for 'im Text'  ?
        JR      Z,A6BE0         ; ja
        OR      A               ; Code for 'im CHR$'  ?
        LD      DE,M6C25        ; Text  ')+"'
        JR      NZ,A6BDE        ; im CHR$ -->  CHR$ abschliessen
        INC     DE              ;! Textzeiger auf Anf√ºhrungszeichen stellen
        INC     DE              ;!
A6BDE:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    11              ; Code 11  Text (DE) auf Bildschirm oder Drucker ausgeben
A6BE0:  LD      A,(HL)          ; ein Zeichen Tastentext holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    10              ; Code 10  Accu auf Bildschirm oder Drucker (Anzeige Steuerzeichen)
        INC     HL              ; Zeiger auf Tastentext auf n√§chstes Zeichen
        LD      C,1             ; Code for 'im Text'  vorgeben
        DJNZ    A6BC8           ; weitere Zeichen ausgeben
        LD      A,'\"'          ; Anf√ºhrungszeichen
A6BEA:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    10              ; Code 10  Accu auf Bildschirm oder Drucker (Anzeige Steuerzeichen)
        RET
;
A6BED:  LD      A,C             ; Textcodeflag holen
        CP      -1              ; Code for 'im CHR$'  ?
        JR      Z,A6C12         ; ja -->  Komma ausgeben
        OR      A               ; Code for 'im Text'  ?
        LD      DE,M6C29        ; Text '"+CHR$('
        JR      NZ,A6BFA        ; ja -->  Anf√ºhrungszeichen mit ausgeben
        INC     DE              ;! Anf√ºhrungszeichen und plus √ºberspringen
        INC     DE              ;!
A6BFA:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    11              ; Code 11  Text (DE) auf Bildschirm oder Drucker ausgeben
A6BFC:  PUSH    BC              ; Restl√§nge retten
        PUSH    HL              ; Zeiger auf Resttext retten
        LD      L,(HL)          ; Steuerzeichen holen
        LD      H,0             ; High - Byte Wert auf Null
        CALL    A7998           ; Hex-Wert in HL umsetzen in Dezimal nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    11              ; Code 11  Text (DE) auf Bildschirm oder Drucker ausgeben
        POP     HL              ; geretteten Zeiger auf Resttext holen
        POP     BC              ; gerettete Restanzahl Zeichen holen
        INC     HL              ; Zeiger auf Text auf n√§chstes Zeichen
        LD      C,-1            ; Code for 'im CHR$'
        DJNZ    A6BC8           ; weitere Zeichen Text ausgeben
        LD      A,')'           ; Klammer zu, um CHR$ abzuschliessen
        JP      A6BEA           ; Zeichen im Accu ausgeben
;
A6C12:  LD      A,','           ; Komma als Trennzeichen zwischen Werten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    10              ; Code 10  Accu auf Bildschirm oder Drucker (Anzeige Steuerzeichen)
        JR      A6BFC           ; Steuerzeichen ausgeben
;
;
;   Texte f√ºr KEY  LIST  - Befehl
;
M6C18:  DEFM    "DEF KEY("      ; Text  'DEF KEY(  )=
M6C20:  DEFS    2               ; Freistelle f√ºr Tastennummer
        DEFM    ")="
		DEFB    NUL
;
M6C25:  DEFM    ")+\""          ; Text  ')+"'
        DEFB    NUL
;
M6C29:  DEFM    "\"+CHR$("      ; Text  '"+CHR$('
        DEFB    NUL
;
;
;   Basic - Befehl   DEF     (Zwischencode  199 / 0C7H)
;
A6C31:  CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    ___KEY          ; KEY  (Zwischencode)  ?
        JR      Z,A6C42         ; ja -->  DEF KEY
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    0FFH            ; Vorbyte  Tabelle drei  ?
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    ____FN          ; FN   (Zwischencode)  ?
        JP      A8F44           ; Basic - Befehl   DEF FN
;
;
;   Basic - Befehl   DEF KEY     (Zwischencode 199 178 / 0C7H 0B2H)
;
A6C42:  CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "("             ; Klammer auf  ?
        CALL    A853D           ; ein - Byte - Wert nach DE / Accu bereitstellen
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    ")"             ; Klammer zu  ?
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFB    ____EQ          ; =   (Zwischencode)  ?
        LD      A,E             ; Tastennummer holen
        DEC     A               ; f√ºr Tastenoffset corrigieren
        CP      10              ; Taste null bis neun  ?
        JP      NC,A636A        ; nein -->  Fehler 3  Illegal data error
        PUSH    HL              ; Programmzeiger retten
        CALL    A6C77           ; Zeiger auf Tastentextspeicher nach Nummer in A stellen
        EX      (SP),HL         ; Zeiger f√ºr Tastentext retten / Programmzeiger holen
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        EX      (SP),HL         ; Programmzeiger retten / Zeiger f√ºr Text holen
        LD      A,B             ; Textl√§nge holen
        CP      15 + 1          ; mit maximaler L√§nge vergleichen
        JR      C,A6C68         ; Textl√§nge ist OK
        LD      A,15            ; maximale Textl√§nge vorgeben
A6C68:  LD      (HL),A          ; Textl√§nge in Speicher eintragen
        OR      A               ; Textl√§nge gleich Null  ?
        JR      Z,A6C74         ; ja -->  geretteten Programmzeiger holen
        LD      B,A             ; Textl√§nge als Z√§hler vorgeben
        INC     HL              ; Textl√§nge √ºberspringen
A6C6E:  LD      A,(DE)          ;! ein Zeichen Text √ºbertragen
        LD      (HL),A          ;!
        INC     DE              ;!   Zeiger auf vorgegebenen Text
        INC     HL              ;!   Zeiger auf Stelle f√ºr Tastentext
        DJNZ    A6C6E           ; weitere Zeichen √ºbertragen
A6C74:  POP     HL              ; geretteten Programmzeiger holen
        EI                      ; Interrupt freigeben
        RET
;
;
;   Zeiger auf Tastentextspeicher nach Nummer im Accu bereitstellen
;
A6C77:  ADD     A,A             ;! Tastenz√§hler mal  2    (16 Byte je Taste)
        ADD     A,A             ;!                   4
        ADD     A,A             ;!                   8
        ADD     A,A             ;!                  16
        LD      HL,B12B2        ; Zeiger auf Speicher f√ºr Funktionstastentexte
        JP      A0158           ; Wert im Accu zum HL - Register addieren
;
;
;   Abfrage, ob aktuelles Ger√§t gleich Bildschirm ist
;
A6C81:  LD      A,(S1042)       ; interne aktuelle Ger√§te - Nummer holen
        CP      136             ; Ger√§te - Nummer Bildschirm   (CRT:)  ?
        RET
;
;
;   Ausdruck (HL) auswerten und Ergebnis als Zeichenketten bereitstellen
;
A6C87:  CALL    A857C           ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
        LD      A,(S9E9C)       ; Wertartflag holen
        CP      3               ; Zeichenkettenwert  ?
        PUSH    HL              ; Programmzeiger retten
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        JR      Z,A6C9A         ; Ergebnis ist Zeichenkette
		CALL    A7B5B           ; Real-Wert (HL) umsetzen in ASCII nach Zwischenspeicher
        POP     HL              ; geretteten Programmzeiger holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    23              ; Code 23  L√§nge des Textes (DE) ausz√§hlen
        RET
;
A6C9A:  CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   PRINT     (Zwischencode  143 / 08FH)
;
A6C9F:  XOR     A               ; Code for 'Steuerzeichen ausf√ºhren'
        LD      (S1090),A       ; im Flag  'Steuerzeichen anzeigen'  merken
        CALL    A6EF9           ; Datei- oder Ger√§tenummer bereitstellen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    46              ; Code 46  Datei-Verwaltungssatz nach Nr. bereitstellen
        JP      C,A6E2D         ; Datei nicht gefunden -->  Fehler 44  Not open error
        BIT     2,A             ; XOPEN  ?
        JP      NZ,A7459        ; ja -->  PRINT auf RANDOM - Datei
        BIT     1,A             ; Datei oder Ger√§t zum Schreiben er√∂ffnet  ?
        JP      Z,A6E30         ; nein -->  Fehler 59'  Can't execute error
        CALL    A6F39           ; bei Datei auf 'Syntax Komma' √ºberpr√ºfen
        CALL    A6C81           ; Abfrage, ob aktuelles Ger√§t gleich Bildschirm ist
        JR      NZ,A6CD3        ; nicht Bildschirm -->  nicht auf Farbe untersuchen
        LD      A,(S137B)       ; maximaler Palettenwert / aktuelle Zeichenfarbe holen
        LD      (B7591),A       ; als Vorgabe f√ºr Palettenwert der Zeichen merken
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    "["             ; Eckige Klammer auf  ?
        JR      NZ,A6CD3        ; nein -->  kein Farbwert angegeben
		CALL    A76D9           ; Ausdruck (HL) auswerten und auf max. Palettenwert untersuchen
        LD      (B7591),A       ; Palettenwert f√ºr Zeichen merken
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "]"             ; eckige Klammer zu  ?
A6CD3:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JP      Z,A6DB1         ; Zeilenvorschub auf angew√§hltem Ger√§t/Datei ausgeben
A6CD9:  LD      A,(HL)          ; n√§chstes Programmbyte holen
        CP      _USING          ; Zwischencode  USING  ?
        JR      Z,A6D58         ; ja -->  PRINT USING - Routine
        LD      BC,T6CF2        ; R√ºcksprungadresse
        PUSH    BC              ; auf Stack ablegen
        CP      ';'             ; Trennzeichen Strichpunkt ?
        RET     Z               ; ja
        CP      ','             ; Trennzeichen Komma  ?
        RET     Z               ; ja
        CP      ___TAB          ; Zwischencode  TAB  ?
        JR      Z,A6D28         ; ja -->  PRINT TAB
        CALL    A6C87           ; Ausdruck (HL) auswerten / Ergebnis als Zeichenkette
        JP      A6DB6           ; bereitgestellten Wert auf Ger√§t/Datei ausgeben
;
T6CF2:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JP      Z,A6DB1         ; Zeilenvorschub auf angew√§hltem Ger√§t/Datei ausgeben
        CP      ','             ; Trennzeichen Komma  ?
        JR      NZ,A6D18        ; nein -->  auf anderes Trennzeichen untersuchen
;
;
;   Ausgabe bei PRINT auf n√§chste 10er - Tabulationsstelle setzen
;
        CALL    A6C81           ; Abfrage, ob aktuelles Ger√§t gleich Bildschirm ist
        JR      C,A6D15         ; Tabulation auf Ger√§t nicht m√∂glich -->  Zeilenvorschub
        LD      IX,(S1061)      ; Adresse 'aktuelle Spaltennummer bereitstellen' holen
        CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        LD      B,A             ; aktuelle Spaltennummer merken
A6D09:  SUB     10              ; 10 abziehen
        JR      NC,A6D09        ; weiter abziehen
        NEG                     ; Anzahl auszugebender Zeichen errechnen
        LD      B,A             ; Anzahl Zeichen merken
        CALL    A6D4A           ; Zeichenkette mit Spaces aufbauen und ausgeben
        JR      A6D18           ; auf Syntax Trennzeichen untersuchen
;
A6D15:  CALL    A6DB1           ; Zeilenvorschub auf angew√§hltem Ger√§t/Datei ausgeben
A6D18:  LD      A,(HL)          ; n√§chstes Programmbyte holen
        CP      ','             ; Trennzeichen Komma  ?
        JR      Z,A6D1F         ; ja -->  Syntax ist OK
        CP      ';'             ; Trennzeichen Strichpunkt  ?
A6D1F:  JR      NZ,A6D22        ; nein -->  testen, ob Befehlsende
        INC     HL              ; Trennzeichen √ºberspringen
A6D22:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        RET     Z               ; ja -->  n√§chster Befehl
        JR      A6CD9           ; n√§chsten PRINT - Teil ausf√ºhren
;
;
;   PRINT TAB
;
A6D28:  CALL    A6C81           ; Abfrage, ob aktuelles Ger√§t gleich Bildschirm ist
        JP      C,A6E30         ; kein tabellierbares Ger√§t -->  Fehler 59'  Can't execute error
		CALL    A79A2           ; auf Syntax 'Klammer auf' √ºberpr√ºfen
        CALL    A853D           ; ein - Byte - Wert nach DE / Accu bereitstellen
        CALL    A79AA           ; auf Syntax 'Klammer zu' √ºberpr√ºfen
        LD      IX,(S1061)      ; Adresse  'aktuelle Spaltennummer bereitstellen'  holen
        CALL    A0247           ; Routine (IX) mit Fehlerbehandlung aufrufen
        SUB     E               ; mit Tabulationsspalten vergleichen
        RET     NC              ; schon √ºber Tabulationsspalte hinaus -->  Befehl vergessen
        NEG                     ; fehlende Spalten errechnen
        LD      B,A             ; und merken
        CALL    A6C81           ; Abfrage, ob aktuelles Ger√§t gleich Bildschirm ist
        LD      A,C_RIGHT       ; 'Cursor rechts' f√ºr Bildschirm
        JR      Z,A6D4C         ; Ausgabe auf Bildschirm
;
;
;   Zeichenkette mit Leerzeichen aufbauen und ausgeben
;
A6D4A:  LD      A,' '           ; Leerzeichen (Space)  f√ºr anderes Ger√§t
A6D4C:  LD      DE,S11A4+1      ; Zeiger auf Zwischenspeicher vorgeben
        PUSH    BC              ; Anzahl Zeichen retten
        PUSH    DE              ; Zeiger auf Anfang Speicher retten
        CALL    A013E           ; Speicher (DE) mit Zeichen im Accu initiieren
        POP     DE              ; Zeiger auf Anfang Speicher holen
        POP     BC              ; Anzahl Zeichen holen
        JR      A6DB6           ; bereitgestellte Zeichenkette auf Ger√§t/Datei ausgeben
;               
;
;   USING - Format bereitstellen und Werte entsprechend USING - Format ausgeben
;
A6D58:  INC     HL              ; Zwischencode USING √ºberspringen
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        LD      A,B             ; L√§nge Format - Text holen
        OR      A               ; gleich Null  ?
        JP      Z,A636A         ; ja -->  Fehler 3  Illegal data error
        PUSH    HL              ; Programmzeiger retten
        LD      HL,S11A4+1      ; Zeiger auf Zwischenspeicher vorgeben
        PUSH    HL              ; Zeiger auf Anfang Speicher retten
        PUSH    BC              ; Textl√§nge retten
        CALL    A014A           ; Speicherbereich von (DE) nach (HL) verschieben
        POP     BC              ; Textl√§nge holen
        LD      A,240           ; Speichernummer f√ºr USING - Format
        LD      E,B             ; Textl√§nge
        LD      D,0             ; High - Byte Textl√§nge auf Null
        INC     DE              ; f√ºr Textendezeichen corrigieren
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    42              ; Code 42  dynamischen Zwischenspeicher bereitstellen
        LD      (S7E39),HL      ;! Zeiger auf Speicher in Routine eintragen
        LD      (S7E3B),HL      ;!
        POP     DE              ; Zeiger auf Speicher mit Format holen
        CALL    A014A           ; Speicherbereich von (DE) nach (HL) verschieben
        LD      (HL),NUL        ; Textendezeichen eintragen
        POP     HL              ; geretteten Programmzeiger holen
A6D80:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A6DA7         ; ja -->  Speicher f√ºr USING - Format l√∂schen
        INC     HL              ; Trennzeichen √ºberspringen 
        CP      ','             ; Trennzeichen Komma  ?
        JR      Z,A6D8F         ; ja -->  Syntax ist OK
        CP      ';'             ; Trennzeichen Strichpunkt  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
A6D8F:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A6DAA         ; ja -->  Speicher f√ºr USING - Format l√∂schen
        CALL    A8584           ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
        PUSH    HL              ; Programmzeiger retten
        LD      BC,(S107A)      ; Ende Stringarbeitsbereich holen
        PUSH    BC              ; und merken
        CALL    A7E3D           ; bereitgestellten Wert entsprechend USING-Format aufbereiten
        POP     DE              ; Zeiger auf aufbereiteten Text holen
        CALL    A6DB4           ; Text auf angew√§hltem Ger√§t / Datei ausgeben
        POP     HL              ; geretteten Programmzeiger holen
        JR      A6D80           ; testen, ob fertig
;
A6DA7:  CALL    A6DB1           ; Zeilenvorschub auf angew√§hltem Ger√§t/Datei ausgeben
;
;
;   Speicher f√ºr USING - Format l√∂schen
;
A6DAA:  LD      A,240           ; Speichernummer f√ºr USING - Format
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    43              ; Code 43   dynamischen Zwischenspeicher l√∂schen
        RET
;
M6DAF:  DEFB    CR,NUL          ; Text f√ºr Zeilenvorschub
;
;
;   Zeilenvorschub auf angew√§hltem Ger√§t/Datei ausgeben
;
A6DB1:  LD      DE,M6DAF        ; Text  'Zeilenvorschub'
;
;
;   Text auf angew√§hltem Ger√§t / Datei ausgeben
;
A6DB4:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    23              ; Code 23  L√§nge des Textes (DE) ausz√§hlen
A6DB6:  CALL    A6C81           ; Abfrage, ob aktuelles Ger√§t gleich Bildschirm ist
        JR      Z,A6DBE         ; Text (DE) auf Bildschirm ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    55              ; Code 55  Text (DE) auf angew√§hltem Ger√§t/Datei ausgeben
        RET
;
;
;   Text (DE) auf Bildschirm ausgeben
;
A6DBE:  PUSH    AF              ; Register - Wert retten
        LD      A,(B7591)       ; Vorgabe f√ºr Palettenwert des Zeichens holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    84              ; Code 84  aktuell benutzte Farbebenen setzen
        POP     AF              ; geretteten Register - Wert holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    55              ; Code 55  Text (DE) auf angew√§hltem Ger√§t/Datei ausgeben
        LD      A,(S137B)       ; maximalen Palettenwert holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    84              ; Code 84  aktuell benutze Farbebenen setzen
        RET
;
;
;   Basic - Befehl   READ     (Zwischencode  149 / 095H)
;
A6DCD:  LD      A,138           ; interne aktuelle Ger√§te - Nummer f√ºr READ
        LD      (S1042),A       ; als interne aktuelle Ger√§te - Nummer merken
        JR      A6E0B           ; Werte bereitstellen und Variablen zuweisen
;
;
;   Basic - Befehl   INPUT     (Zwischencode 145 / 091H)
;
A6DD4:  CALL    A6EF9           ; Datei- oder Ger√§tenummer bereitstellen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    46              ; Code 46  Datei-Verwaltungssatz nach Nr. bereitstellen
        JP      C,A6E2D         ; Datei nicht gefunden -->  Fehler 44  Not open error
        BIT     2,A             ; XOPEN  ?
        JP      NZ,A746A        ; ja -->  INPUT aus RANDOM - Datei
        BIT     0,A             ; Datei oder Ger√§t zum Lesen er√∂ffnet  ?
        JP      Z,A6E30         ; nein -->  Fehler 59'  Can't execute error
        CALL    A6F39           ; bei Datei auf 'Syntax Komma' √ºberpr√ºfen
        CALL    A6C81           ; Abfrage, ob aktuelles Ger√§t gleich Bildschirm ist
        JR      NZ,A6E0B        ; nein -->  INPUT aus Datei
        CALL    A015E           ; Leerzeichen  (Spaces)  (HL) √ºberspringen
        CP      '\"'            ; Anf√ºhrungszeichen  ?
        LD      DE,M6E35        ; Text  ?
        LD      B,2             ; L√§nge zwei Zeichen
        JR      NZ,A6E01        ; kein Text angegeben -->  Fragezeichen ausgeben
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf      
        DEFM    ";"             ; Strichpunkt  ?
A6E01:  LD      A,B             ; Textl√§nge holen
        OR      A               ; gleich Null  ?
        JR      Z,A6E0B         ; ja -->  kein Text vorhanden
A6E05:  LD      A,(DE)          ; ein Zeichen Text holen
        INC     DE              ; Zeiger auf Text auf n√§chstes Zeichen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    3               ; Code 3   Accu auf Bildschirm ausgeben  (Ausf√ºhrung Steuerzeichen)
        DJNZ    A6E05           ; weitere Zeichen Text ausgeben
A6E0B:  LD      (D6E63 + 1),SP  ; Stackpointer merken
        LD      DE,(S1078)      ; Anfang Stringarbeitsbereich holen
        LD      (S107A),DE      ; als Ende Stringarbeitsbereich merken
A6E17:  LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        CALL    A8C08           ; √úberpr√ºfen, ob Adresse in DE mit Stack collidiert
        CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        PUSH    AF              ; Variablentypcode auf Stack merken
        PUSH    BC              ; Zeiger auf Variable merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A6E37         ; ja -->  alle Variablennamen ausgewertet
        CALL    A79B4           ; auf Syntax 'Komma' untersuchen
        JR      A6E17           ; Werte der weiteren Variablen auswerten
;
A6E2D:  LD      A,44            ; Fehler 44  Not open error
        DEFB    LD_HL
A6E30:  LD      A,187           ; Fehler 59  Can't execute error
        JP      A00ED           ; Fehler mit Nummer im Accu behandeln
;
M6E35:  DEFM    "? "            ; Textvorgabe f√ºr Abfrage ohne Textangabe
;
;
;   Werte bereitstellen und den bereitgestellten Variablen zuweisen
;
A6E37:  XOR     A               ; Code for 'Stackende'
        PUSH    AF              ; auf Stack ablegen
        PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    52              ; Code 52  wenn Bildschirm -->  eine Zeile bereitstellen
        LD      HL,(D6E63 + 1)  ; Zeiger auf Stack holen
        DEC     HL              ; Zeiger auf Wertcode
A6E40:  LD      A,(HL)          ; Wertcode vom Stack holen
        OR      A               ; Ende Werte  ?
        JR      Z,A6E62         ; ja -->  Stackpointer richtig setzen
        DEC     HL              ;!  Wertcode √ºberspringen
        DEC     HL              ;!
        LD      B,(HL)          ;! Zeiger auf Variable vom Stack holen
        DEC     HL              ;!
        LD      C,(HL)          ;!
        DEC     HL
        PUSH    HL              ; Zeiger auf n√§chsten Datensatz retten
        PUSH    AF              ; Wertcode der Variablen retten
        PUSH    BC              ; Zeiger auf Variable retten
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        CALL    A6E67           ; n√§chste Konstante f√ºr Zuweisung bereitstellen
        LD      H,0             ; High - Byte L√§nge auf Null
        LD      L,B             ; Textl√§nge als Low - Byte vorgeben
        ADD     HL,DE           ; Zeiger auf Ende Text errechnen
        LD      (HL),NUL        ; Textendezeichen eintragen
        POP     DE              ; Zeiger auf Variable holen
        POP     AF              ; Variablenartcode holen
        CALL    A6E71           ; bereitgestellten Wert der Variablen zuweisen
        POP     HL              ; Zeiger auf n√§chsten Datensatz holen
        JR      A6E40           ; weitere Variable zuweisen
;
A6E62:  POP     HL              ; geretteten Programmzeiger holen
D6E63:  LD      SP,0            ; Stackpointer wieder richtig setzen   (Adresse wird eingetragen)
        RET
;
;
;   n√§chste Konstante aus DATA, Datei oder von Ger√§t bereitstellen
;
A6E67:  LD      A,(S1042)       ; interne aktuelle Ger√§te - Nummer holen
        CP      138             ; interne Ger√§te - Nummer  READ - Befehl   ?
        JR      Z,A6EB0         ; ja -->  n√§chste DATA-Statement-Konstante bereitstellen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren 
        DEFB    53              ; Code 53  einen Datensatz von Datei oder Ger√§t lesen
        RET
;
;
;   bereitgestellten Wert der Variablen zuweisen
;
A6E71:  CP      3               ; Zeichenkettenvariable  ?
        JR      NZ,A6E7C        ; nein
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        LD      A,B             ; Zeichenkettenl√§nge holen
        JP      A6546           ; Zeichenkette der Variablen zuweisen
;
A6E7C:  PUSH    DE              ; Zeiger auf Variable retten
        LD      HL,(S107C)      ; h√∂chste nutzbare Basic - Adresse holen
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        EX      DE,HL           ; Zeiger auf Text nach HL
        CALL    A015E           ; Leerzeichen  (Spaces)  (HL) √ºberspringen
        CP      'E'             ; E  (Exponent)  ?
        JP      Z,A636A         ; ja -->  Fehler 3  Illegal data error
        EX      DE,HL           ; Zeiger auf Text wieder nach DE
        CALL    A7A0E           ; ASCII - Text (DE) umsetzen in Real-Wert nach (HL)
        EX      DE,HL           ; Zeiger auf Resttext nach HL
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    NUL             ; Textendezeichen  ?
        JP      NZ,A636A        ; nicht Textende -->  Fehler 3  Illegal data error
        EX      DE,HL           ; Zeiger auf bereitgestellten Wert nach HL
        POP     DE              ; Zeiger auf Variable holen
        JP      A79C5           ; Zahlwert von (HL) nach (DE) √ºbertragen
;
;
;   Basic - Befehl   RESTORE     (Zwischencode  133 / 085H)
;
A6E9E:  XOR     A               ; Accu auf Null
        LD      (S9E5D),A       ; DATA - Status zur√ºcksetzen
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        CALL    NZ,A5E19        ; Zeiger auf Zeile nach Programmtext (HL) bereitstellen
        EX      DE,HL           ; Zeiger auf Zeile nach HL
        CALL    NZ,A6EE0        ; Zeile angegeben -->  erstes DATA - Statement suchen
        EX      DE,HL           ; Programmzeiger nach HL
        JP      A67FE           ; Zeiger in HL auf Ende Befehl stellen
;
;
;   erstes DATA - Statement ab Zeiger auf Zeile in HL suchen
;
A6EB0:  PUSH    HL              ; Zeiger auf Zeile retten
        PUSH    DE              ; Register - Wert retten
        CALL    A6EBE           ; n√§chstes DATA - Statement ab Zeiger in HL suchen
        POP     DE              ; geretteten Register - Wert holen
        POP     HL              ; geretteten Zeiger auf Zeile holen
        RET
;
;
;   n√§chste DATA - Konstante bereitstellen
;
A6EB8:  LD      HL,(S1070)      ; Basic - Programmanfang holen
        CALL    A6EE0           ; n√§chstes DATA - Statement ab (HL) suchen
A6EBE:  LD      A,(S9E5D)       ; DATA - Flag holen
        CP      1               ; Code for 'Programmende'  ?
        JP      Z,A639A         ; ja -->  Fehler 24  READ error
        JR      C,A6EB8         ; Zeiger zur√ºckgesetzt -->  ab Anfang suchen
        LD      HL,(S9E5E)      ; DATA - Zeiger holen
        LD      C,':'           ; Trennzeichen vorgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    54              ; Code 54  Textkonstante (HL) bis Zeichen in C nach (DE)
        LD      (S9E5E),HL      ; DATA - Zeiger merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        SCF                     ;! Carry - Flag zur√ºcksetzen
        CCF                     ;!
        RET     NZ              ; nicht Befehlsende
        DEC     HL              ; Zeiger corrigieren
A6ED9:  CALL    A6A06           ; Zeiger in HL auf n√§chstes relevante Programmbyte
        OR      A               ; Zeilenendezeichen  ?
        JR      NZ,A6EEB        ; nein -->  auf DATA untersuchen
        INC     HL              ; Zeilenendezeichen √ºberspringen
A6EE0:  LD      A,(HL)          ;! √úberpr√ºfen, ob Offset auf n√§chste Zeile
        INC     HL              ;! vorhanden ist
        OR      (HL)            ;!
        LD      A,1             ; Code for 'Programmende'
        JR      Z,A6EF5         ; Offset gleich Null -->  Code 'Programmende' merken
        INC     HL              ;! Rest Offset und Zeilennummer √ºberspringen
        INC     HL              ;!
        JR      A6ED9           ; untersuchen, ob DATA - Statement
;
A6EEB:  CP      __DATA          ; Zwischencode  DATA  ?
        JR      NZ,A6ED9        ; nein -->  weiter suchen
        INC     HL              ; Zwischencode DATA √ºberspringen
        LD      (S9E5E),HL      ; DATA - Zeiger merken
        LD      A,2             ; Code for 'Zeiger steht auf DATA'
A6EF5:  LD      (S9E5D),A       ; DATA - Status merken
        RET
;
;
;   Text (HL) auswerten und Datei- oder Ger√§tenummer bereitstellen
;
A6EF9:  CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    "#"             ; Kennung Dateinummer  ?
        JR      NZ,A6F24        ; auf Bildschirm, /P, /T untersuchen und Ger√§te-Nr. bereitstellen
        CALL    A015E           ; Leerzeichen  (Spaces)  (HL) √ºberspringen
        CP      ' '             ; Wertcode  ?
        JP      NC,A6364        ; Fehler 1  Syntax error
        PUSH    DE              ;! Register - Werte retten
        PUSH    BC              ;!
		LD      DE,S9E9D        ; Zeiger auf Zwischenspeicher f√ºr Berechnung
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        CALL    A874C           ; Wert der Konstanten bereitstellen
        EX      (SP),HL         ; Programmzeiger retten / Zeiger auf Wert holen
        ;CALL    A7B73           ; Real-Wert (HL) umsetzen in Integer-Wert nach HL
		CALL    A7BEA           ; Real-Wert (HL) umsetzen in Integer-Wert nach HL
        LD      A,H             ; High - Byte Datei - Nummer holen
        OR      A               ; gleich Null  ?
        JP      NZ,A63A3        ; nein -->  Fehler 64  Logical number error
        OR      L               ; Low - Byte Wert holen
        JP      Z,A63A3         ; gleich Null -->  Fehler 64  Logical number error
        JP      M,A63A3         ; > 127 -->  Fehler 64  Logical number error
        POP     HL              ; Programmzeiger holen
        POP     BC              ;! gerettete Register - Werte holen
        POP     DE              ;!
        RET
;
;
;   auf Ger√§t Bildschirm, Drucker oder Cassette √ºberpr√ºfen und Ger√§tenummer bereitstellen
;
A6F24:  CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    ___DIV          ; /  (Zwischencode)  ?
        LD      A,136           ; Vorgabe Ger√§te - Nummer  'CRT:'
        RET     NZ              ; kein Ger√§t angegeben -->  Bildschirm
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    "P"             ; P  (Printer)  ?
        LD      A,137           ; Vorgabe Ger√§te - Nummer  'LPT:'
        RET     Z               ; ist /P
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "T"             ; T  (TAPE)  ?
        LD      A,128           ; Vorgabe Ger√§te - Nummer  'CMT:'
        RET
;
;
;   bei Datei auf 'Syntax Komma' √ºberpr√ºfen
;
A6F39:  LD      A,(S1042)       ; interne aktuelle Ger√§te - Nummer holen
        OR      A       
        RET     M               ; internes Ger√§t -->  fertig
        JP      A79B1           ; auf Syntax  'Komma'  untersuchen
;
;
;   Basic - Befehl   DEFAULT     (Zwischencode  172 / 0ACH)
;
A6F41:  CALL    A6FB1           ; Ger√§te - Namen bereitstellen und Ger√§t anmelden
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    58              ; Code 58  aktuelles Ger√§t als 'DEFAULT - Ger√§t' merken
        RET
;
;
;   Basic - Befehl   INIT    (Zwischencode  220 / 0DCH)
;
A6F47:  CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        LD      B,0             ; Vorgabe  L√§nge Null
        CALL    NZ,A8561        ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
A6F4F:  PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    44              ; Code 44  Text (DE) auf Ger√§te - Namen auswerten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    60              ; Code 60  Ger√§t initialisieren
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   ROPEN     (Zwischencode  208 / 0D0H)
;
A6F56:  LD      A,1             ; Code for 'Datei zum Lesen er√∂ffnen'
        DEFB    LD_BC   
;
;
;   Basic - Befehl   WOPEN     (Zwischencode  206 / 0CEH)
;
A6F59:  LD      A,2             ; Code for 'Datei zum Schreiben er√∂ffnen'
        DEFB    LD_BC
;
;
;   Basic - Befehl   XOPEN     (Zwischencode  209 / 0D1H)
;
A6F5C:  LD      A,4             ; Code for 'Datei zum wahlfreien Zugriff er√∂ffnen'
        PUSH    AF              ; Code merken
        LD      (S1043),A       ; Zugriffscode eintragen
        CALL    A6EF9           ; Datei- oder Ger√§tenummer bereitstellen
        CP      136             ; Ger√§te - Nummer 136  (Bildschirm)  ?
        JR      NZ,A6F6B        ; nein
        LD      A,128           ; f√ºr Datei -->  Cassette vorgeben
A6F6B:  LD      (S1042),A       ; als interne aktuelle Ger√§te - Nummer merken
        CALL    A6F39           ; bei Datei auf 'Syntax Komma' √ºberpr√ºfen
        CALL    A6FA4           ; Text (HL) auf Ger√§te-Namen und Dateinamen auswerten
        POP     AF              ; Zugriffscode holen
        CP      4               ; RANDOM - Datei  ?
        JR      Z,A6F7B         ; ja -->  Code 'BRD - Datei'  vorgeben
A6F79:  LD      A,_BSD          ; Code for 'BSD - Datei'
A6F7B:  LD      (S1000),A       ; Datei - Typ - Code eintragen
        PUSH    AF              ; Datei - Typ - Code merken
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    51              ; Code 51  Datei nach bereitgestellten Daten er√∂ffnen
        LD      A,(S1000)       ; gefundenen Datei - Typ holen
        POP     BC              ; vorgegebenen Datei - Typ holen
        CP      B               ; Datei - Typen vergleichen
        JP      NZ,A63D1        ; nicht gleich -->  Fehler 61  Illegal filemode error
        RET
;
;
;   Basic - Befehl   CLOSE     (Zwischencode  207 / 0CFH)
;
B6F8A:  DEFB    OR_N            ; Code for 'CLOSE'
;
;
;   Basic - Befehl   KILL     (Zwischencode  217 / 0D9H)
;
A6F8B:  XOR     A               ; Code for 'KILL'
        LD      B,A             ; Flag 'CLOSE/KILL'  merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      Z,A6FA0         ; ja -->  alle Dateien CLOSEn oder KILLen
A6F92:  CALL    A6EF9           ; Datei- oder Ger√§tenummer bereitstellen
        CP      135 + 1         ; CRT oder h√∂her  ?
        RET     NC              ; ja -->  fertig
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    56              ; Code 56  Dateien CLOSEn oder KILLen
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JR      A6F92           ; n√§chste Dateinummer auswerten
;
A6FA0:  XOR     A               ; Code for 'alle Dateien'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    56              ; Code 56  Dateien CLOSEn oder KILLen
        RET
;
;
;   Text (HL) auf Ger√§te-Namen und Dateinamen auswerten
;
A6FA4:  CALL    A5F15           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        LD      B,0             ; Code for 'L√§nge Null Zeichen'
        CALL    NZ,A8561        ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    45              ; Code 45  Ger√§te- und Dateinamen (DE) auswerten und aufbereiten
        POP     HL
        RET
;
;
;   Ger√§te - Namen bereitstellen und Ger√§t anmelden
;
A6FB1:  PUSH    HL              ; Programmzeiger retten
        CALL    A015E           ; Leerzeichen  (Spaces)  (HL) √ºberspringen
        LD      DE,S6FF9        ; Zeiger auf Speicher f√ºr Ger√§te - Namen
        LD      B,1             ; L√§nge  ein Zeichen
        CALL    A6FEC           ; wenn Accu gleich Buchstabe -->  merken
        CALL    NC,A6FEC        ; Buchstabe -->  wenn Accu gleich Buchstabe -->  merken
        JR      C,A6FD9         ; keine zwei Buchstaben -->  kein Ger√§te - Name
        CALL    A6FEC           ; wenn Accu gleich Buchstabe -->  merken
        CALL    A79F6           ; testen, ob Zeichen im Accu gleich Ziffer ist
        CALL    A6FF2           ; wenn Ziffer -->  merken
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        JR      NZ,A6FD9        ; nein -->  auf Dateinamen untersuchen
        LD      A,':'           ; Code for 'Ende Ger√§te - Name'
        LD      (DE),A          ; hinter Text eintragen
        POP     AF              ; alten Programmzeiger verwerfen
        LD      DE,S6FF9        ; Zeiger auf bereitgestellten Ger√§te - Namen
        JR      A6FE2           ; Namen auswerten und Ger√§t anmelden
;
A6FD9:  POP     HL              ; alten Programmzeiger doch wieder holen
        CALL    A5963           ; testen, ob Zeichen (HL) gleich Befehlsendezeichen ist
        LD      B,0             ; Code for 'L√§nge Null Zeichen'
        CALL    NZ,A8561        ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
A6FE2:  PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    44              ; Code 44  Text (DE) auf Ger√§te-Namen auswerten
        INC     (HL)            ;! kompletten Text ausgewertet  ?
        DEC     (HL)            ;!
        JP      NZ,A63A0        ; nein -->  Fehler 58  Dev. name error
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   testen, ob Accu gleich Buchstabe, wenn ja -->  merken
;
A6FEC:  CP      'A'             ; Accu gleich Buchstabe  ?
        RET     C               ; nein
        CP      '['             ; Accu gleich Buchstabe  ?
        CCF                     ; Ergebnis umkehren
A6FF2:  RET     C               ; kein Buchstabe
        LD      (DE),A          ; Zeichen im Accu merken
        INC     HL              ; Zeiger auf vorgegebenen Text auf n√§chstes Zeichen
        INC     DE              ; Zeiger auf Speicher f√ºr Ger√§te - Namen
        LD      A,(HL)          ; n√§chstes Textzeichen holen
        INC     B               ; Z√§hler  'Anzahl Zeichen'  plus eins
        RET
;
S6FF9:  DEFS    4               ; Speicher f√ºr Ger√§te - Namen
;
;
;   Basic - Befehl   LOAD     (Zwischencode  180 / 0B4H)
;
A6FFD:  CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFB    ___ALL          ; ALL  (Zwischencode)  ?
        JR      NZ,A7007        ; nicht 'LOAD ALL'
        XOR     A               ; Code for 'LOAD ALL'
A7004:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    59              ; Code 59  RAM-Karte auf Quick-Disk schreiben oder lesen
        RET
;
;
;   normaler LOAD - Befehl
;
A7007:  CALL    A6FA4           ; Text (HL) auf Ger√§te-Namen und Dateinamen auswerten
        CALL    A0164           ; n√§chstes Programmbyte gleich Byte hinter CALL-Aufruf  ?
        DEFM    ","             ; Komma  ?
        JP      Z,A70C5         ; ja -->  auf Sonderformat untersuchen
        PUSH    HL              ; Programmzeiger retten
        CALL    A7314           ; BASIC - Arbeitsbereich retten und Datei er√∂ffnen
        DEC     A               ; Datei - Typ - Code
        JR      Z,A7027         ; Maschinenprogramm laden
        DEC     A               ; Datei - Typ - Code
        JP      NZ,A63D1        ; nicht BASIC-Programm -->  Fehler 61 Illegal filemode error
        CALL    A7340           ; wenn im Programm-Modus -->  Fehler 19  Instruction error
        CALL    A731D           ; Pseudo - Arbeitsbereiche vorgeben
        CALL    A7349           ; Speicher auf Platz √ºberpr√ºfen und Programm laden
        JR      A7043           ; Zwischenspeicher f√ºr Programmladeroutine l√∂schen
;
;
;   Maschinenprogramm laden
;
A7027:  LD      HL,(S1016)      ; Ladeadresse holen
        PUSH    HL              ; und merken
        LD      DE,(S107E)      ; Ende Rechenspeicherbereich holen
        CALL    A704D           ; Adressen in HL und DE vergleichen
        LD      DE,(S1014)      ; Programml√§nge holen
        LD      BC,(W1080)      ; maximal erlaubte RAM - Adresse holen
        CALL    NC,A7048        ; noch kein Fehler -->  Adressen vergleichen
        JP      C,A638B         ; Fehler 18  Memory protection error
        POP     HL              ; Ladeadresse holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    48              ; Code 48  Programm nach vorgegebener Kennung laden
A7043:  CALL    A737C           ; Zwischenspeicher f√ºr Programmladeroutine l√∂schen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Endadresse errechnen und Adressen vergleichen
;
A7048:  ADD     HL,DE
        RET     C
        EX      DE,HL
        LD      H,B
        LD      L,C
 
;   Adressen in DE und HL vergleichen
;
A704D:  PUSH    HL              ; Register - Wert retten
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Adressen vergleichen
        POP     HL              ; gerettete Register - Werte wieder holen
        RET
;
;
;   Basic - Befehl   CHAIN     (Zwischencode  183 / 0B7H)
;
A7053:  CALL    A6FA4           ; Text (HL) auf Ger√§te-Namen und Datei-Nummer auswerten
        CALL    A7314           ; BASIC - Arbeitsbereich retten und Datei er√∂ffnen
        CP      _BTX            ; Datei - Typ  BTX  ?
        JP      NZ,A63D1        ; nein -->  Fehler 61  Illegal filemode error
        LD      A,(S9E68)       ; SWAP - Flag holen
        OR      A               ; im SWAP - Modus  ?
        JP      Z,A718B         ; nein -->  Programm nachladen
        JP      A74F3           ; SWAP - Daten retten und Programm nachladen
;
;
;   Basic - Befehl   MERGE     (Zwischencode 182 / 0B6H)
;
A7068:  CALL    A7340           ; wenn im Programm-Modus -->  Fehler 19  Instruction error
        CALL    A6FA4           ; Text (HL) auf Ger√§te-Namen und Datei-Nummer auswerten
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma ?
        JR      Z,A70CB         ; MERGE mit Sonderformatangabe
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    47              ; Code 47   (Programm-) Datei er√∂ffnen
        CP      _BTX            ; Datei - Typ  BTX  ?
        JP      NZ,A63D1        ; nein -->  Fehler 61  Illegal filemode error
        PUSH    HL              ; Programmzeiger retten
        LD      HL,(S1078)      ; Anfang Stringarbeitsbereich holen
        LD      (S107A),HL      ; als Ende Stringarbeitsbereich merken
        LD      BC,1000         ; Vorgabe f√ºr Puffer
        ADD     HL,BC           ; Anfang freier Speicher errechnen
        JP      C,A63A7         ; √úberlauf -->  Fehler 6  Memory error
        PUSH    HL              ; Pufferadresse retten
        LD      BC,(S1014)      ; Programml√§nge holen
        INC     B               ; noch ein bischen Sicherheit dazutun  (256 Bytes)
        ADD     HL,BC           ; Endadresse errechnen
        JP      C,A63A7         ; √úberlauf -->  Fehler 6  Memory error
        SBC     HL,SP           ; Adresse mit Stackpointer vergleichen
        JP      NC,A63A7        ; Adressen √ºberschneiden sich -->  Fehler 6  Memory error
        POP     HL              ; Zeiger auf Puffer holen
        PUSH    HL              ; und wieder merken
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    48              ; Code 48   Programm nach vorgegebener Kennung nach (HL) laden
        POP     HL              ; Zeiger auf Puffer mit Programm holen
        CALL    A70A2           ; geladenes Programm mit vorhandenem Programm mischen
        POP     HL              ; Programmzeiger holen
        RET
;
;
;   geladenes Programm in vorhandenes Programm einmischen
;
A70A2:  CALL    A012D           ; Wert (HL) nach DE holen
        LD      A,D             ;! Offset gleich Null  ?
        OR      E               ;!
        RET     Z               ; ja -->  Programm zugemischt
        PUSH    DE              ; Offset auf n√§chste Zeile retten
        CALL    A012D           ; Zeilennummer der Zeile holen
        PUSH    HL              ; Zeiger auf Zeile retten
        LD      H,D             ;! Zeilennummer nach HL
        LD      L,E             ;!
        LD      (S9E4D),HL      ; als Editor - Zeilennummer merken
        CALL    A622C           ; eventuell vorhandene Zeile(n) l√∂schen
        POP     HL              ; Zeiger auf Zeile holen
        POP     BC              ; Offset auf n√§chste Zeile holen
        PUSH    BC              ; und wieder merken
        PUSH    HL              ; Zeiger auf Zeile merken
        CALL    A6003           ; Zeile in Programmspeicher eintragen
        POP     HL              ; Zeiger auf Zeile holen
        POP     BC              ; Offset auf n√§chste Zeile holen
        ADD     HL,BC           ;! Zeiger auf Anfang der n√§chsten Zeile stellen
        DEC     HL              ;!
        DEC     HL              ;!
        DEC     HL              ;!
        DEC     HL              ;!
        JR      A70A2           ; n√§chste Zeile einsortieren
;
;
;   LOAD mit Sonderformatangabe
;
A70C5:  CALL    A7340           ; wenn im Programm-Modus -->  Fehler 19  Instruction error
        LD      A,1             ; Code for 'LOAD'
        DEFB    LD_BC
;
; 
;   MERGE mit Sonderformatangabe
;
A70CB:  LD      A,0             ; Code for 'MERGE'
        DEFB    LD_BC
;
;
;   RUN mit Sonderformatangabe
;
A70CE:  LD      A,2             ; Code for 'RUN'
        PUSH    AF              ; Flag  'MERGE/LOAD/RUN'  retten
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    "A"             ; A   (ASCII)  ?
        CALL    A797A           ; auf Syntax Befehlsende √ºberpr√ºfen
        LD      A,1             ; Code for 'Datei zum Lesen er√∂ffnen'
        LD      (S1043),A       ; als Datei - Zugriffscode eintragen
        LD      A,129           ; Datei - Nummer f√ºr Programm
        LD      (S1042),A       ; als interne aktuelle Ger√§te-Nummer merken
        CALL    A6F79           ; sequentielle Datei er√∂ffnen
        POP     AF              ; Flag 'MERGE/LOAD/RUN' holen
        PUSH    AF              ; und wieder merken
        PUSH    HL              ; Programmzeiger retten
        LD      HL,0            ; Vorgabe f√ºr Anfangszeilennummer
        LD      DE,65535        ; Vorgabe f√ºr Endzeilennummer
        OR      A               ; Flag  'MERG/LOAD/RUN'
        CALL    NZ,A622C        ; nicht MERGE -->   eventuell vorhandene Zeilen l√∂schen
        LD      A,129           ; Datei - Nummer f√ºr Programm
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    46              ; Code 46   Datei-Verwaltungssatz nach Nr. bereitstellen
        LD      HL,(S1078)      ; Anfang Stringarbeitsbereich holen
        LD      (S107A),HL      ; als Ende Stringarbeitsbereich merken
        LD      BC,1000         ; Vorgabe f√ºr Puffer
        ADD     HL,BC           ; Zeiger auf Anfang Puffer errechnen
        JP      C,A6373         ; √úberlauf -->  Fehler 6   Memory capacity error
        PUSH    HL              ; Zeiger auf Anfang Puffer
        LD      (S7169),HL      ; merken
A7107:  LD      HL,-512         ; Vorgabe f√ºr Stackarbeitsbereich
        ADD     HL,SP           ; minimal Stackadresse errechnen
        LD      DE,(S7169)      ; Zeiger auf Anfang Puffer holen
        SBC     HL,DE           ; Adressen vergleichen
        JP      C,A6373         ; Fehler 6   Memory error
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    53              ; Code 53   einen Datensatz von Datei oder Ger√§t lesen
        LD      A,B             ; Datensatzl√§nge holen
        OR      A               ; gleich Null  ?
        JR      Z,A7154         ; ja -->  bereitgestelltes Programm einsortieren
        CALL    A8532           ; ASCII - Wert (DE) umsetzen in Hex-Wert nach BC
        LD      A,B             ;! Zeilennummer gleich Null  ?
        OR      C               ;!
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        LD      HL,(S7169)      ; Zeiger auf Puffer holen
        PUSH    HL              ; Zeiger auf Anfang merken
        INC     HL              ;! Stelle f√ºr Offset √ºbersprungen
        INC     HL              ;!
        LD      (HL),C          ;! Zeilennummer der Zeile eintragen
        INC     HL              ;!
        LD      (HL),B          ;!
        INC     HL
        PUSH    HL              ; Zeiger auf Stelle f√ºr Zwischencodetext merken
        LD      H,D             ;! Zeiger auf ASCII-Text-Zeile nach HL
        LD      L,E             ;!
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFB    NUL             ; Zeilenendezeichen  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        POP     HL              ; Zeiger auf Stelle f√ºr Zwischencode holen
        LD      A,(DE)          ; ein Textzeichen holen
        CP      ' '             ; Space  (Leerzeichen)  ?
        JR      NZ,A7141        ; nein -->  Zeichen auswerten
        INC     DE              ; Leerzeichen √ºberspringen
A7141:  CALL    A8216           ; ASCII-Text (DE) umsetzen in Zwischencode nach (HL)
        LD      (HL),NUL        ; Zeilenendezeichen eintragen
        INC     HL              ; Zeilenendezeichen √ºberspringen
        LD      (S7169),HL      ; neuen Zeiger auf Puffer merken
        POP     DE              ; Zeiger auf Anfang Zeile holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; L√§nge der Zeile errechnen
        EX      DE,HL           ; L√§nge nach DE / Zeiger f√ºr Offset nach HL
        LD      (HL),E          ;! Offset auf n√§chste Zeile vor
        INC     HL              ;! Zeilennummer eintragen
        LD      (HL),D          ;!
        JR      A7107           ; restliche Zeilen aus Datei einlesen
;
A7154:  LD      HL,(S7169)      ; Zeiger auf Puffer holen
        CALL    A61C5           ; (HL) Bereichsende  (00 00)  eintragen
        CALL    A619B           ; Variable l√∂schen  (CLR - Routine)
        POP     HL              ; Zeiger auf Anfang Puffer holen
        CALL    A70A2           ; bereitgestellte Zeilen einsortieren
        POP     HL              ; Programmzeiger holen
        POP     AF              ; Flag  'MERGE/LOAD/RUN'  holen
        CP      2               ; Code for 'RUN'  ?
        RET     NZ              ; nein
        JP      A607C           ; Basic  - Programm starten
;
S7169:  DEFS    2               ; Zeiger f√ºr Pufferspeicher

;
;
;   RUN  "Dateiname"
;
A716B:  CALL    A6FA4           ; Text (HL) auf Ger√§te-Namen und Datei-Nummer auswerten
        PUSH    HL              ; Programmzeiger retten
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      NZ,A717D        ; nicht Komma -->  kein Sonderformat
        CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
        CP      'A'             ; A  (ASCII)  ?
        JP      Z,A70CE         ; ja -->  ASCII-Datei laden und starten
A717D:  CALL    A7314           ; BASIC - Arbeitsbereich retten und Datei er√∂ffnen
        POP     HL              ; geretteten Programmzeiger holen
        DEC     A               ; Datei - Typ - Code
        JR      Z,A7194         ; Maschinenprogramm
        DEC     A               ; Datei - Typ - Code
        JP      NZ,A63D1        ; nicht BTX -->  Fehler 61  Illegal filemode error
        CALL    A731D           ; Pseudo - Arbeitsbereiche vorgeben
;
;
;   Programm  CHAINen
;
A718B:  CALL    A7349           ; Speicher auf Platz √ºberpr√ºfen und Programm laden
        CALL    A737C           ; Zwischenspeicher f√ºr Programmladeroutine l√∂schen
        JP      A607C           ; BASIC - Programm starten
;
;
;   RUN  Maschinenprogramm
;
A7194:  LD      D,0             ; Code 'MZ-700 - Programm'
        LD      BC,0FF00H       ; maximale Speichergrenze  im MZ-800 - Modus
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      NZ,A71A8        ; nein -->  MZ-800  Maschinenprogramm laden
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    "R"             ; R   (Code for 'MZ-80 K - Programm laden)
        LD      D,1             ; Code for 'MZ-80 K - Programm'
        LD      BC,0CFF0H       ; maximale Speicheradresse im MZ-80 K - Modus
A71A8:  LD      A,D             ; Code 'MZ-800 / MZ-80 K'
        LD      (S11A4),A       ; merken
        LD      HL,(S1014)      ; Programml√§nge holen
        LD      DE,(S1016)      ; Ladeadresse aus Dateikennung holen
        PUSH    HL              ; Programml√§nge merken
        CALL    A7048           ; Endadresse errechnen und auf Ende Speicher √ºberpr√ºfen
        POP     DE              ; Programml√§nge holen
        LD      HL,A5800        ; Ladespeicheranfang vorgeben
        LD      BC,-256 
        CALL    NC,A7048        ; Endadresse errechnen und auf Ende Speicher √ºberpr√ºfen
        JP      C,A63A7         ; √úberlauf -->  Fehler 6  Memory error
        LD      SP,0            ; Stackpointer neu setzen
        CALL    A61A3           ; I/O-WORK-Area und BASIC-Variable/Funktionen l√∂schen
        XOR     A               ; Code for 'keine Variable gerettet'
        LD      (S733F),A       ; im Flag  'Variable gerettet'  merken
        LD      A,00110110B     ; Code 'Z√§hler 0/Mode 3/Binary'
        OUT     (CTC_53),A      ; an Kontrollwortregister 8253 ausgeben
        LD      A,00000001B     ; Code 'Set Bit 0'
        OUT     (KEYP_F),A      ; Z√§hler 0 im 8253 sperren
        LD      HL,(S1016)      ; Ladeadresse aus Dateikennung holen
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        CALL    A704D           ; Adressen in DE und HL vergleichen
        JR      NC,A71F3        ; Ladeadresse liegt hinter Ende Stringarbeitsbereich
        PUSH    HL              ; Datei - Ladeadresse retten
        LD      HL,A5800        ; minimal m√∂gliche Ladeadresse vorgeben
        LD      (S1070),HL      ; als Anfang Basic - Programm merken
        CALL    A61A3           ; I/O-WORK-Area und BASIC-Variable/Funktionen l√∂schen
        LD      HL,S122C        ; Anfangsadresse der neuen Fehlerbehandlungsroutine 
		;LD      HL,0        ; Anfangsadresse der neuen Fehlerbehandlungsroutine 
        LD      (S004F),HL      ; Adresse der Fehlerbehandlungsroutine merken
        POP     HL              ; Original - Ladeadresse holen
A71F3:  LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        CALL    A704D           ; Adressen in DE und HL vergleichen
        JR      NC,A71FD        ; Programm wird an Originaladresse geladen
        EX      DE,HL           ; Zeiger vertauschen
A71FD:  PUSH    AF              ; Programmladecode merken
        PUSH    HL              ; Programmladeadresse  merken
        LD      HL,T720C        ; Zeiger auf Ladeprogramm
		LD      DE,S11A4+1      ; Zeiger auf Speicher f√ºr Ladeprogramm
        PUSH    DE              ; Zeiger auf Anfang Ladeprogramm retten
        LD      BC,208          ; L√§nge des Ladeprogramms
        LDIR                    ; Ladeprogramm in Speicher √ºbertragen
        RET
;
;
;   Load program for machine program that is to be started
;
T720C:  POP     HL              ; Get loading address
        RST     _DOCMD          ; Software - Execute command
        DEFB    48              ; Code 48 Load program according to specified identifier to (HL).
        LD      A,_JP           ; Z-80 - Command JP nn
        LD      HL,TIMIN        ; Start address 'time - interrupt' in the ROM - monitor
        LD      (INT_JP),A      ; JP - enter command
        LD      (INT_JP +1),HL  ; Enter interrupt address
        LD      A,1             ; Screen mode 1 (320x200 pixels/4 colors)
        RST     _DOCMD          ; Software - Execute command
        DEFB    80              ; Code 80 screen - set operating mode
        RST     _DOCMD          ; Software - Execute command
        DEFB    16              ; Code 16 disable interrupts
        EX      AF,AF           ; Register - save value
        LD      A,(S11A4)       ; Get flag 'MZ-800 / MZ-80 K - program'
        OR      A               ; MZ-800 - Program ?
        CALL    NZ,S1246        ; no --> Initiate peripheral modules for MZ-700 mode
        EX      AF,AF           ; rescued register - fetch value
        LD      HL,(S1018)      ; Start address from file - get identifier
        LD      A,H             ;!  Start address given?
        OR      L               ;!
        EXX                       
        LD      HL,(S107A)      ; Get end of string workspace
        LD      DE,(S1016)      ; Get load address from file identifier
        LD      BC,(S1014)      ; Get program length from file identifier
        OR      D               ;!  Load address also zero?
        OR      E               ;!
        JR      Z,A7243         ; neither load address nor start address specified
        LD      A,JP_HL         ; Z-80 - Befehl  JP (HL)
        LD      (S123E),A        
A7243:  EXX
        POP     AF              ; Get program load flag
        PUSH    HL              ; Save the original start address
        LD      HL,S11EE        ; Pointer to part loading area
        LD      DE,XFF00        ; Pointer to reserved memory
        LD      BC,88           ; Length of the program to be moved
        LDIR                    ; Move the rest of the loader 
        EXX
        JP      XFF00           ; Call the rest of the loader 
;
;
;   zweiter Teil des Ladeprogramms
;
        JR      NC,A7259        ; geladenes Programm steht an Originaladresse
        LDIR                    ; Programm an Originaladresse verschieben
A7259:  EX      AF,AF           ; ",R" - Flag holen
        RET     Z               ; R bei RUN nicht angegeben -->  Programm starten
        IN      A,(CRTCDM)      ; Ger√§testatus lesen
        AND     00000010B       ; Schalter auf MZ-700 - Modus  ?
        LD      A,00000000B     ; Code 'Umschalten auf 320x200 Punkte/4 Farben'
        OUT     (CRTCDM),A      ; an 'Display-Mode-Register' des Bildschirm-Controllers ausgeben
        LD      HL,0FF53H       ; Zeiger auf Programmteil f√ºr MZ-800 - Modus
        LD      BC,5            ; L√§nge 
        JR      NZ,A7284        ; Schalter steht auf MZ-800 - Modus
        LD      A,00001000B     ; Code for 'MZ-700 - Modus'
        OUT     (CRTCDM),A      ; an 'Display-Mode-Register' des Bildschirm-Controllers ausgeben
        IN      A,(_CGVIN)      ; Zeichensatzrom und Video-Ram einschalten
        LD      HL,01000H       ; Zeiger auf Zeichensatzrom
        LD      DE,0C000H       ; Zeiger auf Zeichensatzram f√ºr MZ-700 - Modus
        LD      BC,4096         ; L√§nge Zeichensatzrom
        LDIR                    ; Zeichensatzrom in Speicher f√ºr Zeichensatz √ºbertragen
        IN      A,(_CGVOT)      ; Zeichensatzrom und Video-RAM ausschalten
        LD      HL,0FF45H       ; Zeiger auf Programmteil f√ºr MZ-700 - Modus
        LD      BC,14           ; L√§nge Programmteil
A7284:  LD      DE,0CFF0H       ; Zeiger auf Stelle f√ºr Programm
        LDIR                    ; Rest Ladeprogramm an richtige Stelle √ºbertragen
        POP     HL              ; Original - Startadresse holen
        LD      SP,S10F0        ; Stackpointer f√ºr MZ-80 K-Modus setzen
        LD      DE,ZD800        ; Zeiger auf Farbspeicher im MZ-80 K - Modus
        JP      0CFF0H          ; letzten Teil des Ladeprogramms aufrufen



;
;
;   Error handling routine for loading machine programs 
;
;   (is shifted to addresses from S122C )
;
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    27              ; Code 27   Fehlertext nach Fehlernummer in A ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    67              ; Code 67  Datei-Daten der Ausgabe-DAtei (bei Fehler) l√∂schen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    16              ; Code 16   Interrupts sperren
        HALT                    ; System aufh√§ngen
;
;
;   letzter Teil Ladeprogramm f√ºr MZ-700 - Modus und R - Option
;
;   (wird auf Adressen ab 0FF45H und dann nach  0CFF0H verschoben)
;
        OUT     (_KMODE),A      ; umschalten auf MZ-80 K -Modus
A729C:  LD      A,071H          ; Vordergrund- Hintergrundfarbe  (wei√ü/blau)
        LD      (DE),A          ; in Farbspeicher eintragen
        INC     DE              ; Zeiger auf Farbspeicher auf n√§chstes Byte
        LD      A,D             ; High - Byte Zeiger holen
        CP      0E0H            ; Ende Farbspeicher  ?
        JR      NZ,A729C        ; nein -->  Rest Farbspeicher initialisieren
        OUT     (_00RAM),A      ; Umschalten auf RAM von 00000H bis 07FFFH
        JP      (HL)            ; geladenes Maschinenprogramm starten
;
;
;   letzter Teil Ladeprogramm f√ºr MZ-800 - Modus und R - Option
;
;   (wird auf Adressen ab 0FF53H und dann nach  0CFF0H verschoben)
;
        OUT     (_00RAM),A      ; Umschalten auf RAM von 00000H bis 07FFFH
        OUT     (_E0ROM),A      ; Umschalten auf ROM von 0E000H bis 0FFFFH
        JP      (HL)            ; geladenes Maschinenprogramm starten
;
;
;   Initiate peripheral modules for MZ - 700 mode
;
;   (is moved to addresses starting at 01246H)
;
;
        PUSH    AF              ; Register - save value
        DI                      ; Disable interrupts
        IM      1               ; Specify MZ - 700 - Interrupt mode
        LD      HL,S1253        ; Pointer to table for initializing the peripherals - control blocks
        LD      B,17            ; Number of values in table
        RST     _DOCMD          ; Software - Execute command
        DEFB    36              ; Output code 36 table of values (HL) to ports
        POP     AF              ; saved register - retrieve value again
        RET
;
;
;   Table for initializing the control blocks in MZ-700 mode
;
;   (is shifted to addresses S1253)
;
        DEFB    00000000B       ; Interrupt - Vector
        DEFB    PIOA_C          ; Controll - Port  Z-80 PIO  Kanal A
        DEFB    11001111B       ; Mode 3 - Select
        DEFB    PIOA_C          ; Controll - Port  Z-80 PIO  Kanal A
        DEFB    00111111B       ; Bit 0 - 5 Input / Bit 6/7 Output
        DEFB    PIOA_C          ; Controll - Port  Z-80 PIO  Kanal A
        DEFB    00000111B       ; Interrupt-Controll-Wort  (kein Interrupt)
        DEFB    PIOA_C          ; Controll - Port  Z-80 PIO  Kanal A
;
        DEFB    00000000B       ; Interrupt - Vector
        DEFB    PIOB_C          ; Controll - Port  Z-80 PIO  Kanal B
        DEFB    11001111B       ; Mode 3 - Select
        DEFB    PIOB_C          ; Controll - Port  Z-80 PIO  Kanal B
        DEFB    00000000B       ; alle Bits auf Output
        DEFB    PIOB_C          ; Controll - Port  Z-80 PIO  Kanal B
        DEFB    00000111B       ; Interrupt-Controll-Wort  (kein Interrupt)
        DEFB    PIOB_C          ; Controll - Port  Z-80 PIO  Kanal B
;
        DEFB    01110100B       ; Z√§hler 1/Read'Load 2 Byte/Mode 2/Binary
        DEFB    CTC_53          ; Kontrollwortregister Z√§hlerbaustein 8253
        DEFB    10110000B       ; Z√§hler 2/Read'Load 2 Byte/Mode 0/Binary
        DEFB    CTC_53          ; Kontrollwortregister Z√§hlerbaustein 8253
;
        DEFB    (43200)%256     ; Low - Byte Anzahl Sekunden f√ºr 12 Stunden
        DEFB    CT2_53          ; Z√§hler zwei im Z√§hlerbaustein 8253
        DEFB    (43200)/256     ; High - Byte Anzahl Sekunden f√ºr 12 Stunden
        DEFB    CT2_53          ; Z√§hler zwei im Z√§hlerbaustein 8253
;
        DEFB    (15611)%256     ; Low - Byte Teilungsverh√§ltnis f√ºr Sekunden
        DEFB    CT1_53          ; Z√§hler eins im Z√§hlerbaustein 8253
        DEFB    (15611)/256     ; High - Byte Teilungsverh√§ltnis f√ºr Sekunden
        DEFB    CT1_53          ; Z√§hler eins im Z√§hlerbaustein 8253
;
        DEFB    00000101B       ; Code for 'Enable Timer Interrupt'
        DEFB    KEYP_F          ; Kontrollwortregister Ein- Ausgabebaustein 8255
;
        DEFB    00000001B       ; Code 'MZ-700 Bildschirm - Modus' 
        DEFB    CRTCRF          ; Read-Format-Register des Bildschirm-Controllers
;
        DEFB    00000001B       ; Code 'MZ-700 Bildschirm - Modus'
        DEFB    CRTCWF          ; Write-Format-Register des Bildschirm-Controllers
;
;
;   BASIC - Arbeitsbereiche am Speicherende retten
;
A72DC:  LD      HL,(S1078)      ; Anfang Stringarbeitsbereich holen
        LD      (S107A),HL      ; als Ende Stringarbeitsbereich merken
        LD      DE,(S1072)      ; Zeiger auf I/O - Work Area holen
        LD      (S7339),DE      ; und merken
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; L√§nge I/O - Work-Area und Basic-Variable errechnen
        LD      (S733B),HL      ; und merken
        LD      HL,-256         ; Vorgabe f√ºr Stackbereich
        ADD     HL,SP           ; minimale Stackadresse errechnen
        LD      (S733D),HL      ; und als Ende geretteter Bereich merken
        LD      DE,(S1078)      ; Anfang Stringarbeitsbereich holen
        PUSH    HL              ; Zeiger auf Ende Bereich merken
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Adressen vergleichen
        JP      C,A63A7         ; Adressen √ºberschneiden sich -->  Fehler 6  Memory error
        EX      (SP),HL         ; Zeiger auf Ende Rettspeicher holen
        EX      DE,HL           ; Zeiger vertauschen
        LD      BC,(S733B)      ; L√§nge I/O-Work-Area / Basic-Variable holen
        INC     BC              ; corrigieren
        LDDR                    ; Daten in Rettspeicher √ºbertragen
        POP     DE              ; Schiebeoffset holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    24              ; Code 24   Zeiger auf I/O-Work-Area,Basic-Var.,Strings corrigieren
        LD      A,1             ; Code for 'Variable gerettet'
        LD      (S733F),A       ; im Flag  'Variable gerettet'  merken
        RET
;
;
;   BASIC - Arbeitsbereiche retten und Datei er√∂ffnen
;
A7314:  CALL    A72DC           ; BASIC-Arbeitsbereiche am Speicherende retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    47              ; Code 47   (Programm-) Datei er√∂ffnen
        LD      A,(S1000)       ; Datei - Typ - Modus holen
        RET
;
;
;   Pseudo - Bereiche f√ºr die verschiedenen Arbeitsbereiche vorgeben
;
A731D:  LD      HL,(S1078)      ; Anfang Stringarbeitsbereich holen
        XOR     A               ; Accu auf Null
        DEC     HL
        LD      (HL),A          ;! Ende Stringtextbereich eintragen
        DEC     HL              ;!
        LD      (HL),A          ;!
        LD      (S1076),HL      ; Anfang Stringtextbereich merken
        DEC     HL
        LD      (HL),A          ; Ende  Basic - Variable  eintragen
        LD      (S1074),HL      ; Anfang Basic - Variable merken
        DEC     HL
        LD      (HL),A          ; Ende I/O - Work - Area eintragen
        LD      (S1072),HL      ; Zeiger auf I/O - Work Area merken
        LD      HL,4            ; L√§nge der Pseudo - Bereiche vorgeben
        LD      (S733B),HL      ; L√§nge I/O-Work-Area / Basic-Variable merken
        RET
;
S7339:  DEFS    2               ; Zeiger auf gerettete I/O - Work - Area
;
S733B:  DEFS    2               ; L√§nge I/O-Work-Area / Basic-Variable
;
S733D:  DEFS    2               ; Ende geretteter Bereich
;
S733F:  DEFS    1               ; Flag  'Variable gerettet'
;
;
;   wenn im Programm-Modus -->  Fehler 19  Instruction error
;
A7340:  PUSH    AF              ; Register - Wert retten
        CALL    A596B           ; Abfrage, ob in direkter Programmierung
        JP      NZ,A638E        ; nein -->  Fehler 19  Instruction error
        POP     AF              ; geretteten Register - Wert holen
        RET
;
;
;   Speicher auf Platz √ºberpr√ºfen und Programm laden
;
A7349:  LD      BC,(S1014)      ; Programml√§nge aus Dateikennung holen
        PUSH    BC              ; und merken
        LD      HL,(S1072)      ; Zeiger auf I/O - Work Area holen
        LD      DE,(S1070)      ; Anfang Basic - Programm holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; L√§nge freier Arbeitsspeicher errechnen
        LD      L,0
        SBC     HL,BC           ; mit neuer Programml√§nge vergleichen
        JP      C,A63A7         ; neues Programm l√§nger -->  Fehler 6  Memory error
        LD      HL,0
        LD      (S7339),HL      ; als Zeiger auf gerettete I/O-Work-Area merken
        CALL    A6090           ; alle Flags auf Anfangsbedingungen setzen
        LD      HL,0            ; HL auf Null
        LD      (S9E51),HL      ; als Zeilennummer der aktuellen Programmzeile merken
        LD      HL,(S1070)      ; Anfang Basic - Programm holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    48              ; Code 48   Programm nach vorgegebener Kennung nach (HL) laden
        POP     BC              ; gerettete Programml√§nge holen
        LD      HL,(S1070)      ; Anfang Basic - Programm holen
        ADD     HL,BC           ; Zeiger auf Ende Programm errechnen
        LD      (S7339),HL      ; als Zeiger auf I/O - Work - Area merken
        RET
;
;
;   Zwischenspeicher f√ºr Programmladeroutine l√∂schen
;   und gerettete BASIC - Arbeitsbereiche wieder vorgeben
;
A737C:  LD      A,129           ; Datei - Nummer f√ºr Programm
        LD      B,0             ; Code for 'KILL'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    56              ; Code 56  Datei schliessen oder Dateidaten in Rechner l√∂schen
        LD      HL,S733F        ; Zeiger auf Flag  'Variable gerettet'
        LD      A,(HL)          ; Flag  'Variable gerettet'  holen
        OR      A               ; gesetzt  ?
        RET     Z               ; nein
        LD      (HL),0          ; Flag zur√ºcksetzen
        LD      HL,(S7339)      ; Zeiger auf I/O - Work - Area holen
        LD      A,H             ;! Zeiger vorhanden  ?
        OR      L               ;!
        JR      NZ,A7397        ; ja
        LD      HL,(S1070)      ; Anfang Basic - Programm holen
        CALL    A61C5           ; (HL) Bereichsende  (00 00)  eintragen
A7397:  EX      DE,HL           ; Zeiger auf Stelle f√ºr I/O - Work-Area nach DE
        LD      HL,(S1072)      ; Zeiger auf I/O - Work Area holen
        LD      BC,(S733B)      ; L√§nge I/O-Work-Area / Basic-Variable holen
        LDIR
        EX      DE,HL
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; 'um Anzahl verschobene Bytes' errechnen
        EX      DE,HL           ; nach DE
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    24              ; Code 24   Zeiger auf I/O-Work-Area,Basic-Var.,Strings corrigieren
        RET
;
;
;   Basic - Befehl   VERIFY     (Zwischencode  254 165 / 0FEH 0A5H)
;
A73A9:  PUSH    HL              ; Programmzeiger retten
        CALL    A5F2F           ; Zeiger auf Zeilen im Programm in Zeilennummern umsetzen
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A6FA4           ; Text (HL) auf Ger√§te-Namen und Datei-Nummer auswerten
        PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    47              ; Code 47   (Programm-) Datei er√∂ffnen
        CP      _BTX            ; Datei - Typ  BTX  ?
        JP      NZ,A63D1        ; nein -->  Fehler 61  Illegal filemode error
        LD      HL,(S1070)      ; Anfang Basic - Programm holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    50              ; Code 50   (Programm-) Datei vergleichen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   SAVE     (Zwischencode  181 / 0B5H)
;
A73C0:  CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFB    ___ALL          ; ALL  (Zwischencode)  ?
        LD      A,1             ; Code for 'SAVE ALL'
        JP      Z,A7004         ; ja -->  RAM - Karteninhalt auf Quick - Disk schreiben
        PUSH    HL              ; Programmzeiger retten
        CALL    A5F2F           ; Zeiger auf Zeilen im Programm in Zeilennummern umsetzen
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A6FA4           ; Text (HL) auf Ger√§te-Namen und Datei-Nummer auswerten
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A73F6         ; ja -->  auf Sonderformat untersuchen
        PUSH    HL              ; Programmzeiger retten
        LD      A,_BTX          ; Code for 'Basic - Programm - Datei'
        LD      (S1000),A       ; als Datei - Typ - Kennung eintragen
        LD      HL,(S1072)      ; Zeiger auf I/O - Work Area holen
        LD      DE,(S1070)      ; Anfang Basic - Programm holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; L√§nge des Basic - Programms errechnen
        LD      (S1014),HL      ; Programml√§nge in Dateikennung eintragen
        LD      A,(S1001)       ; erstes Zeichen Datei - Name holen
        CP      CR              ; Textendezeichen  ?
        JP      Z,A63CE         ; ja -->  Fehler 60  Illegal filename error
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    49              ; Code 49   Programm abspeichern
        POP     HL              ; geretten Programmzeiger holen
        RET
;
;
;   Basic - Programm in ASCII abspeichern
;
A73F6:  CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    "A"             ; A   (ASCII)  ?
        PUSH    HL              ; Programmzeiger retten
        LD      A,2             ; Code for 'Datei zum Schreiben er√∂ffnen'
        LD      (S1043),A       ; als Datei - Zugriffscode eintragen
        LD      A,129           ; Datei - Nummer f√ºr Programm
        LD      (S1042),A       ; als interne aktuelle Ger√§te-Nummer merken
        CALL    A6F79           ; sequentielle Datei er√∂ffnen
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A6AC8           ; Zeilen aufbereiten in ASCII und an Datei ausgeben
        CALL    A6DB1           ; Zeilenvorschub ausgeben
        LD      B,1             ; Code for 'CLOSE'
        LD      A,129           ; Datei - Nummer f√ºr Programm
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    56              ; Code 56  Datei schliessen oder Dateidaten in Rechner l√∂schen
        RET
;
;
;   Basic - Befehl   UNLOCK     (Zwischencode  219 / 0DBH)
;
A7416:  XOR     A               ; Code for 'UNLOCK'
        DEFB    LD_BC
;
;
;   Basic - Befehl   LOCK     (Zwischencode 218 / 0DAH)
;
A7418:  LD      A,1             ; Code for 'LOCK'
        PUSH    AF              ; Flag  'UNLOCK/LOCK'  merken
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    45              ; Code 45  Ger√§te- und Dateinamen (DE) auswerten und aufbereiten
        POP     AF              ; Flag  'UNLOCK/LOCK' holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    63              ; Code 63   (Programm-) Datei sch√ºtzen oder freigeben
        RET
;
;
;   Basic - Befehl   DIR     (Zwischencode 213 / 0D5H)
;
A7424:  CALL    A6EF9           ; Datei- oder Ger√§tenummer bereitstellen
        PUSH    AF              ; Ausgabe - Datei (Ger√§te) - Nummer retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    46              ; Code 46   Datei-Verwaltungssatz nach Nr. bereitstellen
        JP      C,A6E2D         ; Datensatz nicht gefunden -->  Fehler 44  Not open error
        BIT     1,A             ; Datei oder Ger√§t zum Schreiben er√∂ffnet  ?
        JP      Z,A6E30         ; nein -->  Fehler 59  Can't execute error
        CALL    A6F39           ; bei Datei auf Syntax 'Komma' untersuchen
        CALL    A6FB1           ; Ger√§te-Namen bereitstellen und Ger√§t anmelden
        LD      B,A             ; Ger√§te - Nummer merken
        XOR     A               ; Code for 'Inhaltsverzeichnis einlesen'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    57              ; Code 57  Inhaltsverzeichnis einlesen oder ausgeben
        LD      A,B             ; Ger√§te - Nummer holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    58              ; Code 58   Zeiger auf Ger√§te-Tabelle/Ger√§te-Nummer merken
        POP     AF              ; Ausgabe-Datei (Ger√§te) - Nummer holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    57              ; Code 57   Inhaltsverzeichnis einlesen oder ausgeben
        RET
;
;
;   DELETE   "Datei"
;
A7443:  CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    45              ; Code 45  Ger√§te- und Dateinamen (DE) auswerten und aufbereiten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    61              ; Code 61  (Programm-) Datei l√∂schen
        RET
;
;
;   Basic - Befehl   RENAME     (Zwischencode  216 / 0D8H)
;
A744B:  CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    45              ; Code 45  Ger√§te- und Dateinamen (DE) auswerten und aufbereiten
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    62              ; Code 62   Datei umbenennen
        RET
;
;
;   PRINT  auf  RANDOM - Datei
;
A7459:  CALL    A748F           ; RANDOM - Satz - Nummer auswerten und vorgeben
A745C:  CALL    A6C87           ; Ausdruck (HL) auswerten/Ergebnis als Zeichenkette bereitst.
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    66              ; Code 66  Datensatz in RANDOM - Datei schreiben
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        RET     Z               ; fertig
        CALL    A79B4           ; auf Syntax 'Komma' √ºberpr√ºfen
        JR      A745C           ; weitere S√§tze in RANDOM - Datei schreiben
;
;
;   INPUT  aus  RANDOM - Datei
;
A746A:  CALL    A748F           ; RANDOM - Satz - Nummer auswerten und vorgeben
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        CALL    A8C08           ; √ºberpr√ºfen, ob Adresse in DE mit Stack kollidiert
A7474:  CALL    A8B56           ; Zeiger auf Variable nach Namen (HL) bereitstellen
        PUSH    HL              ; Programmzeiger retten
        PUSH    AF              ; Variablentypcode retten
        PUSH    BC              ; Zeiger auf Variable retten
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    65              ; Code 65   Datensatz aus RANDOM - Datei lesen
        POP     DE              ; Zeiger auf Variable holen
        POP     AF              ; Variablentypcode holen
        CALL    A6E71           ; bereitgestellten String der Variable zuweisen
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        RET     Z               ; fertig
A748B:
        CALL    A79B4           ; auf Syntax 'Komma' √ºberpr√ºfen
        JR      A7474           ; weitere Werte aus RANDOM - Datei lesen
;
;
;   RANDOM - Satz - Nummer auswerten und vorgeben
;
A748F:  CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    "("             ; Klammer auf
        RET     NZ              ; nein -->  keine RANDOM - Satznummer angegeben
        CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        LD      A,D             ;! Satznummer gleich Null  ?
        OR      E               ;!
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    64              ; Code 64   RANDOM - Satznummer setzen
        CALL    A79AA           ; auf Syntax 'Klammer zu' √ºberpr√ºfen
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma
        RET
;
;
;   Basic - command SWAP (intermediate code 191 / 0BFH)
;
A74A6:  LD      A,(S9E68)       ; SWAP - get flag
        OR      A               ; set  ?
        JP      NZ,A639D        ; already in the SWAP program --> error 25 SWAP error
        PUSH    HL              ; Save program pointer
        LD      B,0             ; Code 'length equals zero'
        RST     _DOCMD          ; Software - Execute command
        DEFB    44              ; Code 44 text (DE) on devices - evaluate names
        LD      (S755B),DE      ; Remember pointer to device table for SWAP main program
        LD      (S755D),A       ; Device - number SWAP - remember main program
        LD      HL,(S1072)      ; Get pointer to I/O - Work Area
        LD      DE,(S1070)      ; Start Basic - Get program
        XOR     A               ; reset carry flag (code 'write away')
        SBC     HL,DE           ; Length Basic - Calculate program
        LD      (S1014),HL      ; Enter the program length in the file identifier
        RST     _DOCMD          ; Software - Execute command
        DEFB    68              ; Code 68 SWAP - Write or load main program
        POP     HL              ; get saved program pointer
        CALL    A6FA4           ; Evaluate text (HL) for device name and file number
        CALL    A797A           ; check for syntax at the end of the command
        LD      A,(S1050)       ; Get Device - Type - Byte
        BIT     5,A             ; SWAP possible?
        JP      Z,A6E30         ; no --> Error 59 Can't execute error
        PUSH    HL              ; Save program pointer
        LD      HL,(W9E62)      ; Length of data set to be saved (2 CPL)
        ADD     HL,SP           ; Calculate pointer to position for record
        LD      SP,HL           ; Reset stack pointer
        EX      DE,HL           ; Pointer to memory after DE
        LD      HL,S9E4B        ; Pointer to next program line
        LD      BC,(W9E60)      ; Get length of data record to be saved
        LDIR                    ; Save data of the current program
        CALL    A7314           ; BASIC - Save workspace and open file
        CP      _BTX            ; File Type Basic Program ?
        JP      NZ,A63D1        ; no --> Error 61 Illegal filemode error
        LD      (A74F3 + 1),SP  ; Enter stack pointer in routine
;
;
;   CHAIN program if in SWAP program
;
A74F3:  LD      SP,0            ; Set stack pointer
        CALL    A7349           ; Check memory for space and load program
        CALL    A737C           ; Delete buffer for program load routine
        LD      HL,0FFFDH       ; Code 'Start SWAP - Stack'
        PUSH    HL              ; put on stack
        PUSH    HL                
        LD      A,1             ; Code 'in the SWAP program'
        LD      (S9E68),A       ; note in the SWAP flag
        LD      HL,(S1070)      ; Start Basic - Get program
        JP      A5909           ; Process program from line (HL).
;
;
;   SWAP - program end --> reload main program
;
A750C:  XOR     A               ; Code 'not in SWAP program'
        LD      (S9E68),A       ; note in the SWAP flag
        POP     IX              ; Get return address
A7512:  POP     BC              ; Get value ID from stack
        LD      A,B             ; High - byte value identifier
        CP      0FFH            ; same value identifier ?
        JP      NZ,A639D        ; no --> error 25 SWAP error
        LD      A,C             ; Get low byte value identifier
        CP      0FDH            ; same identifier 'SWAP - Stack' ?
        JR      Z,A7531         ; yes -> start of stack found
        CP      0FEH            ; same identifier 'RETURN - data' ?
        LD      HL,4            ; The remainder of the data record is 4 bytes long
        JR      Z,A752D         ; yes --> Calculate pointer to next data set
        CP      18              ; same identifier 'NEXT - data set' ?
        LD      HL,16           ; The remainder of the data record is 16 bytes long
        JP      NZ,A639D        ; wrong identifier --> error 25 SWAP error
A752D:  ADD     HL,SP           ; Calculate pointer to next record
        LD      SP,HL           ; Reset stack pointer
        JR      A7512           ; check next record
;
A7531:  LD      DE,(S755B)      ; Get pointer to device table for SWAP main program
        LD      A,(S755D)       ; Device - Number SWAP - Get main program
        RST     _DOCMD          ; Software - Execute command
        DEFB    58              ; Code 58 Pointer to device table/remember device number
        LD      B,0             ; Code 'length zero characters'
        RST     _DOCMD          ; Software - Execute command
        DEFB    44              ; Code 44 text (DE) on devices - evaluate names
        CALL    A72DC           ; Save BASIC workspaces at end of memory
        OR      0FFH            ; Set code 'Load'
        RST     _DOCMD          ; Software - Execute command
        DEFB    68              ; Code 68 SWAP - Write or load main program
        CALL    A7349           ; Check memory for space and load program
        CALL    A737C           ; Delete buffer for program load routine
        LD      HL,0            ;! Get stack pointer to HL
        ADD     HL,SP           ;!
        LD      DE,S9E4B        ; Pointer to next program line
        LD      BC,(W9E60)      ; Get length of saved record
        LDIR                    ; restore saved data
        LD      SP,HL           ; Reset stack pointer
        POP     HL              ; get saved program pointer
        RET                       
;
S755B:  DEFS    2               ; Pointer to device table for SWAP main program
S755D:  DEFS    1               ; Device - number SWAP - main program

;
;
;   Cassettenroutinen und serielle Schnittstelle initialisieren
;
A755E:  POP     HL              ; R√ºcksprungadresse vom Stack holen
        PUSH    HL              ; und wieder merken
        LD      (S004F),HL      ; R√ºcksprungadresse als Fehleradresse eintragen
        LD      A,'1'           ; Code for 'serielle Schnittstelle eins'
        CALL    A7574           ; Nummer eintragen und Ger√§t initialisieren
        LD      A,'2'           ; Code for 'serielle Schnittstelle zwei'
        CALL    A7574           ; Nummer eintragen und Ger√§t initialisieren
        LD      DE,M758B        ; Text  'CMT:T'
        LD      B,5             ; Textl√§nge
        JR      A757C           ; Ger√§t nach Text (HL) initialisieren
;
A7574:  LD      (M7581),A       ; Nummer der Schnittstelle eintragen
        LD      DE,M757F        ; Text  'RSx:0,$8C,13'
        LD      B,12            ; Textl√§nge
A757C:  JP      A6F4F           ; Ger√§t nach Text (HL) initialisieren
;
;
;   Text zur Initialisierung der seriellen Schnittstellen
;   (keine √úberwachungssignale, 8 Bit, 2 Stopbits, keine Parit√§t, Endezeichen CR)
;
M757F:  DEFM    "RS"
M7581:  DEFM    "?:0,$8C,13"           ; auf ? wird Nummer der Schnittstelle eingetragen

;
;
;   Text zur Initialisierung der Cassettenroutinen
;
M758B:  DEFM    "CMT:T"         ; T = Fehler bei EOF ausgeben
;
M7590:  DEFB    0               ; Vorgabe f√ºr √úbschreibmodus
;
B7591:  DEFB    3               ; Vorgabe f√ºr Palettencode der Punkte
;
;
;   Basic - Befehl   SET     (Zwischencode 254 146 / 0FEH 092H)
;
B7592:  DEFB    OR_N            ; Code for 'SET'
;
;
;   Basic - Befehl   RESET     (Zwischencode 254 147 / 0FEH 093H)
;
A7593:  XOR     A               ; Code for 'RESET'
        PUSH    AF              ; Flag  'RESET/SET' retten
        CALL    A75FB           ; auf Farbangabe untersuchen und X,Y-Graphic-Koord. bereitst.
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    71              ; Code 71   Graphic-Cursor auf Koordinate in DE',HL' setzen
        POP     AF              ; Flag  'RESET/SET'  holen
        PUSH    HL              ; Programmzeiger retten
        EXX                     ; Koordinaten in Erstregistersatz holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    72              ; Code 72   Punkt nach Koordinaten in DE,HL setzen/zur√ºcksetzen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   LINE     (Zwischencode 254 148 / 0FEH 094H)
;
B75A1:  DEFB    OR_N            ; Code for 'LINE'
;
;
;   Basic - Befehl   BLINE     (Zwischencode 254 149 / 0FEH 095H)
;
A75A2:  XOR     A               ; Code for 'BLINE'
        LD      (D75B6 + 1),A   ; Flag  'BLINE/LINE'  in Routine eintragen
        CALL    A75FB           ; auf Farbangabe untersuchen und X,Y-Graphic-Koord. bereitst.
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
A75AC:  EXX                     ; Graphic - Koordinaten in Erstregistersatz holen
        PUSH    HL              ; Y - Koordinate des Punktes retten
        PUSH    DE              ; X - Koordinate des Punktes retten
        EXX
        CALL    A75FE           ; Ausdruck (HL) auswerten und X,Y - Graphic - Koordinate bereitstellen
        POP     DE              ; X - Koordinate Anfangspunkt holen
        EX      (SP),HL         ; Y - Koordinate Anfangspunkt holen / Programmzeiger retten
        EXX
D75B6:  LD      A,0             ; Flag  'BLINE/LINE'  holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    73              ; Code 73   Linie zeichnen von DE',HL' nach DE,HL
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A75AC         ; ja -->  Koordinate bereitstellen und Linie zeichnen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    71              ; Code 71   Graphic-Cursor auf Koordinate in DE',HL' setzen
        RET
;
;
;   Basic - Befehl   PATTERN     (Zwischencode 254 155 09BH)
;
A75C4:  CALL    A768A           ; auf Farbangabe untersuchen und auswerten
        CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        XOR     A               ; Accu auf Null  (Code for 'Lagen positiv')
        BIT     7,D             ; Anzahl Lagen positiv  ?
        JR      Z,A75D8         ; ja
        PUSH    HL              ; Programmzeiger retten
        LD      H,A             ; Null
        LD      L,A             ; Null
        SBC     HL,DE           ; positiven Wert f√ºr Anzahl Lagen errechnen
        EX      DE,HL           ; und nach DE
        POP     HL              ; geretteten Programmzeiger holen
        LD      A,1             ; Code for 'Lagen negativ'
A75D8:  EX      AF,AF           ; Flag  'Lagen positiv/negativ'  merken
        LD      A,D             ; High - Byte Anzahl Lagen holen
        OR      A               ; gleich Null  ?
        JR      NZ,A7616        ; Wert zu gro√ü -->  Fehler 3  Illegal data error
        LD      A,E             ; Low - Byte Anzahl Lagen holen
        PUSH    AF              ; und retten
        EX      AF,AF           ; Flag  'Lagen positiv/negativ'  holen
        PUSH    AF              ; und retten
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        POP     AF              ; Flag  'Lagen positiv/negativ'  holen
        LD      C,A             ; und merken
        POP     AF              ; Anzahl Lagen holen
        PUSH    HL              ; Programmzeiger retten
        LD      H,C             ; Flag  'Lagen positiv/negativ'  vorgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    74              ; Code 74  Graphic-Muster ausgeben
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JR      NZ,A75C4        ; nein -->  weitere PATTERN - Teile ausf√ºhren
        RET
;
;
;   Basic - Befehl   POSITION     (Zwischencode 254 154 / 0FEH 09AH)
;
A75F5:  CALL    A75FE           ; Ausdruck (HL) auswerten und X,Y - Graphic - Koordinate bereitstellen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    71              ; Code 71   Graphic-Cursor auf Koordinate in DE',HL' setzen
        RET
;
;
;   auf Farbangabe untersuchen und X,Y-Graphic-Koordinate bereitstellen
;
A75FB:  CALL    A768A           ; auf Farbangabe untersuchen und auswerten
;
;
;   Ausdruck (HL) auswerten und X,Y - Graphic - Koordinate bereitstellen
;
A75FE:  CALL    A760F           ; Ausdruck (HL) auswerten und Ergebnis auf Graphic-Koordinate testen
        PUSH    DE              ; X - Koordinate Graphic retten
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        CALL    A760F           ; Ausdruck (HL) auswerten und Ergebnis auf Graphic-Koordinate testen
        PUSH    DE              ; Y - Koordinate auf Stack 
        EXX
        POP     HL              ; Y - Koordinate Graphic holen
        POP     DE              ; X - Koordinate Graphic holen
        EXX
        RET
;
;
;   Ausdruck (HL) auswerten und Ergebnis auf Graphic-Koordinate testen
;
A760F:  CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        LD      A,D             ; High - Byte Graphic - Koordinate holen
        ADD     A,040H          ; Koordinate im Bereich  -16384 / + 16384  ?
        RET     P               ; ja
A7616:  JP      A636A           ; Fehler 3   Illegal data error
;
;
;   Basic - Befehl   PAL     (Zwischencode 254 150 / 0FEH 096H)
;
A7619:  CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A6364         ; ja -->  Fehler 1  Syntax error
        CALL    A7640           ; ein Byte - Wert zwischen 0 und 15 bereitstellen
        CALL    A76DE           ; Wert auf maximal zul√§ssigen Palettenwert untersuchen
        AND     00000011B       ; Palettenwert im Palettenblock maskieren
        PUSH    AF              ; Palettencodewert retten
        LD      A,(S137E)       ; Palettenblocknummer holen
        LD      D,E             ; Palettencodewert nach D duplizieren
        SRL     D               ;! durch vier teilen
        SRL     D               ;!
        CP      D               ; Palettenblockcode mit aktueller Blocknummer  vergleichen
        JP      NZ,A6397        ; nicht gleich -->  Fehler  22   PAL error
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        CALL    A7640           ; ein Byte - Wert zwischen 0 und 15 bereitstellen
        LD      B,A             ; Farbwert merken
        POP     AF              ; Palettencodewert holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    82              ; Code 82   Farbcode in B der Palettencode-Nummer im Accu zuordnen
        RET
;
;
;   ein Byte - Wert zwischen 0 und 15 bereitstellen
;
A7640:  CALL    A853D           ; ein - Byte - Wert nach DE/Accu bereitstellen
        CP      15 + 1          ; gr√∂√üer 15  ?
        JR      NC,A7616        ; ja -->  Fehler 3  Illegal data error
        RET
;
;
;   Basic - Befehl   BOX     (Zwischencode 254 152 / 0FEH 098H)
;
A7648:  CALL    A75FB           ; auf Farbangabe untersuchen und X,Y-Graphic-Koord. bereitst.
        EXX
        PUSH    HL              ; Y - Koordinate erste Ecke retten
        PUSH    DE              ; X - Koordinate erste Ecke retten
        EXX
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A75FE           ; Ausdruck (HL) auswerten und X,Y - Graphic - Koordinate bereitstellen
        EXX
        PUSH    HL              ; Y - Koordinate zweite Ecke retten
        PUSH    DE              ; X - Koordinate zweite Ecke retten
        EXX
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JR      Z,A766B         ; keine Ausmalfarbe angegeben
        CALL    A79B4           ; auf Syntax 'Komma' √ºberpr√ºfen
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        LD      A,(B7591)       ; Vorgabe f√ºr Palettencode der Punkte holen
        CALL    NZ,A76D9        ; Ausdruck (HL) auswerten und auf maximalen Palettencode unters.
        SCF                     ; Code for 'Rechteck ausmalen'
A766B:  EXX
        POP     DE              ; X - Koordinate der zweiten Ecke holen
        POP     HL              ; Y - Koordinate der zweiten Ecke holen
        EXX
        POP     DE              ; X - Koordinate der ersten Ecke holen
        EX      (SP),HL         ; Y - Koordinate holen / Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    75              ; Code 75   Rechteck zeichnen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   COLOR     (Zwischencode 254 144 / 0FEH 090H)
;
A7675:  CALL    A76B4           ; Palettencodewert und √úberschreibmodus bereitstellen
        LD      A,(B7591)       ; Vorgabe f√ºr Palettencode der Punkte holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    84              ; Code 84  aktuell benutzte Farbebenen merken
        LD      (S137B),A       ; maximaler Palettenwert / aktuelle Zeichenfarbe merken
        LD      A,(S109A)       ; aktuellen √úberschreibmodus holen
        LD      (M7590),A       ; Vorgabe f√ºr √úbschreibmodus merken
        CALL    A797A           ; auf Syntax Befehlsende √ºberpr√ºfen
        RET
;
;
;   auf Farbangabe untersuchen und auswerten
;
A768A:  CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    "["             ; Eckige Klammer auf  ?
        JR      NZ,A76A5        ; nein -->  kein Farbwert angegeben
        CALL    A76B4           ; Palettencodewert und √úberschreibmodus bereitstellen
        LD      A,(B7591)       ; Vorgabe f√ºr Palettencode der Punkte holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    85              ; Code 85   Graphic - Palettenwert merken
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    "]"             ; Eckige Klammer zu   ?
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        RET
;
;
;   Standart-Palettencodewert und √úberschreib-Modus vorgeben
;
A76A5:  LD      A,(S137B)       ; maximaler Palettenwert / aktuelle Zeichenfarbe holen
        LD      (B7591),A       ; als Vorgabe f√ºr Palettencode des Zeichens merken
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    85              ; Code 85   Graphic - Palettenwert merken
A76AD:  LD      A,(M7590)       ; Vorgabe f√ºr √úbschreibmodus holen
        LD      (S109A),A       ; als aktuelle √úberschreibmodus merken
        RET
;
;
;   Palettencodewert und √úberschreibmodus bereitstellen
;
A76B4:  CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A76D1         ; ja -->  nur auf √úberschreibmodus untersuchen
        CALL    A76D9           ; Ausdruck (HL) auswerten und auf maximalen Palettencode unters.
        LD      (B7591),A       ; als Vorgabe f√ºr Palettencode der Punkte merken
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      NZ,A76AD        ; nein -->  √úberschreibmodus vorgeben
A76C6:  CALL    A853D           ; ein - Byte - Wert nach DE/Accu bereitstellen
        CP      1 + 1           ; Null oder Eins  ?
        JR      NC,A76FA        ; nein -->  Fehler 3  Illegal data error
        LD      (S109A),A       ; aktuellen √úberschreibmodus merken
        RET
;
A76D1:  LD      A,(S137B)       ; maximaler Palettenwert / aktuelle Zeichenfarbe holen
        LD      (B7591),A       ; als Vorgabe f√ºr Palettencode der Punkte merken
        JR      A76C6           ; auf √úberschreibmodus untersuchen
;
;
;   Ausdruck (HL) auswerten und Ergebnis auf maximal zul√§ssigen Palettencodewert untersuchen
;
A76D9:  PUSH    BC              ; Register - Wert retten
        CALL    A853D           ; ein - Byte - Wert nach DE/Accu bereitstellen
        POP     BC              ; geretteten Register - Wert holen
A76DE:  LD      A,(S1379)       ; Bildschirm - Modus - Bit holen
        RRA                     ; um eine Stelle nach rechts schieben
        JR      C,A76EA         ; Mode 0 -->  auf Palettencodewert zwischen 0 und 3 untersuchen
        RRA                     ; um eine Stelle nach rechts schieben
        JR      C,A76F0         ; Mode 1 -->  auf Palettencodewert zwischen 0 und 15 untersuchen
        RRA                     ; um eine Stelle nach rechts schieben
        JR      C,A76F6         ; Mode 2 -->  auf Palettencodewert 0 oder 1 untersuchen
A76EA:  LD      A,E             ; Palettencodewert holen
        CP      3 + 1           ; Null bis Drei  ?
        JR      NC,A76FA        ; nein -->  Fehler 3  Illegal data error
        RET
;
A76F0:  LD      A,E             ; Palettencodewert holen
        CP      15 + 1          ; zwischen Null und 15  ?
        JR      NC,A76FA        ; nein -->  Fehler 3  Illegal data error
        RET
;
A76F6:  LD      A,E             ; Palettencodewert holen
        CP      1 + 1           ; Null oder Eins  ?
        RET     C               ; ja
A76FA:  JP      A636A           ; Fehler 3   Illegal data error
;
;
;   Basic - Befehl   PAINT     (Zwischencode 254 153 / 0FEH 099H)
;
A76FD:  CALL    A768A           ; auf Farbangabe untersuchen und auswerten
        CALL    A75F5           ; X,Y-Koordinate bereitstellen und Graphic-Cursor setzen
        LD      B,0             ; Z√§hler 'Anzahl Palettenwerte' auf Null
        LD      DE,S773C        ; Zeiger auf Speicher f√ºr Palettenwerte
        PUSH    DE              ; Zeiger auf Anfang Speicher retten
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JR      Z,A7735         ; kein Palettenwert angegeben -->  ausmalen
A770E:  CALL    A79B4           ; auf Syntax 'Komma' √ºberpr√ºfen
        PUSH    DE              ; Zeiger auf Speicher f√ºr Palettenwerte retten
        CALL    A76D9           ; Ausdruck (HL) auswerten und auf maximalen Palettencode unters.
        POP     DE              ; Zeiger auf Speicher f√ºr Palettenwerte holen
        LD      (DE),A          ; Palettencodewert merken
        INC     DE              ; Zeiger auf Speicher auf n√§chste Speicherzelle
        INC     B               ; Anzahl Palettencodewerte plus eins
        LD      A,B             ; Anzahl Palettencodewerte holen
        CP      16              ; schon 16 Werte bereitgestellt  ?
        JP      Z,A6364         ; ja -->  Fehler 1  Syntax error
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JR      NZ,A770E        ; nein -->  weitere Werte bereitstellen
A7724:  EX      (SP),HL         ; Programmzeiger retten / Zeiger auf Anfang Speicher holen
        PUSH    HL              ; Zeiger auf Speicher f√ºr Palettenwerte retten
        LD      HL,-527         ;! Speicher f√ºr Stack reservieren
        ADD     HL,SP           ;!
        LD      (S137C),HL      ; maximale RAM - Adresse f√ºr PAINT - Routine eintragen
        POP     HL              ; Zeiger auf Speicher f√ºr Palettenwerte holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    76              ; Code 76   Fl√§che ausmalen
        JP      C,A6373         ; Fehler aufgetreten -->  Fehler 6  Memory error
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
A7735:  LD      A,(B7591)       ; Vorgabe f√ºr Palettencode der Punkte holen
        LD      (DE),A          ; im Speicher f√ºr Palettencodewerte merken
        INC     B               ; Anzahl Palettencodewerte auf eins
        JR      A7724           ; Fl√§che ausmalen
;
S773C:  DEFS    16              ; Speicher f√ºr Palettencodewerte bei PAINT
;
;
;   Basic - Befehl   CIRCLE     (Zwischencode 254 151 / 0FEH 097H)
;
A774C:  PUSH    HL              ; Programmzeiger retten
        LD      HL,0
        LD      (D782E + 1),HL  ; Verh√§ltnisflag / Verh√§ltnis l√∂schen
        LD      (D7828 + 1),HL  ; X - Offset auf Startpunkt zur√ºcksetzen
        LD      (D782B + 1),HL  ; Y - Offset auf Startpunkt zur√ºcksetzen
        LD      (D7832 + 1),HL  ; X - Offset auf Endpunkt zur√ºcksetzen
        LD      (D7835 + 1),HL  ; Y - Offset auf Endpunkt zur√ºcksetzen
        LD      HL,S7905        ; Zeiger auf Speicher f√ºr Startwinkel
        CALL    A909E           ; Null im Real - Format nach (HL) eintragen
        LD      HL,B98C1        ; Zeiger auf 2 * Pi   (Real - Konstante)
        LD      DE,S790A        ; Zeiger auf Speicher f√ºr Endwinkel
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen 
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A75FB           ; auf Farbangabe untersuchen und X,Y-Graphic-Koord. bereitst.
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    71              ; Code 71   Graphic-Cursor auf Koordinate in DE',HL' setzen
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        PUSH    HL              ; Programmzeiger retten
        LD      A,D             ; High - Byte Wert holen
        AND     11000000B       ; Wert gr√∂√üer 16384  ?
        JP      NZ,A636A        ; ja -->  Fehler 3   Illegal data error
        EX      DE,HL           ; Radius nach HL
        LD      (D7838 + 2),HL  ; Radius in Routine eintragen
        LD      (D7828 + 1),HL  ; Radius als X - Offset auf Startpunkt eintragen
        LD      (D7832 + 1),HL  ; Radius als X - Offset auf Endpunkt eintragen
        LD      HL,(S107C)      ; Zeiger auf Anfang Rechenspeicher holen
        LD      DE,S78F1        ; Zeiger auf Speicher f√ºr Real-Radius
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; geretteten Programmzeiger holen
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A77EB         ; keine weiteren Parameter angegeben
        CALL    A79B4           ; auf Syntax 'Komma' √ºberpr√ºfen
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A77B0         ; kein Aspekt angegeben
        CALL    A7841           ; Aspekt - Wert f√ºr Circle auswerten
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A77EB         ; keine weiteren Parameter angegeben
        CALL    A79B4           ; auf Syntax 'Komma' √ºberpr√ºfen
A77B0:  CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A77CA         ; kein Startwinkel angegeben
        LD      IX,D7828 + 1    ; Zeiger auf Speicher f√ºr Offsets des Startpunktes
        LD      IY,S7905        ; Zeiger auf Speicher f√ºr Startwinkel
        CALL    A788E           ; X- und Y- Offset auf Punkt aus Radius, Aspekt und Winkel errechnen
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A77EB         ; keine weiteren Parameter
        CALL    A79B4           ; auf Syntax 'Komma' √ºberpr√ºfen
A77CA:  CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A77E4         ; kein Endwinkel angegeben
        LD      IX,D7832 + 1    ; Zeiger auf Speicher f√ºr Offsets des Endpunktes
        LD      IY,S790A        ; Zeiger auf Speicher f√ºr Endwinkel
        CALL    A788E           ; X- und Y- Offset auf Punkt aus Radius, Aspekt und Winkel errechnen
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A77EB         ; ja -->  Tortenflag nicht angegeben
        CALL    A79B4           ; auf Syntax 'Komma' √ºberpr√ºfen
A77E4:  CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    "O"             ; Code for 'Anfangspunkt √ºber Mittelpunkt mit Endpunkt verbinden'
        SCF                     ; Code 'Verbindungslinie Zeichen'
        JR      A77EC           ; Parameter laden und Zeichenroutine aufrufen
;
A77EB:  XOR     A               ; Code for 'keine Verbindungslinie Zeichnen'
A77EC:  PUSH    HL              ; Programmzeiger retten
        PUSH    AF              ; Flag  'Verbindungslinie Zeichnen/nicht Zeichnen'
        LD      HL,S7905        ; Zeiger auf Speicher f√ºr Startwinkel
        LD      DE,S790A        ; Zeiger auf Speicher f√ºr Endwinkel
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        LD      A,(S7905)       ; Exponent der Differenz holen
        OR      A               ; gleich Null  ?
        LD      B,0             ; Code for 'Startwinkel gleich Endwinkel'
        JR      Z,A781E         ; Differenz gleich Null
        LD      HL,S7906        ; Zeiger auf MSByte Mantisse der Differenz
        RES     7,(HL)          ; Differenz auf 'Plus'
        DEC     HL              ; Zeiger wieder auf Exponenten
        LD      DE,B98C6        ; Zeiger auf Pi im Real - Format
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        LD      B,1             ; Code for '0 < Startwinkel - Endwinkel < Pi'
        JR      C,A781E         ; bereitgestellte Parameter laden
        LD      DE,B98C1        ; Zeiger auf 2 * Pi   (Real - Konstante)
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        LD      B,2             ; Code for 'Pi < Startwinkel - Endwinkel < 2 * Pi'
        JR      C,A781E         ; bereitgestellte Parameter laden
        LD      B,3             ; Code for '2 * Pi < Startwinkel - Endwinkel
A781E:  LD      A,(S790B)       ; Mantisse Winkeldifferenz holen
        AND     10000000B       ; Vorzeichen maskieren
        OR      B               ; plus Winkelgr√∂√üenflag
        LD      B,A             ; Winkelflag merken
        POP     AF              ; Tortengraphic - Flag holen
        LD      A,B             ; Winkelflag wieder holen
        EXX
D7828:  LD      DE,0            ; X - Offset auf Startpunkt    (wird eingetragen)
D782B:  LD      HL,0            ; Y - Offset auf Startpunkt    (wird eingetragen)
D782E:  LD      BC,0            ; C = Verh√§ltnisflag  /  B = Verh√§ltniswert
        EXX
D7832:  LD      DE,0            ; X - Offset auf Endpunkt    (wird eingetragen)
D7835:  LD      HL,0            ; Y - Offset auf Endpunkt    (wird eingetragen)
D7838:  LD      IX,0            ; Integer - Radius           (wird eingetragen)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    77              ; Code 77   Kreis zeichnen
        POP     HL              ; geretteten Programmzeiger holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        RET
;
;
;   Aspekt - Wert f√ºr CIRCLE bereitstellen und auswerten
;
A7841:  CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      HL,(S107C)      ; Zeiger auf Anfang Rechenspeicher holen
        INC     HL              ; Zeiger auf Mantisse des Aspekts
        BIT     7,(HL)          ; Aspekt negativ  ?
        JP      NZ,A636A        ; ja -->  Fehler 3   Illegal data error
        DEC     HL              ; Zeiger wieder auf Exponent der Zahl
        LD      DE,B7C45        ; Zeiger auf +1  (Real - Format)
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        RET     Z               ; Aspekt gleich 1
        LD      A,1             ; Code for 'Aspekt < 1'  (X-Achse als Hauptachse)
        JR      C,A7870         ; Aspekt kleiner eins
        LD      HL,B7C45        ; Zeiger auf +1  (Real - Format)
        LD      DE,S78F6        ; Zeiger auf Rechenspeicher f√ºr CIRCLE - Routine
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf +1 im Speicher
        LD      DE,(S107C)      ; Zeiger auf Anfang Rechenspeicher holen
        CALL    A93D5           ; /  - Routine   ( (HL) = (HL) / (DE) )
        LD      A,2             ; Code for 'Aspekt > 1' (Y-Achse als Hauptachse)
A7870:  LD      (D782E + 1),A   ; Verh√§ltnisflag eintragen
        LD      DE,B78FB        ; Zeiger auf 256   (Real - Konstante)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,B7900        ; Zeiger auf  0.50001   (Real - Konstante)
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        CALL    A7BEA           ; Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
        LD      A,L             ; Low - Byte Aspekt - Wert holen
        LD      (D782E + 2),A   ; und in Parameterroutine eintragen
        BIT     0,H             ; High - Byte Aspekt - Wert gleich Null  ?
        RET     Z               ; ja
        XOR     A               ; Code 'Kreis zeichnen'
        LD      (D782E + 1),A   ; Verh√§ltnisflag wieder l√∂schen   (Aspekt zu gro√ü)
        RET
;
;
;   X- und Y- Offset auf Punkt aus Radius, Aspekt und Winkel errechnen
;
A788E:  PUSH    IX              ; Zeiger auf Speicher f√ºr Offsets auf Punkt merken
        PUSH    IY              ; Zeiger auf Speicher f√ºr Winkel merken
        CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
        POP     DE              ; Zeiger auf Speicher f√ºr Winkel holen
        POP     IX              ; Zeiger auf Speicher f√ºr Offsets auf Punkt holen
        PUSH    HL              ; Programmzeiger retten
        PUSH    IX              ; Zeiger auf Speicher f√ºr Offset auf Punkt wieder merken
        LD      HL,(S107C)      ; Zeiger auf Anfang Rechenspeicher holen
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        LD      HL,(S107C)      ; Zeiger auf Anfang Rechenspeicher holen
        LD      D,H             ;! nach DE √ºbertragen
        LD      E,L             ;!
        INC     DE              ;! Zeiger auf n√§chsten Rechenspeicher
        INC     DE              ;! bereitstellen
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        CALL    A96F9           ; COS - Funktion aufrufen   ( COS( (HL) ) )
        LD      DE,S78F1        ; Zeiger auf Speicher mit Real-Radius
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        CALL    A78D0           ; Ergebnis umsetzen in Integer und in Parameterroutine eintr.
        LD      HL,(S107C)      ; Zeiger auf Anfang Rechenspeicher holen
        CALL    A9709           ; SIN - Funktion aufrufen   ( SIN( (HL) ) )
        LD      DE,S78F1        ; Zeiger auf Speicher f√ºr Real-Radius
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        CALL    A90A6           ; Vorzeichen des Wertes (HL) umkehren
        CALL    A78D0           ; Ergebnis umsetzen in Integer und in Parameterroutine eintr.
        POP     IX              ; Zeiger auf Speicher f√ºr Offset verwerfen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   bereitgestelltes Ergebnis umsetzen in Integer und in Parameterroutine eintr.
;
A78D0:  INC     HL              ; Zeiger auf MSByte Mantisse stellen
        BIT     7,(HL)          ; Vorzeichen des Wertes abfragen
        PUSH    AF              ; Vorzeichen retten
        RES     7,(HL)          ; Wert auf plus
        DEC     HL              ; Zeiger wieder auf Exponenten
        LD      DE,B7900        ; Zeiger auf  0.50001   (Real - Konstante)
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        POP     AF              ; Vorzeichen des Wertes holen
        INC     HL              ; Zeiger auf MSByte Mantisse
        JR      Z,A78E3         ; alter Wert war positiv
        SET     7,(HL)          ; Vorzeichen auf Minus
A78E3:  DEC     HL              ; Zeiger wieder auf Exponenten
        CALL    A7BEA           ; Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
        EX      DE,HL           ; bereitgestellten Zahlwert nach DE
        POP     HL              ; R√ºcksprungadresse holen
        EX      (SP),HL         ; mit Zeiger auf Stelle f√ºr Offsett vertauschen
        LD      (HL),E          ;! Offset in Parameterroutine eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL              ;! Zeiger auf Stelle f√ºr n√§chsten Offset
        INC     HL              ;!
        EX      (SP),HL         ; Zeiger f√ºr Offset retten / R√ºcksprungadresse holen
        JP      (HL)            ; RETurn ausf√ºhren
;
;
;   Speicher unf Konstanten f√ºr CIRCLE - Routine
;
S78F1:  DEFS    5                       ; Speicher f√ºr Real-Radius
;
S78F6:  DEFS    5                       ; Zwischenspeicher f√ºr Routine
;
B78FB:  DEFB    089H                    ; Exponent   256
        DEFB    000H,000H,000H,000H     ; Mantisse   256
;
B7900:  DEFB    080H                    ; Exponent   0.50001
        DEFB    000H,000H,0A7H,0C6H     ; Mantisse   0.50001
;
S7905:  DEFS    1                       ; Exponent Startwinkel
S7906:  DEFS    4                       ; Mantisse Startwinkel
;
S790A:  DEFS    1                       ; Exponent Endwinkel
S790B:  DEFS    4                       ; Mantisse Endwinkel
;
;
;   Basic - Befehl   SYMBOL     (Zwischencode 254 160 / 0FEH 0A0H)
;
A790F:  CALL    A75FB           ; auf Farbangabe untersuchen und X,Y-Graphic-Koord. bereitst.
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    71              ; Code 71   Graphic-Cursor auf Koordinate in DE',HL' setzen
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        LD      A,B             ; Anzahl Zeichen String holen
        OR      A               ; gleich Null  ?
        PUSH    BC              ; Anzahl Zeichen retten
        PUSH    HL              ; Programmzeiger retten
        LD      C,B             ; Anzahl Zeichen
        LD      B,0             ; High - Byte Anzahl auf Null
        LD      HL,S27D0        ; Zeiger auf Speicher f√ºr String
        EX      DE,HL           ; Zeiger vertauschen
        JR      Z,A7929         ; Stringl√§nge gleich Null
        LDIR                    ; String im Speicher retten
A7929:  POP     HL              ; geretteten Programmzeiger holen
A792A:
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A853D           ; ein - Byte - Wert nach DE/Accu bereitstellen
        LD      A,D             ;! Vergr√∂√üerung in X - Achse gleich Null  ?
        OR      E               ;!
        JR      Z,A793D         ; ja -->  Fehler 3   Illegal data error
        PUSH    DE              ; Vergr√∂√üerung in X - Achse retten  (horizontale Vergr√∂√üerung)
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A853D           ; ein - Byte - Wert nach DE/Accu bereitstellen
        LD      A,D             ;! Vergr√∂√üerung in Y - Achse gleich Null  ?
        OR      E               ;!
A793D:  JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        LD      A,E             ; Vergr√∂√üerung in Y-Achse  (steht schon im Accu)
        POP     DE              ; gerettete X - Vergr√∂√üerung holen
        LD      D,A             ; Y - Vergr√∂√üerung eintragen  (vertikale Vergr√∂√üerung)
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        PUSH    DE              ; Vergr√∂√üerungen retten
        JR      Z,A7957         ; keine Richtung angegeben
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A853D           ; ein - Byte - Wert nach DE/Accu bereitstellen
        LD      A,3             ; maximalen Richtungswert vorgeben
        CP      E               ; mit angegebenem Richtungswert vergleichen
        JP      C,A636A         ; zu gro√ü -->  Fehler 3   Illegal data error
        LD      A,E             ; Richtungswert holen
        DEFB    LD_B            ; Vorgabe f√ºr 'Keine Richtung angegeben' √ºberspringen
A7957:  XOR     A               ; Richtung in X-Achse vorgeben
        POP     DE              ; Vergr√∂√üerung in X- und Y-Achse holen
        POP     BC              ; Anzahl Zeichen der Zeichenkette holen
        LD      C,A             ; Richtung merken
        LD      A,B             ; Anzahl Zeichen holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  fertig
        LD      A,C             ; Richtung holen
        PUSH    HL              ; Programmzeiger retten
        EX      DE,HL           ; Vergr√∂√üerungen nach HL
        LD      DE,S27D0        ; Zeiger auf Speicher mit Text vorgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    87              ; Code 87  Text mit Vergr√∂√üerung ausgeben
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   HCOPY     (Zwischencode 254 156 / 0FEH 09CH)
;
A7968:  CALL    A797A           ; auf Syntax Befehlsende √ºberpr√ºfen
        PUSH    HL              ; Programmzeiger retten
        LD      A,0             ; Code for 'Bildschirm null'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    79              ; Code 79   Bildschirminhalt auf Graphic-Drucker ausgeben
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   CLS     (Zwischencode 155 / 09BH
;
A7972:  CALL    A797A           ; auf Syntax Befehlsende √ºberpr√ºfen
        PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    69              ; Code 69   Bildschirm l√∂schen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Programm (HL) auf Syntax Befehlsende √ºberpr√ºfen
;
A797A:  CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        RET     Z               ; Befehlsende -->  Syntax ist OK
        JP      A6364           ; Fehler 1  Syntax error
;
;
;   auf /P untersuchen und Ausgaberoutinen entsprechend umstellen
;
A7981:  XOR     A               ; Code for 'Ausgabe auf Bildschirm'
        LD      (S1091),A       ; Ausgabeflag  CRT/LPT  setzen
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFB    ___DIV          ; /   (Zwischencode)  ?
        RET     NZ              ; nein
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFM    "P"             ; P   (Printer)  ?
        ;CALL    AA007           ; Drucker auf Textmodus √ºberpr√ºfen
		CALL    AA009           ; Drucker auf Textmodus √ºberpr√ºfen
        LD      A,'P'           ; Code for 'Ausgabe auf Drucker'
        LD      (S1091),A       ; Ausgabeflag  CRT/LPT  setzen
        CP      A               ; Zero - Flag setzen
        RET
;
;
;   Hex - Wert in HL umsetzen in Dezimal - ASCII nach Zwischenspeicher
;
A7998:  LD      DE,S9E6A        ; Zeiger auf Zwischenspeicher vorgeben
        LD      B,0             ; Code for 'Vornullen unterdr√ºcken'
        PUSH    DE              ; Zeiger auf Anfang Zwischenspeicher retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    22              ; Code 22   Hex-Wert in HL umsetzen in Dezimal-ASCII nach (DE)
        POP     DE              ; Zeiger auf aufbreiteten Text holen
        RET
;
;
;   auf Syntax  'Klammer auf'  √ºberpr√ºfen
;
A79A2:  INC     HL              ; ausgewertetes Zeichen √ºberspringen
A79A3:  CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
A79A6:  CP      '('             ; n√§chstes Zeichen gleich 'Klammer auf'  ?
        JR      A79B6           ; Syntax√ºberpr√ºfung auswerten
;
;
;   auf Syntax 'Klammer zu' √ºberpr√ºfen
;
A79AA:  CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
A79AD:  CP      ')'             ; n√§chstes Zeichen gleich 'Klammer zu'  ?
        JR      A79B6           ; Syntax√ºberpr√ºfung auswerten
;
;
;   auf Syntax  'Komma'  untersuchen
;
A79B1:  CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
A79B4:  CP      ','             ; n√§chstes Zeichen gleich Komma  ?
A79B6:  INC     HL              ; Syntax - Zeichen √ºberspringen
        RET     Z               ; Syntax ist OK
        JP      A6364           ; Fehler 1  Syntax error
;
;
;   Zeiger in DE auf n√§chstes relevantes Zeichen setzen
;
A79BB:  INC     DE              ; Textzeichen √ºberspringen
A79BC:  LD      A,(DE)          ; ein Zeichen Text holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A79BB         ; ja -->  relevantes Zeichen suchen
        RET
;
;
;   +1 im Real - Format nach (DE) √ºbertragen
;
A79C2:  LD      HL,B7C45        ; Zeiger auf +1  (Real - Format)
;
;
;   Real - Zahlwert von (HL) nach (DE) √ºbertragen
;
A79C5:  LD      BC,5            ; L√§nge der Zahl im internen Real - Format
        LDIR                    ; Zahlwert von (HL) nach (DE) √ºbertragen
        RET
;
;
;   Integer - Wert in (DE) umsetzen in Real - Wert nach (HL)
;
A79CB:  CALL    A909E           ; Null im Real - Format nach (HL) eintragen
        LD      A,E             ;! Wert gleich NUll  ?
        OR      D               ;!
        RET     Z               ; ja -->  fertig
        BIT     7,D             ; Wert negativ  ?
        LD      A,01111111B     ; Maske f√ºr MSB positive Zahl vorgeben
        JR      Z,A79E0         ; Zahl  positiv
        LD      A,D             ;! Wert in DE negieren
        CPL                     ;!
        LD      D,A             ;!
        LD      A,E             ;!
        CPL                     ;!
        LD      E,A             ;!
        INC     DE              ;!
        LD      A,11111111B     ; Maske f√ºr MSB negative Zahl vorgeben
A79E0:  LD      B,091H          ; Vorgabe f√ºr Exponent
A79E2:  DEC     B               ; Exponent minus eins
        BIT     7,D             ; 1tes Bit Mantisse gesetzt  ?
        JR      NZ,A79ED        ; ja -->  internes Format stimmt
        RL      E               ;! Mantisse mal zwei
        RL      D               ;!
        JR      A79E2           ; √ºberpr√ºfen, ob internes Format stimmt
;
A79ED:  LD      (HL),B          ; Exponenten eintragen
        INC     HL              ; eingetragenen Exponenten √ºberspringen
        AND     D               ; Vorzeichen setzen
        LD      (HL),A          ; MSByte Mantisse eintragen
        INC     HL              ; Byte √ºberspringen
        LD      (HL),E          ; zweites Byte Mantisse eintragen
        DEC     HL              ;! Zeiger wieder auf Exponenten
        DEC     HL              ;!
        RET
;
;
;   testen, ob ASCII - Zeichen im Accu gleic Ziffer ist   (nein -->  Carry)
;
A79F6:  CP      '0'             ; Anfang Ziffern
        RET     C               ; keine Ziffer
        CP      '9' + 1         ; Ende Ziffern 
        CCF                     ; Ergebnisflag umkehren
        RET
;
;
;  untersuchen, ob Zeichen im Accu gleich Variablennamenzeichen ist
;
A79FD:  CP      '_'             ; Pfeil links im Sharp - Zeichensatz  ?
        RET     Z               ; ja -->  OK  
        CP      '0'             ; Anfang Ziffern
        RET     C               ; kein g√ºltiges Zeichen
        CP      'Z' + 1         ; Ende Buchstaben
        CCF                     ; ergebnisflag umkehren
        RET     C               ; kein g√ºltiges Zeichen
        CP      '9' + 1         ; Ende Ziffern
        CCF                     ; Ergebnis umkehren
        RET     NC              ; Zeichen ist g√ºltig
        CP      'A'             ; Anfang Buchstaben
        RET
;
;
;   ASCII - Text (DE) umsetzen in Real - Wert nach (HL)
;
A7A0E:  CALL    A909E           ; Null im Real - Format nach (HL) eintragen
        LD      (S7E34),A       ; Anzahl Stellen zur√ºcksetzen
        LD      (S7E35),A       ; Flag 'Stellen angegeben' zur√ºcksetzen
        LD      (S7E36),A       ; Flag  'Real - Wert' zur√ºcksetzen
        LD      (D7AB5 + 1),A   ; Dezimalpunkt - Flag zur√ºcksetzen
        LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
A7A22:  CALL    A79BC           ; Zeiger in DE auf n√§chstes relevantes Zeichen
        INC     DE              ; Zeichen √ºberspringen
        CP      '+'             ; Vorzeichen plus  ?
        JR      Z,A7A22         ; ja -->  vergessen
        CP      '-'             ; Vorzeichen minus  ?
        JR      NZ,A7A34        ; nein -->  weiter untersuchen
        CALL    A7A22           ; ASCII-Text (DE) umsetzen in Real - Wert
        JP      A90A9           ; Vorzeichen des Wertes (HL) umkehren
;
A7A34:  CP      '$'             ; Kennung  Hex - Wert  ?
        JR      NZ,A7A44        ; nein -->  weiter untersuchen
        PUSH    HL              ; Zeiger auf Stelle f√ºr Zahl merken
        EX      DE,HL           ; Zeiger auf Text nach HL
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    20              ; Code 20   Sedezimal-Wert  (HL) umsetzen in Hex-Wert nach DE
        EX      (SP),HL         ; Programmzeiger retten / Zeiger f√ºr Zahlwert holen
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        POP     DE              ; geretteten Programmzeiger holen
        LD      A,5             ; Code for 'Real - Wert'
        RET
;
A7A44:  CP      '0'             ; Vornull  ?
        JR      NZ,A7A4E        ; nein -->  weiter untersuchen
        LD      A,(DE)          ; n√§chstes Zeichen holen
        INC     DE              ; Zeichen √ºberspringen
        JR      A7A44           ; untersuchen, ob Vornull
;
A7A4C:  LD      A,(DE)          ; n√§chstes Textzeichen holen
        INC     DE              ; Zeichen √ºberspringen
A7A4E:  CP      ' '             ; Leerzeichen  ?
        JR      Z,A7A4C         ; ja -->  n√§chstes Zeichen holen
        CP      '.'             ; Dezimalpunkt  ?
        JR      Z,A7A71         ; ja -->  'Dezimalpunkt gefunden'  merken
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        JR      C,A7AAB         ; keine Ziffer -->  testen, ob Exponent
        SUB     '0'             ; ASCII - Zeichen umsetzen in Dezimal-Ziffer
        CALL    A7BDD           ; altes Teilergebnis mal 10
        CALL    A7B47           ; Wert der neuen Stelle addieren   (Wert im Accu)
        LD      A,1             ; Code 'Stelle angegeben'
        LD      (S7E35),A       ; im Flag 'Stellen angegeben' merken
        LD      A,(S7E34)       ; Anzahl Stellen holen
        INC     A               ; plus eins 
        LD      (S7E34),A       ; und wieder merken
        JR      A7A4C           ; n√§chstes Zeichen untersuchen
;
A7A71:  LD      A,1             ; Code for 'Dezimalpunkt angegeben'
        LD      (D7AB5 + 1),A   ; im Dezimalpunkt - Flag merken
        LD      C,A             ; Vorgabe f√ºr Z√§hler  'Anzahl Nachkommastellen'
A7A77:  LD      A,(DE)          ; ein Textzeichen holen
        INC     DE              ; Zeiger auf Text n√§chstes Zeichen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A7A77         ; ja -->  n√§chstes relevantes Zeichen suchen
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        JR      C,A7AA3         ; nein -->  Exponent f√ºr Nachkommastellen corrigieren
        INC     C               ; Anzahl Nachkommastellen plus eins
        SUB     '0'             ; ASCII - Zeichen umsetzen in Dezimal - Ziifer
        JR      Z,A7A8E         ; Null -->  Stelle nicht als angegebene Stelle merken
        PUSH    AF              ; Wert der Stelle retten
        LD      A,1             ; Code for 'Stellen angegeben'
        LD      (S7E35),A       ; im Flag 'Stellen angegeben' merken
        POP     AF              ; Wert der Stelle holen
A7A8E:  PUSH    AF              ; Wert der Stelle retten
        LD      A,(S7E35)       ; Flag 'Stellen angegeben' holen
        LD      B,A             ; und merken
        LD      A,(S7E34)       ; Anzahl Stellen holen
        ADD     A,B             ; plus Flag  `Stellen angegeben'   (0 oder 1)
        LD      (S7E34),A       ; neue Anzahl Stellen merken
        POP     AF              ; geretteten Wert der Stelle holen
        CALL    A7BDD           ; altes Teilergebnis mal 10
        CALL    A7B47           ; Wert der neuen Stelle addieren   (Wert im Accu)
        JR      A7A77           ; n√§chstes Textzeichen untersuchen
;
A7AA3:  DEC     C               ; Z√§hler 'Anzahl Nachkommastellen' minus iens
        JR      Z,A7AAB         ; Exponent corrigiert   (Zahlwert stimmt)
        CALL    A7B31           ; Real - Zahlwert (HL) durch zehn
        JR      A7AA3           ; √ºberpr√ºfen, ob Zahlwert stimmt
;
A7AAB:  CP      'E'             ; Exponenten - Kennung  ?
        JR      Z,A7ABC         ; ja -->  angegebenen Exponenten auswerten
A7AAF:  DEC     DE              ; Zeiger auf ASCII - Text wieder corrigieren
        LD      A,(S7E36)       ; Flag  'Real - Wert' holen
        OR      A               ; Real - Wert  ?
        RET     NZ              ; ja
D7AB5:  LD      A,0             ; Dezimalpunkt - Flag holen   (wird eingetragen)
        OR      A               ; Dezimalpunkt angegeben  ?
        RET     NZ              ; ja
        LD      A,5             ; Code for 'Real - Wert'
        RET
;
;
;   angegebenen Dezimal - Exponenten des Zahlwertes auswerten
;
A7ABC:  LD      A,(DE)          ; n√§chstes Textzeichen holen
        CP      '-'             ; Vorzeichen minus  ?
        JR      Z,A7ACA         ; ja -->  Vorzeichen f√ºr Exponenten angegeben
        CP      '+'             ; Vorzeichen plus  ?
        JR      Z,A7ACA         ; ja -->  Vorzeichen f√ºr Exponenten angegeben
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        JR      C,A7AAF         ; keine Ziffer -->  kein Exponent -->  Zahl umgesetzt
A7ACA:  LD      A,1             ; Code for 'Real - Wert'
        LD      (D7AB5 + 1),A   ; im Dezimalpunkt - Flag merken
        PUSH    HL              ; Zeiegr auf bisher bereitgestellten Zahlwert merken
        LD      HL,A92EA        ; Adresse  der  *  - Routine
        LD      (D7B29 + 1),HL  ; in Routine eintragen
        LD      HL,0            ; Vorgabe f√ºr Z√§hler Exponent
        LD      A,(DE)          ; Textzeichen holen
        INC     DE              ; Textzeichen √ºberspringen
        CP      '+'             ; Vorzeichen plus  ?
        JR      Z,A7AEB         ; ja -->  vergessen
        CP      '-'             ; Vorzeichen minus  ?
        JR      NZ,A7AED        ; nein -->  Ziffer auswerten
A7AE4:
        PUSH    HL              ; Exponentenz√§hler retten
        LD      HL,A93D5        ; Adresse der / - Routine
        LD      (D7B29 + 1),HL  ; in Routine eintragen
        POP     HL              ; geretteten Z√§hler wieder holen
A7AEB:  LD      A,(DE)          ; ein Textzeichen holen
        INC     DE              ; Textzeichen √ºberspringen
A7AED:  SUB     '0'             ; ASCII-Zeichen umsetzen in Dezimal - Wert
        JR      C,A7B0D         ; keine Ziffer -->  Exponent ausgewertet
        CP      10              ; mit Anzahl Ziffern vergleichen
        JR      NC,A7B0D        ; keine Ziffer -->  Exponent ausgewertet
        PUSH    DE              ; Zeiger auf Resttext retten
        CALL    A7B42           ; HL * 2 mit Untersuchung auf √úbertrag   (Exp. * 2)
        LD      E,L             ;! Zwischenergebnis duplizieren
        LD      D,H             ;!
        CALL    A7B42           ; HL * 2 mit Untersuchung auf √úbertrag   (Exp. * 4)
        CALL    A7B42           ; HL * 2 mit Untersuchung auf √úbertrag   (Exp. * 8)
        CALL    A7B3E           ; HL + DE mit Untersuchung auf √úbertrag  (Exp. * 10)
        LD      E,A             ; Wert der neuen Stelle
        LD      D,0             ; High - Byte Wert auf Null
        CALL    A7B3E           ; HL + DE mit Untersuchung auf √úbertrag
        POP     DE              ; Zeiger auf Resttext wieder holen
        JR      A7AEB           ; Rest des angegebenen Exponenten auswerten
;
A7B0D:  LD      A,H             ; High - Byte Exponent holen
        OR      A               ; gleich Null  ?
        JR      NZ,A7B44        ; nein -->  zu gro√ü -->  Fehler 2  Overflow error
        LD      A,L             ; Low - Byte Exponent holen
        POP     HL              ; Zeiger auf bereitgestellte Mantisse holen
        PUSH    DE              ; Zeiger auf Resttext retten
        PUSH    BC              ; Register - Wert retten
        PUSH    HL              ; Zeiger auf bereitgestellte Mantisse retten
        LD      DE,S9E9D        ; Zeiger auf Zwischenspeicher f√ºr Berechnung
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        CALL    A79C2           ; +1 im Real - Format nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Zahlwert +1 im Speicher
        LD      B,A             ; angegebenen Exponenten merken
        INC     B               ; f√ºr Schleife corrigieren
        JR      A7B25           ; Correcturfaktor f√ºr Mantissenwert errechnen
;
A7B22:  CALL    A7BDD           ; altes Teilergebnis mal 10
A7B25:  DJNZ    A7B22           ; richtigen Correcturfaktor errechnen
        EX      DE,HL           ; Zeiger auf Correcturfaktor nach DE
        POP     HL              ; Zeiger auf ZAhlwert der Mantisse holen
D7B29:  CALL    0               ; Wert corrigieren  (* oder /  Correcturfaktor)
        POP     BC              ; geretteten Register - Wert holen
        POP     DE              ; Zeiger auf Resttext holen
        JP      A7AAF           ; Typ des bereitgestellten Zahlwertes auswerten
;
;
;   Real - Zahlwert (HL) durch zehn
;
A7B31:  PUSH    AF              ;! Register - Werte retten
        PUSH    BC              ;!
        PUSH    DE              ;!
        LD      DE,B7C40        ; Zeiger auf  + 10  (Real - Format)
        CALL    A93D5           ; /  - Routine   ( (HL) = (HL) / (DE) )
        POP     DE              ;! gerettete Register - Werte holen
        POP     BC              ;!
        POP     AF              ;!
        RET
;
;
;   HL = HL + DE  mit Untersuchung auf √úberlauf
;
A7B3E:  ADD     HL,DE           ; Zahlen addieren
        RET     NC              ; Ergebnis ist OK
        JR      A7B44           ; zu gro√ü -->  Fehler 2  Overflow error
;
;
;   HL = HL + HL  mit Untersuchung auf √úberlauf 
;
A7B42:  ADD     HL,HL           ; Zahlen addieren
        RET     NC              ; Ergebnis ist OK
A7B44:  JP      A6367           ; zu gro√ü -->  Fehler 2  Overflow error
;
;
;   Wert der neuen Stelle addieren   (Wert im Accu)
;
A7B47:  PUSH    DE              ; Register - Wert retten
        PUSH    HL              ; Zeiger auf Real - Zahlwert merken
        LD      HL,S9E9D        ; Zeiger auf Zwischenspeicher f√ºr Berechnung
        LD      E,A             ; Dezimal - Ziffer
        LD      D,0             ; High - Byte Wert auf Null
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        EX      DE,HL           ; Zeiger auf umgesetzten Real-Wert nach DE
        POP     HL              ; Zeiger auf Zahl holen
        PUSH    BC              ; Register - Wert retten
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) ) 
        POP     BC              ;! gerettete Register - Werte wieder holen
        POP     DE              ;!
        RET
;
;
;   Real - Zahlwert  (HL)  umsetzen in ASCII nach Zwischenspeicher
;
A7B5B:  LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        LD      A,(HL)          ; Exponenten der Zahl holen
        OR      A               ; gleich Null  ?
        JR      Z,A7B68         ; ja -->  Zahl gleich Null
        INC     HL              ; Zeiger auf MSByte der Mantisse
        LD      A,(HL)          ; MSByte der Mantisse holen
        DEC     HL              ; Zeiger auf Zahl wieder auf Exponenten
        RLCA                    ; Vorzeichen nach Carry - Flag schieben
A7B68:  LD      A,' '           ; Leerzeichen  (Space) bei positiver Zahl
        JR      NC,A7B71        ; Zahl ist positiv
        CALL    A90A9           ; Vorzeichen des Wertes (HL) umkehren
        LD      A,'-'           ; Vorzeichen minus f√ºr negative Zahl
A7B71:  PUSH    AF              ; Vorzeichen retten
        CALL    A7CE0           ; Zahl aufbereiten in ASCII, wenn ohne Exponent m√∂glich
        CALL    A7D6D           ; Rest der Zahl aufbereiten in ASCII
        POP     AF              ; Vorzeichen holen
        DEC     DE              ; Zeiger auf ASCII-Text auf Stelle f√ºr Vorzeichen
        LD      (DE),A          ; Vorzeichen eintragen
        RET             
;
;
;   Real - Zahlen (HL) und (DE) vergleichen    (BC - Register - Wert retten)
;
A7B7C:  PUSH    BC              ; Register - Wert retten
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Nachkommastellen des Real - Zahlwertes (HL) vergessen
;
A7B82:  CALL    A00C7           ; Register IX, HL, BC und DE retten
        LD      A,(HL)          ; Exponenten der Zahl holen
        CP      081H            ; Zahl mit Vorkommastellen
        JP      C,A909E         ; nein -->  Null im Real - Format nach (HL) eintragen
        LD      A,(HL)          ; Exponenten der Zahl holen
        CP      0A0H            ; Zahl mit Nachkommastellen
        RET     NC              ; nein -->  fertig
        INC     HL              ; Zeiger auf Mantisse stellen
        CALL    A7BB9           ; drei Byte der Mantisse aus Speicher (HL) nach Register laden
        PUSH    HL              ; Zeiger auf Ende der Mantissen merken
        LD      L,(HL)          ; letztes Byte der Mantisse laden
        LD      B,0             ; Z√§hler 'wie oft geschoben' auf Null
A7B97:  SRL     E               ;! Mantisse um ein Bit schieben
        RR      D               ;! (ein Bit vergessen)
        RR      C               ;!
        RR      L               ;!
        INC     A               ; Exponenten plus eins
        INC     B               ; Z√§hler 'wie oft geschoben' plus eins
        CP      0A0H            ; Exponent f√ºr Zahl ohne Nachkommastellen  ?
        JR      NZ,A7B97        ; nein -->  weiter schieben und vergessen
A7BA5:  SLA     L               ;! Mantisse wieder auf richtige Wertigkeit
        RL      C               ;! schieben
        RL      D               ;!
        RL      E               ;!
        DJNZ    A7BA5           ;!   weiter schieben
        LD      A,L             ; letztes Byte der Mantisse holen
        POP     HL              ; Zeiger auf Stelle f√ºr letztes Byte Mantisse holen
        LD      (HL),A          ;! Mantisse wieder in Speicher eintragen
        DEC     HL              ;!
        LD      (HL),C          ;!
        DEC     HL              ;!
        LD      (HL),D          ;!
        DEC     HL              ;!
        LD      (HL),E          ;!
        RET
;
;
;   drei Byte aus Speicher (HL) nach Register laden
;
A7BB9:  LD      E,(HL)          ;! Bytes aus Speicher nach Register laden
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL              ;!
        LD      C,(HL)          ;!
        INC     HL              ;!
        RET
;
;
;   Basic - Funktion   FRAC     (Zwischencode  255 141 / 0FFH 08DH)
;   (Nachkommastellen des Real - Zahlwertes (HL) errechnen)
;
A7BC0:  LD      A,(HL)          ; Exponenten der Zahl holen
        CP      081H            ; Betrag der Zahl gr√∂√üer eins  ?
        RET     C               ; nein -->  Zahl hat keine Vorkommastellen -->  fertig
        PUSH    DE              ; Register - Wert retten
        PUSH    HL              ; Zeiger auf Zahlwert retten
        LD      DE,S7BD8        ; Zeiger auf Zwischenspeicher f√ºr Routine
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Anfang Speicher holen
        CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        EX      DE,HL           ; Zeiger auf Zahl ohne Nachkommastellen nach DE
        POP     HL              ; Zeiger auf Originalwert holen
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     DE              ; geretteten Register - Wert holen
        RET
;
S7BD8:  DEFS    5               ; Zwischenspeicher f√ºr FRAC - Routine
;
;
;   Real - Zahlwert (HL) mal zehn
;
A7BDD:  PUSH    AF              ;! Register - Werte retten
        PUSH    BC              ;!
        PUSH    DE              ;!
        LD      DE,B7C40        ; Zeiger auf  + 10  (Real - Format)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     DE              ;! gerettete Register - Werte holen
        POP     BC              ;!
        POP     AF              ;!
        RET
;
;       
;   vorzeichenbehafteten Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
;
A7BEA:  INC     HL              ; Zeiger auf umzusetzende Zahl auf Mantisse stellen
        BIT     7,(HL)          ; Zahl positiv  ?
        JR      Z,A7BFA         ; ja -->  Zahl umsetzen in Integer - Wert
        CALL    A7BFA           ; Betrag der Zahl (HL) umsetzen in Integer nach HL
        LD      A,H             ;! 2er Complement des Zahlwertes in HL bilden
        CPL                     ;!
        LD      H,A             ;!
        LD      A,L             ;!
        CPL                     ;!
        LD      L,A             ;!
        INC     HL              ;!
        RET
;
A7BFA:  DEC     HL              ; Zeiger wieder auf Exponent
        LD      A,(HL)          ; Exponenten der Zahl holen
        CP      091H            ; mit gr√∂√ütem umsetzbarem Exponenten vergleichen
        JP      NC,A6367        ; Zahl zu gro√ü -->  Fehler 2  Overflow error
        CP      081H            ; kleinster Exponent mit Vorkommastellen  ?
        JR      C,A7C18         ; Zahl hat keine Vorkommastellen -->  Ergebnis gleich 0
        PUSH    AF              ; Exponenten retten
        INC     HL              ; Zeiger auf Zahl auf Mantisse
        LD      A,(HL)          ;! die zwei h√∂chstwertigen Bytes der
        INC     HL              ;! Mantisse laden
        LD      L,(HL)          ;!
        LD      H,A             ;!
        POP     AF              ; geretteten Exponenten wieder holen
        SET     7,H             ; erstes Bit der Mantisse setzen   (Vorzeichen - Bit)
A7C0E:  CP      090H            ; normierter Exponent  ?
        RET     Z               ; ja -->  Wert in HL stimmt
        INC     A               ; Z√§hler f√ºr Exponenten plus eins
        SRL     H               ;! Mantisse durch zwei
        RR      L               ;!
        JR      A7C0E           ; testen, ob Wert stimmt
;
A7C18:  CCF                     ; Carry - Flag zur√ºcksetzen   (Code 'kein Fehler'
        LD      HL,0            ; Null als Ergebnis vorgeben
        RET
;
;
;   Konstanten f√ºr die Zahlumsetzroutinen
;
B7C1D:  DEFB    09BH                    ; Exponent   .1E+09
        DEFB    03EH,0BCH,020H,000H     ; Mantisse   .1E+09
;
B7C22:  DEFB    098H                    ; Exponent   10000000
        DEFB    018H,096H,080H,000H     ; Mantisse   10000000
;
        DEFB    094H                    ; Exponent   1000000
        DEFB    074H,024H,000H,000H     ; Mantisse   1000000
;
        DEFB    091H                    ; Exponent   100000
        DEFB    043H,050H,000H,000H     ; Mantisse   100000
;
        DEFB    08EH                    ; Exponent   10000
        DEFB    01CH,040H,000H,000H     ; Mantisse   10000
;
        DEFB    08AH                    ; Exponent   1000
        DEFB    07AH,000H,000H,000H     ; Mantisse   1000
;
        DEFB    087H                    ; Exponent   100
        DEFB    048H,000H,000H,000H     ; Mantisse   100
;
B7C40:  DEFB    084H                    ; Exponent   10
        DEFB    020H,000H,000H,000H     ; Mantisse   10
;
B7C45:  DEFB    081H                    ; Exponent   1
        DEFB    000H,000H,000H,000H     ; Mantisse   1
;
        DEFB    07DH                    ; Exponent   .1
        DEFB    04CH,0CCH,0CCH,0CDH     ; Mantisse   .1
;
B7C4F:  DEFB    066H                    ; Exponent   .1E-07
        DEFB    02BH,0CCH,077H,012H     ; Mantisse   .1E-07
;
;
;   Real - Zahlwert umsetzen in ASCII mit Exponentialdarstellung
;
A7C54:  LD      HL,(S7E37)      ; Zeiger auf Real - Zahlwert holen
        LD      B,0             ; Vorgabe f√ºr Exponenten
A7C59:  LD      DE,B7C40        ; Zeiger auf  + 10  (Real - Format)
        CALL    A7B7C           ; Real-Zahlen (HL) und (DE) vergleichen (BC-Register retten)
        JR      C,A7C67         ; Zahl (HL) ist kleiner als 10
        CALL    A7B31           ; Real - Zahlwert (HL) durch zehn
        INC     B               ; Exponentenz√§hler plus eins
        JR      A7C59           ; √ºberpr√ºfen, ob Zahl (HL) kleiner 10 ist
;
A7C67:  LD      DE,B7C45        ; Zeiger auf +1  (Real - Format)
        CALL    A7B7C           ; Real-Zahlen (HL) und (DE) vergleichen (BC-Register retten)
        JR      NC,A7C75        ; Zahl (HL) ist gr√∂√üer gleich +1
        CALL    A7BDD           ; Real - Zahlwert (HL) mal 10
        DEC     B               ; Exponentenz√§hler minus eins
        JR      A7C67           ; √ºberpr√ºfen, ob Zahl (HL) gr√∂√üer gleich eins ist
;
A7C75:  PUSH    BC              ; Exponentenz√§hler retten
        CALL    A7CE0           ; Zahl aufbereiten in ASCII, wenn ohne Exponent m√∂glich
        CALL    A7D6D           ; Rest der Zahl aufbereiten in ASCII
        POP     BC              ; geretteten Exponentenz√§hler holen
        PUSH    DE              ; Zeiger auf Anfang ASCII-Zahlwert retten
        EX      DE,HL           ; Zeiger auf Zahl nach HL
A7C7F:  LD      A,(HL)          ; ein Zeichen Zahl holen
        OR      A               ; Ende Zahlwert  ?
        JR      Z,A7C86         ; ja
        INC     HL              ; Zeiger auf Zahltext auf n√§chste Stelle
        JR      A7C7F           ; Ende Zahltext suchen
;
A7C86:  DEC     HL              ; Zeiger auf letzte Stelle der Zahl
        LD      A,(HL)          ; ASCII - Stelle holen
        INC     HL              ; Zeiger wieder auf Ende Zahl
        CP      '0'             ; Null  ?
        JR      NZ,A7C8F        ; nein -->  relevante Stelle
        INC     B               ; Exponentenz√§hler plus eins
        DEC     HL              ; Zeiger wieder auf Null
A7C8F:  LD      A,'E'           ; Code for 'Exponent'
        LD      (HL),A          ; hinter Zahlwert Mantisse eintragen
        INC     HL              ; Exponentenzeichen √ºberspringen
        LD      A,B             ; Exponentenz√§hler holen
        LD      B,'+'           ; Vorgabe f√ºr Vorzeichen Exponent
        BIT     7,A             ; Z√§hler positiv  ?
        JR      Z,A7C9E         ; Exponent positiv
        NEG                     ; 2er Complement des Z√§hlers bilden
        LD      B,'-'           ; richtiges Vorzeichen vorgeben
A7C9E:  LD      (HL),B          ; Vorzeichen des Exponenten eintragen
        INC     HL              ; Vorzeichen √ºberspringen
        LD      (HL),'0'        ; erste Stelle Exponent vorgeben
A7CA2:  SUB     10              ; ein mal Wertigkeit der Stelle abziehen
        JR      C,A7CA9         ; schon zu klein
        INC     (HL)            ; 10er Stelle plus eins
        JR      A7CA2           ; weiter untersuchen
;
A7CA9:  ADD     A,'9' + 1       ; 1er Stelle Exponent umsetzen in ASCII
        INC     HL              ; 10er Stelle √ºberspringen
        LD      (HL),A          ; 1er Stelle des Exponenten eintragen
        INC     HL              ; 1er Stelle des Exponenten √ºberspringen
        LD      (HL),NUL        ; Code for 'Textende'  eintragen
        POP     DE              ; Zeiger auf Anfang Zahltext holen
        RET
;
;
;   Real - Zahlwert im Integer - Zahlbereich aufbereiten in ASCII
;
A7CB2:  PUSH    HL              ; Zeiger auf Real - Zahlwert retten
        CALL    A7BEA           ; Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
        LD      DE,S9E75        ; Zeiger auf Speicher f√ºr ASCII - Zahl vorgeben
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        LD      B,1             ; Code for 'auch Vornullen aufbereiten'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    22              ; Code 22   Hex-Wert in HL umsetzen in Dezimal-ASCII nach (DE)
        POP     HL              ; Zeiger auf Anfang aufbereitete Zahl holen
        LD      A,'0'           ; Null
        LD      B,5             ; maximal 5 Stellen vergleichen
A7CC3:  CP      (HL)            ; eine Stelle auf Vornull vergleichen
        JR      NZ,A7CCB        ; nicht Vornull -->  Vorkommastellen merken
        INC     HL              ; Vornull √ºberspringen
        DJNZ    A7CC3           ; weitere Stellen √ºberpr√ºfen
        JR      A7CD4           ; Zahl hat keine Vorkommastellen
;
A7CCB:  LD      A,B             ; Anzahl Vorkommastellen holen
        LD      (S7E34),A       ; Anzahl Stellen merken
        LD      A,1             ; Code for 'Vorkommastellen'
        LD      (S7E35),A       ; im Flag 'Stellen angegeben' merken
A7CD4:  LD      A,'.'           ; Dezimalpunkt
        LD      (S9E7A),A       ; in Speicher eintragen
        POP     HL              ; Zeiger auf Real - Zahlwert holen
        CALL    A7BC0           ; Nachkommastellen des Real-Zahlwertes (HL) errechnen
        JP      A7D30           ; Nachkommastellen aufbereiten in ASCII
;
;
;   Zahl aufbereiten in ASCII, wenn ohne Exponent m√∂glich
;
A7CE0:  LD      (S7E37),HL      ; Zeiger auf Real - Zahlwert merken
        XOR     A               ; Accu auf Null
        LD      (S7E34),A       ; Anzahl Stellen zur√ºcksetzen
        LD      (S7E35),A       ; Flag 'Stellen angegeben' zur√ºcksetzen
        PUSH    HL              ; Zeiger auf Real - Zahlwert merken
        LD      HL,S9E71        ; Zeiger auf Speicher zur Zahlaufbereitung in ASCII
        LD      (HL),-1         ; Code for 'Zahlanfang'  eintragen
        LD      B,33            ; 33 Zeichen L√§nge
        LD      A,'0'           ; Null
A7CF4:  INC     HL              ;! Speicher mit Null initialisieren
        LD      (HL),A          ;!
        DJNZ    A7CF4           ;!
        LD      A,'.'           ; Dezimalpunkt
        LD      (S9E7A),A       ; in Speicher eintragen
        POP     HL              ; Zeiger auf Real - Zahlwert holen
        LD      A,(HL)          ; Exponenten der Zahl holen
        OR      A               ; gleich Null  ?
        RET     Z               ; Zahl gleich Null -->  fertig
        LD      DE,B7C1D        ; Zeiger auf .1E+09 im Real - Format
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        CCF                     ; Ergebnis umkehren
        RET     C               ; Zahlwert zu gro√ü f√ºr Ansgabe ohne Exponent
        LD      DE,B7C4F        ; Zeiger auf .1E-07 im Real - Format
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        RET     C               ; Zahl zu klein f√ºr Ausgabe ohne Exponent
        LD      DE,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahl
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Speicher mit Real-Zahlwert holen
        LD      A,(HL)          ; Exponenten der Zahl holen
        CP      081H            ; Exponent f√ºr Zahlwert  +/- 1
        JR      C,A7D30         ; Nachkommastellen aufbereiten in ASCII
        CP      090H            ; Zahl kleiner 32728  ?
        JP      C,A7CB2         ; Zahl im Integer-Wert-Bereich -->  aufbereiten in ASCII
        LD      IX,S9E72        ; Zeiger auf Anfang Speicher f√ºr ASCII-Zahl
        LD      DE,B7C22        ; Zeiger auf  +10000000
        CALL    A7DF7           ; Vorkommastellen der Zahl (HL) aufbereiten in ASCII
        CALL    A7E2B           ; √ºberpr√ºfen, ob Rest gleich Null oder weitere Stellen
        RET     NC              ; keine Nachkommastellen
;
;
;   Nachkommastellen aufbereiten in ASCII
;
A7D30:  LD      IX,S9E7B        ; Zeiger auf Speicher f√ºr Nachkommastellen
A7D34:  LD      DE,B7C1D        ; Zeiger auf .1E+09 im Real - Format
        PUSH    BC              ; Register - Wert retten
        PUSH    IX              ; Zeiger f√ºr Nachkommastellen retten
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     IX              ; Zeiger f√ºr Nachkommastellen holen
        POP     BC              ; geretteten Register - Wert holen
        INC     DE              ;! Zeiger in DE auf n√§chste Zahl in Tabelle
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        CALL    A7DF7           ; Vorkommastellen der Zahl (HL) aufbereiten in ASCII
        CALL    A7E2B           ; √ºberpr√ºfen, ob Rest gleich Null oder weitere Stellen
        JR      C,A7D34
        RET
;
;
;   Real - Zahlwert (HL) aufbereiten in ASCII nach Zwischenspeicher
;
A7D4E:  LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        PUSH    HL              ; Zeiger auf Real - Zahlwert retten
        LD      DE,S9EAD        ; Zeiger auf Speicher f√ºr Real-Zahlwert  (ASCII)
        PUSH    DE              ; Zeiger auf Speicher merken
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Speicher mit aufbereiteter Zahl
        CALL    A7CE0           ; Zahl aufbereiten in ASCII, wenn ohne Exponent m√∂glich
        CALL    A7D6A           ; Rest Zahl aufbereiten in ASCII
        POP     HL              ; Zeiger auf geretteten Real-Zahl-Wert holen
        RET
;
A7D64:  LD      DE,S9E7A        ; Zeiger auf Stelle f√ºr Dezimalpunkt
        LD      (DE),A          ; Textendezeichen eintragen
        DEC     DE              ; Zeiger auf Null  (0)
        RET
;
;
;   Rest des Zahlwertes aufbereiten in ASCII
;
A7D6A:  JP      C,A7C54         ; Real-Zahl aufbereiten in ASCII mit Exponenten
A7D6D:  LD      HL,(S7E37)      ; Zeiger auf Real - Zahlwert holen
        LD      A,(HL)          ; Exponenten der Zahl holen
        OR      A               ; Exponent gleich Null  ?
        JR      Z,A7D64         ; ja -->  Textende auf Dezimalwert eintragen  (0)
        LD      DE,S9E72        ; Zeiger auf Anfang Speicher f√ºr ASCII-Zahl
        DEC     DE              ; Zeiger f√ºr Schleife corrigieren
        EX      DE,HL           ; Zeiger f√ºr ASCII-Zahl nach HL
        LD      DE,1            ; Code for 'Dezimalpunkt'
A7D7C:  INC     HL              ; Zeiger auf ASCII-Zahlwert auf n√§chstes Zeichen
        LD      A,(HL)          ; eine Ziffernstelle holen
        CP      '.'             ; Dezimalpunkt  ?
        JR      NZ,A7D87        ; nein -->  weiter untersuchen
        LD      DE,0            ; Code for 'kein Dezimalpunkt'
        JR      A7D7C           ; weiter untersuchen
;
A7D87:  CP      '0'             ; Null  ?
        JR      Z,A7D7C         ; ja -->  weiter untersuchen
        ADD     HL,DE           ; eventuell Dezimalpunkt √ºberspringen
        LD      DE,8            ; maximale L√§nge Mantisse
        ADD     HL,DE           ; Zeiger auf Ende Zahlwert errechnen
        LD      A,(HL)          ; letzte Stelle der Zahl holen
A7D91:  LD      (HL),'0'        ; und Null eintragen
        CP      '5'             ; Stelle runden  (4/5tel Rundung)  ?
        JR      C,A7DA6         ; kleiner 5 -->  nicht runden
A7D97:  DEC     HL              ; Zeiger auf Stelle davor
        LD      A,(HL)          ; ASCII - Stelle holen
        CP      '.'             ; Dezimalpunkt  ?
        JR      Z,A7D97         ; ja -->  n√§chste Ziffernstelle suchen
        INC     A               ; Zahlanfang  ?
        JR      Z,A7DE0         ; ja -->  Text  '1E+08'  vorgeben
        LD      (HL),A          ; aufgerundeten Zahlwert wieder eintragen
        CP      '9' + 1         ; √úbertrag auf vorige Stelle  ?
        JR      Z,A7D91         ; ja -->  weiter runden
        INC     HL              ; Zeiger wieder auf letzte aufbereitete Stelle
A7DA6:  LD      DE,S9E7A        ; Zeiger auf Stelle f√ºr Dezimalpunkt
        EX      DE,HL
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE
        EX      DE,HL
        JR      C,A7DB5         ; Zeiger steht auf Nachkommastelle
        LD      HL,S9E7A        ; Zeiger auf Stelle f√ºr Dezimalpunkt
        JR      A7DCC           ; aufbereitete Nachkommastelle  (jetzt 0)  abnippeln
;
A7DB5:  DEC     HL              ; Zeiger auf ASCII- Zahl
        LD      A,(HL)          ; eine Ziffernstelle holen
        CP      '.'             ; Dezimalpunkt  ?
        DEC     HL              ; Zeiger wieder corrigieren
        JR      Z,A7DCB         ; ja -->  Zahl ohne Dezimalpunkt ausgeben
        INC     HL              
        CP      '0'             ; Stelle gleich Null  ?
        JR      Z,A7DA6         ; ja -->  letzte relevante Stelle suchen
        PUSH    HL              ; Zeiger auf letzte relevante Stelle retten
        LD      DE,S9E83        ; Zeiger auf maximales Ende Mantisse ohne Exponent
        SBC     HL,DE           ; √ºberpr√ºfen, ob Zahl nach ohne Exponent geht
        POP     HL              ; Zeiger auf letzte relevante Stelle holen
        JP      NC,A7C54        ; zu gro√ü -->  Zahl mit Exponenten aufbereiten
A7DCB:  INC     HL              ; Zeiger auf ASCII - Zahl
A7DCC:  LD      (HL),NUL        ; Textendezeichen hinter Zahlwert eintragen
        LD      DE,S9E72        ; Zeiger auf Anfang Speicher f√ºr ASCII - Zahl
A7DD1:  LD      A,(DE)          ; eine Ziffernstelle holen
        CP      '0'             ; Null  ?
        JR      NZ,A7DD9        ; nein -->  testen, ob Ende Zahl
        INC     DE              ; Zeiger auf Zahl auf n√§chste Stelle
        JR      A7DD1           ; erste relevante Stelle suchen
;
A7DD9:  OR      A               ; Textendezeichen  ?
        RET     NZ              ; nein -->  Zahlwert  OK
        DEC     DE              ; Zeiger wieder auf Stelle davor
        LD      A,'0'           ; Null
        LD      (DE),A          ; eintragen
        RET
;
A7DE0:  LD      HL,S9E6A        ; Zeiger auf Speicher f√ºr ASCII-Zahl
        LD      DE,M7DF1        ; Text  '1E+08'
        PUSH    BC              ; Register - Wert retten
        LD      BC,6            ; Textl√§nge
        LDIR                    ; Text nach Speicher f√ºr ASCII-Zahl √ºbertragen
        POP     BC              ; geretteten Register - Wert holen
        LD      DE,S9E6A        ; Zeiger auf Speicher mit ASCII - Zahl vorgeben
        RET
;
M7DF1:  DEFM    "1E+08"
        DEFB    NUL
;
;
;   Vorkommastellen des Real - Zahlwertes (HL) aufbereiten in ASCII
;
A7DF7:  LD      A,(DE)          ; Exponenten aus Tabelle holen
        CP      07DH            ; letzter Tabellenwert  ?
        RET     Z               ; ja -->  fertig
A7DFB:  CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A7E13         ; Zahl ist kleiner als Stellenwertigkeit in Tabelle
        INC     (IX+0)          ; ASCII - Stelle plus eins
        PUSH    IX              ; Zeiger auf ASCII - Stelle merken
        PUSH    BC              ; Register - Wert retten
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     BC              ; geretteten Register - Wert holen
        POP     IX              ; Zeiger auf ASCII - Stelle holen
        LD      A,1             ; Code for 'Ziffer aufbereitet'
        LD      (S7E35),A       ; im Flag 'Ziffer aufbereitet' merken
        JR      A7DFB           ; weiter untersuchen
;
A7E13:  INC     IX              ; Zeiger auf n√§chste ASCII-Ziffern-Stelle
        INC     DE              ;! Zeiger auf Tabelle auf n√§chsten Wert
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        LD      A,(S7E35)       ; Flag 'Ziffer aufbereitet' holen  (0 oder 1)
        LD      B,A             ; und merken
        LD      A,(S7E34)       ; Anzahl Stellen holen
        ADD     A,B             ; neue Anzahl Stellen errechnen
        LD      (S7E34),A       ; neuen Anzahl Stellen merken
        CALL    A7E2B           ; √ºberpr√ºfen, ob Rest gleich Null oder weitere Stellen
        RET     NC              ; fertig
        JR      A7DF7           ; Vorkommastellen der Zahl (HL) aufbereiten in ASCII
;
;
;   √ºberpr√ºfen, ob Rest gleich Null oder weitere Stellen
;
A7E2B:  LD      A,(HL)          ; Exponenten des Restes des Real - Wertes holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  fertig
        LD      A,(S7E34)       ; Anzahl aufbereitete Stellen holen
        CP      9               ; mit maximaler Anzahl Stellen vergleichen
        RET
;
;
;   Speicher f√ºr Zahlaufbereitungsroutinen
;
S7E34:  DEFS    1               ; Speicher f√ºr Anzahl aufbereitete Stellen
;
S7E35:  DEFS    1               ; Flag 'Stellen angegeben/Ziffer aufbereitet'
;
S7E36:  DEFS    1               ; Flag  'Real - Wert'
;
S7E37:  DEFS    2               ; Zeiger auf Real - Zahlwert
;
S7E39:  DEFS    2               ; Zeiger auf Anfang USING - Format
;
S7E3B:  DEFS    2               ; Zeiger auf aktuelle Stelle USING - Format
;
;
;   bereitgestellten Wert entsprechend USING - Format aufbereiten
;   (DE = Zeiger auf Wertdescriptor / BC = Zeiger auf Speicher f√ºr aufbereiteten Wert)
;
A7E3D:  LD      HL,(S7E3B)      ; Zeiger auf aktuelle Stelle USING - Format holen
        PUSH    DE              ; Zeiger auf Wertdescriptor retten
A7E41:  LD      A,(HL)          ; n√§chstes Textzeichen aus USING - Format holen
        OR      A               ; Textendezeichen  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        CALL    A7EDF           ; √ºberpr√ºfen, ob Zeichen im Accu USING-Format-Zeichen ist
        JR      Z,A7E50         ; Formatzeichen -->  Format auswerten und Wert aufbereiten
        LD      (BC),A          ; Textzeichen aus USING-Format f√ºr Ausgabe merken
        INC     BC              ; Textzeichen √ºberspringen
        INC     HL              ; Zeiger auf USING-Format auf n√§chstes Zeichen
        JR      A7E41           ; n√§chstes Zeichen USING-Format auswerten
;
A7E50:  EX      AF,AF           ; USING - Formatzeichen retten
        LD      A,(S9E9C)       ; Wertart - Flag holen
        CP      3               ; Code for 'Zeichenkettenwert'  ?
        JP      NZ,A7F08        ; nein -->  Zahlwert nach USING - Format aufbereiten
        EX      AF,AF           ; gerettetes USING - Formatzeichen wieder holen
        CP      '!'             ; Code for 'ein Zeichen Text'  ?
        JP      Z,A7E67         ; ja -->  ein Zeichen Text der Zeichenkette aufbereiten
        CP      '&'             ; Code for 'mehrere Zeichen Text'  ?
        JP      Z,A7E8E         ; ja -->  L√§nge ausz√§hlen und Text aufbereiten
        JP      A636D           ; Fehler 4   Type mismatch error
;
;
;   ein Zeichen Text nach USING - Format aufbereiten
;
A7E67:  EX      (SP),HL         ; Zeiger auf USING-Format merken / Wertdescriptor holen
        PUSH    BC              ; Zeiger f√ºr aufbereitete Zeichen retten
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
        OR      A               ; L√§nge auszugebender Text gleich Null ?
        LD      A,' '           ; Leerzeichen  (Space)  vorgeben
        JR      Z,A7E72         ; L√§nge gleich Null -->  Leerzeichen vorgeben
        LD      A,(DE)          ; erstes Zeichen der Zeichenkette holen
A7E72:  POP     BC              ; Zeiger auf aufbereitete Zeichen holen
        LD      (BC),A          ; neues Zeichen merken
        INC     BC              ; neues Zeichen √ºberspringen
;
;
;   eventuell vorhandene Textkonstante im USING - Format aufbereiten zur Ausgabe
;
A7E75:  POP     HL              ; Zeiger auf USING - Format holen
        INC     HL              ; ausgewertetes Zeichen √ºberspringen
A7E77:  LD      A,(HL)          ; n√§chstes Zeichen USING - Format holen
        OR      A               ; gleich Textendezeichen  ?
        JR      Z,A7E85         ; ja -->  wieder Anfang USING - Format vorgeben
        CALL    A7EDF           ; √ºberpr√ºfen, ob Zeichen im Accu USING-Format-Zeichen ist
        JR      Z,A7E88         ; Formatzeichen -->  Zeiger auf Rest USING-Format merken
        LD      (BC),A          ; Textzeichen zur Ausgabe merken
        INC     BC              ; Textzeichen √ºberspringen
        INC     HL              ; Zeiger auf USING-Format auf n√§chstes Zeichen
        JR      A7E77           ; n√§chstes Zeichen USING - Format auswerten
;
A7E85:  LD      HL,(S7E39)      ; Zeiger auf Anfang USING - Format holen
A7E88:  LD      (S7E3B),HL      ; Zeiger auf aktuelle Stelle USING - Format merken
        XOR     A               ; Code for 'Textende'
        LD      (BC),A          ; hinter bereitgestellte Zeichenfolge eintragen
        RET
;
;
;   Formatl√§nge f√ºr Zeichenkette ausz√§hlen und Text nach USING - Format aufbereiten
;
A7E8E:  LD      D,2             ; Vorgabe zwei Zeichen
A7E90:  INC     HL              ; Textanfangszeichen in USING - Format √ºberspringen
        LD      A,(HL)          ; n√§chstes Zeichen im USING - Format holen
        CP      '&'             ; Code for 'Formatende'  ?
        JR      Z,A7E9E         ; ja -->  Text nach Format ausgeben
        INC     D               ; Z√§hler 'Anzahl Zeichen Text' plus eins
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A7E90         ; ja -->  Formatl√§nge ausz√§hlen
        JP      A636A           ; ja -->  Fehler 3   Illegal data error
;
A7E9E:  EX      (SP),HL         ; Zeiger auf USING-Format merken / Wertdescriptor holen
        LD      A,(HL)          ; L√§nge der auszugebenden Zeichenkette holen
        CP      D               ; mit auszugebender Zeichenkette vergleichen
        JR      C,A7EB8         ; Zeichenkette ist k√ºrzer als Format
        INC     HL              ; Zeiger auf 'Offset auf Zeichenkette'  stellen
        CALL    A0151           ; Offset aus Descriptor (HL) nach HL holen
        PUSH    BC              ; Zeiger f√ºr aufbereitete Zeichen retten
        LD      BC,(S1076)      ; Anfang Stringtextbereich holen
        ADD     HL,BC           ; Zeiger auf Stringtext errechnen
        POP     BC              ; Zeiger f√ºr aufbereitete Zeichen wieder holen
A7EAE:  LD      A,(HL)          ; ein Zeichen der Zeichenkette holen
        LD      (BC),A          ; und als auszugebendes Zeichen merken
        INC     BC              ; auszugebendes Zeichen √ºberspringen
        INC     HL              ; Zeiger auf String auf n√§chstes Zeichen
        DEC     D               ; Restanzahl Zeichen minus eins
        JR      NZ,A7EAE        ; ungleich Null -->  weitere Zeichen √ºbertragen
        JP      A7E75           ; Textkonstante im USING-Format f√ºr Ausgabe aufbereiten
;
;
;   Zeichenkette, die k√ºrzer als USING - Format ist, aufbereiten zur Ausgabe
;
A7EB8:  LD      E,(HL)          ; L√§nge der auszugebenden Zeichenkette holen
        INC     HL              ; Zeiger auf 'Offset auf Zeichenkette'  stellen
        CALL    A0151           ; Adresse aus Tabelle (HL) nach HL holen
        LD      A,E             ; L√§nge der Zeichenkette holen
        OR      A               ; L√§nge gleich Null  ?
        JR      Z,A7ED5         ; ja -->  nur Leerzeichen ausgeben
        PUSH    BC              ; Zeiger f√ºr aufbereitete Zeichen retten
        LD      BC,(S1076)      ; Anfang Stringtextbereich holen
        ADD     HL,BC           ; Zeiger auf Stringtext errechnen
        POP     BC              ; Zeiger f√ºr aufbereitete Zeichen wieder holen
A7EC8:  LD      A,(HL)          ; ein Zeichen der Zeichenkette holen
        LD      (BC),A          ; und als auszugebendes Zeichen merken
        INC     BC              ; auszugebendes Zeichen √ºberspringen
        INC     HL              ; Zeiger auf String auf n√§chstes Zeichen
        DEC     E               ; Restanzahl Zeichen in Zeichenkette minus eins
        JR      Z,A7ED9         ; gleich Null -->  Rest mit Leerzeichen auff√ºllen
        DEC     D               ; Restanzahl Zeichen f√ºr Format minus eins
        JR      NZ,A7EC8        ; weitere Zeichen der Zeichenkette bereitstellen
        JP      A7E75           ; Textkonstante im USING-Format f√ºr Ausgabe aufbereiten
;
;
;   nicht vorhandene Zeichen mit Leerzeichen auff√ºllen
;
A7ED5:  LD      A,' '           ; Leerzeichen  (Space)  vorgeben
        LD      (BC),A          ; und als auszugebendes Zeichen merken
        INC     BC              ; bereitgestelltes Zeichen √ºberspringen
A7ED9:  DEC     D               ; Z√§hler 'Restanzahl Zeichen' minus eins
        JR      NZ,A7ED5        ; weitere Leerzeichen bereitstellen
        JP      A7E75           ; Textkonstante im USING-Format f√ºr Ausgabe aufbereiten
;
;
;   √ºberpr√ºfen, ob Zeichen im Accu USING - Format - Zeichen ist
;
A7EDF:  CALL    A011B           ; Vergleich Accu mit hinter CALL angegebenen Bytes
        DEFB    4               ; vier Zeichen angegeben
        DEFM    "!&#+"          ; USING - Formatzeichen
        RET     Z               ; Zeichen im Accu ist Formatzeichen
        LD      E,A             ; Zeichen merken
        CP      '*'             ; Sternchen als Schecksperrzeichen  ?
        JR      Z,A7F02         ; ja -->  √ºberpr√ºfen, ob zwei Zeichen hintereinander
        CALL    A80DF           ; √úberpr√ºfen, ob Accu gleich W√§hrungszeichen ist
        JR      Z,A7F02         ; ja -->  testen, ob zwei Zeichen hintereinander
        CP      '.'             ; Dezimalpunktkennzeichen  ?
        LD      E,'#'           ; Nummernfeld f√ºr n√§chstes Zeichen vorgeben
        JR      Z,A7F02         ; Dezimalpunkt -->  testen, ob n√§chstes Zeichen Nummernfeld
        CP      0C4H            ; Code for 'n√§chstes Zeichen ausgeben'  ?
        RET     NZ              ; nein
        INC     HL              ; Code √ºberspringen
        LD      A,(HL)          ; n√§chstes Zeichen aus USING - Format holen
        OR      A               ; Textendezeichen  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        RET
;
A7F02:  INC     HL              ; erstes Formatzeichen √ºberspringen
        LD      A,(HL)          ; zweites Formatzeichen holen
        CP      E               ; mit Zeichenvorgabe vergleichen
        DEC     HL              ; Zeiger wieder auf erstes Zeichen stellen
        LD      A,(HL)          ; erstes Zeichen wieder aus Format holen
        RET
;
;
;   bereitgestellten Zahlwert nach USING - Format aufbereiten
;
A7F08:  XOR     A               ; Accu auf Null
        LD      (D804E + 1),A   ; Flag  'Vorzeichen vorne angegeben'  zur√ºcksetzen
        LD      (A809E + 1),A   ; Schecksperre - Flag zur√ºcksetzen
        LD      (A8086 + 1),A   ; W√§hrungszeichen - Flag zur√ºcksetzen
        LD      (A8044 + 1),A   ; Flag  'Vorzeichen minus hinten angegeben'  zur√ºcksetzen
        LD      (D7FFE + 1),A   ; Komma - Flag  zur√ºcksetzen
        LD      (A802B + 1),A   ; Anzahl Vorkommastellen l√∂schen
        LD      (D8049 + 1),A   ; FLag  'Vorzeichen plus hinten angegeben'  zur√ºcksetzen
        LD      (D7FF7 + 1),A   ; Exponent - Flag zur√ºcksetzen
        DEC     A               ; Code for 'keine Nachkommastellen'
        LD      (D7FF4 + 1),A   ; als Anzahl Nachkommastellen merken
        EX      AF,AF           ; Formatzeichen holen
        LD      D,0             ; Vorgabe f√ºr Anzahl Vorkommastellen
        CP      '#'             ; Nummernkreuz  ?
        JP      Z,A7F64         ; ja -->  Anzahl Vorkommastellen ausz√§hlen
        CP      '*'             ; Schecksperrzeichen  ?
        JP      Z,A7F45         ; ja -->  merken und Format ausz√§hlen
        CALL    A80DF           ; √ºberpr√ºfen, ob Accu gleich W√§hrungszeichen ist
        JP      Z,A7F56         ; ja -->  merken und Format ausz√§hlen
        CP      '.'             ; Dezimalpunktzeichen  ?
        JP      Z,A7F66         ; ja -->  Nachkommastellen ausz√§hlen
        CP      '+'             ; Code for 'Vorzeichen vorne ausgeben'  ?
        JP      Z,A7F5F         ; ja -->  merken und Format ausz√§hlen
        JP      A636D           ; Fehler 4   Type mismatch error
;
A7F45:  LD      A,1             ; Code for 'Schecksperre angegeben'
        LD      (A809E + 1),A   ; im Schecksperre - Flag merken
        INC     HL              ; erstes Schecksperrzeichen √ºberspringen
        INC     D               ; Anzahl Vorkommastellen plus eins
        INC     HL              ; zweites Schecksperrzeichen √ºberspringen
        INC     D               ; Anzahl Vorkommastellen plus eins
        LD      A,(HL)          ; n√§chstes Formatzeichen holen
        CALL    A80DF           ; √ºberpr√ºfen, ob Accu gleich W√§hrungszeichen ist
        JR      NZ,A7F66        ; nein -->  Vorkommastellen ausz√§hlen
        JR      A7F58           ; Code for 'W√§hrungszeichen angegeben'  merken
;
;
;   Zahlformat mit W√§hrungszeichen begonnen
;
A7F56:  INC     HL              ; Format - Zeichen im USING - String √ºberspringen
        INC     D               ; Anzahl Vorkommastellen plus eins
A7F58:  INC     HL              ; Format-Zeichen im USING-String √ºberspringen
        INC     D               ; Anzahl Vorkommastellen plus eins
        LD      (A8086 + 1),A   ; W√§hrungszeichen im W√§hrungszeichen - Flag merken
        JR      A7F66           ; Restliche Vorkommastellen ausz√§hlen
;
A7F5F:  LD      A,1             ; Code for 'Vorzeichen vorne angegeben'
        LD      (D804E + 1),A   ; Flag  'Vorzeichen vorne angegeben' setzen
;
;
;   Anzahl Vorkommastellen im USING - Format ausz√§hlen
;
A7F64:  INC     HL              ; Formatzeichen √ºberspringen
        INC     D               ; Anzahl Vorkommastellen plus eins
A7F66:  EX      DE,HL           ; Zeiger auf Format nach DE / Z√§hler nach HL
        DEC     H               ; Z√§hler Anzahl Vorkommastellen f√ºr Schleife corrigieren
A7F68:  INC     H               ; Z√§hler Anzahl Vorkommastellen plus eins
        LD      A,(DE)          ; n√§chstes Zeichen aus USING - Format holen
        INC     DE              ; Formatzeichen √ºberspringen
        CP      '#'             ; Nummernkreuz  ?
        JR      Z,A7F68         ; ja -->  n√§chstes Zeichen auswerten
        CP      ','             ; Tabulationskomma  ?
        JR      NZ,A7F7A        ; nein -->  weiter untersuchen
        LD      A,1             ; Code for 'mit Komma tabulieren'
        LD      (D7FFE + 1),A   ; Komma - Flag setzen
        JR      A7F68           ; restliche Vorkommastellen ausz√§hlen
;
A7F7A:  CP      '.'             ; Dezimalpunkt  ?
        JR      Z,A7FA1         ; ja -->  Nachkommastellen ausz√§hlen
        CP      '-'             ; Vorzeichen minus  ?
        JR      NZ,A7F8A        ; nein -->  weiter untersuchen
        LD      A,1             ; Code for 'Vorzeichen minus hinten angegeben'  
        LD      (A8044 + 1),A   ; Flag  'Vorzeichen minus hinten angegeben' setzen
        INC     DE              ; Zeiger f√ºr Ende Schleife corrigieren
        JR      A7F9A           ; Anzahl Vorkommastellen merken und Zahl aufbereite
;
A7F8A:  CP      '+'             ; Vorzeichen plus  ?
        JR      NZ,A7F9A        ; nein -->  Anzahl Vorkommastelen merken und Zahl aufbereiten
        LD      A,(D804E + 1)   ; Flag  'Vorzeichen vorne angegeben' holen
        OR      A               ; gesetzt  ?
        JR      NZ,A7F9A        ; ja -->  Vorzeichen hinten vergessen
        LD      A,1             ; Code for 'Vorzeichen plus hinten angegeben'
        LD      (D8049 + 1),A   ; FLag  'Vorzeichen plus hinten angegeben' setzen
        INC     DE              ; Zeiger auf USING - Format
A7F9A:  DEC     DE              ; Zeiger auf USING - Format corrigiern
        LD      A,H             ; Anzahl Vorkommastellen holen
        LD      (A802B + 1),A   ; Anzahl Vorkommastellen merken
        JR      A7FD4           ; Format auf angegebenen Exponenten  untersuchen
;
;
;   Anzahl Nachkommastellen im USING - Format ausz√§hlen
;
A7FA1:  LD      A,H             ; Anzahl Vorkommastellen holen
        LD      (A802B + 1),A   ; Anzahl Vorkommastellen merken
        LD      H,-1            ; Vorgabe f√ºr Z√§hler 'Anzahl Nachkommastellen'
A7FA7:  INC     H               ; Z√§hler 'Anzahl Nachkommastellen' plus eins
        LD      A,(DE)          ; ein Format - Zeichen holen
        INC     DE              ; Formatzeichen √ºberspringen
        CP      '#'             ; Nummernkreuz  ?
        JR      Z,A7FA7         ; ja -->  n√§chstes Zeichen auswerten
        CP      '-'             ; Vorzeichen minus  ?
        JR      NZ,A7FBA        ; nein -->  weiter untersuchen
        LD      A,1             ; Code for 'Vorzeichen minus hinten angegeben'
        LD      (A8044 + 1),A   ; Flag  'Vorzeichen minus hinten angegeben' setzen
        INC     DE              ; Zeiger auf Format f√ºr Einsprung corrigieren
        JR      A7FCA           ; Format auf angegebenen Exponenten untersuchen
;
A7FBA:  CP      '+'             ; Vorzeichen plus  ?
        JR      NZ,A7FCA        ; nein -->  Nachkommastellen merken
        LD      A,(D804E + 1)   ; Flag  'Vorzeichen vorne angegeben' holen
        OR      A               ; gesetzt  ?
        JR      NZ,A7FCA        ; ja -->  Vorzeichen hinten vergessen
        LD      A,1             ; Code for 'Vorzeichen plus hinten angegeben'
        LD      (D8049 + 1),A   ; FLag  'Vorzeichen plus hinten angegeben'  setzen
        INC     DE              ; Zeiger auf USING - Format
A7FCA:  DEC     DE              ; Zeiger auf USING - Format corrigieren
        LD      A,H             ; Anzahl Nachkommastellen holen
        LD      (D7FF4 + 1),A   ; Anzahl Nachkommastellen merken
        JR      A7FD4           ; Format auf Exponenten untersuchen
;
A7FD1:  POP     DE              ; Zeiger auf Formatstelle  'Anfang Exponent'  holen
        JR      A7FE6           ; Zahlwert entsprechend USING-Format aufbereiten
;
;
;   auf Exponenten im USING - Format untersuchen
;
A7FD4:  LD      H,4             ; auf vier Zeichen Exponent untersuchen
        PUSH    DE              ; Zeiger auf Anfang Exponenten im Format merken
A7FD7:  LD      A,(DE)          ; ein Zeichen Format holen
        INC     DE              ; Formatzeichen √ºberspringen
        CP      '^'             ; Exponentenzeichen  ?
        JR      NZ,A7FD1        ; nein -->  kein Exponent angegeben
        DEC     H               ; Z√§hler minus eins
        JR      NZ,A7FD7        ; weitere Stellen untersuchen
        POP     AF              ; Zeiger auf Anfang Exponenten vergessen
        LD      A,1             ; Code for 'Exponent angegeben'
        LD      (D7FF7 + 1),A   ; Exponent - Flag setzen
A7FE6:  POP     HL              ; Zeiger auf Zahlwert holen
        PUSH    DE              ; Zeiger auf Rest USING - Format merken
        INC     HL              ; Zeiger auf MSByte Mantisse stellen
        LD      A,(HL)          ; MSByte Mantisse der Zahl holen
        RES     7,(HL)          ; Vorzeichen der Zahl auf plus
        DEC     HL              ; Zeiger auf Zahl wieder auf Exponenten
        LD      (A807B + 1),A   ; MSByte Mantisse aufzubereitende Zahl merken
        LD      A,(A802B + 1)   ; Anzahl Vorkommastellen holen
        LD      D,A             ; und merken
D7FF4:  LD      A,0             ; Anzahl Nachkommastellen holen   (wird eingetragen)
        LD      E,A             ; und merken
D7FF7:  LD      A,0             ; Exponent - Flag holen   (wird eingetragen)
        PUSH    BC              ; Zeiger auf Speicher f√ºr aufbereiteten Zahlwert retten
        CALL    A80E5           ; Zahlwert nach USING - Format aufbereiten
        POP     BC              ; Zeiger auf Speicher f√ºr aufbereiteten Zahlwert holen
D7FFE:  LD      A,0             ; Komma - Flag holen   (wird eingetragen)
        OR      A               ; gesetzt  ?
        JR      Z,A8044         ; nein -->  ohne Komma ausgeben
        PUSH    BC              ; Zeiger auf Speicher f√ºr aufbereiteten Zahlwert retten
        PUSH    DE              ; Zeiger auf aufbereiteten Zahlwert retten
        LD      A,(A802B + 1)   ; Anzahl Vorkommastellen holen
        LD      L,A             ; und merken
        LD      H,0             ; High - Byte Offset auf Null
        ADD     HL,DE           ; Zeiger auf Dezimalpunkt errechnen
        LD      DE,S9E6A        ; Zeiger auf Zwischenspeicher  (bei USING-Routine)
        LD      C,0             ; Z√§hler 'Anzahl Stellen' auf null
        DEC     HL              ; Zeiger auf ASCII - Zahlwert
A8012:  LD      B,3             ; nach je drei Stellen ein Komma setzen
A8014:  LD      A,(HL)          ; ein Zeichen des ASCII - Zahlwertes holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A802B         ; ja -->  Zahlanfang gefunden
        INC     C               ; Z√§hler 'Anzahl Zeichen' plus eins
        LD      (DE),A          ; Zahlzeichen merken
        INC     DE              ; Zeiger auf Zwischenspeicher f√ºr Zahltext
        DEC     HL              ; Zeiger auf ASCII - Zahltext
        DJNZ    A8014           ; weitere Zeichen √ºbertragen
        LD      A,(HL)          ; n√§chstes Zeichen ASCII - Zahlwert holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A802B         ; ja -->  kein Komma vor Zahlwert schreiben
        LD      A,','           ; Komma als Trennzeichen
        LD      (DE),A          ; in Text eintragen
        INC     DE              ; Komma √ºberspringen
        INC     C               ; Z√§hler 'Anzahl Zeichen' plus eins
        JR      A8012           ; Rest der Vorkommazahl aufbereiten
;
A802B:  LD      A,0             ; Anzahl Vorkommastellen holen   (wird eingetragen)
        CP      C               ; mit jetziger Anzahl Vorkommastellen vergleichen
        JP      C,A6367         ; mit Komma zu viele Stellen -->  Fehler 2  Overflow error
        LD      B,C             ; Textl√§nge mit Komma
        LD      L,A             ; Anzahl Vorkommastellen
        LD      H,0             ; High - Byte Anzahl auf Null
        POP     DE              ; Zeiger auf Anfang ASCII - Zahl holen
        PUSH    DE              ; und wieder merken
        ADD     HL,DE           ; Zeiger auf Dezimalpunktstelle errechnen
        LD      DE,S9E6A        ; Zeiger auf Zwischenspeicher   (bei USING-Routine)
        DEC     HL              ; Zeiger auf Stelle f√ºr Zahl
A803C:  LD      A,(DE)          ; ein Zeichen Zahltext mit Komma
        LD      (HL),A          ; wieder vor Nachkommastellen setzen
        DEC     HL              ; Zeiger auf Stelle f√ºr Vorkommastellen
        INC     DE              ; Zeiger auf aufbereitete Vorkommastellen
        DJNZ    A803C           ; weitere Zeichen √ºbertragen
        POP     DE              ; Zeiger auf Anfang aufbereitete ASCII - Zahl
        POP     BC              ; Zeiger auf Stelle f√ºr ASCII - Zahl
A8044:  LD      A,0             ; Flag  'Vorzeichen minus hinten angegeben' holen
        OR      A               ; gesetzt  ?
        JR      NZ,A8086        ; ja -->  Vorzeichen hinter Zahl eintragen
D8049:  LD      A,0             ; FLag  'Vorzeichen plus hinten angegeben' holen
        OR      A               ; gesetzt  ?
        JR      NZ,A8086        ; ja -->  Vorzeichen hinter Zahl eintragen
D804E:  LD      A,0             ; Flag  'Vorzeichen vorne angegeben'  holen
        OR      A               ; gesetzt  ?
        JR      NZ,A807B        ; ja -->  auf jeden Fall Vorzeichen vor Zahl schreiben
        LD      A,(A807B + 1)   ; MSByte Mantisse aufzubereitende Zahl holen
        RLCA                    ; Vorzeichenbit nach Carry schieben
        JR      NC,A8086        ; Zahl ist positiv -->  kein Vorzeichen vor Zahl schreiben
        LD      A,(DE)          ; erstes Zeichen der aufbereiteten Zahl holen
        CP      ' '             ; Leerzeichen  (Space) ?
        LD      H,'-'           ; Vorzeichen minus vorgeben
        JR      Z,A8065         ; Leerzeichen -->  Stelle f√ºr Vorzeichen suchen
        CP      '0'             ; f√ºhrende Null  ?
        JP      NZ,A6367        ; nein -->  Fehler 2  Overflow error
A8065:  PUSH    DE              ; Zeiger auf Anfang ASCII - Zahlwert merken
A8066:  LD      A,(DE)          ; ein Zeichen ASCII - Zahl holen
        INC     DE              ; Zeiger auf Zahltext auf n√§chstes Zeichen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A8066         ; ja -->  relevantes Zeichen suchen
        CP      '0'             ; f√ºhrende Null  ?
        JR      Z,A8066         ; ja -->  relevantes Zeichen suchen
        OR      A               ; Textendezeichen  ?
        JR      NZ,A8074        ; nein
        DEC     DE              ; Textendezeichen retten
A8074:  DEC     DE              ; letzte Stelle der Zahl retten
        DEC     DE              ; Zeiger auf Stelle f√ºr Vorzeichen
        LD      A,H             ; Vorzeichen holen
        LD      (DE),A          ; und vor Zahlwert eintragen
        POP     DE              ; Zeiger auf Anfang ASCII - Zahlwert holen
        JR      A8086           ; auf W√§hrungszeichen untersuchen
;
A807B:  LD      A,0             ; MSByte Mantisse aufzubereitende Zahl holen
        RLCA                    ; Vorzeichen nach Carry schieben
        LD      H,'+'           ; Vorzeichen 'Plus' vorgeben
        JR      NC,A8065        ; Zahlwert ist positiv
        LD      H,'-'           ; Vorzeichen 'Minus' vorgeben
        JR      A8065           ; Vorzeichen vor Zahlwert eintragen
;
A8086:  LD      A,0             ; W√§hrungszeichen - Flag holen   (wird eingetragen)
        OR      A               ; gesetzt  ?
        JR      Z,A809E         ; nein -->  auf Schecksperre untersuchen
        LD      A,(DE)          ; erstes Zeichen ASCII - Zahl holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      NZ,A809E        ; nein -->  W√§hrungszeichen vergessen
        PUSH    DE              ; Zeiger auf Anfang Zahlwert merken
A8091:  LD      A,(DE)          ; ein Zeichen ASCII - Zahl holen
        INC     DE              ; Zeichen √ºberspringen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A8091         ; ja -->  Anfang Zahlwert suchen
        DEC     DE              ;! Zeiger auf Freistelle f√ºr W√§hrungszeichen stellen
        DEC     DE              ;!
        LD      A,(A8086 + 1)   ; W√§hrungszeichen - Flag holen
        LD      (DE),A          ; W√§hrungszeichen vor Zahlwert eintragen
        POP     DE              ; Zeiger auf Anfang Zahlwert holen
A809E:  LD      A,0             ; Schecksperre - Flag holen   (wird eingetragen)
        OR      A               ; gesetzt  ?
        JR      Z,A80B0         ; nein -->  auf Vorzeichen hinter Zahlwert untersuchen
        PUSH    DE              ; Zeiger auf Anfang Zahlwert retten
A80A4:  LD      A,(DE)          ; ein Zeichen ASCII - Zahlwert holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      NZ,A80AF        ; nein -->  Schecksperre vergessen
        LD      A,'*'           ; Schecksperrzeichen
        LD      (DE),A          ; eintragen
        INC     DE              ; Zeiger auf ASCII - Zahl auf n√§chstes Zeichen
        JR      A80A4           ; n√§chste Stelle untersuchen
;
A80AF:  POP     DE              ; Zeiger auf Anfang ASCII - Zahlwert holen
A80B0:  LD      A,(DE)          ; ein ASCII - Zahlzeichen holen
        OR      A               ; Textendezeichen  ?
        JR      Z,A80B9         ; ja -->  auf Vorzeichen hinten untersuchen
        LD      (BC),A          ; ein Zahlzeichen zur Ausgabe merken
        INC     BC              ; Zeiger auf Speicher f√ºr aufbereiteten Text
        INC     DE              ; Zeiger auf ASCII - Zahlwert
        JR      A80B0           ; weitere Zahlzeichen √ºbertragen
;
;
;   auf 'Vorzeichen hinten angegeben' untersuchen und eventuell Vorzeichen eintragen
;
A80B9:  LD      A,(D8049 + 1)   ; FLag  'Vorzeichen plus hinten angegeben'  holen
        OR      A               ; gesetzt  ?
        JR      Z,A80CD         ; nein -->  auf 'Vorzeichen minus hinten angegeben' untersuchen
        LD      A,(A807B + 1)   ; MSByte Mantisse aufzubereitende Zahl holen
        RLCA                    ; Vorzeichenbit nach Carry schieben
        LD      A,'+'           ; Vorzeichen 'Plus' vorgeben
A80C5:  JR      NC,A80C9        ; Zahlwert ist positiv
        LD      A,'-'           ; Vorzeichen 'Minus' vorgeben
A80C9:  LD      (BC),A          ; Vorzeichen hinter Zahlwert eintragen
        INC     BC              ; Vorzeichen √ºberspringen
        JR      A80DB           ; Textkonstante im USING-Format f√ºr Ausgabe aufbereiten
;
A80CD:  LD      A,(A8044 + 1)   ; Flag  'Vorzeichen minus hinten angegeben' holen
        OR      A               ; gesetzt  ?
        JR      Z,A80DB         ; nein -->  Textkonstante im USING-Format f√ºr Ausgabe aufb.
        LD      A,(A807B + 1)   ; MSByte Mantisse aufzubereitende Zahl holen
        RLCA                    ; Vorzeichenbit nach Carry schieben
        LD      A,' '           ; Vorgabe 'Leerzeichen' f√ºr positives Vorzeichen
        JR      A80C5           ; bei negativem Zahlwert minus eintragen
;
A80DB:  POP     HL              ; Zeiger auf Rest USING - Format holen
        JP      A7E77           ; Textkonstante im USING - Format f√ºr Ausgabe aufbereiten
;
;
;   testen, ob Zeichen im Accu gleich W√§hrungszeichen ist
;
A80DF:  CP      0FBH            ; Pfund - Zeichen  ?
        RET     Z               ; ja
        CP      '$'             ; Dollar - Zeichen  ?
        RET
;
;
;   Zahlwert (HL) nach USING - Format aufbereiten
;   (D = Vorkommastellen / E = Nachkommastellen / A = Exponentenflag)
;
A80E5:  OR      A               ; mit Exponent aufbereiten  ?
        JP      Z,A8170         ; nein
        PUSH    DE              ; Vorkommastellen / Nachkommastellen retten
        LD      A,(HL)          ; Exponenten der Zahl holen
        OR      A               ; Zahlwert gleich Null  ?
        JR      Z,A812D         ; Zahl gleich Null -->  Text vorgeben
        PUSH    HL              ; Zeiger auf Zahlwert im Real - Format retten
        LD      A,D             ; Anzahl Vorkommastellen holen
        LD      DE,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        PUSH    AF              ; Anzahl Vorkommastellen merken
        CALL    A79C2           ; +1 im Real - Format nach (DE) √ºbertragen
        POP     AF              ; Anzahl Vorkommastellen holen
        OR      A               ; gleich Null  ?
        JR      Z,A8106         ; ja -->  Faktor stimmt
        LD      B,A             ; Anzahl Vorkommastellen f√ºr Schleife merken
        LD      HL,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        JR      A8104           ; Faktor errechnen
;
A8101:  CALL    A7BDD           ; Zahlwert (HL) mal 10
A8104:  DJNZ    A8101           ; richtigen Faktor errechnen
A8106:  POP     HL              ; Zeiger auf aufzubereitenden Zahlwert holen
        LD      B,0             ; Vorgabe f√ºr Exponentenz√§hler
A8109:  LD      DE,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        CALL    A7B7C           ; Real-Zahlen (HL) und (DE) vergleichen (BC-Register retten)
        JR      C,A8117         ; Real - Zahlwert ist kleiner als Normierungsfaktor
        CALL    A7B31           ; Real - Zahlwert (HL) durch zehn
        INC     B               ; Exponentenz√§hler plus eins
        JR      A8109           ; weiter untersuchen
;
A8117:  PUSH    HL              ; Zeiger normierter Wert merken
        LD      HL,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        CALL    A7B31           ; Real - Zahlwert (HL) durch zehn
        POP     HL              ; Zeiger auf normierten Wert holen
A811F:  LD      DE,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        CALL    A7B7C           ; Real-Zahlen (HL) und (DE) vergleichen (BC-Register retten)
        JR      NC,A812D        ; Real - Zahl ist gr√∂√üer als Normierungsfaktor
        CALL    A7BDD           ; altes Teilergebnis mal 10
        DEC     B               ; Exponentenz√§hler minus eins
        JR      A811F           ; weiter untersuchen
;
A812D:  POP     DE              ; Vorkommastellen / Nachkommastellen holen
        PUSH    BC              ; Exponentenz√§hler retten
        CALL    A818A           ; Zahlwert aufbereiten in ASCII
        POP     BC              ; Exponentenz√§hler holen
        PUSH    DE              ; Zeiger auf ASCII - Zahlwert retten
        LD      A,(DE)          ; erstes Zeichen ASCII - Zahlwert holen
        CP      '.'             ; Dezimalpunkt  ?
        JR      NZ,A814B        ; nein
        LD      DE,S9E7A        ; Zeiger auf Stelle f√ºr Dezimalpunkt
        DEC     DE              ; Zeiger auf Vorkommastelle
        LD      A,(DE)          ; erste Vorkommastelle holen
        CP      '1'             ; eins  ?
        POP     DE              ; Zeiger auf ASCII - Wert holen
        PUSH    DE              ; und wieder merken
        JR      NZ,A8167        ; Vorkommastellen vorhanden
        EX      DE,HL           ; Zeiger auf ASCII - Wert nach HL
        INC     HL
        LD      (HL),'1'
        DEC     HL
        JR      A8165
;
A814B:  LD      A,(DE)          ; ASCII - Stelle holen
        CP      '1'             ; eins  ?
        JR      NZ,A8167        ; nein -->  Stelle f√ºr Exponenten suchen
        EX      DE,HL           ; Zeiger auf ASCII - Zahl nach HL
        INC     HL              ; Stelle √ºberspringen
        LD      A,(HL)          ; n√§chste Stelle holen
        DEC     HL              ; Zeiger wieder auf vorige Stelle
        CP      '.'             ; Dezimalpunkt  ?
        LD      A,'0'           ; Null
        JR      Z,A815C         ; Dezimalpunkt -->  0.1
        LD      A,' '           ; Leerzeichen  (Space)
A815C:  LD      (HL),A          ; Zeichen eintragen
A815D:  INC     HL              ; Zeiger auf n√§chste ASCII - Stelle
        LD      A,(HL)          ; ASCII - Stelle holen
        CP      '.'             ; Dezimalpunkt  ?
        JR      Z,A815D         ; ja -->  Dezimalpunkt √ºberspringen
        LD      (HL),'1'        ; 'Eins' eintragen
A8165:  EX      DE,HL           ; Zeiger auf ASCII - Zahlwert nach DE
        INC     B               ; Exponentenz√§hler plus eins
A8167:  LD      A,(DE)          ; eine ASCII - Stelle holen
        INC     DE              ; Stelle √ºberspringen
        OR      A               ; Textendezeichen  ?
        JR      NZ,A8167        ; nein -->  Textende suchen
        DEC     DE              ; Zeiger wieder auf Textendezeichen
        JP      A7C8F           ; Exponenten aufbereiten in ASCII
;
;
;   Zahl im Real - Format ohne Exponenten aufbereiten
;
A8170:  PUSH    DE              ; Vorkommastellen / Nachkommastellen retten
        CALL    A818A           ; Zahlwert aufbereiten in ASCII
        POP     AF              ; Vorkommastellen holen
        OR      A               ; Zahlwert mit Vorkommastellen  ?
        RET     NZ              ; ja -->  fertig
        PUSH    HL              ; Zeiger auf Anfang aufbereitete Zahl retten
        LD      HL,S9E7A        ; Zeiger auf Stelle f√ºr Dezimalpunkt
        DEC     HL              ; Zeiger auf erste Vorkommastelle
        LD      A,'0'           ; Null
        CP      (HL)            ; mit erster Vorkommastelle vergleichen
A817F:  JP      NZ,A6367        ; nicht Null -->  Fehler 2  Overflow error
        DEC     HL              ; Zeiger auf Stelle f√ºr Vorzeichen
        LD      A,' '           ; Leerzeichen  (Space)  vorgeben
        CP      (HL)            ; mit Stelle f√ºr Vorzeichen vergleichen
        JR      NZ,A817F        ; nicht gleich -->  Fehler 2  Overflow error
        POP     HL              ; Zeiger auf Anfang aufbereiteten Zahlwert
        RET
;
;
;   Zahlwert aufbereiten in ASCII
;
A818A:  PUSH    DE              ; Vorkommastellen / Nachkommastellen retten
        CALL    A7CE0           ; Zahl aufbereiten in ASCII, wenn ohne Exponent m√∂glich
        JP      C,A6367         ; nicht ohne Exponent m√∂glich -->  Fehler 2  Overflow error
        POP     HL              ; Vorkommastellen / Nachkommastellen holen
        PUSH    HL              ; und wieder merken
        LD      H,0             ; High - Byte Offset auf Null
        INC     L               ; Nachkommastellen angegeben  ?
        JR      Z,A8199         ; nein
        DEC     L               ; Z√§hler wieder corrigieren
A8199:  LD      DE,S9E7B        ; Zeiger auf Speicher f√ºr Nachkommastellen
        ADD     HL,DE           ; Zeiger auf Rundungsstelle errechnen
        LD      A,(HL)          ; Stelle holen
        LD      (HL),NUL        ; Textendezeichen eintragen
        DEFB    LD_DE           ; n√§chsten Befehl √ºberspringen
A81A1:  LD      (HL),'0'        ; Rundungsstelle l√∂schen
        CP      '5'             ; aufrunden  ?
        JR      C,A81B6         ; nein
A81A7:  DEC     HL              ; Zeiger auf Stelle davor
        LD      A,(HL)          ; Zeichen an Stelle holen
        CP      '.'             ; Dezimalpunkt  ?
        JR      Z,A81A7         ; ja -->  n√§chste Ziffer suchen
        INC     A               ; Stelle plus eins
        JP      Z,A6367         ; Zahlanfang -->  Fehler 2  Overflow error
        LD      (HL),A          ; gerundete Stelle eintragen
        CP      '9' + 1         ; √úberlauf in Ziffernstelle  ?
        JR      Z,A81A1         ; ja -->  weiter aufrunden
A81B6:  LD      HL,S11A3        ; Zeiger auf Speicher f√ºr Aufbereitung nach Format
        LD      DE,256*' ' + 0  ; ' ' =Leerzeichen  / 0 = 256 Zeichen
A81BC:  LD      (HL),D          ; ein Zeichen des Speichers l√∂schen
        INC     HL              ; Zeiger auf Speicher auf n√§chste Stelle
        DEC     E               ; Z√§hler minus eins
        JR      NZ,A81BC        ; weitere Stellen l√∂schen
        POP     HL              ; H = Vorkommastellen / L = Nachkommastellen
        PUSH    HL              ; Stellen wieder merken
        LD      E,H             ; Anzahl Vorkommastellen
        LD      D,0             ; High - Byte Offset auf Null
        LD      HL,S11A4        ; Zeiger auf Anfang Speicher
        ADD     HL,DE           ; Zeiger auf Stelle f√ºr Dezimalpunkt errechnen
        PUSH    HL              ; Dezimalpunktstelle retten
        LD      HL,S9E71        ; Zeiger auf Speicher zur Zahlaufbereitung in ASCII
        LD      (HL),' '        ; Leerzeichen  (Space) als Vorzeichen eintragen
        INC     HL              ; Zeiger auf ASCII - Zahlwert
        LD      D,7             ; maximal 7 Vorkommastellen
A81D3:  LD      A,(HL)          ; eine Vorkommastelle holen
        CP      '0'             ; Null  ?
        JR      NZ,A81DE        ; nein -->  relevante Ziffer
        LD      (HL),' '        ; Vornull gegen Leerzeichen  (Space) austauschen
        INC     HL              ; Zeiger auf ASCII - Zahlwert auf n√§chste Stelle
        DEC     D               ; Restanzahl zu √ºberpr√ºfender Stellen minus eins
        JR      NZ,A81D3        ; n√§chste Stelle √ºberpr√ºfen
A81DE:  POP     HL              ; Zeiger auf Stelle f√ºr Dazimalpunkt holen
        PUSH    HL              ; und wieder merken
        LD      B,E             ; Anzahl Vorkommastellen duplizieren
        LD      A,B             ; Anzahl Vorkommastellen holen
        OR      A               ; gleich Null  ?
        JR      Z,A81FC         ; ja -->  keine Vorkommastellen
        LD      DE,S9E7A        ; Zeiger auf Stelle f√ºr Dezimalpunkt
A81E8:  DEC     HL              ; Zeiger f√ºr Vorkommastelle
        DEC     DE              ; Zeiger auf Vorkommastelle
        LD      A,(DE)          ; eine aufbereitete Vorkommastelle holen
        LD      (HL),A          ; und im Speicher merken
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A81FC         ; ja -->  fertig
        DJNZ    A81E8           ; weitere Vorkommastellen √ºbertragen
        DEC     DE              ; Zeiger auf ASCII - Zahlwert
        LD      A,(DE)          ; eine Stelle holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A81FC         ; ja -->  Format ist OK
        INC     A               ; Zahlanfangzeichen  ?
        JP      NZ,A6367        ; nein -->  Fehler 2  Overflow error
A81FC:  POP     HL              ; Zeiger auf Dezimalpunkt holen
        POP     DE              ; Vorkommastellen / Nachkommastellen holen
        INC     E               ; Anzahl Nachkommastellen
        JR      Z,A8210         ; keine Nachkommastellen aufbereiten
        LD      B,E             ; Anzahl aufzubereitende Nachkommastellen
        LD      DE,S9E7B        ; Zeiger auf Speicher f√ºr Nachkommastellen
        LD      (HL),'.'        ; Dezimalpunkt eintragen
A8207:  INC     HL              ; Dezimalpunkt √ºberspringen
        DEC     B               ; Restanzahl Nachkommastellen minus eins
        JR      Z,A8210         ; fertig -->  Textendezeichen eintragen
        LD      A,(DE)          ;! eine Nachkommastelle √ºbertragen
        INC     DE              ;!
        LD      (HL),A          ;!
        JR      A8207           ; untersuchen, ob weitere Nachkommastellen
;
A8210:  LD      (HL),NUL        ; Textendezeichen hinter Zahlwert eintragen
        LD      DE,S11A4        ; Zeiger auf Anfang aufbereiteten ASCII-Zahlwert
        RET
;
;
;   ASCII - Text - Zeile (DE) umsetzen in Zwischencodezeile nach (HL)
;
A8216:  PUSH    DE              ;! Register - Werte retten
        PUSH    BC              ;!
        LD      C,0             ; Vorgabe f√ºr L√§ngenz√§hler der Zwischencodezeile
        DEC     DE              ; Zeiger auf ASCII-Text f√ºr Schleife corrigieren
A821B:  INC     DE              ; Zeiger auf ASCII-Text auf n√§chstes Zeichen
A821C:  CALL    A839C           ; Leerzeichen (DE) nach (HL) √ºbertragen
        OR      A               ; Zeilenendezeichen  ?
        JR      Z,A8253         ; ja -->  merken und gerettete Register holen
        CP      0FFH            ; PI  ?
        JR      Z,A8257         ; ja -->  Zwischencode f√ºr PI vorgeben
        CP      080H            ; schon Zwischencodezeichen  ?
        JP      NC,A6364        ; ja -->  Fehler 1  Syntax error
        CP      ' '             ; Steuerzeichen  ?
        JR      C,A821B         ; ja -->  vergessen und n√§chstes Zeichen untersuchen
        LD      IX,A821C        ; R√ºcksprungadresse f√ºr Umsetzung des n√§chsten Zeichens
        PUSH    IX              ; auf Stack ablegen
        CP      '\"'            ; Textanfangzeichen  ?
        JR      Z,A8272         ; ja -->  Text bis Ende der Textkonstanten √ºbertragen
        CP      '\''            ; Kommentarkennzeichen  ?
        JR      Z,A8265         ; ja -->  Text bis Ende Kommentar √ºbertragen
        CP      '?'             ; Fragezeichen als Abk√ºrzung f√ºr PRINT  ?
        JR      Z,A825E         ; ja -->  Zwischencode f√ºr PRINT eintragen
        CP      '.'             ; Dezimalpunkt  ?
        JP      Z,A83BF         ; ja -->  Zahlwert umsetzen in internes Format
        CP      '$'             ; Kennung Hex - Wert  ?
        JP      Z,A83D9         ; ja -->  Zahlwert umsetzen
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        JR      C,A829A         ; nein -->  untersuchen, ob BASIC - Befehl
        JP      A83A6           ; auf Zahlwert untersuchen; wenn ja -->  Zahl umsetzen
;
A8253:  LD      (HL),A          ; Textendezeichen eintragen
        POP     BC              ;! gerettete Register - Werte holen
        POP     DE              ;!
        RET
;
;
;   Zwischencode f√ºr Pi im Zwischencodetext merken
;
A8257:  LD      (HL),____PI     ; Zwischencode (Token) f√ºr Pi eintragen
        CALL    A827E           ; Zeiger f√ºr Zwischencode und L√§ngenz√§hler corrigieren
        JR      A821C           ; Resttext untersuchen und umsetzen
;
;
;   Zwischencode f√ºr PRINT statt Fragezeichen merken
;
A825E:  LD      A,_PRINT        ; Zwischencode (Token)  PRINT
        CALL    A827D           ; Zwischencode merken und Zeiger corrigieren
        JR      A82D5           ; auf Befehle mit Sonderbehandlung untersuchen
;
;
;   Kommentartext bis Ende Kommentar √ºbertragen
;
A8265:  LD      (HL),':'        ; Doppelpunkt im Zwischencodetext eintragen
        CALL    A827E           ; Zeiger f√ºr Zwischencode und L√§ngenz√§hler corrigieren
        LD      (HL),'\''       ; Code for 'Kommentar'  in Zwischencodetext eintragen
        CALL    A827F           ; Zwischencodezeiger und L√§ngenz√§hler corrigieren
        JP      A833C           ; Text (DE) bis Befehlsende in Zwischencodetext √ºbernehmen
;
;
;   Text bis Ende der Textkonstanten √ºbertragen
;
A8272:  LD      (HL),A          ; ein Textzeichen merken
        CALL    A827E           ; Zeiger f√ºr Zwischencode und L√§ngenz√§hler corrigieren
A8276:  LD      A,(DE)          ; ein Textzeichen holen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja -->  fertig
        CP      '\"'            ; Textendezeichen  ?
        JR      NZ,A8272        ; nein -->  Zeichen merken
A827D:  LD      (HL),A          ; Zeichen f√ºr Zwischencodetext merken
A827E:  INC     DE              ; Zeiger auf ASCII-Text auf n√§chstes Zeichen
A827F:  INC     HL              ; Zeiger f√ºr Zwischencodetext auf n√§chstes Zeichen
A8280:  INC     C               ; Z√§hler 'Anzahl umgesetzte Zeichen' plus eins
        RET     NZ              ; noch OK
        JP      A6379           ; Fehler 8   Line lenght error
;
A8285:  POP     BC              ; geretteten Z√§hler 'Anzahl umgesetzte Zeichen' holen
        LD      A,(DE)          ; n√§chstes ASCII-Text-Zeichen holen
        CALL    A79FD           ; Zeichen im Accu gleich Variablennamenzeichen  ?
        JR      C,A827D         ; nein -->  Zwischencode merken und Zeiger corrigieren
A828C:  CALL    A827D           ; Zwischencode merken und Zeiger corrigieren
        LD      A,(DE)          ; n√§chstes ASCII - Text - Zeichen holen
        CP      '$'             ; Kennung Zeichenkettenvariable  ?
        JR      Z,A827D         ; ja -->  Zwischencode merken und Zeiger corrigieren
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        RET     C               ; nein
        JR      A828C           ; Ziffer merken und weiter untersuchen
;
;
;   Examine text (DE) for BASIC command word
;   if so --> convert to correct intermediate code
;
A829A:  PUSH    BC              ; Save line length
        LD      BC,M5973        ; Pointers to BASIC command words specify table one
        CALL    A834B           ; Find text (DE) in BASIC command word table (BC).
        JR      NC,A82D1        ; Command found --> remember intermediate code
        LD      BC,M5B16        ; Pointers to BASIC command words provide table two
        CALL    A834B           ; Find text (DE) in BASIC command word table (BC).
        LD      C,0FEH          ; Prebyte for table two
        JR      NC,A82B7        ; Command found --> note prebyte and intermediate code
        LD      BC,M5BAD        ; Pointers to BASIC Command Words Table Three
        CALL    A834B           ; Find text (DE) in BASIC command word table (BC).
        LD      C,0FFH          ; Prebyte for table three
        JR      C,A8285         ; Command not found --> remember text characters
A82B7:  LD      (HL),C          ; Remember prebyte of table in intermediate code text
        INC     HL              ; Skip prebyte
        LD      (HL),A          ; Note the intermediate code of the command
        POP     BC              ; Get saved counter 'Number of converted characters'
        CALL    A8280           ; Correct pointer for intermediate code and counter
        CALL    A827F           ; Correct intermediate code pointer and length counter
        CP      ___ERL          ; Function ERL (intermediate code) ?
        RET     NZ              ; no
        CALL    A839C           ; Transfer spaces (DE) to (HL).
        CP      '='             ; Equal  ?
        RET     NZ              ; no
        LD      (HL),____EQ     ; Enter intermediate code for =
        CALL    A827E           ; Correct pointer for intermediate code and length counter
        JR      A8311           ; examine for label name or line number
;
A82D1:  POP     BC              ; Repeat saved counter 'Number of converted characters'
        CALL    A827F           ; Correct intermediate code pointer and length counter
A82D5:  CP      ___REM          ; Basic command REM ?
        JR      Z,A833C         ; Yes --> Text (DE) to end of command in intermediate code text.
        CP      __DATA          ; Basic command DATA ?
        JR      Z,A833C         ; Yes --> Text (DE) to end of command in intermediate code text.
        CP      __ELSE          ; Basic command ELSE ?
        JR      Z,A8332         ; yes --> enter a colon in front of ELSE
        CP      __THEN          ; Basic command THEN ?
        JR      Z,A8311         ; examine for label name or line number
        CP      0E0H              
        RET     NC              ; only arithmetic functions
        PUSH    AF              ; Note the intermediate code of the command
        CALL    A839C           ; Transfer spaces (DE) to (HL).
        CP      '/'             ; dash (slash) ?
        JR      NZ,A82FD        ; no --> check for number cross
        LD      (HL),___DIV     ; Remember intermediate code for /
        CALL    A827E           ; Correct pointer for intermediate code and length counter
        CALL    A79BC           ; Pointer in DE to next relevant character
        CALL    A827D           ; Memorize intermediate code and correct pointer
        JR      A830D           ; check for command with jump address
;
A82FD:  CP      '#'             ; number cross ?
        JR      NZ,A830D        ; no --> check for command with jump address
        CALL    A827D           ; Memorize intermediate code and correct pointer
        CALL    A79BC           ; Pointer in DE to next relevant character
        CALL    A79F6           ; character in accu same digit ?
        CALL    NC,A83A6        ; yes --> convert numerical value
A830D:  POP     AF              ; Get intermediate code of command
        CP      08DH            ; Command with line number or label ?
        RET     NC              ; no
;
;
;   examine for label name or line number
;
A8311:  CALL    A839C           ; Transfer spaces (DE) to (HL).
        CP      '\"'            ; identifier label name ?
        JR      NZ,A831D        ; no --> investigate further
        CALL    A8272           ; Transfer text to the end of the text constant
        JR      A8311           ; examine whether additional jump addresses
;
A831D:  CP      ','
        RET     C               ; kein Trennungszeichen zwischen Sprungadressen
        CP      '/'
        JR      C,A832D         ; Trennungszeichen merken und weiter untersuchen
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        RET     C               ; nein -->  kein Sprungziel
        CALL    A83D0           ; ASCII - Zeilennummer umsetzen und mit Kennung merken
        JR      A8311           ; auf Labelnamen oder Zeilennummer untersuchen
;
A832D:  CALL    A827D           ; Zwischencode merken und Zeiger corrigieren
        JR      A8311           ; auf Labelnamen oder Zeilennummer untersuchen
;
;
;   Doppelpunkt vor ELSE eintragen
;
A8332:  DEC     HL              ; Zeiger auf Stelle mit Zwischencode ELSE
        LD      (HL),':'        ; hier Doppelpunkt eintragen
        INC     HL              ; Doppelpunkt √ºberspringen
        LD      (HL),A          ; und wieder Zwischencode  ELSE  eintragen
        CALL    A827F           ; Zwischencodezeiger und L√§ngenz√§hler corrigieren
        JR      A8311           ; auf Labelnamen oder Zeilennummer untersuchen
;
;
;   Text (DE) to end of command in intermediate code text
;
A833C:  LD      A,(DE)          ; ein Zeichen ASCII - Text holen
        CALL    A5966           ; testen, ob Accu gleich Befehlsendezeichen
        RET     Z               ; Befehlsende -->  Text √ºbertragen
        CALL    A827D           ; Zwischencode merken und Zeiger corrigieren
        CP      '\"'            ; Textanfangszeichen  ?
        CALL    Z,A8276         ; ja -->  Text bis Textende √ºbertragen
        JR      A833C           ; Text bis Befehlsende √ºbertragen
;
;
;   Find text (DE) in BASIC - command word table (BC).
;
A834B:  PUSH    HL              ; Save pointer to memory for intermediate code text
        PUSH    DE              ; Pointer to start ASCII - save text
        LD      H,B             ;! Pointer to command word table after HL
        LD      L,C             ;!
        LD      B,07FH          ; Default for intermediate code
A8351:  POP     DE              ; Pointer to beginning of ASCII - get text
        PUSH    DE              ; and remember again
        INC     B               ; Intermediate code counter plus one
        LD      A,(HL)          ; Get a character from the table
        CP      -1              ; end-of-table character ?
        JR      NZ,A835D        ; no --> compare text
        POP     DE              ; Pointer to beginning of ASCII - get text
        POP     HL              ; Get pointer to memory for intermediate code text
        SCF                     ; Set command word not found code
        RET
;
A835D:  CP      '.'             ; Punkt  ?
        JR      NZ,A836A        ; nein
        INC     HL              ; Punkt in Tabelle √ºberspringen
        DEC     DE              ; Zeiger auf ASCII - Text auf letztes Zeichen
        LD      A,(DE)          ; letztes ASCII - Zeichen holen
        INC     DE              ; Zeiger wieder auf aktuelles Zeichen stellen
        CALL    A79FD           ; Zeichen im Accu gleich Variablennamenzeichen  ?
        JR      NC,A8389        ; ja -->  n√§chstes Befehlswort in Tabelle suchen
A836A:  LD      A,(DE)          ; ein Zeichen ASCII - Text holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      NZ,A837B        ; nein -->  Zeichen vergleichen
        LD      A,(HL)          ; ein Zeichen aus Tabelle holen
        AND     01111111B       ; ASCII - Zeichen maskieren
        SUB     'A'             ;! Buchstabe  ?
        CP      26              ;!
        JR      C,A8389         ; ja -->  n√§chstes Befehlswort in Tabelle suchen
        CALL    A79BB           ; Leerzeichen im Text (DE) √ºberspringen
A837B:  LD      C,(HL)          ; ein Zeichen aus Befehlsworttabelle holen
        INC     HL              ; Zeiger auf Tabelle auf n√§chstes Zeichen
        INC     DE              ; Zeiger auf ASCII-Text auf n√§chstes Zeichen
        CP      '.'             ; Punkt   (f√ºr Abk√ºrzung)
        JR      Z,A8391         ; ja -->  untersuchen, ob Abk√ºrzung erlaubt
        SUB     C               ; ASCII-Zeichen mit Tabellenzeichen vergleichen
        JR      Z,A836A         ; gleich -->  n√§chstes Zeichen vergleichen
        CP      080H            ; Tabellenendezeichen verglichen  ?
        JR      Z,A8397         ; ja -->  Befehlswort gefunden
A8389:  DEC     HL              ; Zeiger auf Tabelle auf letztes verglichenes Zeichen
A838A:  BIT     7,(HL)          ; Wortendezeichen  ?
        INC     HL              ; Zeiger auf Tabelle auf n√§chstes Zeichen
        JR      Z,A838A         ; nein -->  Ende Befehlswort suchen
        JR      A8351           ; ASCII - text mit n√§chstes Wort in Tabelle vergleichen
;
A8391:  LD      A,B             ; Zwischencodez√§hler holen
        CP      0E8H
        JR      NC,A8389        ; logischer Befehl -->  Abk√ºrzung nicht erlaubt
        CCF                     ; Flag auf 'Wort gefunden' setzen
A8397:  POP     HL              ; Zeiger auf Anfang ASCII-Text verwerfen
        POP     HL              ; Zeiger f√ºr Zwischencodetext holen
        LD      (HL),B          ; gefundenen Zwischencode merken
        LD      A,B             ; Zwischencode des Befehls holen
        RET
;
;
;   Leerzeichen (DE) nach (HL) √ºbertragen
;
A839C:  LD      A,(DE)          ; ein ASCII - Textzeichen holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        RET     NZ              ; nein
        LD      (HL),A          ; Leerzeichen merken
        CALL    A827E           ; Zeiger f√ºr Zwischencode und L√§ngenz√§hler corrigieren
        JR      A839C           ; auf weitere Leerzeichen untersuchen
;
;
;   auf Zahlwert untersuchen; wenn ja -->  Zahl umsetzen
;
A83A6:  EX      AF,AF           ; ASCII - Textzeichen retten
        PUSH    DE              ; Zeiger auf ASCII - Text retten
        CALL    A79BB           ; Leerzeichen im Text (DE) √ºberspringen
        POP     DE              ; Zeiger auf ASCII - Text retten
        CALL    A79F6           ; Zeichen im Accu gleich Ziffer  ?
        JR      NC,A83BF        ; ja -->  Zahlwert umsetzen in internes Format
        CP      '.'             ; Dezimalpunkt  ?
        JR      Z,A83BF         ; ja -->  Zahlwert umsetzen in internes Format
        CP      'E'             ; Exponentenkennung  ?
        JR      Z,A83BF         ; ja -->  Zahlwert umsetzen in internes Format
        EX      AF,AF           ; gerettetes Textzeichen holen
        SUB     '0'-1           ; einzelne Ziffer umsetzen in Zwischencode
        JP      A83BF           ; Zahlwert umsetzen in internes Format
;
;
;   Zahlwert umsetzen in internes Format und im Zwischencodetext merken
;
A83BF:  PUSH    BC              ; Z√§hler 'Anzahl umgesetzte Zeichen' retten
        LD      (HL),__REAL     ; Code for 'Real - Zahlwert'  eintragen
        INC     HL              ; Zwischencode √ºberspringen
        PUSH    HL              ; Zeiger auf Stelle f√ºr Real - Zahlwert merken
        CALL    A7A0E           ; ASCII-Text (DE) umsetzen in Real - Wert nach (HL)
        POP     HL              ; Zeiger auf Real - Zahlwert holen
        LD      BC,5            ; L√§nge Real - Zahlwert
        ADD     HL,BC           ; Zeiger auf Ende Zahlwert errechnen
        LD      A,6             ; 6 Zeichen neu hinzugekommen
        JR      A83F3           ; Z√§hler 'Anzahl umgesetzte Zeichen' corrigieren
;
;
;   ASCII - Zeilennummer umsetzen und mit Kennung merken
;
A83D0:  PUSH    BC              ; Z√§hler  'Anzahl umgesetzte Zeichen'  retten
        CALL    A8532           ; ASCII - Wert (DE) umsetzen in Hex-Wert nach BC
        LD      (HL),_LINNO     ; Code for 'Zeilennummer'  eintragen
        INC     HL              ; Code √ºberspringen
        JR      A83ED           ; Z√§hler  'Anzahl umgesetzte Zeichen'  corrigieren
;
;
;   Sedezimalwert (DE) umsetzen in internes Format nach (HL)
;
A83D9:  LD      (HL),A          ; $ - Zeichen erst einmal merken
        INC     DE              ; Zeiger auf ASCII-Text auf n√§chstes Zeichen
        LD      A,(DE)          ; n√§chstes ASCII - Textzeichen holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    21              ; Code 21  Sedezimal-Zeichen im Accu umsetzen in Hex-Wert
        JP      C,A827F         ; kein Hex-Wert -->  Zwischencodezeiger und L√§ngenz√§hler corrigieren
        PUSH    BC              ; Z√§hler  'Anzahl umgesetzte Zeichen'  retten
        LD      (HL),_HEXNO     ; Kennung  'Sedezimalwert'  eintragen
        INC     HL              ; Wertkennung √ºberspringen
        PUSH    HL              ; Zeiger auf Stelle f√ºr Hex - Wert merken
        EX      DE,HL           ; Zeiger auf ASCII - Text nach HL
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    20              ; Code 20   Sedezimal-Wert (HL) umsetzen in Hex-Wert nach DE
        LD      B,D             ;! bereitgestellten Wert nach BC
        LD      C,E             ;!
        EX      DE,HL           ; Zeiger auf Rest ASCII - Text nach DE
        POP     HL              ; Zeiger auf Stelle f√ºr Zahlwert holen
A83ED:  LD      A,3             ; Vorgabe 3 neue Zeichen im Zwischencodetext
        LD      (HL),C          ; Low - Byte Wert eintragen
        INC     HL              ; Low - Byte Wert √ºberspringen
        LD      (HL),B          ; High - Byte Wert eintragen
        INC     HL              ; High - Byte Wert √ºberspringen
A83F3:  POP     BC              ; Z√§hler  'Anzahl umgesetzte Zeichen'  holen
        ADD     A,C             ; neue Anzahl Zeichen addieren
        JP      C,A6379         ; √úberlauf -->  Fehler 8  Line lenght error
        LD      C,A             ; neue Anzahl umgesetzter Zeichen merken
A83F9:  DEC     DE              ; Zeiger auf ASCII-Text auf letztes Zeichen
        LD      A,(DE)          ; ASCII - Zeichen holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      Z,A83F9         ; ja -->  letztes relevantes Zeichen suchen
        INC     DE              ; Zeiger auf n√§chstes abzuarbeitendes Zeichen
        RET
;
;
;   Zwischencodezeile (HL) umsetzen in ASCII-Text nach (DE)
;
A8401:  PUSH    HL              ; Zeiger auf Zwischencodezeile retten
        PUSH    DE              ; Zeiger auf Speicher f√ºr ASCII retten
        PUSH    BC              ; Register - Wert retten
        EXX
        LD      B,0             ; Vorgabe f√ºr Z√§hler  'umgesetzte Zeichen'
        EXX
        LD      C,0             ; Vorgabe f√ºr L√§ngez√§hler
T840A:  LD      A,(HL)          ; ein Zeichen Zwischencodetext holen
        OR      A               ; Zeilenendezeichen  ?
        JR      Z,A843E         ; ja -->  merken und gerettete Register holen
        LD      BC,T840A        ; R√ºcksprungadresse f√ºr n√§chstes Zeichen
        PUSH    BC              ; auf Stack ablegen
        CP      '\''            ; Anfang Kommentar  ?
        JR      Z,A8458         ; ja -->  Text (HL) bis Befehlsende nach (DE) √ºbertragen
        INC     HL              ; Zwischencodezeichen √ºberspringen
        LD      BC,M5973        ; Zeiger auf BASIC-Befehlsw√∂rter Tabelle eins vorgeben
        CP      ' '             ; Steuerzeichen  ?
        JR      C,A8480         ; ja -->  in entsprechenden Zahlwert umsetzen
        CP      '\"'            ; Textanfangszeichen  ?
        JR      Z,A8469         ; ja -->  Text (HL) nach (DE) √ºbertragen
        CP      ':'             ; Doppelpunkt  ?
        JR      Z,A8476         ; ja -->  bei Kommentar und ELSE vergessen
        CP      ___REM          ; Zwischencode  REM  ?
        JR      Z,A8454         ; ja -->  Text (HL) bis Ende Befehl nach (DE) √ºbertragen
        CP      __DATA          ; Zwischencode  DATA  ?
        JR      Z,A8454         ; ja -->  Text (HL) bis Ende Befehl nach (DE) √ºbertragen
        CP      ____PI          ; Zwischencode  Pi  ?
        JR      Z,A8443         ; ja -->  Zeichen f√ºr Pi nach (DE) eintragen
        CP      0FEH            ; Vorbyte f√ºr Befehlsworttabellen  ?
        JR      NC,A8448        ; ja -->  Basic - Befehlswort aufbereiten
        CP      080H            ; Zwischencode  ?
        JP      NC,A84C4        ; ja -->  Zwischencode umsetzen in ASCII - Text
        JP      A84E1           ; ASCII-Zeichen im Accu merken, Z√§hler corrigieren
;
A843E:  LD      (DE),A          ; Zeilenendezeichen merken
        POP     BC              ; geretteten Register - Wert holen
        POP     DE              ; Zeiger auf Anfang ASCII-Text holen
        POP     HL              ; Zeiger auf Zwischencodetext holen
        RET
;
A8443:  LD      A,0FFH          ; Pi   (Sharp - ASCII - Code)
        JP      A84E1           ; ASCII-Zeichen im Accu merken, Z√§hler corrigieren
;
A8448:  LD      BC,M5BAD        ; Zeiger auf BASIC-Befehlsw√∂rter Tabelle drei vorgeben
        JR      NZ,A8450        ; nicht Befehlsworttabelle zwei -->  Wort umsetzen
        LD      BC,M5B16        ; Zeiger auf BASIC-Befehlsw√∂rter Tabelle zwei vorgeben
A8450:  LD      A,(HL)          ; eigentlichen Zwischencode holen
        INC     HL              ; Zwischencode √ºberspringen
        JR      A84C4           ; Zwischencode umsetzen in ASCII - Text
;
;
;    Text (HL) bis Ende Befehl nach (DE) √ºbertragen
;
A8454:  CALL    A84C4           ; Zwischencode umsetzen in ASCII - Text
        RET     Z               ; Befehlsende
;
A8458:  LD      A,(HL)          ; n√§chstes Zwischencodezeichen holen
        CALL    A5966           ; testen, ob Accu gleich Befehlsendezeichen
        RET     Z               ; ja -->  fertig
        CALL    A84E1           ; ASCII-Zeichen im Accu merken, Z√§hler corrigieren
        LD      A,(HL)          ; Zwischencodezeichen noch einmal holen
        INC     HL              ; und √ºberspringen
        CP      '\"'            ; Textanfangzeichen  ?
        CALL    Z,A846C         ; ja -->  Text (HL) nach (DE) √ºbertragen
        JR      A8458           ; ja -->  Text (HL) bis Befehlsende nach (DE) √ºbertragen
;
;
;   Textkonstante (HL) nach (DE) √ºbertragen
;
A8469:  CALL    A84E1           ; ASCII-Zeichen im Accu merken, Z√§hler corrigieren
A846C:  LD      A,(HL)          ; n√§chstes Zwischencodezeichen holen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja -->  fertig
        INC     HL              ; Zwischencodezeichen √ºberspringen
        CP      '\"'            ; Textendezeichen  ?
        JR      NZ,A8469        ; nein -->  weitere Zeicehn √ºbertragen
        JR      A84E1           ; ASCII-Zeichen im Accu merken, Z√§hler corrigieren
;
;
;   bei Doppelpunkt auf ELSE oder Kommentar untersuchen
;
A8476:  LD      (DE),A          ; Doppelpunkt f√ºr ASCII - Text merken
        LD      A,(HL)          ; n√§chstes Zwischencodezeichen holen
        CP      __ELSE          ; Zwischencode  ELSE  ?
        RET     Z               ; ja -->  Doppelpunkt vergessen
        CP      '\''            ; Kommentaranfang
        RET     Z               ; ja -->  Doppelpunkt vergessen
        JR      A84E4           ; Zeiger f√ºr ASCII-Text  und Z√§hler corrigieren
;
;
;   Zwischencodekennung in entsprechenden Zahlwert umsetzen
;
A8480:  CP      __REAL          ; Kennung Real - Zahlwert  ?
        JR      Z,A84B4         ; ja -->  Real - Wert aufberieten in ASCII
        CP      _LINNO          ; Kennung  Zeilennummer / Hex - Wert etc  ?
        JR      NC,A848D        ; ja -->  umsetzen in ASCII - Zeichen
        DEC     A               ; Steuerzeichen auf Dezimalwert corrigieren
        OR      '0'             ; und umsetzen in ASCII - Zeichen
        JR      A84E1           ; ASCII-Zeichen im Accu merken, Z√§hler corrigieren
;
A848D:  PUSH    DE              ; Zeiger auf Speicher f√ºr ASCII - Wert retten
        LD      E,(HL)          ;! Wert aus Zwischencodetext holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL              
        PUSH    HL              ; Zeiger auf Zwischencodetext retten
        CP      _INTNO          ; Code  `Integer - Wert'  ?
        JR      Z,A84A3         ; ja -->  Integer - Wert umsetzen in ASCII
        CP      _LIN_P          ; Zeiger auf Zeile  ?
        JR      C,A84A3         ; nein -->  Zeilennummer umsetzen in ASCII
        JR      NZ,A84F0        ; nein -->  Hex - Wert umsetzen in ASCII
        EX      DE,HL           ; Zeiger auf Zeile nach HL
        INC     HL              ;! Offset auf n√§chste Zeile √ºberspringen
        INC     HL              ;!
        LD      E,(HL)          ;! Zeilennummer der Zeile holen
        INC     HL              ;!
        LD      D,(HL)          ;!
A84A3:  EX      DE,HL           ; aufzubereitenden Wert nach HL
        CALL    A7998           ; Hex - Wert in HL umsetzen in Dezimal - ASCII nach Zwischenspeicher
        LD      B,D             ;! Zeiger auf aufbereiteten Zahlwert nach BC
        LD      C,E             ;!
        POP     HL              ; Zeiger auf Zwischencodetext holen
        POP     DE              ; Zeiger auf Speicher f√ºr ASCII - Text holen
A84AB:  LD      A,(BC)          ; auf aufbereitetes Textzeichen holen
        OR      A               ; Textendezeichen  ?
        RET     Z               ; ja -->  fertig
        CALL    A84E1           ; ASCII-Zeichen im Accu merken, Z√§hler corrigieren
        INC     BC              ; Zeiger auf aufbereiteten Text auf n√§chstes Zeichen
        JR      A84AB           ; weitere Zeichen Zahltext √ºbertragen
;
;
;   Real - Zahlwert (HL) aufbereiten in ASCII - Text nach (DE)
;
A84B4:  PUSH    HL              ; Zeiger auf Zwischencodetext retten
        PUSH    DE              ; Zeiger f√ºr ASCII - Text retten
        CALL    A7D4E           ; Real - Zahlwert (HL) aufbereiten in ASCII - Text
        LD      B,D             ;! Zeiger auf aufbereiteten Zahlwert nach
        LD      C,E             ;! BC kopieren
        POP     DE              ; Zeiger auf Speicher f√ºr ASCII - Text holen
        POP     HL              ; Zeiger auf Zwischencodetext holen
        INC     HL              ;! aufbereiteten Real - Zahlwert im
        INC     HL              ;! Zwischencodetext √ºberspringen
        INC     HL              ;!
        INC     HL              ;!
        INC     HL              ;!
        JR      A84AB           ; aufbereiteten Zahlwert nach ASCII-Text-Speicher √ºbertragen
;
;
;   Zwischencode im Accu nach Tabelle (BC) umsetzen in ASCII - Text
;
A84C4:  CP      080H            ; Zwischencode
        JR      Z,A84D2         ; Zeiger steht auf richtigem Text
        EX      AF,AF           ; Rest Zwischencodez√§hler retten
A84C9:  LD      A,(BC)          ; ein Zeichen aus Tabelle holen
        RLCA                    ; Textendebit nach Carry schieben
        INC     BC              ; Zeiger auf Texttabelle auf n√§chstes Zeichen
        JR      NC,A84C9        ; nicht Textende -->  Ende des Wortes suchen
        EX      AF,AF           ; geretteten Zwischencodez√§hler wieder holen
        DEC     A               ; minus eins
        JR      A84C4           ; und testen, ob Zeiger auf richtigem Wort steht
;
A84D2:  LD      A,(BC)          ; ein Textzeichen aus Tabelle holen
        BIT     7,A             ; Wortendebit gesetzt  ?
        JR      NZ,A84DF        ; ja -->  letztes Zeichen des Wortes eintragen
        CP      '.'             ; Punkt  ?
        CALL    NZ,A84E1        ; nein -->  ASCII-Zeichen im Accu merken, Z√§hler corrigieren
        INC     BC              ; Zeiger auf Texttabelle auf n√§chstes Zeichen
        JR      A84D2           ; n√§chstes Tabellenzeichen aufbereiten
;
;
;   ASCII-Zeichen im Accu merken und Z√§hler f√ºr L√§nge der ASCII - Text - Zeile corrigieren
;
A84DF:  AND     01111111B       ; eigentliches ASCII - Zeichen maskieren
A84E1:  LD      (DE),A          ; ASCII - Text - Zeichen merken
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja -->  fertig
A84E4:  INC     DE              ; eingetragenes Zeichen √ºberspringen
        EXX
        INC     B               ; Z√§hler  'Anzahl umgesetzte Zeichen' plus eins
        EXX
        RET     NZ              ; Z√§hler noch OK
        XOR     A               ; Code for 'Zeilenende'
        LD      (DE),A          ; hinter Text eintragen
        DEC     DE              ; und Zeiger f√ºr Text corrigieren
        EXX
        DEC     B               ; Z√§hler wieder auf 255
        EXX
        RET
;
;
;   Hex - Wert in DE  umsetzen in ASCII - Text
;
A84F0:  LD      A,'$'           ; Kennung Hex - Wert
        EX      AF,AF           ; Kennung merken
        EX      DE,HL           ; Hex - Wert nach HL
        CALL    A8501           ; Hex - Wert in HL aufbereiten in ASCII nach Speicher
        LD      B,D             ;! Zeiger auf aufbereiteten Text nach BC
        LD      C,E             ;!
        POP     HL              ; Zeiger auf Zwischencodetext holen
        POP     DE              ; Zeiger auf Speicher f√ºr ASCII - Text holen
        EX      AF,AF           ; gerettete Zahlkennung wieder holen
        CALL    A84E1           ; ASCII - Zeichen im Accu merken, Z√§hler corrigieren
        JR      A84AB           ; aufbereiteten Zahlwert nach ASCII-Text-Speicher √ºbertragen
;
;
;   Hex - Wert in HL aufbereiten in Hex - ASCII - Wert nach Zwischenspeicher
;
A8501:  LD      DE,S9E76        ; Zeiger auf Speicher f√ºr Aufbereitung  Hex - Wert
        PUSH    DE              ; Zeiger auf Anfang Speicher merken
        LD      A,H             ; High - Byte Wert holen
        CALL    A851A           ; Byte im Accu umsetzen in zwei ASCII-Hex-Zeichen
        LD      A,L             ; Low - Byte Wert holen
        CALL    A851A           ; Byte im Accu umsetzen in zwei ASCII-Hex-Zeichen
        XOR     A               ; Code for 'Textende'
        LD      (DE),A          ; hinter aufbereiteten Zahlwert eintragen
        POP     DE              ; Zeiger auf Anfang Speicher holen
        LD      B,3             ; maximal drei Stellen auf Null √ºberpr√ºfen
A8512:  LD      A,(DE)          ; eine Stelle holen
        CP      '0'             ; gleich Null  ?
        RET     NZ              ; nein
        INC     DE              ; f√ºhrende Null vergessen
        DJNZ    A8512           ; weiteren Stellen √ºberpr√ºfen
        RET
;
;
;   Byte im Accu umsetzen in zwei ASCII - Hex - Zeichen nach (DE)
;
A851A:  PUSH    AF              ; auszugebendes Byte retten
        RRCA                    ;! High - Nibble auf Low - Nibble schieben
        RRCA                    ;!
        RRCA                    ;!
        RRCA                    ;!
        AND     00001111B       ; Low - Nibble maskieren
        CALL    A8527           ; Nibble aufbereiten in ASCII und merken
        POP     AF              ; aufzugebenden Zahlwert holen
        AND     00001111B       ; Low - Nibble maskieren
A8527:  ADD     A,'0'           ; umsetzen in ASCII
        CP      '9' + 1         ; Ziffer  ?
        JR      C,A852F         ; ja -->  Zeichen merken
        ADD     A,7             ; f√ºr A - F corrigieren
A852F:  LD      (DE),A          ; Hex - ASCII - Zeichen merken
        INC     DE              ; eingetragenes Zeichen √ºberspringen
        RET
;
;
;   ASCII - Wert (DE) umsetzen in Hex - Wert nach BC
;
A8532:  PUSH    HL              ; Zeiger f√ºr Zwischencodetext retten
        EX      DE,HL           ; Zeiger auf Dezimal - ASCII - Wert nach HL
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    19              ; Code 19   ASCII - Wert (HL) umsetzen in Hex-Wert nach DE
        LD      B,D             ;! bereitgestellten Wert nach BC kopieren
        LD      C,E             ;!
        EX      DE,HL           ; Zeiger auf Rest ASCII - Text wieder nach HL
        POP     HL              ; geretteten Zeiger f√ºr Zwischencodetext holen
        JP      A83F9           ; Zeiger auf letztes relevantes Zeichen stellen
;
;
;   Ausdruck (HL) auswerten und ein - Byte - Wert nach E/Accu bereitstellen
;
A853D:  CALL    A8551           ; zwei - Byte - Wert nach DE bereitstellen
;
;
;   untersuchen, ob bereitgestellter Wert zwischen 0 und 255 liegt
;
A8540:  LD      A,D             ; High - Byte Wert holen
        OR      A               ; gleich Null  ?
        JP      NZ,A636A        ; nein -->  Fehler 3   Illegal data error
        LD      A,E             ; Lwo -Byte Wert holen
        RET
;
;
;   Ausdruck (HL) auswerten und 2 - Byte - Wert nach DE
;   ohne vorherige Zwischenergebnisse zu vergessen
;
A8547:  CALL    A858E           ; Ausdruck (HL) auswerten
        DEC     DE              ;! Zeiger auf bereitgestellten Wert stellen
        DEC     DE              ;!
        DEC     DE              ;!
        DEC     DE              ;!
        DEC     DE              ;!
        JR      A8554           ; Real - Wert (DE) umsetzen in zwei - Byte - Wert
;
;
;   Ausdruck (HL) auswerten und zwei - Byte - Wert nach DE bereitstellen
;
A8551:  CALL    A857C           ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitst.
A8554:  PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        EX      DE,HL           ; Zeiger auf Wert nach HL
        CALL    A903F           ; Syntaxuntersuchung auf Real - Wert - Ergebnis
        CALL    A7BEA           ; Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
        EX      DE,HL           ; Ergebnis nach DE
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; n√§chstes Programmbyte holen
        RET
;
;
;   Stringausdruc√´ (HL¬© auswerte√Æ un√§ Zeige√≤ au√¶ Strin√ß nac√® DE bereitstellen
;
A8561:  CALL    A857C           ; Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitst.
        PUSH    AF              ; n√§chstes Programmbyte retten
        CALL    A9036           ; Syntaxuntersuchung auf Zeichenkettenergebnis
        PUSH    HL              ; Programmzeiger retten
        EX      DE,HL           ; Zeiger auf Stringdescriptor nach HL
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; n√§chstes Programmbyte holen
        RET
;
;
;   Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
;
A8570:  LD      B,(HL)          ; L√§nge der Zeichenkette holen
        INC     HL              ; L√§nge in Stringdescriptor √ºberspringen
        LD      E,(HL)          ;! Offset auf String auf Descriptor holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      HL,(S1076)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf String errechnen
        EX      DE,HL           ; Zeiger auf String nach DE
        LD      A,B             ; L√§nge der Zeichenkette holen
        RET
;
;
;   Ausdruck (HL) auswerten und Zeiger auf Ergebnis bereitstellen
;
A857C:  LD      DE,(S1078)      ; Anfang Stringarbeitsbereich holen
        LD      (S107A),DE      ; als Ende Stringarbeitsbereich merken
A8584:  LD      DE,(S107C)      ; Zeiger auf Anfang Rechenspeicher holen
        PUSH    DE              ; Zeiger f√ºr Ergebnis merken
        CALL    A858E           ; Ausdruck (HL) auswerten und Ergebnis bereitstellen
        POP     DE              ; Zeiger auf Ergebnis holen
        RET
;
;
;   Ausdruck (HL) mit allen Priorit√§ten auswerten
;
A858E:  PUSH    DE              ; Zeiger f√ºr Ergebnis retten
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        CALL    A8C08           ; √ºberpr√ºfen, ob Adresse in DE mit Stack kollidiert
        POP     DE              ; Zeiger f√ºr Ergebnis holen
        CALL    A85B2           ; Ausdruck mit Priorit√§t acht und h√∂her auswerten
A859A:  CP      ___XOR          ; Zwischencode  XOR  ?
        RET     NZ              ; nein
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode XOR √ºberspringen
        CALL    A85B2           ; Ausdruck mit Priorit√§t acht und h√∂her auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A959C           ; XOR - Routine aufrufen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; n√§chstes Programmbyte holen
        JR      A859A           ; auf weitere Funktionen mit gleicher Priorit√§t untersuchen
;
;
;   Ausdruck mit Priorit√§t acht und h√∂her auswerten
;
A85B2:  CALL    A85CD           ; Ausdruck mit Priorit√§t sieben und h√∂her auswerten
A85B5:  CP      ____OR          ; Zwischencode  OR  ?
        RET     NZ              ; nein
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode OR √ºberspringen
        CALL    A85CD           ; Ausdruck mit Priorit√§t sieben und h√∂her auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A9599           ; OR - Routine aufrufen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; n√§chstes Programmbyte holen
        JR      A85B5           ; auf weitere Funktionen mit gleicher Priorit√§t untersuchen
;
;
;   Ausdruck mit Priorit√§t sieben und h√∂her auswerten
;
A85CD:  CALL    A85E8           ; Ausdruck mit Priorit√§t sechs und h√∂her auswerten
A85D0:  CP      ___AND          ; Zwischencode  AND  ?
        RET     NZ              ; nein
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode  AND √ºberspringen
        CALL    A85E8           ; Ausdruck mit Priorit√§t sechs und h√∂her auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A9596           ; AND - Routine aufrufen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; n√§chstes Programmbyte holen
        JR      A85D0           ; auf weitere Funktionen mit gleicher Priorit√§t untersuchen
;
;
;   Ausdruck mit Priorit√§t sechs und h√∂her auswerten
;
A85E8:  CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFB    ___NOT          ; Zwischencode  NOT  ?
        JR      NZ,A85FD        ; nein -->  Ausdruck mit Priorit√§t f√ºnf und h√∂her auswerten
        CALL    A85FD           ; Ausdruck mit Priorit√§t f√ºnf und h√∂her auswerten
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        LD      HL,-5           ; L√§nge Real - Zahlwert
        ADD     HL,DE           ; Zeiger auf bereitgestellten Wert errechnen
        CALL    A9586           ; NOT - Routine aufrufen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; n√§chstes Programmbyte holen
        RET
;
;
;   Ausdruck mit Priorit√§t f√ºnf und h√∂her auswerten
;
A85FD:  CALL    A8667           ; Ausdruck mit Priorit√§t vier oder h√∂her auswerten
A8600:  CP      0EEH            ; Vergleichsbefehl  ?
        RET     C               ; nein
        PUSH    AF              ; n√§chstes Programmbyte retten
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und retten
        INC     HL              ; Zwischencode der Funktion √ºberspringen
        CALL    A8667           ; Ausdruck mit Priorit√§t vier oder h√∂her auswerten
        POP     BC              ; Wertart des erstes Wertes holen
        EX      (SP),HL         ; Programmzeiger retten / Vergleichsberfehl holen
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Vergleichsbefehl retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        EX      AF,AF           ; Ergebnis Vergleich retten 
        POP     AF              ; Vergleichsbefehl holen
        CP      ____LT          ; Zwischencode  <  ?
        JR      NZ,A863A        ; nein -->  weiter untersuchen
;
;
;   Auswertung  Vergleich  <
;
        EX      AF,AF           ; Ergebnis Vergleich holen
        JR      C,A8635         ; Vergleich ist erf√ºllt
;
;
;   Ergebnis  'Vergleich nicht erf√ºllt'  vorgeben
;
A861F:  LD      BC,0            ; Vorgabe f√ºr Wert Null  (logisch FALSE)
A8622:  LD      (HL),C          ; Exponenten eintragen
        INC     HL              ; eingetragenen Exponenten √ºberspringen
        LD      (HL),B          ; MSBYte Mantisse eintragen
        INC     HL              ; MSByte Mantisse √ºberspringen
        XOR     A               ; Accu auf Null
        LD      (HL),A          ;! Rest Mantisse auf Null setzen
        INC     HL              ;!
        LD      (HL),A          ;!
        INC     HL              ;!
        LD      (HL),A          ;!
        LD      A,5             ; Code for 'Real - Wert'  vorgeben
        LD      (S9E9C),A       ; im Wertart - Flag merken
        POP     AF              ; n√§chstes Programmbyte holen
        POP     HL              ; geretteten Programmzeiger holen
        JR      A8600           ; auf weitere Funktionen mit gleicher Priorit√§t untersuchen
;
;
;   Ergebnis  'Vergleich erf√ºllt'  vorgeben
;
A8635:  LD      BC,08081H       ; Vorgabe f√ºr -1  (logisch  TRUE)
        JR      A8622           ; Wert eintragen
;
A863A:  CP      ____GT          ; Zwischencode  >  ?
        JR      NZ,A8645        ; nein -->  weiter untersuchen
;
;
;   Auswertung  Vergleich  >
;
        EX      AF,AF           ; Ergebnis Vergleich holen
        JR      Z,A861F         ; Vergleich ist nicht erf√ºllt -->  0
        JR      C,A861F         ; Vergleich ist nicht erf√ºllt -->  0
        JR      A8635           ; Vergleich erf√ºllt -->  -1
;
A8645:  CP      ____EQ          ; Zwischencode  =  ?
        JR      NZ,A864E        ; nein -->  weiter untersuchen
;
;
;   Auswertung  Vergleich  =
;
        EX      AF,AF           ; Ergebnis Vergleich holen
        JR      Z,A8635         ; Vergleich erf√ºllt -->  -1
        JR      A861F           ; vergleich ist nicht erf√ºllt -->  0
;
A864E:  CP      ____GE          ; Zwischencode  =>  ?
        JR      C,A8657         ; nein -->  weiter untersuchen
;
;
;   Auswertung  Vergleich  =>  oder >=
;
        EX      AF,AF           ; Ergebnis Vergleich holen
        JR      NC,A8635        ; Vergleich ist erf√ºllt -->  -1
        JR      A861F           ; Vergleich ist nicht erf√ºllt -->  0
;
A8657:  CP      ____LE          ; Zwischencode  <  ?
        JR      C,A8662         ; nein
;
;
;   Asuwertung  Vergleich  =< oder <=
;
        EX      AF,AF           ; Ergebnis Vergleich holen
        JR      Z,A8635         ; Vergleich erf√ºllt -->  -1
        JR      C,A8635         ; Vergleich erf√ºllt -->  -1
        JR      A861F           ; Vergleich ist nicht erf√ºllt -->  0
;
;
;   Auswertung Vergleich  <> oder ><
;
A8662:  EX      AF,AF           ; Ergebnis Vergleich holen
        JR      Z,A861F         ; Vergleich ist nicht erf√ºllt -->  0
        JR      A8635           ; Vergleich ist erf√ºllt -->  -1
;
;
;   Ausdruck mit Priorit√§t vier oder h√∂her auswerten
;
A8667:  CALL    A8692           ; Ausdruck mit Priorit√§t drei oder h√∂her auswerten
A866A:  CP      __PLUS          ; Zwischencode  Plus/Minus  ?
        RET     C               ; nein
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode √ºberspringen
        JR      Z,A8684         ; Funktion plus
;
;
;   zweiten Parameter f√ºr -  - Routine bereitstellen
;
        CALL    A8692           ; Ausdruck mit Priorit√§t drei oder h√∂her auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
A8680:  POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; n√§chstes Programmbyte holen
        JR      A866A           ; auf weitere Funktionen mit gleicher Priorit√§t unersuchen
;
;
;   zweiten Parameter f√ºr +  - Routine bereitstellen
;
A8684:  CALL    A8692           ; Ausdruck mit Priorit√§t drei oder h√∂her auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        JR      A8680           ; auf weitere Funktionen mit gleicher Priorit√§t untersuchen
;
;
;   Ausdruck mit Priorit√§t drei oder h√∂her auswerten
;
A8692:  CALL    A86BD           ; Ausdruck mit Priorit√§t zwei oder h√∂her auswerten
A8695:  CP      __IDIV          ; Zwischencode  Backslash / MOD  ?
        RET     C               ; nein
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode √ºberspringen
        JR      Z,A86AF         ; Integer - Division
;
;
;   zweiten Parameter f√ºr MOD - Routine bereitstellen
;
        CALL    A86BD           ; Ausdruck mit Priorit√§t zwei oder h√∂her auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A95F2           ; MOD - Routine aufrufen
A86AB:  POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; n√§chstes Programmbyte holen
        JR      A8695           ; auf weitere Funktionen mit gleicher Priorit√§t untersuchen
;
;
;   zweiten Parameter f√ºr Integer - Division bereitstellen
;
A86AF:  CALL    A86BD           ; Ausdruck mit Priorit√§t zwei oder h√∂her auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A9611           ; Integer - Divisions - Routine aufrufen
        JR      A86AB           ; auf weitere Funktionen mit gleicher Priorit√§t untersuchen
;
;
;   Ausdruck mit Priorit√§t zwei oder h√∂her auswerten
;
A86BD:  CALL    A86E8           ; Ausdruck mit Priorit√§t eins oder h√∂her auswerten
A86C0:  CP      ___DIV          ; Zwischencode / oder *  ?
        RET     C               ; nein
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode √ºberspringen
        JR      Z,A86DA         ; Funktion  /  (geteilt)
;
;
;   zweiten Parameter f√ºr *  - Routine bereitstellen
;
        CALL    A86E8           ; Ausdruck mit Priorit√§t eins oder h√∂her auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
A86D6:  POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; n√§chstes Programmbyte holen
        JR      A86C0           ; auf weitere Funktionen mit gleicher Priorit√§t untersuchen
;
;
;   zweiten Parameter f√ºr /  - Routine bereitstellen
;
A86DA:  CALL    A86E8           ; Ausdruck mit Priorit√§t eins oder h√∂her auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A93D5           ; /  - Routine   ( (HL) = (HL) / (DE) )
        JR      A86D6           ; auf weitere Funktionen mit gleicher Priorit√§t untersuchen
;
;
;   Ausdruck mit Priorit√§t eins oder h√∂her auswerten
;
A86E8:  CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFB    __PLUS          ; Zwischencode  PLUS  ?
        JR      Z,A86E8         ; ja -->  Vorzeichen vergessen
        CP      _MINUS          ; Zwischencode minus  ?
        JR      NZ,A86F8        ; nein -->  weiter untersuchen
        INC     HL              ; Vorzeichen √ºberspringen
        CALL    A86F8           ; Ausdruck mit Priorit√§t null oder h√∂her auswerten
        JR      A8721           ; Vorzeichen des bereitgestellten Wertes umkehren
;
;
;   Ausdruck mit Priorit√§t null oder h√∂her auswerten
;
A86F8:  CALL    A872D           ; Konstante, Variable oder Funktion (HL) auswerten
A86FB:  CP      ___POT          ; Zwischencode  ^  ?
        RET     NZ              ; nein
        LD      A,(S9E9C)       ; Wertart des beritgestellten Wertes holen
        PUSH    AF              ; und merken
        INC     HL              ; Zwischencode ^ √ºberspringen
        CALL    A8713           ; Konstante, Variable oder Funktion mit Vorzeichen auswerten
        POP     BC              ; Wertart des ersten Wertes holen
        PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        CALL    A8BE5           ; Zeiger auf letzte zwei Werte bereitstellen
        CALL    A950A           ; ^  - Routine aufrufen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; n√§chstes Programmbyte holen
        JR      A86FB           ; auf weitere Funktionen mit gleicher Priorit√§t untersuchen
;
;
;   Konstante, Variable oder Funktion (HL) mit Vorzeichen auswerten
;
A8713:  CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFB    __PLUS          ; Zwischencode PLUS  ?
        JR      Z,A8713         ; ja -->  positives Vorzeichen vergessen
        CP      _MINUS          ; Zwischencode MINUS  ?
        JR      NZ,A872D        ; Konstante, Variable oder Funktion (HL) auswerten
        INC     HL              ; Zwischencode MINUS √ºberspringen
        CALL    A872D           ; Konstante, Variable oder Funktion (HL) auswerten
;
;
;   Vorzeichen des bereitgestellten Wertes umkehren
;
A8721:  PUSH    AF              ; n√§chstes Programmbyte retten
        PUSH    HL              ; Programmzeiger retten
        LD      HL,-5           ; L√§nge Real - Zahlwert
        ADD     HL,DE           ; Zeiger auf bereitgestellten Wert errechnen
        CALL    A90A6           ; Vorzeichen des Wertes (HL) umkehren
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; n√§chstes Programmbyte holen
        RET
;
;
;   Konstante, Variable oder Funktion (HL) auswerten
;
A872D:  CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A6364         ; Fehler 1  Syntax error
        CALL    A8739           ; Wert Funktion, Konstante, Variable bereitstellen
        JP      A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
;
;
;   Wert der eingebauten Funktion, Konstanten oder Variablen bereitstellen
;
A8739:  PUSH    HL              ; Programmzeiger retten
        LD      HL,(S107E)      ; LIMIT - Adresse holen
        SCF                     ;! Adresse des Rechenspeichers √ºberpr√ºfen
        SBC     HL,DE           ;!
        JP      C,A6373         ; zu hoch -->  Fehler 6  Memory error
        POP     HL              ; geretteten Programmzeiger holen
        CP      ____PI          ; Zwischencode  Pi  ?
        JR      Z,A8756         ; ja -->  Wert f√ºr Pi vorgeben
        CP      ' '             ; Zahlwertcode  ?
        JR      NC,A8796        ; nein -->  weiter untersuchen
A874C:  INC     HL              ; Zahlwertcode √ºberspringen
        CP      __REAL          ; Real - Zahlwert  ?
        JR      C,A8765         ; nein -->  weiter untersuchen
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        JR      A875F           ; Code for 'Ergebnis ist Real-Wert'  vorgeben
;
;
;   Wert f√ºr Konstante Pi vorgeben
;
A8756:  INC     HL              ; Zwischencode Pi √ºberspringen
        PUSH    HL              ; Programmzeiger retten
        LD      HL,B98C6        ; Zeiger auf Pi im Real - Format
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; geretteten Programmzeiger holen
;
;
;   Code for 'Ergebnis ist Real - Wert' vorgeben
;
A875F:  LD      A,5             ; Code for 'Real - Wert'
A8761:  LD      (S9E9C),A       ; im Wertart - Flag merken
        RET
;
;
;   Wert der Zahlkonstante bereitstellen
;
A8765:  CP      _LINNO          ; ZwischenCode for 'Zeilennummer'  ?
        JR      NC,A8772        ; kein einziffrige Zahlkonstante
        DEC     A               ; Zwischencode in Zahlwert corrigieren
        JP      M,A6364         ; Zeilenende -->  Fehler 1  Syntax error
        LD      B,0             ; High - Byte Wert auf Null
        LD      C,A             ; Ziffer als Low - Byte Wert vorgeben
        JR      A8783           ; Integer - Wert in BC aufbereiten in Real - Wert
;
A8772:  LD      C,(HL)          ;! Zwei - Byte - Wert aus Programm holen
        INC     HL              ;!
        LD      B,(HL)          ;!
        INC     HL
        CP      _LIN_P          ; ZwischenCode for 'Zeiger auf Zeile'  ?
        JR      NZ,A8783        ; nein -->  Integer - Wert in BC aufbereiten in Real - Wert
        INC     BC              ;! Offset auf n√§chste Zeile √ºberspringen
        INC     BC              ;!
        LD      A,(BC)          ;! Zeilennummer der Zeile holen
        INC     BC              ;!
        EX      AF,AF           ;!
        LD      A,(BC)          ;!
        LD      B,A             ;!
        EX      AF,AF           ;!
        LD      C,A             ;!
;
;
;   Integer - Wert in BC aufbereiten in Real - Wert
;
A8783:  PUSH    HL              ; Programmzeiger retten
        PUSH    DE              ; Zeiger f√ºr Zahlwert retten
        EX      DE,HL           ; Zeiger f√ºr Zahlwert nach HL
        LD      E,C             ;! aufzubereitenden Wert nach BC
        LD      D,B             ;!
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        POP     DE              ; Zeiger auf aufbereiteten Zahlwert holen
        POP     HL              ; geretteten Programmzeiger holen
        LD      A,5             ; Code for 'Real - Wert'
A878F:  INC     DE              ;! bereitgestellten Wert retten
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        JR      A8761           ; Wertcode des bereitgestellten Wertes merken
;
A8796:  CP      '\"'            ; Anf√ºhrungszeichen  ?
        JR      NZ,A87C9        ; keine Zeichenkettenkonstante
;
;
;   angegebene Zeichenkettenkonstante als Ergebnis bereitstellen
;
        INC     HL              ; Anf√ºhrungszeichen √ºberspringen
        PUSH    HL              ; Zeiger auf Anfang String retten
        CALL    A8BF0           ; L√§nge der Zeichenkettenkonstante (HL) ausz√§hlen
        EX      (SP),HL         ; Zeiger auf Anfang holen / Zeiger auf Ende retten
        PUSH    HL              ; Zeiger auf Anfang String merken
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        PUSH    BC              ; Stringl√§nge retten
        LD      BC,(S1076)      ; Anfang Stringtextbereich holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; Offset auf String errechnen
        POP     BC              ; Stringl√§nge holen
        EX      DE,HL           ; Zeiger f√ºr Ergebnis nach HL
        LD      (HL),B          ; Stringl√§nge in Descriptor eintragen
        INC     HL              ; eingetragene L√§nge √ºberspringen
        LD      (HL),E          ;! Offset auf Stringtext in Descriptor eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL
        INC     HL
        INC     HL
        POP     DE              ; Zeiger auf Anfang String holen
        PUSH    HL              ; Zeiger f√ºr n√§chstes Ergebnis retten
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich √ºbertragen
        LD      (S107A),HL      ; Ende Stringarbeitsbereich merken
        POP     DE              ; Zeiger auf Speicher f√ºr Ergebnis holen
        POP     HL              ; geretteten Programmzeiger holen
        LD      A,3             ; Code for 'Zeichenkettenwert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        RET
;
A87C9:  CP      '('             ; Klammer auf  ?
        JR      NZ,A87D4        ; nein -->  weiter untersuchen
;
;
;   Vorrangzeichen  'Klammer auf'  abarbeiten
;
        INC     HL              ; 'Klammer auf'√ºberspringen
        CALL    A858E           ; Ausdruck (HL) auswerten
        JP      A79AD           ; auf Syntax  'Klammer zu'  √ºberpr√ºfen
;
A87D4:  OR      A               ; Zwischencode  ?
        JP      P,A8E15         ; nein -->  Wert der Variablen bereitstellen
        CP      ___SPC          ; Zwischencode  SPC  ?
        INC     HL              ; Zwischencode √ºberspringen
        JR      NZ,A87E4        ; nicht SPC -->  weiter untersuchen
        LD      B,5             ; Code for 'Zahlparameter'  vorgeben
        LD      A,_SPACE        ; Zwischencode SPACE$ vorgeben
        PUSH    AF              ; Zwischencode merken
        JR      A8813           ; Syntax  'Klammer auf'  und Parameter bereitstellen
;
A87E4:  CP      0FFH            ; Vorbyte  Tabelle drei  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
        LD      A,(HL)          ; eigentlichen Zwischencode holen
        INC     HL              ; Zwischencode √ºberspringen
        CP      ___CHR          ; Zwischencode  CHR$  ?
        JP      Z,A889F         ; ja -->  CHR$ - Funktion aufrufen
        CP      0C8H
        JP      NC,A6364        ; Fehler 1  Syntax error
        CP      0BAH
        JR      NC,A8843        ; Funktion, die sich Parameter selbst bereitstellt
        CP      09CH            ; Zwischencode  STICK  ?
        JR      Z,A8843         ; ja -->  Funktionsroutine aufrufen
        CP      09DH            ; Zwischencode  STRIG  ?
        JP      Z,A8843         ; ja -->  Funktionsroutine aufrufen
        PUSH    AF              ; Zwischencode der Funktion retten
        CP      0B3H
        JR      NC,A8834        ; Funktion mit Real - Wert - Argument
        LD      B,3             ; Code for 'Zeichenkettenwert'
        CP      0ABH
        JR      NC,A8813        ; Funktionen mit Zeichenkettenargument
        LD      B,5             ; Code for 'Real - Wert'
        CP      ___RND          ; Zwischencode  RND  ?
        JR      Z,A882E         ; ja -->  Funktion braucht nicht unbedingt Argument
A8813:  CALL    A79A3           ; auf Syntax  'Klammer auf'  √ºberpr√ºfen
A8816:  PUSH    BC              ; Code der Ergebnisvorgabe retten
        CALL    A858E           ; Ausdruck (HL) auswerten
        CALL    A79AD           ; auf Syntax  'Klammer zu'  √ºberpr√ºfen
        POP     AF              ; Code der Ergebnisvorgabe holen
        CALL    A9032           ; auf Syntax 'zwei gleiche Ergebnistypen'  untersuchen
A8821:  POP     AF              ; Zwischencode der Funktion holen
        PUSH    DE              ; Zeiger auf Speicher f√ºr Ergebnis retten
        PUSH    HL              ; Programmzeiger retten
        LD      HL,-5           ; L√§nge Ergebnis - Wert  (Real oder Descriptor)
        ADD     HL,DE           ; Zeiger auf bereitgestellten Wert errechnen
        CALL    A8843           ; Funktionsroutine nach Zwischencode aufrufen
        POP     HL              ; geretteten Programmzeiger holen
        POP     DE              ; Zeiger auf Speicher f√ºr Ergebnis holen
        RET
;
;
;   Funktionsdecodierung  RND
;
A882E:  CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    "("             ; Klammer auf  ?
        JR      Z,A8816         ; ja -->  Parameter angegeben -->  Funktion aufrufen
A8834:  LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        PUSH    HL              ; Programmzeiger retten
        LD      HL,B7C45        ; Zeiger auf +1  (Real - Format)
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; geretteten Programmzeiger holen
        JR      A8821           ; RND - Funktion aufrufen
;
;
;   Funktionsroutine nach Zwischencode im Accu aufrufen
;
A8843:  PUSH    HL              ; Zeiger auf Parameter retten
        ADD     A,A             ; Zwischencode mal zwei  (zwei Byte je Adresse)
        LD      L,A             ; und als Low - Byte Offset merken
        LD      H,0             ; High - Byte Offset auf Null
        LD      BC,W5D79        ; Zeiger auf Tabelle mit Anfangsadresse der Routinen
        ADD     HL,BC           ; Zeiger auf richtige Adresse errechnen
        LD      A,(HL)          ;! Anfangsadresse der Routine aus Tabelle holen
        INC     HL              ;!
        LD      H,(HL)          ;!
        LD      L,A             ;!
        EX      (SP),HL         ; Adresse ablegen / Zeiger auf Argument holen
        RET
;
;
;   Basic - Funktion   SIZE   (Zwischencode  255 181 / 0FFH 0B5H)
;
A8852:  EX      DE,HL           ; Programmzeiger nach DE retten
        LD      HL,-527         ; Vorgabe f√ºr freien Arbeitsbereich
        ADD     HL,SP           ; Stackpointer holen
        LD      BC,(S107A)      ; Ende Stringarbeitsbereich holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; freien Arbeitsspeicher errechnen
        EX      DE,HL           ; Wert nach DE / Programmzeiger nach HL
        JR      NC,A8880        ; Wert ist OK -->  aufbereiten
        XOR     A               ; Accu auf Null
        JR      A887D           ; Null als Ergebnis aufbereiten
;
; 
;   Basic - Funktion   CSRH     (Zwischencode 255 182 / 0FFH 0B6H)
;
A8864:  LD      A,(S1082)       ; aktuelle X - Koordinate Cursor holen
        JR      A887D           ; Wert im Accu umsetzen in Real - Wert
;
;
;   Basic - Funktion   CSRV     (Zwischencode 255 183 / 0FFH 0B7H)
;
A8869:  LD      A,(S1083)       ; aktuelle Y - Koordinate Cursor holen
        JR      A887D           ; Wert im Accu umsetzen in Real - Wert
;
;
;   Basic - Funktion   POSH     (Zwischencode 255 184 / 0FFH 0B8H)
;
A886E:  LD      DE,(S1088)      ; X - Koordinate Graphic - Cursor holen
        JR      A8880           ; Wert in DE umsetzen in Real - Wert
;
;
;   Basic - Funktion   POSV     (Zwischencode 255 185 / 0FEH 0B9H)
;
A8874:  LD      DE,(S108A)      ; Y - Koordinate Graphic - Cursor holen
        JR      A8880           ; Wert in DE umsetzen in Real - Wert
;
;
;   Basic - Funktion   ERN     (Zwischencode 255 179 / 0FFH 0B3H)
;
A887A:  LD      A,(S9E53)       ; Fehlernummer holen
;
;
;   Wert im Accu umsetzen in Real - Wert
;
A887D:  LD      E,A             ; Low - Byte Wert merken
        LD      D,0             ; High - Byte Wert auf Null
;
;
;   Wert in DE umsetzen in Real - Wert
;
A8880:  LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        JP      A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
;
;
;   Basic - Funktion  ERL     (Zwischencode 255 180 / 0FFH 0B4H)
;
A8888:  LD      DE,(S9E55)      ; Fehler - Zeilennummer holen
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        INC     HL              ; Zeiger auf MSByte Mantisse aufbereitete Zahl
        BIT     7,(HL)          ; Wert Positiv  ?
        DEC     HL              ; Zeiger wieder auf Exponenten
        RET     Z               ; Wert ist Positiv
        LD      DE,B889A        ; Zeiger auf Real - Wert 65536
        JP      A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
;
B889A:  DEFB    091H                    ; Exponent  65536
        DEFB    000H,000H,000H,000H     ; Mantisse  65536
;
;
;   Basic - Funktion  CHR$     (Zwischencode 255 160 / 0FFH 0A0H)
;
A889F:  CALL    A79A3           ; auf Syntax  'Klammer auf'  √ºberpr√ºfen
        LD      B,0             ; Vorgabe f√ºr Anzahl Zeichen
A88A4:  PUSH    BC              ; Z√§hler  'Anzahl Zeichen' retten
        PUSH    DE              ; Zeiger f√ºr Ergebnis retten
        CALL    A8547           ; Ausdruck auswerten und 2-Byte - Wert bereitstellen
        CALL    A8540           ; untersuchen, ob Wert in DE zwischen 0 und 255 liegt
        POP     DE              ; Zeiger f√ºr Ergebnis holen
        POP     BC              ; Z√§hler  'Anzahl Zeichen'  holen
        PUSH    AF              ; bereitgestellten Wert retten
        INC     B               ; Z√§hler  'Anzahl Zeichen'  plus eins
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A88A4         ; ja -->  weitere Werte angegeben
        CALL    A79AD           ; auf Syntax  'Klammer zu'  √ºberpr√ºfen
        LD      A,B             ; Z√§hler  'Anzahl Zeichen'  holen
        EXX
        LD      B,A             ; Z√§hler  'Anzahl Zeichen'  merken
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        CALL    A0158           ; Wert im Accu zum HL-Register addieren
        LD      D,H             ;! Zeiger auf neues Ende benutzter String-
        LD      E,L             ;! arbeitsbereich nach DE
        CALL    A8C08           ; √ºberpr√ºfen, ob Adresse in DE mit Stack kollidiert
A88C7:  DEC     HL              ; Zeiger auf Stelle f√ºr String
        POP     AF              ; ein Zeichen String holen
        LD      (HL),A          ; Stringzeichen merken
        DJNZ    A88C7           ; weitere Zeichen String bereitstellen
        EXX
        LD      A,B             ; Z√§hler  'Anzahl Zeichen'  holen
        EXX
        LD      B,A             ; und merken
A88D0:  LD      (S107A),DE      ; Ende Stringarbeitsbereich merken
        LD      DE,(S1076)      ; Anfang Stringtextbereich holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offset auf String errechnen
        PUSH    HL              ; und merken
        LD      A,B             ; Stringl√§nge holen
        EXX
        EX      DE,HL           ; Zeiger auf Stringdescriptor nach HL
        LD      (HL),A          ; Stringl√§nge in Descriptor eintragen
        INC     HL              ; Zeiger auf Stelle f√ºr Offset im Descriptor
        POP     BC              ; Offset auf String holen
        LD      (HL),C          ;! Offset auf String in Descriptor eintragen
        INC     HL              ;!
        LD      (HL),B          ;!
        LD      BC,3            ; Code for 'Ergebnis vom Typ String'
        ADD     HL,BC           ; Zeiger auf n√§chstes Ergebnis corrigieren
A88E9:  EX      DE,HL           ; Programmzeiger nach HL / Ergebniszeiger nach DE
        LD      A,3             ; Code for 'Zeichenkettenwert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        RET
;
;
;   Basic - Funktion   HEX$     (Zwischencode 255 162 / 0FFH 0A2H)
;
A88F0:  PUSH    HL              ; Zeiger auf Argumnet retten
        CALL    A7BEA           ; Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
        CALL    A8501           ; Hex-Wert in HL aufbereiten in Hex-ASCII nach Z-Speicher
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    23              ; Code 23   L√§nge des Textes (DE) ausz√§hlen
;
;
;   Stringdescriptor aufbauen und String in Stringarbeitsspeicher √ºbertragen
;
A88F9:  LD      A,B             ; Textl√§nge holen
        OR      A               ; gleich Null  ?
        JR      Z,A890D         ; ja -->  Leerstring vorgebe
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        PUSH    HL              ; Zeiger merken
        PUSH    BC              ; Stringl√§nge retten
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich √ºbertragen
        POP     BC              ; gerettete Stringl√§nge holen
        EX      DE,HL
        POP     HL              ; Zeiger auf Anfang String holen
        EXX
        POP     DE              ; Zeiger auf Speicher f√ºr Ergebnis holen
        EXX
        JR      A88D0           ; Stringdescriptor f√ºr Ergebnis holen
;
A890D:  POP     HL              ; Zeiger auf Stelle f√ºr Ergebnis holen
        CALL    A909E           ; Null im Real - Format nach (HL) eintragen
        JR      A88E9           ; Code for 'Ergebnis ist Zeichenkette'  setzen
;
;
;   Basic - Funktion   SPACE$     (Zwischencode 255 168 / 0FFH 0A8H)
;
A8913:  PUSH    HL              ; Zeiger f√ºr Ergebnis retten
        CALL    A8924           ; Real-Wert (HL) umsetzen in Integer mit Test auf < 256
        LD      B,A             ; Anzahl Spaces merken
        LD      C,A             ; Textl√§nge merken
        OR      A               ; Textl√§nge gleich Null ?
        LD      A,' '           ; Leerzeichen  (Space)  vorgeben
        PUSH    DE              ; Zeiger auf Speicher f√ºr String merken
        CALL    NZ,A013E        ; Stringbereich (DE) mit Konstanten auff√ºllen
        POP     DE              ; Zeiger auf Speicher mit Zeichenkette holen
        LD      B,C             ; Textl√§nge vorgeben
        JR      A88F9           ; Stringdescriptor aufbauen und String merken
;
;
;   Real-Wert (HL) umsetzen in Integer mit Untersuchung, ob Wert kleiner 256 ist
;
A8924:  CALL    A7BEA           ; Real - Zahlwert (HL) umsetzen in Integer - Wert nach HL
        LD      DE,S11A4        ; Zeiger auf Speicher f√ºr String vorgeben
        LD      A,H             ; High - Byte L√§nge holen
        OR      A               ; gleich Null  ?
        JP      NZ,A636A        ; nein -->  Fehler 3   Illegal data error
        LD      A,L             ; Low - Byte Wert holen
        RET
;
;
;   Basic - Funktion   STR$     (Zwischencode 255 161 / 0FFH 0A1H)
;
A8931:  PUSH    HL              ; Programmzeiger retten
        CALL    A7B5B           ; Real-Wert (HL) umsetzen in ASCII nach Z-Speicher
        LD      A,(DE)          ; erstes aufbereitetes Zeichen holen
        CP      ' '             ; Leerzeichen  (Space)  ?
        JR      NZ,A893B        ; nein -->  relevantes Zeichen
        INC     DE              ; Freistelle f√ºr Vorzeichen √ºberspringen
A893B:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    23              ; Code 23   L√§nge des Textes (DE) ausz√§hlen
        JR      A88F9           ; Stringdescriptor aufbauen und String merken
;
;
;   Basic - Funktion   EOF     (Zwischencode 255 198 / 0FFH 0C8H)
;
A893F:  CALL    A79A3           ; auf Syntax  'Klammer auf'  √ºberpr√ºfen
        CALL    A6EF9           ; Datei- oder Ger√§tenummer bereitstellen
        LD      B,A             ; Datei - Nummer retten
        CALL    A79AA           ; auf Syntax 'Klammer zu' √ºberpr√ºfen
        LD      A,B             ; gerettete Datei - Nummer holen
        PUSH    HL              ; Programmzeiger retten
        PUSH    DE              ; Zeiger auf Speicher f√ºr Ergebnis retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    41              ; Code 41   Zeiger auf Datensatz nach Datensatznr bereitstellen
        LD      DE,-1           ; Vorgabe  'Dateiende'
        JR      C,A895B         ; Datei nicht ge√∂ffnet -->  Wert aufbereiten
        INC     HL              ; Zeiger auf Dateiendeflag
        BIT     7,(HL)          ; Dateiendeflag abfragen
        JR      NZ,A895B        ; gesetzt -->  -1 als 'logisch wahr' aufbereiten
        LD      DE,0            ; Code for 'nicht Dateiende'
A895B:  POP     HL              ; Zeiger auf Stelle f√ºr Ergebnis holen
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        LD      A,5             ; Code for 'Real - Wert'
        LD      (S9E9C),A       ; Wertart - Flag merken
A8964:  INC     HL              ;! bereitgestellten Wert retten
        INC     HL              ;!
        INC     HL              ;!
        INC     HL              ;!
        INC     HL              ;!
        EX      DE,HL           ; Zeiger f√ºr Wert nach DE
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Funktion   POINT     (Zwischencode 255 197 / 0FFH 0C5H)
;
A896C:  CALL    A79A3           ; auf Syntax  'Klammer auf'  √ºberpr√ºfen
        PUSH    DE              ; Zeiger f√ºr Ergebnis retten
        CALL    A8547           ; Ausdruck auswerten und 2-Byte - Wert bereitstellen
        LD      B,D             ;! X - Koordinate Graphic retten
        LD      C,E             ;!
        POP     DE              ; Zeiger auf Stelle f√ºr Ergebnis holen
        PUSH    DE              ; und wieder merken
        PUSH    BC              ; X - Koordinate Graphic - retten
        CALL    A79B4           ; auf Syntax 'Komma' √ºberpr√ºfen
        CALL    A8547           ; Ausdruck auswerten und 2-Byte - Wert bereitstellen
        CALL    A79AD           ; auf Syntax  'Klammer zu'  √ºberpr√ºfen
        EX      (SP),HL         ; Programmzeiger retten / X - Koordinate Graphic holen
        EX      DE,HL           ; X- und Y- Koordinate Graphic vertauschen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    78              ; Abfrage, ob Graphic - Punkt gesetzt ist
        INC     A               ; Ergebnis gleich minus eins
        JP      Z,A636A         ; ja -->  Fehler in Koordinate -->  Fehler 3   Illegal data error
        DEC     A               ; Ergebnis wieder corrigieren
        POP     DE              ; Programmzeiger holen
        POP     HL              ; Zeiger f√ºr Ergebnis holen
        PUSH    DE              ; Programmzeiger wieder retten
        CALL    A887D           ; Wert im Accu umsetzen in Real - Wert
        JR      A8964           ; bereitgestellten Wert retten und Programmzeiger holen
;
;
;   Basic - Funktion   ASC     (Zwischencode 255 171 / 0FFH 0ABH)
;
A8992:  PUSH    HL              ; Zeiger f√ºr Ergebnis retten
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
        OR      A               ; L√§nge gleich Null  ?
        JR      Z,A899A         ; ja -->  Null als Ergebnis aufbereiten
        LD      A,(DE)          ; erstes Zeichen der Zeichenkette holen
A899A:  JR      A89A0           ; Zeiger f√ºr Ergebnis holen und Wert aufbereiten
;
;
;   Basic - Funktion   LEN     (Zwischencode 255 172 / 0FFH 0ACH)
;
A899C:  PUSH    HL              ; Zeiger f√ºr Ergebnis retten
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
A89A0:  POP     HL              ; Zeiger f√ºr Ergebnis holen
        JP      A887D           ; Wert im Accu umsetzen in Real - Wert
;
;
;   Basic - Funktion   VAL     (Zwischencode 255 173 / 0FFH 0ADH)
;
A89A4:  PUSH    HL              ; Zeiger f√ºr Ergebnis retten
        CALL    A8570           ; Zeiger auf Zeichenkette nach Descriptor (HL) bereitstellen
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        PUSH    HL              ; und merken
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich √ºbertragen
        LD      (HL),NUL        ; Code for 'Textende'  hinter String eintragen
        POP     DE              ; Zeiger auf Anfang String holen
        POP     HL              ; Zeiger f√ºr Ergebnis holen
        JP      A7A0E           ; ASCII-Text (DE) umsetzen in Real - Wert nach (HL)
;
;
;   Basic - Funktion  LEFT$     (Zwischencode 255 186 / 0FFH 0BAH)
;
A89B6:  CALL    A8A32           ; String und 2-Byte-Wert bereitstellen
        CALL    A79AD           ; auf Syntax  'Klammer zu'  √ºberpr√ºfen
        CALL    A8A2B           ; √ºberpr√ºfen, ob Wert in BC kleiner 256 ist
        EX      DE,HL           ; Programmzeiger nach DE / Stringzeiger nach HL
        LD      A,(HL)          ; Stringl√§nge holen
        CP      C               ; mit LEFT$ - Wert vergleichen
        JR      NC,A89C5        ; String ist l√§nger als Wert
        LD      C,A             ; LEFT$ - Wert als Stringl√§nge merken
A89C5:  LD      (HL),C          ; neue Stringl√§nge eintragen
        LD      BC,5            ; L√§nge Descriptoreintrag
A89C9:  LD      A,3             ; Code for 'Zeichenkettenwert'
        ADD     HL,BC           ; Springdescriptor retten
        EX      DE,HL           ; Zeiger f√ºr Wert nach DE / Programmzeiger nach HL
        LD      (S9E9C),A       ; Werttyp im Wertart - Flag merken
        JP      A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
;
;
;   Basic - Funktion   RIGHT$     (Zwischencode 255 187 / 0FFH 0BBH)
;
A89D3:  CALL    A8A32           ; String und 2-Byte-Wert bereitstellen
        CALL    A79AD           ; auf Syntax  'Klammer zu'  √ºberpr√ºfen
        CALL    A8A2B           ; √ºberpr√ºfen, ob Wert in BC kleiner 256 ist
        EX      DE,HL           ; Programmzeiger nach DE / Stringzeiger nach HL
        LD      A,(HL)          ; Stringzeiger holen
        SUB     C               ; angegebene L√§nge RIGHT$ abziehen
        JR      NC,A89E3        ; String ist l√§nger
        XOR     A               ; Offset auf neuen String vorgeben
        LD      C,(HL)          ; neue Stringl√§nge holen  (gleich alte)
A89E3:  LD      (HL),C          ; neue Stringl√§nge eintragen
        INC     HL              ; Zeiger auf 'Offset auf String'
        ADD     A,(HL)          ; Low - Byte Offset corrigieren
        LD      (HL),A          ; neues Low - Byte merken
        INC     HL              ; Zeiger auf Descriptor auf High - Byte
        JR      NC,A89EB        ; kein √úbertrag
        INC     (HL)            ; High - Byte Offset corrigieren
A89EB:  LD      BC,3            ; Restl√§nge f√ºr Rettung Stringdescriptor
        JR      A89C9           ; Stringdescriptor retten und Wertcode vorgeben
;
;
;   Basic - Funktion   MID$     (Zwischencode 255 188 / 0FFH 0BCH)
;
A89F0:  CALL    A8A32           ; String und 2-Byte-Wert bereitstellen
        CALL    A8A2B           ; √ºberpr√ºfen, ob Wert in BC kleiner 256 ist
        OR      A               ; Anfangsstelle gleich Null  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        PUSH    AF              ; Anfangsstelle retten
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ")"             ; Klammer zu  ?
        LD      A,255           ; Vorgabe f√ºr  'Anzahl Zeichen'
        JR      Z,A8A17         ; keine Anzahl angegeben -->  alle Zeichen ab Anfangsposition
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        PUSH    DE              ; Zeiger auf Stringdescriptor retten
        EX      DE,HL           ; Programmzeiger nach DE
        LD      BC,5            ; Vorgabe f√ºr L√§nge zu rettender Wert
        ADD     HL,BC           ; Stringdescriptor retten
        EX      DE,HL           ; Programmzeiger wieder nach HL
        CALL    A8547           ; Ausdruck auswerten und 2-Byte - Wert bereitstellen
        CALL    A79AD           ; auf Syntax  'Klammer zu'  √ºberpr√ºfen
        CALL    A8540           ; untersuchen, ob Wert in DE zwischen 0 und 255 liegt
        POP     DE              ; Zeiger auf Stringdescriptor holen
A8A17:  POP     BC              ; Anfangsstelle holen
        LD      C,A             ; Anzahl Zeichen merken
        EX      DE,HL           ; Zeiger auf Stringdescriptor nach HL
        LD      A,(HL)          ; L√§nge des vorgegebenen Strings holen
        SUB     B               ; Anfangsstelle abziehen
        JR      C,A8A27         ; zu kurz -->  Ergebnis ist Leerstring
        INC     A               ; Restl√§nge corrigieren
        CP      C               ; mit angegebener L√§nge vergleichen
        JR      NC,A8A23        ; String ist noch l√§nger
        LD      C,A             ; Restl√§nge vorgeben
A8A23:  LD      A,B             ; Anfangsstelle holen
        DEC     A               ; f√ºr Offset corrigieren
        JR      A89E3           ; neue L√§nge merken und Offset auf String corrigieren
;
A8A27:  XOR     A               ; Accu auf Null
        LD      C,A             ; als neue L√§nge vorgeben
        JR      A89E3           ; Stringdescriptor corrigieren
;
;
;   √ºberpr√ºfen, ob Wert in BC kleiner 256 ist
;
A8A2B:  LD      A,B             ; High - Byte Wert holen
        OR      A               ; gleich Null  ?
        JP      NZ,A636A        ; nein -->  Fehler 3   Illegal data error
        LD      A,C             ; Low - Byte Wert holen
        RET
;
;
;   String und 2-Byte-Wert bereitstellen
;
A8A32:  CALL    A79A3           ; auf Syntax  'Klammer auf'  √ºberpr√ºfen
        PUSH    DE              ; Zeiger auf Stelle f√ºr Ergebnismerken
        CALL    A858E           ; Ausdruck (HL) auswerten
        CALL    A79B4           ; auf Syntax 'Komma' √ºberpr√ºfen
        CALL    A9036           ; Syntaxuntersuchung auf Zeichenkettenergebnis
        CALL    A8547           ; Ausdruck auswerten und 2-Byte - Wert bereitstellen
        LD      C,E             ;! Wert nach DE kopieren
        LD      B,D             ;!
        POP     DE              ; Zeiger auf Stringdescriptor holen
        RET
;
;
;   Basic - Funktion   TI$     (Zwischencode 255 196 / 0FFH 0C4H)
;
A8A46:  PUSH    HL              ; Programmzeiger retten
        PUSH    DE              ; Zeiger auf Stelle f√ºr Ergebnis merken
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        PUSH    HL              ; und merken
        LD      A,'0'           ; Null
        LD      B,6             ; sechs Zeichen f√ºr Uhrzeit
        CALL    A0138           ; Speicherbereich (HL) mit Konstante belegen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    37              ; Code 37   Uhrzeit lesen
        POP     HL              ; Zeiger auf Textvorgabe holen
        OR      A               ; Flag  Vormittag / Nachmittag
        JR      Z,A8A5E         ; Vormittag
        INC     (HL)            ;! 12 f√ºr Nachmittag  vorgeben
        INC     HL              ;!
        INC     (HL)            ;!
        INC     (HL)            ;!
        DEC     HL
A8A5E:  EX      DE,HL           ; Zeiger auf Textspeicher nach DE
        LD      BC,36000        ; 36000 Sekunden  (Wert 10er Stundenstelle)
        CALL    A8AD5           ; eine Stelle der Uhrzeit aufbereiten
        LD      BC,3600         ; 3600 Sekunden  (Wert 1er Stundenstelle)
        CALL    A8AD5           ; eine Stelle der Uhrzeit aufbereiten
        CP      '9' + 1         ; Stelle gr√∂√üer neun  ?
        JR      C,A8A79         ; kein √úbertrag auf 10er Stelle
        SUB     10              ; 1er - Stelle corrigieren
        DEC     DE              ; Zeiger auf 1er - Stundenstelle
        LD      (DE),A          ; richtigen Stellenwert eintragen
        DEC     DE              ; Zeiger auf 10er - Stundenstelle
        LD      A,(DE)          ; 10er - Stundenstelle holen
        INC     A               ; corrigieren
        LD      (DE),A          ; und richtigen Stellenwert eintragen
        INC     DE              ; Zeiger auf 1er - Stundenstelle
        INC     DE              ; Zeiger auf 10er - Minutenstelle
A8A79:  DEC     DE              ; Zeiger auf 1er - Stundenstelle
        DEC     DE              ; Zeiger auf 10er - Stundenstelle
        LD      A,(DE)          ; 10er - Stundenstelle holen
        INC     DE              ; Zeiger auf 1er - Stundenstelle
        LD      B,A             ; 10er - Stundenstelle merken
        LD      A,(DE)          ; 1er - Stundenstelle holen
        INC     DE              ; Zeiger wieder auf 10er - Minutenstelle
        LD      C,A             ; 1er - Stundenstelle merken
        LD      A,B             ; 10er - Stundenstelle holen
        CP      '2'             ; gleich 2  (24)  ?
        JR      NZ,A8A97        ; nein -->  Rest Uhrzeit aufbereiten
        LD      A,C             ; 1er - Stundenstelle holen
        CP      '4'             ; gleich 4  (24)  ?
        JR      NZ,A8A97        ; nein -->  Rest Uhrzeit aufbereiten
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        LD      A,'0'           ; Null
        LD      B,6             ; 6 Stellen Stringl√§nge TI$
        CALL    A0138           ; Speicherbereich (HL) mit Konstante belegen
        JR      A8AAD           ; Stringdescriptor aufbereiten
;
A8A97:  LD      BC,600          ; 600 Sekunden  (Wert 10er - Minutenstelle)
        CALL    A8AD5           ; eine Stelle der Uhrzeit aufbereiten
        LD      BC,60           ; 60 Sekunden  (Wert 1er - Minutenstelle)
        CALL    A8AD5           ; eine Stelle der Uhrzeit aufbereiten
        LD      BC,10           ; 10 Sekunden  (Wert 10er Sekundenstelle)
        CALL    A8AD5           ; eine Stelle der Uhrzeit aufbereiten
        LD      A,'0'           ; Vorgabe f√ºr ASCII - Wert
        ADD     A,L             ; ASCII - Ziffer errechnen
        LD      (DE),A          ; Wert 1er - Sekundenstelle eintragen
A8AAD:  LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        LD      DE,6            ; L√§nge aufbereiteter String vorgeben
        EX      DE,HL
        ADD     HL,DE           ; neuen String retten
        LD      (S107A),HL      ; neues Ende Stringarbeitsbereich merken
        EX      DE,HL
        LD      DE,(S1076)      ; Anfang Stringtextbereich holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offset auf String errechnen
        EX      DE,HL           ; Offset nach DE
        POP     HL              ; Zeiger auf Stelle f√ºr Ergebnis holen
        LD      (HL),6          ; Stringl√§nge in Descriptor eintragen
        INC     HL
        LD      (HL),E          ;! Offset auf String in Descriptor eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL
        INC     HL
        INC     HL
        EX      DE,HL           ; Zeiger auf Stelle f√ºr n√§chstes Ergebnis nach DE
        POP     HL              ; geretteten Programmzeiger holen
        LD      A,3             ; Code for 'Zeichenkettenwert'
        LD      (S9E9C),A       ; im Wertart - Flag merken
        JP      A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
;
;
;   eine Stelle der Uhrzeit aufbereiten
;
A8AD5:  OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; ein mal Stellenwertigkeit abziehen
        JR      C,A8ADF         ; ging schon nicht mehr
        LD      A,(DE)          ; Stelle holen
        INC     A               ; plus eins
        LD      (DE),A          ; und wieder merken
        JR      A8AD5           ; untersuchen, ob Wert gr√∂√üer Stellenwert
;
A8ADF:  ADD     HL,BC           ; Restwert wieder corrigieren
        INC     DE              ; Zeiger auf n√§chste Stelle
        RET
;
;
;   Uhrzeit zuweisen   (TI$=___)
;
A8AE2:  CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL
        DEFB    ____EQ          ; Zwischencode  =
        CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        LD      A,B             ; Stringl√§nge holen
        CP      6               ; gleich sechs  ?
        JP      NZ,A636A        ; nein -->  Fehler 3   Illegal data error
        PUSH    HL              ; Programmzeiger retten
        PUSH    DE              ; Zeiger auf String retten 
        LD      HL,0            ; Vorgabe f√ºr Anzahl Sekunden
        CALL    A8B23           ; zwei Ziffernstellen auswerten
        CP      23 + 1          ; gr√∂√üer als 23  ?
        JP      NC,A636A        ; ja -->  Fehler 3   Illegal data error
        CP      11 + 1          ; gr√∂√üer als 11  ?
        LD      A,0             ; Vorgabe  'Vormittag'
        JR      C,A8B0B         ; nein -->  Uhrzeit ist Vormittags
        PUSH    DE              ; Zeiger auf Text merken
        LD      DE,12           ; 12 Stunden
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; bisher bereitgestellten Wert corrigieren
        POP     DE              ; Zeiger auf Resttext holen
        INC     A               ; Flag auf Nachmittag
A8B0B:  PUSH    AF              ; Flag  Vormittag / Nachmittag  merken
        CALL    A8B23           ; zwei Ziffernstellen auswerten
        CP      59 + 1          ; gr√∂√üer 59  ?
        JP      NC,A636A        ; ja -->  Fehler 3   Illegal data error
        CALL    A8B23           ; zwei Ziffernstellen auswerten
        CP      59 + 1          ; gr√∂√üer 59  ?
        JP      NC,A636A        ; ja -->  Fehler 3   Illegal data error
        POP     AF              ; Flag  Vormittag / Nachmittag  holen
        EX      DE,HL           ; ausgewertete Anzahl Sekunden nach DE
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    38              ; Code 38   Uhrzeit setzen
        POP     DE              ; Zeiger auf String holen
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   bisher vorhandene Anzahl Sekunden * 60 plus Wert f√ºr zwei neue
;   auszuwertende Stellen
;
A8B23:  PUSH    DE              ; Zeiger auf Text retten
        LD      D,H             ;! alten Wert duplizieren
        LD      E,L             ;!
        ADD     HL,HL           ;! alten Wert mal   2
        ADD     HL,HL           ;!            mal   4
        ADD     HL,DE           ;!            mal   5
        LD      D,H             ;! Zwischenergebnis duplizieren
        LD      E,L             ;!
        ADD     HL,HL           ;!            mal  10
        ADD     HL,DE           ;!            mal  15
        ADD     HL,HL           ;!            mal  30
        ADD     HL,HL           ;!            mal  60
        POP     DE              ; Zeiger auf Rest Zeittext holen
        LD      A,(DE)          ; n√§chstes Textzeichen holen
        INC     DE              ; Zeiger auf n√§chste Stellen
        SUB     '0'             ; ASCII - Stelle umsetzen in Dezimalwert
        JP      C,A636A         ; keine Ziffer -->  Fehler 3   Illegal data error
        CP      10              ; mit Anzahl Ziffern vergleichen
        JP      NC,A636A        ; keine Ziffer -->  Fehler 3   Illegal data error
        PUSH    BC              ; Register retten
        LD      C,A             ; erste Ziffer merken
        ADD     A,A             ;! Wert neue Stelle mal  2
        ADD     A,A             ;!                  mal  4
        ADD     A,C             ;!                  mal  5
        ADD     A,A             ;!                  mal 10
        LD      C,A             ; Wert erste neue Stelle
        LD      A,(DE)          ; n√§chstes Textzeichen holen
        INC     DE              ; Zeiger auf Text auf n√§chste Stelle
        SUB     '0'             ; ASCII - Stelle umsetzen in Dezimalwert
        JP      C,A636A         ; keine Ziffer -->  Fehler 3   Illegal data error
        CP      10              ; mit Anzahl Ziffern vergleichen
        JP      NC,A636A        ; keine Ziffer -->  Fehler 3   Illegal data error
        ADD     A,C             ; plus erste Stelle
        LD      C,A             ; neuen Stellenwert merken
        LD      B,0             ; High - Byte Wert auf Null
        ADD     HL,BC           ; plus altes Ergebnis
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Variablennamen (HL) auswerten und Zeiger auf Variable nach BC,
;   Variablenartcode nach Accu bereitstellen
;
A8B56:  LD      DE,(S1078)      ; Anfang Stringarbeitsbereich holen
        LD      (S107A),DE      ; als Ende Stringarbeitsbereich merken
        LD      DE,(S107C)      ; Zeiger auf Anfang Rechenspeicher holen
A8B62:  PUSH    DE              ; Zeiger f√ºr Ergebnis merken
        CALL    A8BB5           ; Variablennamen (HL) im Zwischenspeicher bereitstellen
A8B66:  LD      A,(HL)          ; n√§chstes Programmbyte holen
        CP      '('             ; Klammer auf   ?
        JP      Z,A8C1B         ; ja -->  indizierte Variable
        PUSH    HL              ; Programmzeiger retten
        CALL    A8ED6           ; Variable nach bereitgestelltem Namen suchen
        JR      NC,A8B78        ; Variable nicht gefunden -->  anlegen
        LD      A,C             ; Variablentyp nach Accu holen
        LD      C,L             ;! Zeiger auf Variable nach BC
        LD      B,H             ;!
        POP     HL              ; geretteten Programmzeiger holen
        POP     DE              ; geretteten Register - Wert holen
        RET
;
;
;   neue Variable einf√ºgen
;
A8B78:  LD      A,(DE)          ; L√§nge des Variablennamens holen
        ADD     A,C             ; plus Variablentypl√§nge
        ADD     A,2             ; plus Stellen f√ºr Verwaltungsflags
        PUSH    BC              ; Typl√§nge merken
        EX      DE,HL           ; Zeiger f√ºr Variable nach DE
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        PUSH    HL              ; und merken
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ;! zu verschiebende Anzahl Bytes errechnen
        INC     HL              ;!
        LD      C,L             ;! und nach BC √ºbertragen
        LD      B,H             ;!
        POP     HL              ; Ende Stringarbeitsbereich holen
        PUSH    DE              ; Zeiger auf Stelle f√ºr Variable merken
        EX      DE,HL
        LD      L,A             ;! Zeiger auf neues Ende errechnen
        LD      H,0             ;!
        ADD     HL,DE           ;!
        EX      DE,HL
        CALL    A8C08           ; √ºberpr√ºfen, ob Adresse in DE mit Stack kollidiert
        LDDR                    ; vorhandene Werte verschieben
        LD      E,A             ; L√§nge neue Variable
        LD      D,0             ; High - Byte L√§nge auf Null
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    26              ; Code 26   Zeiger auf Stringbereiche corrigieren
        POP     HL              ; Zeiger auf Stelle f√ºr Variable holen
        POP     BC              ; Variablentypflag holen
        LD      DE,S11A4        ; Zeiger auf Speicher mit Variablennamen vorgeben
        LD      (HL),C          ; Variablentyp eintragen
        INC     HL              ; Variablentyp √ºberspringen
        SCF                     ; eins f√ºr Typflag
        SBC     A,C             ; L√§nge Variablennamen errechnen
        LD      B,A             ; L√§nge Variablenname
A8BA4:  LD      A,(DE)          ;! L√§nge Variablenname udn Variablennamen
        LD      (HL),A          ;! merken
        INC     DE              ;!
        INC     HL              ;!
        DJNZ    A8BA4           ;!   weitere Zeichen √ºbertragen
        PUSH    HL              ; Zeiger auf Variable merken
        LD      B,C             ; Variablentypflag holen
        CALL    A0137           ; Speicherbereich (HL) l√∂schen
        LD      (HL),A          ; Code for 'Ende Bereich'  eintragen
        LD      A,C             ; Variablentypflag holen
        POP     BC              ; Zeiger auf Variable holen
        POP     HL              ; geretteten Programmzeiger holen
        POP     DE              ; geretteten Register - Wert holen
        RET
;
;
;   Variablennamen (HL) im Zwischenspeicher bereitstellen
;
A8BB5:  CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
        SUB     'A'             ;! Accu gleich Buchstabe  ?
        CP      26              ;!
        JP      NC,A6364        ; nein -->  Fehler 1  Syntax error
        LD      DE,S11A4        ; Zeiger auf Zwischenspeicher vorgeben
        LD      B,0             ; Z√§hler  'Anzahl Zeichen Variablenname'  vorgeben
A8BC4:  INC     DE              ; Zeiger auf Speicher auf n√§chste Stelle
        LD      A,(HL)          ; n√§chstes Programmbyte holen
        CALL    A79FD           ; Zeichen im Accu gleich Variablennamenzeichen  ?
        JR      C,A8BD6         ; kein Variablennamenzeichen -->  L√§nge merken
        LD      (DE),A          ; ein Zeichen Variablenname merken
        INC     B               ; Z√§hler  'Anzahl Zeichen Variablenname'  plus eins
        LD      A,B             ; Z√§hler holen
        CP      2 + 1           ; maximale L√§nge erreicht  ?
        JR      C,A8BD3         ; nein -->  noch OK
        DEC     B               ; Z√§hler minus eins
A8BD3:  INC     HL              ; Programmzeiger auf n√§chstes Zeichen
        JR      A8BC4           ; weitere Zeichen Variablenname auswerten
;
A8BD6:  LD      DE,S11A4        ; Zeiger auf Speicher mit Variablennamen
        EX      DE,HL           ; nach HL / Programmzeiger nach DE
        LD      (HL),B          ; L√§nge Variablenname eintragen
        EX      DE,HL           ; Programmzeiger nach HL / Zeiger  V.-Name nach DE
        LD      C,5             ; Code for 'Real - Wert'
        CP      '$'             ; Kennung Zeichenkette  ?
        RET     NZ              ; nein
        LD      C,3             ; Code for 'Zeichenkettenwert'
        INC     HL              ; Zeichenkettenkennung √ºberspringen
        RET
;
;
;   Zeiger auf letzte zwei Werte bereitstellen
;
A8BE5:  LD      HL,-5           ; L√§nge bereitgestellter Wert
        EX      DE,HL
        ADD     HL,DE           ; Zeiger auf zweites Argument bereitstellen
        EX      DE,HL
        ADD     HL,DE           ; Zeiger auf erstes Argument bereitstellen
        LD      A,B             ; Typ des zweiten Arguments holen
        JP      A9032           ; auf Syntax 'zwei gleiche Ergebnistypen'  untersuchen
;
;
;   L√§nge der Zeichenkettenkonstante (HL) ausz√§hlen
;
A8BF0:  LD      B,-1            ; Vorgabe f√ºr L√§ngenz√§hler
A8BF2:  INC     B               ; L√§nge plus eins
        LD      A,(HL)          ; ein Zeichen holen
        OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja -->  fertig
        INC     HL              ; Textzeichen √ºberspringen
        CP      '\"'            ; Textendezeichen  ?
        RET     Z               ; ja -->  fertig
        JR      A8BF2           ; Textende suchen
;
;
;   Zeichenkette mit L√§nge in B von (DE) nach (HL) √ºbertragen
;   (Zeichenkette in Stringarbeitsbereich √ºbertragen)
;
A8BFC:  LD      A,B             ; L√§nge holen
        OR      A               ; gleich Null ?
        RET     Z               ; ja -->  fertig
        CALL    A014A           ; Speicherbereich von (DE) nach (HL) verschieben
        EX      DE,HL           ; Zeiger auf Arbeitsbereich nach DE
        CALL    A8C08           ; √ºberpr√ºfen, ob Adresse in DE mit Stack kollidiert
        EX      DE,HL           ; Zeiger auf Arbeitsbereich nach HL
        RET
;
;
;   √ºberpr√ºfen, ob Adresse in DE mit Stackbereich collidiert
;
A8C08:  PUSH    HL              ; Register - Wert retten
        LD      HL,-512         ; Vorgabe f√ºr Arbeitsbereich
        ADD     HL,SP           ; Stackpointer holen
        SBC     HL,DE           ; Adresse in DE pr√ºfen
        POP     HL              ; geretteten Register - Wert holen
        RET     NC              ; Adresse ist OK
        JP      A63A7           ; Fehler 6  Memory error
;
;
;   Dimensionierung bereitstellen und Variable dimensionieren
;
A8C14:  LD      DE,(S107C)      ; Zeiger auf Anfang Rechenspeicher holen
        PUSH    DE              ; Zeiger auf Rechenspeicher merken
        JR      A8C23           ; Einsprung in Routine
;
;
;   Wert einer dimensionierten Variable bereitstellen
;
A8C1B:  XOR     A               ; Code for 'Aufruf'
        LD      (S8E14),A       ; im Flag  'DIM - Aufruf' merken
        INC     HL              ; 'Klammer auf' √ºberspringen
        LD      (S8E12),HL      ; Programmzeiger bei Anfang Dimensionierung merken
A8C23:  LD      B,0             ; Z√§hler  'Anzahl Dimensionen'  auf Null
        EXX
        POP     HL              ; Zeiger auf Rechenspeicher holen
        PUSH    HL              ;! und wieder merken
        PUSH    HL              ;!
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        LD      DE,S11A4        ; Zeiger auf Speicher f√ºr Variablennamen
        PUSH    HL              ; Zeiger f√ºr Variablennamen merken
        LD      A,(DE)          ;! L√§nge Variablennamen nach String-
        LD      (HL),A          ;! arbeitsbereich √ºbertragen
        INC     DE              ; Zeiger auf Variablennamen
        INC     HL              ; Zeiger auf Stringarbeitsbereich
        LD      B,A             ; L√§nge Variablenname
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich √ºbertragen
        POP     DE              ; Zeiger auf Variablennamen holen
        LD      (S107A),HL      ; neues Ende Stringarbeitsbereich merken
        LD      HL,(S1076)      ; Anfang Stringtextbereich holen
        EX      DE,HL           ; Zeiger vertauschen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offset auf Variablennamen errechnen
        EX      (SP),HL         ; Offset merken / Zeiger Rechenspeicher holen
        PUSH    HL              ; Zeiger auf Rechenspeicher wieder merken
        EXX
A8C46:  POP     DE              ; Zeiger auf Rechenspeicher holen
        PUSH    DE              ; und wieder merken
        PUSH    BC              ; Z√§hler  'Anzahl Dimensionen'  merken
        LD      BC,(S8E12)      ; Programmzeiger bei Anfang Dimensionierung holen
        LD      A,(S8E14)       ; Flag  'DIM - Aufruf' holen
        PUSH    BC              ; Programmzeiger merken
        PUSH    AF              ; Flag  'DIM - Aufruf'  merken
        LD      BC,(S9E6A)      ; Programmzeiger aus Zwischenspeicher holen
        PUSH    BC              ; und merken
        CALL    A8547           ; Ausdruck auswerten und 2-Byte - Wert bereitstellen
        BIT     7,D             ; Wert gr√∂√üer 32767  ?
        JP      NZ,A636A        ; ja -->  Fehler 3   Illegal data error
        EX      AF,AF           ; n√§chstes Programmbyte retten
        POP     BC              ; geretteten Programmzeiger holen
        LD      (S9E6A),BC      ; und wieder in Zwischenspeicher merken
        POP     AF              ; gerettetes Flag  'DIM - Aufruf'  holen
        LD      (S8E14),A       ; Flag  'DIM - Aufruf' merken
        POP     BC              ; Programmzeiger auf Anfang Index holen
        LD      (S8E12),BC      ; Programmzeiger bei Anfang Dimensionierung merken
        EX      AF,AF           ; n√§chstes Programmbyte holen
        INC     HL              ; Programmzeiger auf n√§chstes Programmbyte
        CP      ')'             ; Klammer zu  ?
        JR      Z,A8C8C         ; ja -->  Ende Index
        CP      ','             ; Komma als Trennzeichen  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
        POP     BC              ; Z√§hler  'Anzahl Dimensionen'  holen
        INC     B               ; Anzahl Dimensionen plus eins
        LD      A,B             ; Anzahl holen
        CP      3 + 1           ; mit maximaler Anzahl Dimensionen vergleichen
        JP      NC,A636A        ; zu viele Dimensionen -->  Fehler 3   Illegal data error
        EXX
        POP     HL              ; Zeiger f√ºr Ergebnis holen
        POP     DE              ; Offset auf Variablennamen holen
        EXX
        PUSH    DE              ; Index / Dimension merken
        EXX
        PUSH    DE              ; Offset auf Variablennamen wieder merken
        PUSH    HL              ; Zeiger f√ºr Ergebnis wieder merken
        EXX
        JR      A8C46           ; n√§chsten Index / Dimension bereitstellen
;
A8C8C:  POP     BC              ; Z√§hler  'Anzahl Dimensionen'  holen
        EXX
        POP     HL              ; Zeiger f√ºr Ergebnis holen
        POP     DE              ; Offset auf Variablennamen holen
        EXX
        INC     B               ; Anzahl Dimensionen plus eins
        PUSH    DE              ; Index / Dimension merken
        PUSH    HL              ; Programmzeiger merken
        EXX
        LD      HL,(S1076)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf Variablennamen errechnen
        LD      B,(HL)          ; L√§nge Name holen
        INC     B               ; f√ºr L√§nge corrigieren
        LD      DE,S11A4        ; Zeiger auf Speicher f√ºr Variablennamen
        CALL    A0143           ; Speicherbereich von (HL) nach (DE) verschieben
        EXX
        SET     7,C             ; Code for 'indizierte Variable'
        CALL    A8ED6           ; Variable nach bereitgestelltem Namen suchen
        RES     7,C             ; Code wieder zur√ºcksetzen
        JR      NC,A8D01        ; Variable nicht gefunden
        LD      A,B             ; jetzige Anzahl Dimensionen holen
        CP      (HL)            ; mit vorhandener Anzahl Dimensionen vergleichen
        JP      NZ,A6376        ; nicht gleich -->  Fehler 7  Array def. error
        INC     HL              ; Dimensionsz√§hler √ºberspringen
        EX      DE,HL           ; Zeiger auf Variabe nach DE
        POP     HL              ; Programmzeiger holen
        LD      (S9E6A),HL      ; und im Speicher merken
        EXX
        LD      HL,0            ; Vorgabe f√ºr Berechnung, welches Feldelement
        EXX
        EX      DE,HL
A8CBC:  LD      E,(HL)          ;! bei Dimensionierung angegebene Dimension holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL
        EX      (SP),HL         ; Zeiger auf Feld merken / Index holen
        PUSH    DE              ; vorhandene Dimensionen auf Stack ablegen
        EXX
        POP     DE              ; vorhandene Dimensionen holen
        CALL    A8DE8           ; HL = HL * DE   (Integer)
        EXX
        PUSH    HL              ; angegebenen Index merken
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; √ºberpr√ºfen, ob Index gr√∂√üer Dimensionierung
        JP      NC,A636A        ; ja -->  Fehler 3   Illegal data error
        EXX
        POP     DE              ; angegebenen Index holen
        CALL    A8DE4           ; HL und DE addieren mit Untersuchung auf √úbertrag
        EXX
        POP     HL              ; Zeiger auf Feld holen
        DJNZ    A8CBC           ; weitere Dimensionen auswerten
        PUSH    HL              ; Zeiger auf Feld merken
        EXX
        LD      A,C             ; Variablentypflag holen
        LD      D,B             ; Null
        BIT     6,A             ; Code  FN  ?
        JR      NZ,A8CF4        ; ja
        AND     00001111B       ; Variablentypl√§nge maskieren
        LD      E,A             ; DE enth√§lt Typl√§nge
        PUSH    AF              ; Variablentypflag retten
        CALL    A8DE8           ; HL = HL * DE   (Integer)
        PUSH    HL              ; Offset auf Wert merken
        EXX
        POP     BC              ; Offset auf Wert holen
        POP     AF              ; Variablentypflag holen
        POP     HL              ; Zeiger auf Anfang Feld holen
        ADD     HL,BC           ; Zeiger auf Wert  (Feldelement)  errechnen
        LD      C,L             ;! Zeiger auf Feldelement nach BC kopieren
        LD      B,H             ;!
A8CEF:  LD      HL,(S9E6A)      ; geretteten Programmzeiger holen
        POP     DE              ; Zeiger f√ºr Ergebnis holen
        RET
;
A8CF4:  LD      E,(HL)          ;! L√§nge FN holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        POP     HL              ; Zeiger auf Feld holen
        LD      C,L             ;! Zeiger auf FN nach BC kopieren
        LD      B,H             ;!
        LD      (HL),E
        INC     HL
        LD      (HL),D
        AND     00001111B       ; Variablentyp maskieren
        JR      A8CEF           ; Porgrammzeiger holen
;
;
;   Dimensionierte Variable noch nicht vorhanden
;
A8D01:  EXX
        LD      A,(S8E14)       ; Flag  'DIM - Aufruf' holen
        OR      A               ; Aufruf  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
                                ; wenn hier NOP's eingesetzt werden, wird beim ersten 
                                ; Aufruf automatisch bis auf Index 10 dimensioniert
        POP     HL              ; Programmzeiger holen
        LD      (S9E6A),HL      ; und merken
        EXX
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        LD      L,B             ; Anzahl Dimensionen
        LD      H,0             ; High - Byte Anzahl auf Null
        ADD     HL,HL           ; Anzahl mal zwei
        ADD     HL,DE           ; plus Anfang Stringarbeitsbereich
        EX      DE,HL           ; nach DE
        INC     DE              ; f√ºr Z√§hler corrigieren
        CALL    A8C08           ; √ºberpr√ºfen, ob Adresse in DE mit Stack kollidiert
        LD      (HL),B          ; Anzahl Dimensionen eintragen
        INC     HL              ; Zeiger auf Stelle f√ºr Dimensionen
        EXX
        LD      HL,1            ; Vorgabe f√ºr Feldl√§ngenerrechnung
        EXX
A8D23:  POP     DE              ; eine Dimension holen
        LD      A,(S8E14)       ; Flag  'DIM - Aufruf' holen
        OR      A               ; Aufruf  ?
        JR      NZ,A8D36        ; nein -->  Dimensionierung
        PUSH    HL              ; Zeiger auf Feld retten
        EX      DE,HL           ; Dimension nach DE
        LD      DE,10           ; Vorgabe Index bis 10 f√ºr nicht dimensionierte Variable
        SCF                     ;! √ºberpr√ºfen, ob angegebener Index gr√∂√üer ist
        SBC     HL,DE           ;!
        JP      NC,A636A        ; ja -->  Fehler 3   Illegal data error
        POP     HL              ; Zeiger auf Feld wieder holen
A8D36:  INC     DE              ; f√ºr Index Null corrigieren
        LD      (HL),E          ;! Anzahl Elemente dieser Dimension merken
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL              ; Zeiger f√ºr Felddaten
        PUSH    DE              ; Anzahl Elemente Dimension
        EXX
        POP     DE              ; Anzahl Elemente Dimension
        CALL    A8DE8           ; HL = HL * DE   (Integer)
        EXX
        DJNZ    A8D23           ; weitere Dimensionen
        LD      E,C             ; Variablentypl√§nge
        LD      D,0             ; High - Byte L√§nge auf Null
        PUSH    BC              ; Variablentyp - L√§nge merken
        PUSH    DE              ; Typ - L√§nge
        EXX
        POP     DE              ; Typ - L√§nge holen
        CALL    A8DE8           ; HL = HL * DE   (Speicherplatz f√ºr Feld errechnen)
        PUSH    HL              ; Gesamtfeldl√§nge
        EXX
        POP     BC              ; Gesamtfeldl√§nge holen
        PUSH    BC              ; und wieder merken
        EX      DE,HL
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        LD      L,(HL)          ; Anzahl Dimensionen holen
        LD      H,0             ; High - Byte Anzahl auf Null
        ADD     HL,HL           ; mal zwei
        LD      A,(S11A4)       ; L√§nge Feldname holen
        ADD     A,5             ; plus Stammdatenl√§nge
        ADD     A,L             ; plus Low - Byte L√§nge f√ºr Dimension
        LD      L,A             ; Low - Byte Feldl√§nge merken
        LD      A,0             ; Vorgabe Null
        ADC     A,H             ; High - Byte L√§nge corrigieren
        LD      H,A             ; High - Byte Feldl√§nge merken
        JR      C,A8D6C         ; √úberlauf -->  Fehler 6  Memory error
        ADD     HL,BC           ; plus L√§nge f√ºr Felddaten
        JR      C,A8D6C         ; √úberlauf -->  Fehler 6  Memory error
        PUSH    HL              ; Gesamtfeldl√§nge retten
        ADD     HL,DE           ; Zeiger auf Ende Feld errechnen
A8D6C:  JP      C,A63A7         ; √úberlauf -->  Fehler 6  Memory error
        EX      DE,HL           ; Zeiger auf Ende Feld nach DE
        CALL    A8C08           ; √ºberpr√ºfen, ob Adresse in DE mit Stack kollidiert
        PUSH    HL              ; Zeiger auf Anfang Feld
        EXX
        POP     HL              ; Zeiger auf Anfang Feld
        LD      BC,(S1076)      ; Anfang Stringtextbereich holen
        DEC     BC              ; corrigieren
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; L√§nge der gespeicherten Strings errechnen
        PUSH    HL              ; und merken
        EXX
        POP     BC              ; L√§nge der gespeicherten Strings
        LDDR                    ; Stringtextbereich verschieben  (Platz f√ºr Feld schaffen)
        POP     DE              ; Gesamtfeldl√§nge holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    26              ; Code 26   Zeiger auf Stringbereiche corrigieren
        POP     BC              ; L√§nge Felddaten holen
        PUSH    DE              ; Gesamtfeldl√§nge auf Stack ablegen
        EXX
        POP     DE              ; Gesamtfeldl√§nge
        LD      H,B             ;! Zeiger auf Feldanfang
        LD      L,C             ;!
        POP     BC              ; Variablentypflag holen
        LD      A,C             ; Variablentypflag
        OR      10000000B       ; plus Code for 'dimensionierte Variable'
        LD      (HL),A          ; Variablentyp eintragen
        INC     HL              ; Zeiger auf Feld
        DEC     DE              ; Feldl√§nge corrigieren
        LD      (HL),E          ;! Offset auf Ende Feld eintragen
        INC     HL              ;!   Gesamtfeldl√§nge)
        LD      (HL),D          ;!
        INC     HL
        LD      DE,S11A4        ; Zeiger auf Variablennamen vorgeben
        LD      A,(DE)          ; L√§nge Variablenname holen
        INC     A               ; f√ºr L√§nge Variablenname corrigieren
        LD      B,A             ; Anzahl Zeichen merken
        CALL    A014A           ; Speicherbereich von (DE) nach (HL) verschieben
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        LD      A,(DE)          ;! Anzahl Dimensionen √ºbertragen
        LD      (HL),A          ;!
        INC     HL              ; Zeiger f√ºr Dimensionen
        INC     DE              ; Zeiger auf Dimensionen
        ADD     A,A             ; mal zwei   (zwei Byte je Dimension)
        LD      B,A             ; Anzahl zu √ºbertragende Zeichen merken
        CALL    A014A           ; Speicherbereich von (DE) nach (HL) verschieben
        PUSH    HL              ; Zeiger auf Felddatenbereich merken
        EXX
        POP     HL              ; Zeiger auf Felddatenbereich holen
A8DB0:  XOR     A               ; Accu auf Null
        LD      (HL),A          ; ein Byte Felddaten auf Null
        INC     HL              ; Zeiger auf Felddatenbereich
        DEC     BC              ; Restanzahl Bytes minus eins
        LD      A,B             ;! Restl√§nge gleich Null  ?
        OR      C               ;!
        JR      NZ,A8DB0        ; nein -->  weitere Bytes l√∂schen
        LD      (HL),A          ; Code for 'Ende Bereich'  eintragen
        EXX
        POP     DE              ; Zeiger f√ºr Ergebnis holen
        LD      A,(S8E14)       ; Flag  'DIM - Aufruf' holen
        OR      A               ; Aufruf  ?
        JR      Z,A8DC5         ; ja -->  Wert bereitstellen
        LD      HL,(S9E6A)      ; Programmzeiger aus Speicher holen
        RET
;
A8DC5:  LD      HL,(S8E12)      ; Programmzeiger bei Anfang Dimensionierung holen
        PUSH    DE              ; Zeiger f√ºr Ergebnis retten
        JP      A8C23           ; Index auswerten und Wert Variable bereitstellen
;
;
;   Basic - Befehl   DIM     (Zwischencode 150 / 096H)
;
A8DCC:  LD      A,-1            ; Code for 'DIM'
        LD      (S8E14),A       ; im Flag  'DIM - Aufruf' merken
A8DD1:  CALL    A8BB5           ; Variablennamen (HL) im Zwischenspeicher bereitstellen
        LD      A,(HL)          ; n√§chstes Programmbyte holen
        CALL    A79A6           ; Accu auf Syntax 'Klammer auf' √ºberpr√ºfen
        CALL    A8C14           ; angegebene Dimensionen auswerten und dimensionieren
        CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
        CP      ','             ; Komma  ?
        RET     NZ              ; nein -->  fertig
        INC     HL              ; Komma √ºberspringen
        JR      A8DD1           ; weitere Variable dimensionieren
;
;
;   HL und DE addieren mit Untersuchung auf √úbertrag
;
A8DE4:  ADD     HL,DE           ; Werte addieren
        RET     NC              ; Ergebnis ist OK
        JR      A8E0F           ; √úbertrag -->  Fehler 6  Memory error
;
;
;   HL = HL * DE   mit Untersuchung auf √úbertrag
;
A8DE8:  PUSH    BC              ; Register - Wert retten
        EX      DE,HL           ; Faktoren vertauschen
        LD      C,L             ; Low - Byte Faktor
        LD      A,H             ; High - Byte Faktor
        LD      HL,0            ; Vorgabe f√ºr Ergebnis
        CALL    A8DF8           ; HL = HL * 256 + A * DE
        LD      A,C             ; Low - Byte Faktor holen
        CALL    A8DF8           ; HL = HL * 256 + A * DE
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   HL = HL * 256 + A * DE   mit Untersuchung auf √úbertrag
;
A8DF8:  OR      A               ; Faktor gleich Null  ?
        JR      Z,A8E09         ; ja -->  nur altes Teilergebnis mal 256
        LD      B,8             ; 8 Bit multiplizieren
A8DFD:  ADD     HL,HL           ; altes Teilergebnis mal zwei
        JR      C,A8E0F         ; √úbertrag -->  Fehler 6  Memory error
        RLCA                    ; ein Bit nach Carry schieben
        JR      NC,A8E06        ; nicht gesetzt -->  Stelle nicht addieren
        ADD     HL,DE           ; zweiten Faktor addieren
        JR      C,A8E0F         ; √úbertrag -->  Fehler 6  Memory error
A8E06:  DJNZ    A8DFD           ; weitere Bits auswerten
        RET
;
A8E09:  LD      A,H             ; altes High - Byte holen
        LD      H,L             ; Low - Byte auf High - Byte schieben
        LD      L,0             ; Low - Byte auf Null
        OR      A               ; altes High - Byte gleich Null  ?
        RET     Z               ; ja -->  OK
A8E0F:  JP      A6373           ; zu hoch -->  Fehler 6  Memory error
;
S8E12:  DEFS    2               ; Programmzeiger bei Anfang Dimensionierung
S8E14:  DEFS    1               ; Flag  'DIM - Aufruf'
;
;
;   Wert der Variablen mit Namen (HL) bereitstellen
;
A8E15:  SUB     'A'             ;! Buchstabe im Accu  ?
        CP      26              ;!
        JP      NC,A6364        ; nein -->  Fehler 1  Syntax error
        LD      BC,(S9048)      ; Zeiger auf Parameter aktuelle FN  holen
        LD      A,B             ;! Zeiger vorhanden  ?
        OR      C               ;!
        JR      NZ,A8E36        ; ja -->  in selbstdefinierter Funktion
        CALL    A8B62           ; Variablennamen ausweten und Zeiger auf Variable liefern
A8E27:  PUSH    DE              ; Zeiger f√ºr Ergebnis merken
        PUSH    HL              ; Programmzeiger retten
        LD      L,C             ;! Zeiger auf Variablenwert / -descriptor
        LD      H,B             ;!
        LD      B,A             ; Variablentypflag merken
        LD      C,A             ; Variablentypflag
        CALL    A0143           ; Speicherbereich von (HL) nach (DE) verschieben
        POP     HL              ; geretteten Programmzeiger holen
        LD      A,C             ; Variablentypflag holen
        POP     DE              ; Zeiger auf Ergebnis holen
        JP      A878F           ; bereitgestellten Wert retten
;
;
;   da in FN -->  √ºberpr√ºfen, ob Variable Parameter der Funktion ist
;
A8E36:  PUSH    DE              ; Zeiger f√ºr Ergebnis retten
        CALL    A8BB5           ; Variablennamen (HL) im Zwischenspeicher bereitstellen
        PUSH    HL              ; Programmzeiger retten
        INC     B               ; L√§nge Variablenname f√ºr L√§nge corrigieren
        LD      DE,S11A4        ; Zeiger auf bereitgestellten Variablennamen
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich √ºbertragen
        LD      B,0             ; Z√§hler  'Anzahl Parameter'  auf Null
        LD      HL,(S9048)      ; Zeiger auf Parameter aktuelle FN  holen
        CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
        CP      ____EQ          ; Zwischencode  =  ?
        JR      Z,A8E80         ; ja -->  Funktion hat keine Parameter
        CP      '('             ; Klammer auf  ?
        JR      NZ,A8E7D        ; nein -->  Fehler 1  Syntax error
A8E55:  INC     HL              ; Programmzeiger auf n√§chstes Byte
        INC     B               ; Z√§hler  'Anzahl Dimensionen'  plus eins
        PUSH    BC              ; Z√§hler  'Anzahl Dimensionen'  retten
        CALL    A8BB5           ; Variablennamen (HL) im Zwischenspeicher bereitstellen
        LD      A,C             ; Variablentyp holen
        POP     DE              ; Funktions-Parameter-Typ / Anzahl Parameter
        CP      E               ; mit Typ Variablenname vergleichen
        LD      C,E             ; letzten Typ merken
        JR      NZ,A8E72        ; Typen nicht gleich
        PUSH    DE              ; FN - Parameter - Typ retten
        LD      C,B             ; L√§nge Variablenname
        INC     C               ; f√ºr L√§nge corrigieren
        PUSH    HL              ; Zeiger auf Parameter retten
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        LD      DE,S11A4        ; Zeiger auf Variablennamen bei FN - Aufruf
        CALL    A904C           ; Namen vergleichen
        POP     HL              ; Zeiger auf FN - Parameter holen
        POP     BC              ; FN - Parameter - Typ / Z√§hler  'Anzahl Parameter'
        JR      Z,A8E96         ; Variable ist FN - Parameter
A8E72:  CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
        CP      ')'             ; Klammer zu  ?
        JR      Z,A8E80         ; ja -->  Ende Parameterangabe
        CP      ','             ; Komma  ?
        JR      Z,A8E55         ; ja -->  weitere Parameter √ºberpr√ºfen
A8E7D:  JP      A6364           ; Fehler 1  Syntax error
;
;
;   Variablenname ist nicht FN - Parameter
;
A8E80:  LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        LD      DE,S11A4        ; Zeiger auf Speicher f√ºr Variablennamen
        LD      A,(HL)          ;! L√§nge Variablenname √ºbertragen
        LD      (DE),A          ;!
        LD      B,A             ; Anzahl Zeichen Variablenname
A8E89:  INC     HL              ; Zeiger auf Variablennamen
        INC     DE              ; Zeiger f√ºr Variablennamen
        LD      A,(HL)          ;! ein Zeichen Variablenname √ºbertragen
        LD      (DE),A          ;!
        DJNZ    A8E89           ; weitere Zeichen Variablenname √ºbertragen
        POP     HL              ; Programmzeiger holen
        POP     DE              ; Zeiger f√ºr Ergebnis holen
        CALL    A8ED2           ; Zeiger auf Wert Variable bereitstellen
        JR      A8E27           ; Wert der Variablen bereitstellen
;
;
;   Variable als FN - Parameter gefunden
;
A8E96:  LD      HL,(S904A)      ; Programmzeiger bei FN - Aufruf holen
        CALL    A79A3           ; auf Syntax  'Klammer auf'  √ºberpr√ºfen
        DEC     B               ; Parameter - Z√§hler
        JR      Z,A8EB7         ; steht auf richtigem Parameter
        DEC     HL              ; Programmzeiger corrigieren
A8EA0:  PUSH    BC              ; Parameter - Z√§hler retten
A8EA1:  CALL    A6A0A           ; Zeiger in HL auf n√§chstes Befehlsbyte stellen
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A6364         ; Fehler 1  Syntax error
        CP      ')'             ; Klammer zu  ?
        JP      Z,A6364         ; Fehler 1  Syntax error
        CP      ','             ; Komma  ?
        JR      NZ,A8EA1        ; nein -->  Ende Parameter suchen
        POP     BC              ; Parameter - Z√§hler holen
        DJNZ    A8EA0           ; richtigen Parameter suchen
        INC     HL              ; Komma √ºberspringen
A8EB7:  EX      DE,HL           ; Zeiger nach DE
        POP     HL              ; Programmzeiger holen
        EX      (SP),HL         ; Programmzeiger retten / Zeiger f√ºr Ergebnis holen
        EX      DE,HL           ; Zeiger Ergebnis nach DE / Zeiger Parameter nach HL
        LD      BC,(S9048)      ; Zeiger auf Parameter aktuelle FN  holen
        PUSH    BC              ; und retten
        LD      BC,0            ; Code for 'nicht in FN'
        LD      (S9048),BC      ; als Zeiger auf Parameter aktuelle FN  merken
        CALL    A858E           ; Ausdruck (HL) auswerten
        POP     HL              ; geretteten Zeiger auf Parameter aktuelle FN holen
        LD      (S9048),HL      ; als Zeiger auf Parameter aktuelle FN  merken
        POP     HL              ; Programmzeiger holen
        JP      A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
;
A8ED2:  PUSH    DE              ; Zeiger f√ºr Ergebnis retten
        JP      A8B66           ; Zeiger auf Wert Variable nach Namen (HL) bereitstellen
;
;
;   Variable nach bereitgestelltem Namen in vorhandenen Datens√§tzen suchen
;
A8ED6:  LD      HL,(S1074)      ; Anfang Basic - Variable holen
A8ED9:  LD      DE,S11A4        ; Zeiger auf bereitgestellten Namen
        LD      A,(HL)          ; Typflag der gespeicherten Variablen holen
        OR      A               ; Bereichsendezeichen  ?
        RET     Z               ; ja -->  Namen nicht gefunden
        CP      01000000B       ; Feld oder Funktion  ?
        JR      NC,A8F0A        ; ja
        CP      C               ; mit Namenwertcode vergleichen
        JR      NZ,A8EFF        ; falscher Typ
        INC     HL              ; Variablentypcode √ºberspringen
        LD      A,(DE)          ;! Namenl√§nge vergleichen
        CP      (HL)            ;!
        JR      NZ,A8EFD        ; L√§ngen stimmen nicht √ºberein
        LD      B,A             ; L√§nge Name
A8EEC:  INC     DE              ; Zeiger auf vorgegebenen Namen
        INC     HL              ; Zeiger auf gespeicherten Namen
        LD      A,(DE)          ;! ein Zeichen Name vergleichen
        CP      (HL)            ;!
        JR      NZ,A8EF7        ; Namen nicht gleich
        DJNZ    A8EEC           ; weitere Zeichen Namen vergleichen
        INC     HL              ; Zeiger auf Wert stellen
        SCF                     ; Code for 'Variable gefunden'  setzen
        RET
;
;
;   Zeiger in HL auf Ende Variablenwert bereitstellen
;
A8EF7:  INC     HL              ; Zeiger auf Namen
        DJNZ    A8EF7           ; Zeiger auf Ende Namen stellen
        LD      A,C             ; Typflag holen
        JR      A8F04           ; Zeiger auf Ende Wert stellen
;
;
;   Zeiger in HL auf n√§chste Variable stellen
;
A8EFD:  LD      A,C             ; Typflag holen
        DEC     HL              ; Zeiger auf Anfang Datensatz
A8EFF:  AND     00001111B       ; Wertl√§nge maskieren
        INC     HL              ; Zeiger auf Namenl√§nge
        ADD     A,(HL)          ; Namenl√§nge addieren
        INC     HL              ; Zeiger auf Variablennamen
A8F04:  LD      E,A             ; Offset auf Ende Datensatz
        LD      D,0             ; High - Byte Offset auf Null
        ADD     HL,DE           ; Zeiger auf Ende Datensatz
        JR      A8ED9           ; n√§chsten Datensatz √ºberpr√ºfen
;
;
;   Typ bei dimensionierter Variable oder Funktion √ºberpr√ºfen
;
A8F0A:  CP      C               ; Typen vergleichen
        JR      Z,A8F21         ; richtiger Typ
        INC     HL              ; Zeiger auf Felddaten
A8F0E:  LD      E,(HL)          ;! Offset auf Ende Datensatz holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        DEC     HL              ;! Zeiger auf Ende Datensatz errechnen
        ADD     HL,DE           ;!
        JR      A8ED9           ; n√§chsten Datensatz √ºberpr√ºfen
;
;
;   Zeiger in HL auf Ende Feld / Funktion stellen
;
A8F15:  LD      A,C             ; L√§nge Name holen
        SUB     B               ; schon verglichene Zeichen abziehen
        CPL                     ; 2er Complement bilden
        LD      C,A             ; und merken
        LD      B,-1            ; BC enth√§lt Offset auf Anfang in 2er CPL
        ADD     HL,BC           ; Zeiger auf Anfang Felddaten errechnen
        POP     BC
A8F1D:  DEC     HL
        DEC     HL
        JR      A8F0E           ; Offset auf Ende Feld holen und Zeiger richten
;
;
;   Feld- / Funktionsnamen vergleichen
;
A8F21:  LD      A,(HL)          ; L√§nge Name im Datensatz holen
        EXX
        LD      C,A             ; L√§nge Name
        LD      B,0             ; Z√§hler  'Anzahl verglichene Zeichen'
        EXX
        INC     HL              ; Zeiger auf Dimensionen
        PUSH    DE              ; Zeiger auf Namen
        LD      E,(HL)          ;! Offset auf Feldende holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        INC     HL              ; Zeiger auf Feldnamen
        EX      DE,HL
        ADD     HL,DE           ; Zeiger auf Feldende errechnen
        EX      DE,HL
        POP     DE              ; Zeiger auf Namen holen
        LD      A,(DE)          ;! Namenl√§nge vergleichen
        CP      (HL)            ;!
        JR      NZ,A8F1D        ; L√§ngen nicht gleich -->  n√§chsten Datensatz vergleichen
        PUSH    BC              ; Anzahl Dimensionen merken
        LD      B,A             ; L√§nge Name merken
        LD      C,A             ; L√§nge Name
A8F38:  INC     HL              ; Zeiger auf gespeicherten Namen
        INC     DE              ; Zeiger auf vorgegebenem Namen
        LD      A,(DE)          ;! ein Zeichen Name vergleichen
        CP      (HL)            ;!
        JR      NZ,A8F15        ; nicht gleich -->  n√§chsten Datensatz vergleichen
        DJNZ    A8F38           ; weitere Zeichen Name vergleichen
        INC     HL              ; Zeiger auf Dimensionierung stellen
        POP     BC              ; Anzahl Dimensionen holen
        SCF                     ; Code for 'Feld / Funktion gefunden'  setzen
        RET
;
;
;   Basic - Befehl   DEF FN
;
A8F44:  CALL    A8BB5           ; Variablennamen (HL) im Zwischenspeicher bereitstellen
        SET     6,C             ; Code for 'Funktion'  setzen
        PUSH    HL              ; Programmzeiger auf Anfang Funktion retten
        CALL    A8ED6           ; Variable nach bereitgestelltem Namen suchen
        JP      C,A6376         ; schon vorhanden -->  Fehler 7  Array def. error
        LD      (HL),C          ; Code for 'FN'  eintragen
        EX      (SP),HL         ; Programmzeiger holen / Zeiger f√ºr Funktion merken
        PUSH    HL              ; Programmzeiger auf Anfang Funktion merken
        DEC     HL              ; f√ºr Schleife corrigieren
A8F54:  CALL    A6A0A           ; Zeiger in HL auf n√§chstes Befehlsbyte stellen
        OR      A               ; Zeilenendezeichen  ?
        JR      Z,A8F5E         ; ja
        CP      ':'             ; Befehlsendezeichen  ?
        JR      NZ,A8F54        ; nein -->  Ende Befehl suchen
A8F5E:  POP     DE              ; Zeiger auf Anfang Funktionstext holen
        PUSH    HL              ; Zeiger auf Ende Funktionstext merken
        INC     HL              ;! L√§nge des Funktionstextes errechnen
        SBC     HL,DE           ;!
        LD      A,(S11A4)       ; L√§nge Funktionsname holen
        ADD     A,4             ; Stammdatenl√§nge f√ºr Funktion addieren
        LD      C,A             ; und merken
        LD      B,0             ; High - Byte auf Null
        LD      A,L             ; L√§nge Funktionstext holen
        ADD     HL,BC           ; Speicherplatzl√§nge f√ºr Funktion errechnen
        LD      B,A             ; L√§nge Funktionstext
        PUSH    HL              ; Speicherplatzl√§nge f√ºr Funktion 
        EXX
        POP     BC              ; Speicherplatzl√§nge f√ºr Funktion holen
        PUSH    BC              ; und wieder merken
        PUSH    HL              ;! Register - Werte retten
        PUSH    DE              ;!
        PUSH    BC              ;!
        LD      HL,0            ;! Stackpointer holen
        ADD     HL,SP           ;!
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        DEC     H               ; mindestens 256 Byte Arbeitsbereich
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; freien Speicherplatz errechnen
        LD      A,12            ; Fehler 12  DEF FN nesting error
        JP      C,A63A9         ; Speicher zu klein -->  Fehler behandeln
        POP     BC              ;! gerettete Register - Werte wieder holen
        POP     DE              ;!
        POP     HL              ;!
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        PUSH    HL              ; und merken
        ADD     HL,BC           ; neues Ende errechnen
        EX      (SP),HL         ; neues Ende merken / altes Ende holen
        PUSH    HL              ; und merken
        LD      DE,(S1076)      ; Anfang Stringtextbereich holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; zu verschiebende Anzahl Bytes errechnen
        LD      C,L             ;! Anzahl zu verschiebende Bytes nach BC
        LD      B,H             ;!
        POP     HL              ; altes Ende holen
        POP     DE              ; neues Ende holen
        LDDR                    ; Platz f√ºr neue Funktion schaffen
        POP     DE              ; Speicherplatzl√§nge der Funktion holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    26              ; Code 26   Zeiger auf Stringbereiche corrigieren
        DEC     DE              ; L√§nge Funktion f√ºr Offset corrigieren
        POP     HL              ; Programmzeiger auf Ende Funktion holen
        EX      (SP),HL         ; Zeiger merken / Zeiger auf Stelle f√ºr Funktion
        INC     HL
        LD      (HL),E          ;! Offset auf Ende Funktion eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL
        LD      DE,S11A4        ; Zeiger auf bereitgestellten Funktionsnamen
        LD      A,(DE)          ;! L√§nge Funktionsname √ºbertragen
        LD      (HL),A          ;!
        LD      B,A             ; L√§nge Funktionsname
A8FAE:  INC     DE              ; Zeiger auf Funktionsnamen
        INC     HL              ; Zeiger auf Speicher f√ºr Funktion
        LD      A,(DE)          ;! ein Zeichen Funktionsname √ºbertragen
        LD      (HL),A          ;!
        DJNZ    A8FAE           ; weitere Zeichen Funktionsname √ºbertragen
        INC     HL              ; letztes Zeichen Funktionsname √ºberspringen
        PUSH    HL              ; Zeiger auf Speicher f√ºr Funktion
        EXX
        POP     HL              ; Zeiger auf Speicher f√ºr Funktion
        CALL    A014A           ; Speicherbereich von (DE) nach (HL) verschieben
        LD      (HL),0          ; Code for 'Bereichsende'  eintragen
        POP     HL              ; Programmzeiger holen
        RET
;
;
;   Basic - Funktion   FN     (Zwischencode 255 199 / 0FFH 0C7H)
;
A8FBF:  PUSH    DE              ; Zeiger f√ºr Ergebnis merken
        CALL    A8BB5           ; Variablennamen (HL) im Zwischenspeicher bereitstellen
        POP     IX              ; Zeiger f√ºr Ergebnis holen
        PUSH    BC              ; L√§nge Funktionsname retten
        SET     6,C             ; Code for 'Funktionsname'  setzen
        LD      DE,(S904A)      ; alten Programmzeiger bei FN - Aufruf holen
        LD      (S904A),HL      ; neuen Programmzeiger bei FN - Aufruf merken
        PUSH    DE              ; alten Programmzeiger retten
        CALL    A8ED6           ; Variable nach bereitgestelltem Namen suchen
        JP      NC,A6382        ; Funktion nicht gefunden -->  Fehler 15  Un def. function error
        LD      DE,(S9048)      ; Zeiger auf Parameter aktuelle FN  holen
        LD      (S9048),HL      ; Zeiger auf Parameter aktuelle FN  merken
        PUSH    DE              ; alten Zeiger auf Funktionsparameter retten
        PUSH    IX              ; Zeiger auf Speicher f√ºr Ergebnis retten
        DEC     HL              ; Zeiger auf Funktion corrigieren
A8FE1:  CALL    A6A0A           ; Zeiger in HL auf n√§chstes Befehlsbyte stellen
        CALL    A5963           ; √ºberpr√ºfen, ob Zeichen (HL) gleich Befehlsendezeichen
        JP      Z,A6364         ; Zeilenende -->  Fehler 1  Syntax error
        CP      ____EQ          ; Zwischencode  =  ?
        JR      NZ,A8FE1        ; nein -->  Anfang Funktionstext suchen
        INC     HL              ; Zwischencode = √ºberspringen
        POP     DE              ; Zeiger f√ºr Ergebnis holen
        PUSH    DE              ; und wieder merken
        CALL    A858E           ; Ausdruck (HL) mit allen Priorit√§ten auswerten
        POP     DE              ; Zeiger auf Ergebnis holen
        LD      HL,(S904A)      ; Programmzeiger bei FN - Aufruf holen
        POP     BC              ; alten Zeiger auf Funktionsparameter holen
        LD      (S9048),BC      ; Zeiger auf Parameter aktuelle FN  merken
        POP     BC              ; alten Programmzeiger bei FN - Aufruf holen
        LD      (S904A),BC      ; Programmzeiger bei FN - Aufruf merken
        EX      DE,HL           ; Zeiger auf bereitgestellten Wert nach HL
        POP     BC               
        LD      A,C             ; Funktionstyp holen
        CALL    A9032           ; auf Syntax 'zwei gleiche Ergebnistypen'  untersuchen
        LD      BC,5            ; L√§nge bereitgestellter Wert
        ADD     HL,BC           ; bereitgestellten Wert retten
        EX      DE,HL           ; Zeiger f√ºr Wert nach DE / Programmzeiger nach HL
        CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
        CP      '('             ; Klammer auf  ?
        RET     NZ              ; nein -->  Funktion hat keine Parameter
        PUSH    DE              ; Zeiger f√ºr Ergebnis merken
        LD      B,1             ; Code for 'eine Klammer suchen'
A9016:  PUSH    BC              ; Z√§hler retten
        CALL    A6A0A           ; Zeiger in HL auf n√§chstes Befehlsbyte stellen
        POP     BC              ; Parameterz√§hler holen
        CALL    A5966           ; testen, ob Accu gleich Befehlsendezeichen
        JP      Z,A6364         ; Fehler 1  Syntax error
        CP      '('             ; Klammer auf  ?
        JR      NZ,A9026        ; nein
        INC     B               ; Klammerz√§hler plus eins
A9026:  CP      ')'             ; Klammer zu  ?
        JR      NZ,A9016        ; nein -->  Ende Parameter suchen
        DJNZ    A9016           ; richtige Anzahl  'Klammer zu'  suchen
        INC     HL              ; Klammer zu √ºberspringen
        CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
        POP     DE              ; Zeiger f√ºr Ergebnis holen
        RET
;
;
;   auf Syntax 'zwei gleiche Ergebnistypen'  untersuchen
;
A9032:  CP      3               ; erster Wert vom Typ String  ?
        JR      NZ,A903F        ; nein -->  Syntaxuntersuchung auf Real - Wert - Ergebnis
;
;
;   Syntaxuntersuchung auf Zeichenkettenergebnis
;
A9036:  LD      A,(S9E9C)       ; Wertart - Flag des bereitgestellten Wertes holen
        CP      3               ; Stringwert  ?
        RET     Z               ; ja -->  OK
        JP      A636D           ; Fehler 4   Type mismatch error
;
;
;   Syntaxuntersuchung auf Real - Wert - Ergebnis
;
A903F:  LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        CP      3               ; Stringwert  ?
        RET     NZ              ; nein -->  OK
        JP      A636D           ; Fehler 4   Type mismatch error
;
S9048:  DEFS    2               ; Zeiger auf Parameter der aktuellen Funktion
S904A:  DEFS    2               ; Programmzeiger bei Funktionsaufruf
 
;
;   Variablennamen vergleichen
;
A904C:  LD      A,(DE)          ;! L√§nge Variablennamen vergleichen
        CP      (HL)            ;!
        RET     NZ              ; Namenl√§ngen nicht gleich
        PUSH    BC              ;! Register - Werte retten
        PUSH    DE              ;!
        PUSH    HL              ;!
        LD      B,C             ; Anzahl zu vergleichende Zeichen
A9053:  LD      A,(DE)          ;! ein Zeichen Variablennamen vergleichen
        CP      (HL)            ;!
        JR      NZ,A905C        ; Namen nicht gleich
        INC     DE              ;! Zeiger auf Namen auf n√§chstes Zeichen
        INC     HL              ;!
        DJNZ    A9053           ; weitere Zeichen Variablenname vergleichen
        XOR     A               ; Code for 'Variablenname gleich'
A905C:  POP     HL              ;! gerettete Register - Werte holen
        POP     DE              ;!
        POP     BC              ;!
        RET
;
;
;   Basic - Funktion   STICK     (Zwischencode 255 156 / 0FFH 09CH)
;
A9060:  CALL    A79A3           ; auf Syntax 'Klammer auf' untersuchen
        PUSH    DE              ; Zeiger f√ºr Ergebnis retten
        CALL    A8547           ; Ausdruck (HL) auswerten und 2-Byte Wert nach DE
        CALL    A8540           ; untersuchen, ob Wert in DE zwischen 0 und 255 liegt
        CP      2 + 1           ; bekannte Joy - Stick - Nummer  ?
        JP      NC,A636A        ; nein -->  Fehler 3  Illegal data error
        POP     DE              ; Zeiger auf Stelle f√ºr Ergebnis holen
        PUSH    AF              ; Joy - Stick - Nummer retten
        CALL    A79AA           ; auf Syntax 'Klammer zu' untersuchen
        POP     AF              ; gerettete Joy - Stick - Nummer holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    30              ; Code 30   Joy - Stick nach Richtung abfragen
        EX      DE,HL           ; Programmzeiger nach DE/Zeiger f√ºr Ergebnis nach HL
        PUSH    DE              ; Programmzeiger retten
        CALL    A887D           ; Wert im Accu umsetzen in Real - Wert nach (HL)
        JP      A8964           ; bereitgestellten Wert retten und Programmzeiger holen
;
;
;   Basic - Funktion   STRIG     (ZWischencode 255 157 / 0FFH 09DH)
;
A907F:  CALL    A79A3           ; auf Syntax 'Klammer auf' untersuchen
        PUSH    DE              ; Zeiger f√ºr Ergebnis retten
        CALL    A8547           ; Ausdruck (HL) auswerten und 2-Byte Wert nach DE
        CALL    A8540           ; untersuchen, ob Wert in DE zwischen 0 und 255 liegt
        CP      4 + 1           ; mit maximaler Feuerknopf - Nummer vergleichen
        JP      NC,A636A        ; zu gro√ü -->  Fehler 3  Illegal data error
        POP     DE              ; Zeiger f√ºr Ergebnis holen
        PUSH    AF              ; Feuerknopf - Nummer merken
        CALL    A79AA           ; auf Syntax 'Klammer zu' untersuchen
        POP     AF              ; gerettete Feuerknopf - Nummer abfragen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    31              ; Code 31   Feuerknopf des Joy - Sticks abfragen
        EX      DE,HL           ; Programmzeiger nach DE / Zeiger f√ºr Ergebnis nach HL
        PUSH    DE              ; Programmzeiger retten
        CALL    A887D           ; Wert im Accu umsetzen in Real - Wert nach (HL)
        JP      A8964           ; bereitgestellten Wert retten und Programmzeiger holen
;
;
;   Null im Real - Format nach (HL) eintragen
;
A909E:  PUSH    HL              ; Zeiger auf Speicher f√ºr Zahl retten
        LD      B,5             ; L√§nge Real - Zahlwert
        CALL    A0137           ; Speicherbereich (HL) l√∂schen
        POP     HL              ; Zeiger auf Speicher f√ºr Zahl holen
        RET
;
;
;   Vorzeichen des Wertes (HL) umkehren
;
A90A6:  CALL    A903F           ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
A90A9:  LD      A,(HL)          ; Exponenten des Zahlwertes holen
        OR      A               ; gleich Null  ?
        RET     Z               ; Wert gleich Null -->  fertig
        INC     HL              ; Zeiger auf MSByte Mantisse Zahl
        LD      A,(HL)          ; MSByte Mantisse holen
        XOR     10000000B       ; Vorzeichenflag umkehren
        LD      (HL),A          ; neues MSByte eintragen
        DEC     HL              ; Zeiger wieder auf Exponent
        RET
;
;
;   Basic - Funktion   -
;
A90B3:  CALL    A903F           ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
        LD      C,A             ; L√§nge Real - Wert merken
        LD      A,10000000B     ; Code for 'Minus'
        JP      A90C6           ; Einsprung in Routine
;
;
;   Basic - Funktion   +
;
A90BC:  LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        CP      3               ; Stringwert  ?
        JP      Z,A9110         ; ja -->  zwei Strings addieren
        LD      C,A             ; Wertl√§nge merken
        XOR     A               ; Code for 'Plus'
A90C6:  LD      (S94C0),HL      ; Zeiger auf Speicher f√ºr Ergebnis merken
        PUSH    DE              ;! Zeiger auf Argumente retten
        PUSH    HL              ;!
        LD      (S94C3),SP      ; Stackpointer merken
        INC     HL              ;! Zeiger auf Vorzeichen der Argumente
        INC     DE              ;! stellen
        LD      B,(HL)          ;! Vorzeichen des Ergebnisses errechnen
        XOR     (HL)            ;!
        EX      DE,HL           ;!
        XOR     (HL)            ;!
        DEC     HL              ;! Zeiger wieder auf Exponenten
        DEC     DE              ;!
        EX      DE,HL           
        RLCA                    ; Rechenbit nach Carry schieben
        LD      A,B             ; Vorzeichen holen
        LD      (S94C2),A       ; Vorzeichen Ergebnis merken
        JP      C,A91D1         ; Zahlen voneinander subtrahieren
        XOR     A               ; Accu auf Null
        CP      (HL)            ; mit Exponent erstes Argument vergleichen
        JP      Z,A9105         ; 1. Wert = 0 -->  Ergebnis ist zweites Argument
        LD      A,(DE)          ; Exponent zweites Argument holen
        OR      A               ; gleich Null  ?
        JR      Z,A90ED         ; ja -->  Ergebnis ist erstes Argument
        SUB     (HL)            ; Exponentendifferenz errechnen
        JP      A9214           ; Mantissen angleichen und Zahlen addieren
;
;
;   erstes Argument plus errechnetes Vorzeichen als Ergebnis vorgeben
;
A90ED:  LD      SP,(S94C3)      ; Stackpointer holen
        POP     HL              ;! gerettete Zeiger auf Argumente holen
        POP     DE              ;!
        EI                      ; Interrupt freigeben
        LD      A,(HL)          ; Exponenten holen
        OR      A               ; gleich Null ?
        JP      Z,A95BD         ; ja -->  Absolut - Wert bilden
        LD      A,(S94C2)       ; Vorzeichen Ergebnis holen
        AND     10000000B       ; Vorzeichenbit maskieren
        INC     HL              ; Zeiger auf MSByte Mantisse
        RES     7,(HL)          ; Wert auf positives Vorzeichen
        OR      (HL)            ; plus neues Vorzeichen
        LD      (HL),A          ; MSByte Mantisse wieder merken
        DEC     HL              ; Zeiger auf Exponent Ergebnis
        RET
;
;
;   zweites Argument und errechnetes Vorzeichen als Ergebnis vorgeben
;
A9105:  LD      B,0             ; High - Byte Anzahl auf Null
        LD      A,5             ; L√§nge  Real - Wert
        LD      C,A             ; vorgeben
        EX      DE,HL           ; Zeiger vertauschen
        LDIR                    ; zweites Argument auf erstes Argument √ºbertragen
        JP      A90ED           ; Vorzeichen Ergebnis richten
;
;
;   zwei Zeichenketten addieren
;
A9110:  LD      B,(HL)          ; L√§nge erste Zeichenkette holen
        LD      A,(DE)          ; L√§nge zweite Zeichenkette holen
        ADD     A,B             ; neue Zeichenkettenl√§nge errechnen
        JP      C,A6370         ; √úbertrag -->  Fehler 5  String length error
        LD      C,A             ; L√§nge der neuen Zeichenkette merken
        PUSH    DE              ; Zeiger auf zweiten Zeichenkettendescriptor
        PUSH    HL              ; Zeiger auf ersten Zeichenkettendescriptor
        PUSH    DE              ; Zeiger auf zweiten Zeichenkettendescriptor
        INC     HL              ; L√§nge der ersten Zeichenkette √ºberspringen
        LD      E,(HL)          ;! Offset auf Zeichenkette aus Descriptor holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      HL,(S1076)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf Zeichenkette errechnen
        EX      DE,HL           ; und in DE merken
        LD      HL,(S107A)      ; Ende Stringarbeitsbereich holen
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich √ºbertragen
        EX      (SP),HL         ; Zeiger auf zweiten Descriptor holen
        LD      B,(HL)          ; L√§nge zweite Zeichenkette holen
        INC     HL
        LD      E,(HL)          ;! Offset auf Zeichenkette aus Descriptor holen
        INC     HL              ;!
        LD      D,(HL)          ;!
        LD      HL,(S1076)      ; Anfang Stringtextbereich holen
        ADD     HL,DE           ; Zeiger auf String errechnen
        EX      DE,HL           ; und nach DE
        POP     HL              ; Zeiger auf Ende des ersten Strings holen
        CALL    A8BFC           ; Stringkonstante in Arbeitsbereich √ºbertragen
        LD      A,C             ; L√§nge neuer String holen
        LD      DE,(S107A)      ; Ende Stringarbeitsbereich holen
        LD      BC,(S1076)      ; Anfang Stringtextbereich holen
        EX      DE,HL            
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,BC           ; Offset auf neuen String errechnen
        EX      DE,HL           ; Zeiger auf Ende String nach HL
        LD      (S107A),HL      ; Ende Stringarbeitsbereich merken
        POP     HL              ; Zeiger f√ºr Ergebnis holen
        LD      (HL),A          ; L√§nge des neuen Strings eintragen
        INC     HL              
        LD      (HL),E          ;! Offset auf String in Descriptor eintragen
        INC     HL              ;!
        LD      (HL),D          ;!
        DEC     HL              ;! Zeiger wieder auf Anfang Descriptor setzen
        DEC     HL              ;!
        POP     DE              ; geretteten Register - Wert holen
        RET
;
;
;   zwei Zahlen oder Zeichenketten vergleichen
;       
A9153:  LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        CP      3               ; Strings  ?
        JR      NZ,A918E        ; nein -->  Zahlwerte vergleichen
;
;   
;   Zeichenketten mit Descriptoren (HL) und (DE) vergleichen
;
        PUSH    DE              ; Zeiger auf zweiten Stringdescriptor
        PUSH    HL              ; Zeiger auf ersten Stringdescriptor
        LD      A,(DE)          ;! Stringl√§ngen gleich Null  ?
        OR      (HL)            ;!
        JR      Z,A918B         ; ja -->  Strings gleich
        LD      A,(DE)          ;! Stringl√§ngen vergleichen
        CP      (HL)            ;!
        JR      C,A9165         ; zweiter String ist l√§nger
        LD      A,(HL)          ; kleinere L√§nge holen
A9165:  OR      A               ; gleich Null  ?
        JR      Z,A9185         ; ja
        INC     HL              ; Stringl√§nge √ºberspringen
        LD      C,(HL)          ;! Offset auf ersten String aus Descriptor
        INC     HL              ;! holen
        LD      B,(HL)          ;!
        EX      DE,HL           ; Zeiger auf zweiten Descriptor nach HL
        INC     HL              ; Stringl√§nge √ºberspringen
        LD      E,(HL)          ;! Offset auf zweiten String aus Descriptor 
        INC     HL              ;! holen
        LD      D,(HL)          ;!
        LD      HL,(S1076)      ; Anfang Stringtextbereich holen
        EX      DE,HL
        ADD     HL,DE           ; Zeiger auf zweiten String errechnen
        EX      DE,HL
        ADD     HL,BC           ; Zeiger auf ersten String errechnen
        EX      DE,HL
        LD      B,A             ; zu vergleichende Anzahl merken
        OR      A               ; zu vergleichende Anzahl gleich Null ?
        JR      Z,A918B         ; ja
A917D:  LD      A,(DE)          ;! ein Zeichen vergleichen
        CP      (HL)            ;!
        JR      NZ,A918B        ; nicht gleich -->  Vergleich entschieden
        INC     DE              ;! Zeiger auf Strings auf n√§chstes Zeichen
        INC     HL              ;!
        DJNZ    A917D           ; weitere Zeichen vergleichen
A9185:  POP     DE              ;! Zeiger auf Descriptoren holen
        POP     HL              ;!
        LD      A,(DE)          ;! Stringl√§ngen vergleichen
        CP      (HL)            ;!
        EX      DE,HL
        RET
;
A918B:  POP     HL              ;! Zeiger auf Stringdescriptoren holen
        POP     DE              ;!
        RET
;
;
;   zwei Real - Zahlwerte vergleichen
;
A918E:  INC     DE              ;! Zeiger auf Mantissen der Zahlen
        INC     HL              ;!
        LD      A,(DE)          ; Vorzeichen zweiter Wert holen
        DEC     DE              ; Zeiger wieder auf Exponent
        XOR     (HL)            ; Vorzeichen erster Wert
        RLCA                    ; Vorzeichen nach Carry schieben
        JR      NC,A919A        ; Vorzeichen der Werte gleich
        LD      A,(HL)          ; Vorzeichen erster Wert holen
        DEC     HL              ; Zeiger wieder auf Exponenten
        RLCA                    ; Vorzeichen nach Carry schieben
        RET
;
A919A:  LD      A,(HL)          ; Vorzeichen erster Wert holen
        DEC     HL              ; Zeiger wieder auf Exponenten
        RLCA                    ; Vorzeichen nach Carry schieben
        JR      NC,A91A5        ; Werte sind positiv
        CALL    A91A5           ; Real-Zahlen (HL) ohne Vorzeichen vergleichen
        RET     Z               ; Zahlen sind gleich
        CCF                     ; Ergebnis umkehren
        RET
;
;
;   Real - Zahlen  (HL) und (DE)  ohne Vorzeichen vergleichen
;
A91A5:  PUSH    DE              ;! Zeiger auf Zahlwerte retten
        PUSH    HL              ;!
        EX      DE,HL
        LD      A,(DE)          ;! Exponenten der Zahlen vergleichen
        CP      (HL)            ;!
        JR      NZ,A91C6        ; Exponenten nicht gleich
        INC     DE              ;! Zeiger auf Mantissen der Zahlen
        INC     HL              ;!
        LD      A,(HL)          ; Mantisse erster Wert holen
        OR      10000000B       ; Vorzeichen auf 'minus'
        LD      B,A             ; und Byte merken
        LD      A,(DE)          ; Mantissen zweiter Wert holen
        OR      10000000B       ; Vorzeichen auf 'minus'
        CP      B               ; MSBytes der Mantissen vergleichen
        JR      NZ,A91C6        ; Werte nicht gleich
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        LD      B,A             ; als L√§nge Zahl merken
        DEC     B               ; f√ºr Exponenten corrigieren
        DEC     B               ; f√ºr MSByte corrigieren
A91BE:  INC     DE              ;! Zeiger auf Mantissen auf n√§chstes Byte
        INC     HL              ;!
        LD      A,(DE)          ;! ein Byte der Mantissen vergleichen
        CP      (HL)            ;!
        JR      NZ,A91C6        ; Zahlen nicht gleich
        DJNZ    A91BE           ; weitere Bytes vergleichen
A91C6:  POP     HL              ;! gerettete Zeiger auf Werte holen
        POP     DE              ;!
        RET
;
;
;   Ergebnis gleich  'Null'  vorgeben
;
A91C9:  POP     HL              ; Zeiger f√ºr Ergebnis holen
        PUSH    HL              ; und wieder merken
        CALL    A909E           ; Null im Real - Format nach (HL) eintragen
        JP      A90ED           ; Stackpointer corrigieren
;
;
;   Zahlen (HL) und (DE) subtrahieren
;
A91D1:  CALL    A91A5           ; Real-Zahlen (HL) und (DE) ohne Vorzeichen vergleichen
        JR      Z,A91C9         ; Zahlen gleich -->  Ergebnis gleich Null
        JR      NC,A91E1        ; erster Wert ist gr√∂√üer zweiter Wert
        LD      A,(S94C2)       ; Vorzeichen Ergebnis holen
        XOR     10000000B       ; Vorzeichen umkehren
        LD      (S94C2),A       ; und wieder merken
        SCF                     ; Code for '2tes Argument gr√∂√üer'
A91E1:  EX      AF,AF           ; merken
        LD      A,(HL)          ; Exponent erstes Artgument holen
        OR      A               ; gleich Null  ?
        JP      Z,A9105         ; ja -->  zweites Argument als Ergebnis vorgeben
        LD      A,(DE)          ; Exponent zweites Argument holen
        OR      A               ; gleich Null  ?
        JP      Z,A90ED         ; ja -->  erstes Argument als Ergebnis vorgeben
        SUB     (HL)            ; Exponentendifferenz errechnen
        JR      C,A91F6         ; erstes Argument ist gr√∂√üer
        CP      4 * 8           ; erlaubte Exponentendifferenz maximal
        JP      NC,A9105        ; erstes Argument zu klein -->  Eregbnis 2tes Argument
        JR      A91FD           ; Exponenten angleichen
;
A91F6:  NEG                     ; 2er Complement der Exponentendifferenz bilden
        CP      4 * 8           ; erlaubte Exponentendifferenz maximal
        JP      NC,A90ED        ; 2tes Argument zu klein -->  Ergebnis ist 1tes Argument
A91FD:  EX      AF,AF           ; Flag  '2tes Argument gr√∂√üer'  holen
        JR      C,A9201         ; 2tes Argument ist gr√∂√üer
        EX      DE,HL           ; Zeiger auf Argumente vertauschen
A9201:  EX      AF,AF           ; Exponentendifferenz holen
        JP      A929B           ; Zahlen voneinander subrahieren
;
A9205:  LD      SP,(S94C3)      ; Stackpointer holen
        EI                      ; Interrupt freigeben
        POP     HL              ;! Zeiger auf Argumente holen
        POP     DE              ;!
        LD      A,(S94CA)
        OR      A
        JP      Z,A6367         ; Fehler 2   Overflow error
        RET
;
;
;   Zahlen (HL) und (DE) addieren
;
A9214:  JR      NC,A9220        ; 2tes Argument ist gr√∂√üer
        NEG                     ; 2er Complement der Exponentendifferenz bilden
        CP      4 * 8           ; erlaubte Exponentendifferenz maximal
        JP      NC,A90ED        ; Ergebnis ist 2tes Argument
        EX      DE,HL           ; Zeiger vertauschen
        JR      A9225           ; Mantissen angleichen und Zahlen addieren
;
A9220:  CP      4 * 8           ; erlaubte Exponentendifferenz maximal
        JP      NC,A9105        ; 2tes Argument zu klein -->  1tes Argument als Ergebnis
A9225:  CALL    A925B           ; Mantissen angleichen und Werte in Register laden
        LD      A,H             ;! 4tes Byte Mantisse addieren
        EXX                     ;!
        ADC     A,H             ;!
        EXX
        LD      H,A             ; Ergebnis merken
        LD      A,L             ;! 3tes Byte Mantisse addieren
        EXX                     ;!
        ADC     A,L             ;!
        EXX     
        LD      L,A             ; Ergebnis merken
        LD      A,D             ;! 2tes Byte Mantisse addieren
        EXX                     ;!
        ADC     A,D             ;!
        EXX
        LD      D,A             ; Ergebnis merken
        LD      A,E             ;! 1tes Byte Mantisse addieren
        EXX                     ;!
        ADC     A,E             ;!
        EXX
        JR      NC,A9248        ; kein √úbertrag
        RRA                     ;! Mantisse entsprechend √úbertrag
        RR      D               ;! corrigieren
        RR      L               ;!
        RR      H               ;!
        INC     C               ; Exponent plus eins
        JP      Z,A9205         ; Exponent zu gro√ü
A9248:  LD      E,A             ; MSByte Mantisse merken
        LD      A,C             ; Exponent Ergebnis holen
        EXX
        LD      BC,5            ; L√§nge Real - Wert
        LD      HL,(S94C0)      ; Zeiger auf Speicher f√ºr Ergebnis holen
        LD      (HL),A          ; Exponenten eintragen
        ADD     HL,BC           ; Zeiger auf Ende Mantisse
        DI                      ; Interrupt sperren
        LD      SP,HL           ; Stackpointer auf Ende Mantisse setzen
        EXX
        PUSH    HL              ; LSBytes Mantisse ablegen
        PUSH    DE              ; MSBytes Mantisse ablegen
        JP      A90ED           ; Stackpointer richten und Vorzeichen eintragen
;
;
;   Mantissen entsprechend Exponentendifferenz angleichen
;   und Werte in Register laden
;
A925B:  DI                      ; Interrupt sperren
        LD      (S94C5),SP      ; Stackpointer bei Interruptsperrung merken
        EX      AF,AF           ; Exponentenz√§hler retten
        INC     HL              ; Zeiger auf Mantisse
        LD      SP,HL           ; Stackpointer setzen
        EXX
        POP     DE              ; zwei MSBytes Mantisse holen
        SET     7,E             ; erstes Bit der Mantisse setzen
        POP     HL              ; zwei LSBytes Mantisse holen
        OR      A               ; Carry - Flag zur√ºcksetzen
A9269:  EX      AF,AF           ; Exponentendifferenz holen
        CP      8               ; gr√∂√üer oder gleich acht  ?
        JR      C,A927A         ; nein -->  einzeln schieben
        SUB     8               ; Differenz minus acht
        EX      AF,AF           ; Rest Exponentendifferenz retten
        RL      H               ; Rundungsbit nach Carry schieben
        LD      H,L             ;! Mantisse um acht Bit  (1 Byte) schieben
        LD      L,D             ;!
        LD      D,E             ;!
        LD      E,0             ;!
        JR      A9269           ; √ºberpr√ºfen, ob Mantissen angeglichen
;
A927A:  OR      A               ; Differenz gleich Null  ?
        JR      Z,A928B         ; ja -->  zweites Argument laden
A927D:  EX      AF,AF           ; Restdifferenz retten
        OR      A               ; Carry - Flag zur√ºcksetzen
        RR      E               ;! Mantissen um ein Bit schieben
        RR      D               ;!
        RR      L               ;!
        RR      H               ;!
        EX      AF,AF           ; Rest Exponentendifferenz holen
        DEC     A               ; Z√§hler minus eins
        JR      NZ,A927D        ; weiter angleichen
A928B:  EXX
        EX      DE,HL           ; Zeiger auf 2tes Argument nach HL
        LD      C,(HL)          ; Exponenten holen
        INC     HL              ; Zeiger auf MSByte Mantisse
        LD      SP,HL           ; Stackpointer setzen
        POP     DE              ; MSBytes Mantisse holen
        SET     7,E             ; erstes Bit der Mantisse setzen
        POP     HL              ; LSBytes Mantisse holen
        EX      AF,AF           ; Bit f√ºr Rundung holen
        LD      SP,(S94C5)      ; Stackpointer bei Interruptsperrung holen
        EI                      ; Interrupt wieder freigeben
        RET
;
;
;   Zahl (DE) von Zahl (HL) subtrahieren
;
A929B:  CP      4 * 8           ; Exponentendifferenz maximal
        JP      NC,A90ED        ; zu gro√ü -->  Ergebnis ist 1tes Argument
        CALL    A925B           ; Mantissen angleichen und Werte in Register laden
        LD      A,H             ;! 4tes Byte subtrahieren
        EXX                     ;!
        SBC     A,H             ;!
        EXX
        LD      H,A             ; Ergebnis merken
        LD      A,L             ;! 3tes Byte subtrahieren
        EXX                     ;!
        SBC     A,L             ;!
        EXX             
        LD      L,A             ; Ergebnis merken
        LD      A,D             ;! 2tes Byte subtrahieren
        EXX                     ;!
        SBC     A,D             ;!
        EXX
        LD      D,A             ; Ergebnis merken
        LD      A,E             ;! 1tes Byte subtrahieren
        EXX                     ;!
        SBC     A,E             ;!
        EXX
A92B6:  OR      A               ; MSByte Ergebnis gleich Null  ?
        JR      Z,A92CF         ; ja -->  Ergebnis um 8 Bit schieben
A92B9:  BIT     7,A             ; MSBit Ergebnis Mantisse gesetzt  ?
        JR      NZ,A92CB        ; ja -->  Mantisse hat internes Format
        RL      H               ;! Mantisse Ergebnis um ein Bit schieben
        RL      L               ;!
        RL      D               ;!
        RLA                     ;!
        DEC     C               ; Exponenten corrigieren
        JP      NZ,A92B9        ; weiter f√ºr internes Format corrigieren
        JP      A91C9           ; Ergebnis gleich Null
;
A92CB:  LD      E,A             ; MSByte Mantisse Ergebnis
        JP      A9248           ; Ergebnis in Speicher ablegen
;
;
;   Ergebnis f√ºr internes Format um mehr als 8 Bit corrigieren
;
A92CF:  LD      A,C             ; Exponenten holen
        SUB     8               ; minus acht
        LD      C,A             ; neuen Exponenten merken
        LD      A,D             ;! Mantisse um acht Bit schieben
        LD      D,L             ;!
        LD      L,H             ;!
        LD      H,0             ;!
        JR      Z,A92DC         ; Exponent gleich Null -->  Ergebnis gleich Null
        JR      NC,A92B6        ; √ºberpr√ºfen, ob internes Format stimmt
A92DC:  JP      A91C9           ; Ergebnis gleich Null vorgeben
;
;
;   Vorzeichen Ergebnis f√ºr Division oder Multiplikation errechnen
;
A92DF:  LD      C,A             ; L√§nge Zahl merken
        INC     HL              ;! Zeiger auf Mantisse stellen
        INC     DE              ;!
        LD      A,(DE)          ; MSByte Mantisse 1ter Wert
        XOR     (HL)            ; MSByte Mantisse 2ter Wert
        LD      (S94C2),A       ; Vorzeichen Ergebnis merken
        DEC     HL              ;! Zeiger auf Werte wieder auf Exponent
        DEC     DE              ;!
        RET
;
;
;   Basic - Funktion   *
;
A92EA:  CALL    A903F           ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
        CALL    A92DF           ; Vorzeichen Ergebnis errechnen
        PUSH    DE              ;! Zeiger auf Argumente retten
        PUSH    HL              ;!
        LD      (S94C3),SP      ; Stackpointer merken
        LD      A,(HL)          ; Exponent 1tes Argument holen
        OR      A               ; gleich Null  ?
        JP      Z,A91C9         ; ein Faktor gleich Null -->  Ergebnis gleich Null
        LD      A,(DE)          ; Exponent 2tes Argument holen
        OR      A               ; gleich Null  ?
        JP      Z,A91C9         ; ein Faktor gleich Null -->  Ergebnis gleich Null
        INC     DE              ; Zeiger auf Mantisse
        PUSH    DE              ;! nach IX
        POP     IX              ;!
        ADD     A,(HL)          ; plus Exponent 1ter Wert
        LD      E,A             ; Low - Byte Exponentenz√§hler
        LD      A,0             ;! eventuellen √úbertrag erfassen
        ADC     A,A             ;!
        LD      D,A             ; High - Byte Exponentenz√§hler
        LD      (S94C8),DE      ; Exponentenz√§hler f√ºr Ergebnis merken
        INC     HL              ; Zeiger auf Mantisse
        XOR     A               ; Accu auf Null
        LD      (S94C7),A       ; Flag  '√úbertrag aufgetreten'  zur√ºcksetzen
        LD      D,(HL)          ; MSByte Mantisse 1te Zahl holen
        SET     7,D             ; MSBit setzen
        INC     HL              ; Zeiger auf Wert auf n√§chstes Byte
        LD      E,(HL)          ; 2tes Byte Mantisse holen
        INC     HL              
        PUSH    HL              ; Zeiger auf Mantisse
        LD      H,A             ; Null
        LD      L,A             ; Null
        EXX
        POP     HL              ; Zeiger auf Mantisse
        LD      D,(HL)          ;! zwei niederwertigen Bytes der Mantisse holen
        INC     HL              ;!
        LD      E,(HL)          ;!
        LD      B,A             ; Null
        LD      C,A             ; Null
        LD      H,A             ; Null
        LD      L,A             ; Null
        EXX
        LD      A,(IX+0)        ; MSByte 2ter Faktor holen
        OR      10000000B       ; MSBit setzen
        LD      C,4             ; 4 Byte multiplizieren
A932D:  LD      B,8             ; 8 Bit je Byte
        OR      A               ; Byte Faktor gleich Null  ?
        JP      Z,A93C2         ; ja -->  n√§chstes Byte multiplizieren
A9333:  RLCA                    ; ein Bit nach Carry schieben
        JR      NC,A9348        ; nicht gesetzt -->  Wertigkeit nicht addieren
        EX      AF,AF           ; Restbits retten
        EXX
        LD      A,C             ;! Byte f√ºnf addieren
        ADD     A,B             ;!
        LD      C,A             ;!
        ADC     HL,DE           ; Byte 3/4 addieren
        EXX                     ; h√∂herwertigen Bytes holen
        ADC     HL,DE           ; Byte 1/2 addieren
        JR      NC,A9347        ; kein √úbertrag
        LD      A,1             ; Code '√úbertrag aufgetreten'
        LD      (S94C7),A       ; Flag  '√úbertrag aufgetreten' setzen
A9347:  EX      AF,AF           ; Restbits holen
A9348:  SRL     D               ;! Multiplikator um ein Bit schieben
        RR      E               ;!
        EXX                     ;!
        RR      D               ;!
        RR      E               ;!
        RR      B               ;!
        EXX
        DJNZ    A9333           ; weitere Bits in diesem Byte
A9356:  INC     IX              ; Zeiger auf Multiplikant auf n√§chstes Byte
        LD      A,(IX+0)        ; Byte holen
        DEC     C               ; Z√§hler Restanzahl Bytes minus eins
        JR      NZ,A932D        ; ungleich Null -->  weitere Bytes
        EXX
        LD      A,(S94C7)       ; Flag  '√úbertrag aufgetreten'  holen
        OR      A               ; gesetzt  ?
        JR      Z,A937B         ; nein
        LD      DE,(S94C8)      ; Exponentenz√§hler f√ºr Ergebnis holen
        INC     DE              ; plus eins
        LD      (S94C8),DE      ; und wieder merken
        EXX
        SCF                     ;! Mantisse entsprechend √úbertrag
        RR      H               ;! corrigieren
        RR      L               ;!
        EXX                     ;!
        RR      H               ;!
        RR      L               ;!
        RR      C               ;!
A937B:  BIT     7,C             ; MSBit Byte f√ºnf abfragen  (Rundungsbit)
        JR      Z,A9399         ; nicht aufrunden
        LD      DE,1            ;! Ergebnis aufrunden
        ADD     HL,DE           ;!
        EXX                     ;!
        LD      DE,0            ;!
        ADC     HL,DE           ;!
        EXX
        JR      NC,A9399        ; kein √úbertrag
        LD      DE,(S94C8)      ; Exponentenz√§hler f√ºr Ergebnis holen
        INC     DE              ; plus eins
        LD      (S94C8),DE      ; und wieder merken
        EXX             
        LD      H,10000000B     ; Mantisse vorgeben
        EXX
A9399:  POP     IX              ; Zeiger f√ºr Ergebnis holen
        PUSH    IX              ; und wieder merken
        LD      (IX+4),L        ;! Mantisse Ergebnis im Speicher ablegen
        LD      (IX+3),H        ;!
        EXX                     ;!
        LD      (IX+2),L        ;!
        LD      (IX+1),H        ;!
        LD      HL,(S94C8)      ; Exponentenz√§hler f√ºr Ergebnis holen
        OR      A               ; Carry - Flag zur√ºcksetzen
        LD      DE,00081H       ; Correkturfaktor vorgeben
        SBC     HL,DE           ; Exponenten corrigieren
        LD      A,H
        ADD     A,0
        JP      M,A93CE         ; Ergebnis gleich Null
        JP      NZ,A9205        ; Ergebnis zu gro√ü
        LD      (IX+0),L        ; Exponenten eintragen
        JP      A90ED           ; Vorzeichen Ergebnis eintragen
;
A93C2:  LD      A,E             ;! Multiplikator um ein Byte schieben
        EXX                     ;!
        LD      B,E             ;!
        LD      E,D             ;!
        LD      D,A             ;!
        EXX                     ;!
        LD      E,D             ;!
        LD      D,0             ;!
        JP      A9356           ; weitere Bytes multiplizieren
;
A93CE:  LD      SP,(S94C3)      ; Stackpointer holen
        JP      A91C9           ; Ergebnis 'Null' vorgeben
;
;
;   Basic - Funktion  /
;
A93D5:  CALL    A903F           ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
        CALL    A92DF           ; Vorzeichen Ergebnis errechnen
        PUSH    DE              ;! Zeiger auf Argumente retten
        PUSH    HL              ;!
        LD      (S94C3),SP      ; Stackpointer merken
        LD      A,(DE)          ; Exponent Divisor holen
        OR      A               ; gleich Null  ?
        JP      Z,A6367         ; ja -->  Fehler 2   Overflow error
        EX      AF,AF           ; Exponenten merken
        LD      A,(HL)          ; Exponent Dividend holen
        OR      A               ; gleich Null  ?
        JP      Z,A91C9         ; ja -->  Ergebnis gleich Null
        EXX
        ADD     A,081H          ;! Exponenten Ergebnis errechnen
        LD      B,A             ;!
        LD      A,0             ;!
        ADC     A,A             ;!
        EX      AF,AF           ;!
        LD      C,A             ;!
        LD      A,B             ;!
        SUB     C               ;!
        LD      C,A             ;!
        EX      AF,AF           ;!
        LD      B,A             ;!
        EX      AF,AF           ;!
        LD      A,B             ;!
        SBC     A,0             ;!
        JP      C,A93CE         ; Ergebnis gleich Null
        JP      NZ,A9205        ; Ergebnis zu gro√ü
        LD      A,C             ; Exponent Ergebnis 
        PUSH    AF              ;merken
        EXX
        INC     DE              ;! Zeiger auf Mantissen der Argumente stellen
        INC     HL              ;!
        LD      B,(HL)          ;! h√∂herwertige Bytes der beiden Mantissen laden
        SET     7,B             ;!
        INC     HL              ;!
        LD      C,(HL)          ;!
        INC     HL              ;!
        PUSH    HL              ;!     Zeiger auf Mantisse
        EX      DE,HL           ;!
        LD      D,(HL)          ;!
        SET     7,D             ;!     MSBit setzen
        INC     HL              ;!
        LD      E,(HL)          ;!
        INC     HL              ;!
        PUSH    HL              ;!     Zeiger auf Mantisse
        LD      H,B             ;!
        LD      L,C             ;!
        EXX
        POP     HL              ; Zeiger auf Restmantisse
        LD      D,(HL)          ;! niederwertigen Bytes der beiden Mantissen laden
        INC     HL              ;!
        LD      E,(HL)          ;!
        POP     HL              ;!
        LD      A,(HL)          ;!
        INC     HL              ;!
        LD      L,(HL)          ;!
        LD      H,A             ;!
        EXX
        LD      C,5             ; 5 Byte Ergebnis bilden
A9427:  LD      B,8             ; 8 Bit je Byte
        XOR     A               ; Vorgabe f√ºr Byte Ergebnis
A942A:  BIT     7,H             ; Bit gesetzt  ?
        JR      NZ,A943E        ; ja -->  subtrahieren
        OR      A               ;! ein Bit Ergebnis merken
A942F:  RLA                     ;!
        EXX
        ADD     HL,HL           ;! Dividend um ein Bit schieben
        EXX                     ;!
        ADC     HL,HL           ;!
        DJNZ    A942A           ; weitere Bits dieses Byte
        PUSH    AF              ; Ein Byte Ergebnis merken
        DEC     C               ; Restanzahl Bytes minus eins
        JR      NZ,A9427        ; weitere Bytes errechnen
        JP      A9478           ; Ergebnis aufbereiten
;
A943E:  OR      A               ; Carry Flag zur√ºcksetzen
        EXX
        SBC     HL,DE           ;! Divisor ein mal Subtrahieren
        EXX                     ;!
        SBC     HL,DE           ;!
        CCF             
        JR      C,A942F         ; ein Bit Ergebnis merken
        EXX
        ADD     HL,DE           ;! Restdividend corrigieren
        EXX                     ;!
        ADC     HL,DE           ;!
        OR      A               ; Carry - Flag zur√ºcksetzen
        RLA                     ; ein Bit Ergebnis merken
        EXX
        ADD     HL,HL           ;! Dividend um eine Stelle schieben
        EXX                     ;!
        ADC     HL,HL           ;!
        DJNZ    A945D           ; weitere Bits in diesem Byte
        PUSH    AF              ; ein Byte Ergebnis merken
        LD      B,8             ; 8 Bit je Byte
        DEC     C               ; Restanzahl Bytes minus eins
        JP      Z,A9478         ; Division durchgef√ºhrt
A945D:  EXX
        OR      A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE
        EXX
        SBC     HL,DE
        SCF                     ; Carry - Flag setzen
        RLA                     ; ein Bit Ergebnis merken
        DJNZ    A946E           ; weitere Bits dieses Byte
        PUSH    AF              ; ein Byte Ergebnis merken
        LD      B,8             ; 8 Bit je Byte
        DEC     C               ; Restanzahl Bytes minus eins
        JR      Z,A9478         ; Division durchgef√ºhrt
A946E:  EXX
        ADD     HL,HL           ;! Dividend um eine Stelle schieben
        EXX                     ;!
        ADC     HL,HL           ;!
        JR      C,A945D
        JP      A942A
;
;
;   Ergebnis der Division aufbereiten
;
A9478:  POP     AF              ; 5tes Byte Mantisse holen
        LD      H,A             ; Byte f√ºr Rundung merken
        EXX
        POP     AF              ;! Mantisse Ergebnis holen
        LD      E,A             ;!
        POP     AF              ;!
        LD      D,A             ;!
        POP     AF              ;!
        LD      C,A             ;!
        POP     AF              ;!
        LD      B,A             ;!
        POP     AF              ; Exponent Ergebnis holen
A9484:  BIT     7,B             ; 1tes Mit Mantisse gesetzt  ?
        JR      NZ,A949B        ; ja -->  Mantisse hat internes Format
        EXX
        SLA     H               ;! Mantisse um ein Bit schieben
        EXX                     ;!
        RL      E               ;!
        RL      D               ;!
        RL      C               ;!
        RL      B               ;!
        DEC     A               ; Exponenten corrigieren
        JP      NZ,A9484        ; √ºberpr√ºfen, ob internes Format stimmt
        JP      A91C9           ; Ergebnis  'Null'  vorgeben
;
;
;   Ergebnis der Division eventuell runden
;
A949B:  EXX
        RL      H               ; MSBit Rundungsbyte nach Carry
        EXX
        JR      NC,A94B2        ; nicht aufrunden
        LD      HL,1            ;! Ergebnis aufrunfen
        ADD     HL,DE           ;!
        EX      DE,HL           ;!
        LD      HL,0            ;!
        ADC     HL,BC           ;!
        LD      B,H             ;!
        LD      C,L             ;!
        JR      NC,A94B2        ; kein √úbertrag
        LD      B,10000000B     ; Mantisse vorgeben
        INC     A               ; Exponent plus eins
A94B2:  POP     HL              ; Zeiger f√ºr Ergebnis holen
        PUSH    HL              ; und wieder merken
        LD      (HL),A          ; Exponenten eintragen
        INC     HL
        LD      (HL),B          ;! Mantisse Ergebnis im Speicher ablegen
        INC     HL              ;!
        LD      (HL),C          ;!
        INC     HL              ;!
        LD      (HL),D          ;!
        INC     HL              ;!
        LD      (HL),E          ;!
        JP      A90ED           ; Vorzeichen Ergebnis eintragen
;
;
;   verschiedene Speicher f√ºr Grundrechenarten
;
S94C0:  DEFS    2               ; Zeiger auf Speicher f√ºr Ergebnis
S94C2:  DEFS    1               ; Vorzeichen Ergebnis
S94C3:  DEFS    2               ; Stackpointer
S94C5:  DEFS    2               ; Stackpointer bei Interruptsperrung
S94C7:  DEFS    1               ; Flag  '√úbertrag aufgetreten' 
S94C8:  DEFS    2               ; Exponentenz√§hler f√ºr Ergebnis
S94CA:  DEFS    1  
;
;
;   Vorzeichen des Zahlwertes (HL) abfragen
;
A94CB:  INC     HL              ; Zeiger auf MSByte Mantisse
        BIT     7,(HL)          ; Vorzeichen abfragen
        DEC     HL              ; Zeiger wieder auf Exponenten
        RET
;
;
;   Zahlwert (HL) mal zwei
;
A94D0:  INC     (HL)            ; Exponenten plus eins
        RET     NZ              ; Ergebnis ist OK
        JP      A6367           ; Fehler 2   Overflow error
;
;
;   Zahlwert (HL) durch zwei
;
A94D5:  LD      A,(HL)          ; Exponenten holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  Wert ist gleich Null
        DEC     (HL)            ; Exponenten minus eins
        RET     NZ              ; Ergebnis ist OK
        JP      A909E           ; Null im Real - Format nach (HL) eintragen
;
;
;   einen Rechenspeicher f√ºr Rechenroutine reservieren
;
A94DD:  PUSH    HL              ; Zeiger auf Rechenspeicher retten
        INC     HL              ;! um L√§nge Real - Zahlwert hochz√§hlen
        INC     HL              ;!
        INC     HL              ;!
        INC     HL              ;!
        INC     HL              ;!
        EX      DE,HL           ; Adresse nach DE
        LD      HL,(W1080)      ; maximal erlaubte RAM - Adresse holen
        DEC     HL
        SBC     HL,DE           ; Rechenspeicheradresse √ºberpr√ºfen
        JP      C,A6373         ; zu hoch -->  Fehler 6  Memory error
        POP     HL              ; geretteten Register - Wert holen
        RET
;
;
;   vier Rechenspeicher f√ºr Routinen bereitstellen
;
A94EF:  PUSH    HL              ; Zeiger auf Rechenspeicher merken
        LD      (S9BA0),HL      ; Zeiger auf Rechenspeicher vier
        CALL    A94DD           ; einen Rechenspeicher reservieren
        EX      DE,HL           ; Zeiger nach HL
        LD      (S9BA2),HL      ; Zeiger auf Rechenspeicher drei
        CALL    A94DD           ; einen Rechenspeicher reservieren
        EX      DE,HL           ; Zeiger nach HL
        LD      (S9BA4),HL      ; Zeiger auf Rechenspeicher zwei
        CALL    A94DD           ; einen Rechenspeicher reservieren
        LD      (S9BA6),DE      ; Zeiger auf Rechenspeicher eins
        POP     HL              ; geretteten Zeiger auf Rechenspeicher wieder holen
        RET
;
;
;   Basic - Funktion   ^
;
A950A:  CALL    A903F           ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
        EX      DE,HL           ; Zeiger auf 2tes Argument nach HL
        LD      A,(HL)          ; Exponent der Hochzahl holen
        OR      A               ; gleich Null  ?
        JP      Z,A956C         ; ja -->  Ergebnis gleich +1
        EX      DE,HL
        LD      A,(HL)          ; Exponent der Basis holen
        OR      A               ; gleich Null  ?
        JP      Z,A909E         ; ja -->  Null im Real - Format nach (HL) eintragen
        CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        JR      Z,A9546         ; Zahl positiv
;
;
;   Basis negativ -->  untersuchen, ob Hochzahl ganze Zahl ist
;
        CALL    A90A9           ; Vorzeichen des Wertes (HL) umkehren
        EX      DE,HL
        PUSH    DE              ; Zeiger auf Basis
        PUSH    HL              ; Zeiger auf Hochzahl
        LD      DE,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        LD      HL,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        CALL    A7BC0           ; Nachkommastellen des Real-Zahlwertes (HL) errechnen
        LD      A,(HL)          ; Exponent Ergebnis holen
        OR      A               ; gleich Null ?
        JP      NZ,A636A        ; nein -->  Fehler 3  Illegal data error
        POP     HL              ; Zeiger auf Hochzahl holen
        PUSH    HL              ; und wieder merken
        CALL    A7BEA           ; Real - Wert (HL) umsetzen in Integer - Wert nach HL
        BIT     0,L             ; Wert gerade  ?
        POP     DE              ; Zeiger auf Hochzahl holen
        POP     HL              ; Zeiger auf Basis holen
        JR      Z,A9546         ; Wert gerade -->  (HL) ^ (DE) errechnen
        CALL    A9546           ; (HL) ^ (DE) errechnen
        JP      A90A9           ; Vorzeichen des Wertes (HL) umkehren
;
A9546:  EX      DE,HL
        LD      A,(HL)          ; Exponenten der Hochzahl holen
        OR      A               ; gleich Null  ?
        JR      Z,A956C         ; ja -->  Ergebnis ist gleich +1
        CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        JR      Z,A9572         ; Hochzahl positiv
;
;
;   Hochzahl negativ
;
        CALL    A90A9           ; Vorzeichen des Wertes (HL) umkehren
        CALL    A9572           ; EXP( LN(DE) * (HL) ) errechnen
        PUSH    DE              ; Register - Wert retten
        PUSH    HL              ; Zeiger auf Zwischenergebnis retten
        LD      DE,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        CALL    A79C2           ; +1 im Real - Format nach (DE) √ºbertragen
        LD      HL,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        POP     DE              ; Zeiger auf Zwischenergebnis holen
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        PUSH    DE              ; Zeiger auf Ergebnis merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Ergebnis holen
        POP     DE              ; geretteten Register - Wert holen
        RET
;
;
;   +1  als Ergebnis vorgeben
;
A956C:  PUSH    DE              ; Zeiger f√ºr Ergebnis retten
        CALL    A79C2           ; +1 im Real - Format nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Ergebnis holen
        RET
;
;
;   Basis hoch Hochzahl √ºber Logarithmus errechnen
;
A9572:  PUSH    DE              ; Zeiger auf Basis retten
        LD      DE,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Basis holen
        CALL    A9A4F           ; LN - Routine   ( LN(HL) )
        LD      DE,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        JP      A992B           ; EXP - Routine   ( EXP(HL) )
;
;
;   Basic - Funktion   NOT     (Zwischencode 237 / 0EDH)
;
A9586:  CALL    A903F           ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
        PUSH    DE              ; Register - Wert retten
        PUSH    HL              ; Zeiger f√ºr Ergebnis retten
        CALL    A7BEA           ; Real - Wert (HL) umsetzen in Integer - Wert nach HL
        LD      A,L             ;! Wert complementieren
        CPL                     ;!
        LD      E,A             ;!
        LD      A,H             ;!
        CPL                     ;!
        LD      D,A             ;!
        JR      A95B7           ; Integer - Wert f√ºr Ergebnis umsetzen in Real - Wert
;
;
;   Basic - Funktion   AND     (Zwischencode  236 / 0ECH)
;
A9596:  LD      A,AND_D         ; Vorgabe f√ºr Z-80 - Befehl
        DEFB    LD_BC
;
;
;   Basic - Funktion   OR     (Zwischencode 235 / 0EBH)
;
A9599:  LD      A,OR_D          ; Vorgabe f√ºr Z-80 - Befehl
        DEFB    LD_BC
;
;
;   Basic - Funktion   XOR     (Zwischencode 234 / 0EAH)
;
A959C:  LD      A,XOR_D         ; Vorgabe f√ºr Z-80 - Befehl
        LD      (D95B2),A       ; richtigen Befehl in Routine eintragen
        INC     A               ; auf Befehl mit E - Register corrigieren
        LD      (D95B5),A       ; richtigen Befehl in Routine eintragen
        CALL    A903F           ; Syntaxuntersuchung auf Zahl - Wert - Ergebnis
        PUSH    DE              ;! Zeiger auf Werte retten
        PUSH    HL              ;!
        CALL    A7BEA           ; Real - Wert (HL) umsetzen in Integer - Wert nach HL
        EX      DE,HL           ; Zeiger 2ter Wert nach HL / 1ter Wert nach DE
        CALL    A7BEA           ; Real - Wert (HL) umsetzen in Integer - Wert nach HL
        LD      A,H             ; High - Byte 2ter Wert holen
D95B2:  AND     D               ; mit 1tem Wert verkn√ºpfen   (Befehl wird eingetragen)
        LD      D,A             ; Ergebnis merken
        LD      A,L             ; Low - Byte 2ter Wert holen
D95B5:  AND     E               ; mit 1tem Wert verkn√ºpfen   (Befehl wird eingetragen)
        LD      E,A             ; Ergebnis merken
A95B7:  POP     HL              ; Zeiger f√ºr Ergebnis holen
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        POP     DE              ; geretteten Register - Wert holen
        RET
;
;
;   Basic - Funktion   ABS     (Zwischencode 255 129 / 0FFH 081H)
;
A95BD:  INC     HL              ; Zeiger auf MSByte Mantisse
        RES     7,(HL)          ; Vorzeichen auf plus
        DEC     HL              ; Zeiger wieder auf Exponenten
        RET
;
;
;   Basic - Funktion   INT     (Zwischencode 255 128 / 0FFH 080H)
;
A95C2:  CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        JP      Z,A7B82         ; Zahl positiv -->  Nachkommastellen der Zahl (HL) vergessen
        CALL    A95E7           ; Zahl (HL) im Zwischenspeicher merken
        CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        LD      DE,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        RET     Z               ; Argument hatte keine Nachkommastellen
A95D5:  LD      DE,B7C45        ; Zeiger auf  +1   (Real - Format)
        JP      A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
;
;
;   +1 zur Zahl (HL) addieren
;
A95DB:  LD      DE,B7C45        ; Zeiger auf  +1   (Real - Format)
        JP      A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
;
;
;   Zahl (HL) mit +1 vergleichen
;
A95E1:  LD      DE,B7C45        ; Zeiger auf  +1   (Real - Format)
        JP      A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
;
;
;   Zahl (HL) im Zwischenspeicher merken
;
A95E7:  PUSH    HL              ;! Register - Werte retten
        PUSH    DE              ;!
        LD      DE,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     DE              ;! gerettete Register - Werte wieder holen
        POP     HL              ;!
        RET
;
;
;   Basic - Funktion   MOD     (Zwischencode 250 / 0FAH)
;
A95F2:  CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        EX      DE,HL           ; Zeiger auf Argumente vertauschen
        CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        EX      DE,HL           ; Zeiger auf Argumente vertauschen
        CALL    A95E7           ; Zahl (HL) im Zwischenspeicher merken
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        PUSH    DE              ; Register - Wert retten
        LD      DE,S9EA5        ; Zeiger auf Speicher f√ºr Real - Zahlwert
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     DE              ; geretteten Register - Wert wieder holen
        JP      A90A9           ; Vorzeichen des Wertes (HL) umkehren
;
;
;   Basic - Funktion   Integer-Division   (Backslash)     (Zwischencode 249 / 0F9H)
;
A9611:  CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        EX      DE,HL           ; Zeiger auf Argumente vertauschen
        CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        EX      DE,HL           ; Zeiger auf Argumente vertauschen
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        JP      A7B82           ; Nachkommastellen der Zahl (HL) vergessen
;
;
;   Basic - Funktion   SQR     (Zwischencode 255 135 / 0FFH 087H)
;
A961F:  LD      A,(HL)          ; Exponent Argument holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  Ergebnis gleich Null
        CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        JP      NZ,A636A        ; negativ -->  Fehler 3  Illegal data error
        CALL    A9A4F           ; LN - Routine   ( LN(HL) )
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        JP      A992B           ; EXP - Routine   ( EXP(HL) )
;
;
;   Ergebnis  '+1'  vorgeben und Stack corrigieren
;
A9631:  PUSH    HL              ; Zeiger auf Ergebnis merken
        EX      DE,HL           ; Zeiger f√ºr Ergebnis nach DE
        CALL    A79C2           ; +1 im Real - Format nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Ergebnis holen
        POP     BC              ; geretteten Register - Wert wieder holen
        RET
;
B9639:  DEFB    07EH            ; Exponent  0.19970768
        DEFB    04CH            ; Mantisse  0.19970768
;
B963B:  DEFB    080H            ; Exponent  0.67097684
        DEFB    02BH            ; Mantisse  0.67097684
;
;
;   Basic - Funktion   ATN     (Zwischencode 255 138 / 0FFH 08AH)
;
A963D:  PUSH    BC              ; Register - Wert retten
        INC     HL              ; Zeiger auf Mantisse
        LD      A,(HL)          ; MSByte Mantisse holen
        RES     7,(HL)          ; Vorzeichen auf plus
        DEC     HL              ; Zeiger wieder auf Exponenten
        PUSH    AF              ; Vorzeichen Argument merken
        CALL    A964E           ; ATN - Wert errechnen
        POP     AF              ; Vorzeichen Argument holen
        POP     BC              ; geretteten Register - Wert wieder holen
        RLCA                    ; Vorzeichen nach Carry schieben
        RET     NC              ; Argument war positiv
        JP      A90A9           ; Vorzeichen des Wertes (HL) umkehren
;
;
;   √ºberpr√ºfen, ob Betrag Argument kleiner eins ist, wenn nein
;   ATN √ºber 1/Argument errechnen und Pi/2 vom Ergebnis abziehen
;
A964E:  CALL    A95E1           ; Zahl (HL) mit +1 vergleichen
        JR      C,A9671         ; Argument < +1 -->  ATN direkt errechnen
        CALL    A94DD           ; einen Rechenspeicher reservieren
        PUSH    DE              ; Zeiger auf Rechenspeicher merken
        PUSH    HL              ; Zeiger auf Argument merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     DE              ;! Zeiger auf urspr√ºngliche Stelle 
        PUSH    DE              ;! mit Argument
        CALL    A79C2           ; +1 im Real - Format nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf +1
        POP     DE              ; Zeiger auf Argument
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        CALL    A9671           ; ATN von 1/Argument errechnen
        LD      DE,B98CB        ; Zeiger auf Pi/2  (Real - Konstante)
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        JP      A95BD           ; ABS - Wert der Zahl (HL) bilden
;
;
;   ATN der Zahl (HL) iterieren
;
A9671:  LD      A,11111111B     ; Code for 'Vorzeichen Ergebnis stimmt'
        LD      (S97E7),A       ; Flag  'Vorzeichen Ergebnis Iteration'
        LD      DE,B9639        ; ca.  1/5  (Real)
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A96CD         ; Argument kleiner 1/5 -->  direkt iterieren
        LD      DE,B963B        ; ca.  3/5  (Real)
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        PUSH    AF              ; Ergebnis Vergleich retten
        CALL    A94DD           ; einen Rechenspeicher reservieren
        POP     AF              ; Ergebnis Vergleich holen
        PUSH    HL              ; Zeiger auf Argument retten
        PUSH    DE              ; Zeiger auf Rechenspeicher retten
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Rechenspeicher holen
        JR      C,A96A5         ; Wert ist kleiner 3/5
        CALL    A95DB           ; +1 zur Zahl (HL) addieren
        EX      (SP),HL
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     DE
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        CALL    A96CD           ; ATN - Wert errechnen
        LD      DE,B98D0        ; Zeiger auf  Pi/4   (Real - Konstante)
        JP      A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
;
A96A5:  LD      DE,B96C8        ; Zeiger auf SQR(2) - 1   (Real - Konstante)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        CALL    A95DB           ; +1 zur Zahl (HL) addieren
        EX      (SP),HL
        LD      DE,B96C8        ; Zeiger auf SQR(2) - 1   (Real - Konstante)
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     DE
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        CALL    A96CD           ; ATN - Wert errechnen
        CALL    A94D0           ; Real - Zahl (HL) mal zwei
        LD      DE,B98D0        ; Zeiger auf  Pi/4   (Real - Konstante)
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        JP      A94D5           ; Real - Zahl (HL) durch zwei
;
B96C8:  DEFB    07FH                    ; Exponent  0.41421356   ( SQR(2)-1 )
        DEFB    054H,013H,0CCH,0D0H     ; Mantisse  0.41421356   ( SQR(2)-1 )
;
;
;
;
A96CD:  PUSH    BC              ; Register - Wert retten
        PUSH    HL              ; Zeiger auf Argument retten
        CALL    A94EF           ; 4 Rechenspeicher f√ºr Routine bereitstellen
        POP     HL              ; Zeiger auf Argument holen
        PUSH    HL              ; und wieder retten
        PUSH    DE              ; Zeiger auf Rechenspeicher eins
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Rechenspeicher eins  (Argument)
        LD      E,L             ;! nach DE
        LD      D,H             ;!
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,(S9BA4)      ; Zeiger auf Rechenspeicher zwei
        POP     HL              ; Zeiger auf Argument holen
        PUSH    HL              ; und wieder merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        DEC     A               ; L√§nge Zahl minus eins
        CP      4               ; Real - Wert  ?
        LD      B,A             ; 4  Iterationsschritte
        LD      HL,B986E        ; Zeiger auf Tabelle mit Konstanten f√ºr Iteration
        JP      Z,A9774         ; Real - Wert -->  Iteration ausf√ºhren
        LD      B,10            ; 10 Iterationsschritte bei Double - Precision
        JP      A9774           ; Iteration ausf√ºhren
;
;
;   Basic - Funktion   COS     (Zwischencode  255 131 / 0FFH 083H)
;
A96F9:  PUSH    BC              ; Register - Wert retten
        LD      A,(HL)          ; Exponent Argument holen
        OR      A               ; gleich Null  ?
        JP      Z,A9631         ; ja -->  Ergebnis gleich Null
        LD      DE,B98CB        ; Zeiger auf Pi/2  (Real - Konstante)
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        CALL    A90A9           ; Vorzeichen des Wertes (HL) umkehren
        POP     BC              ; geretteten Register - Wert holen
;
;
;   Basic - Funktion   SIN     (Zwischencode 255 130 / 0FFH 082H)
;
A9709:  PUSH    BC              ; Register - Wert retten
        INC     HL              ; Zeiger auf Mantisse Argument
        LD      A,(HL)          ; MSByte Mantisse holen
        RES     7,(HL)          ; Vorzeichen auf plus
        AND     10000000B       ; Vorzeichen Argument maskieren
        CPL                     ; Maske f√ºr Vorzeichen bilden
        LD      (S97E7),A       ; Flag  'Vorzeichen Ergebnis Iteration'
        DEC     HL              ; Zeiger wieder auf Exponent
        LD      DE,B98C1        ; Zeiger auf 2 * Pi   (Real - Konstante)
        PUSH    HL              ; Zeiger auf Argument merken
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A9727         ; Zahl ist kleiner 2 * Pi
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        CALL    A7BC0           ; Nachkommastellen des Real-Zahlwertes (HL) errechnen
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
A9727:  LD      DE,B98C6        ; Zeiger auf Pi im Real - Format
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A973A         ; Zahl ist kleiner Pi
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        LD      A,(S97E7)       ; Flag  'Vorzeichen Ergebnis Iteration'
        XOR     10000000B       ; Vorzeichen umkehren
        LD      (S97E7),A       ; Flag  'Vorzeichen Ergebnis Iteration'
A973A:  LD      DE,B98CB        ; Zeiger auf Pi/2  (Real - Konstante)
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A974B         ; Zahl ist kleiner Pi/2
        LD      DE,B98C6        ; Zeiger auf Pi im Real - Format
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        CALL    A95BD           ; ABS - Wert der Zahl (HL) bilden
A974B:  CALL    A94EF           ; 4 Rechenspeicher f√ºr Routine bereitstellen
        POP     HL              ; Zeiger auf Argument retten
        PUSH    DE              ; Zeiger auf Rechenspeicher eins
        LD      DE,B98D0        ; Zeiger auf  Pi/4   (Real - Konstante)
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      NC,A97BD        ; Argument gr√∂√üer Pi/4 -->  √ºber COS - Reihe iterieren
        POP     DE              ; Zeiger auf Rechenspeicher eins
        PUSH    HL              ; Zeiger auf Argument
        PUSH    DE              ; Zeiger auf Rechenspeicher eins
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Rechenspeicher eins
        LD      E,L             ;! nach DE
        LD      D,H             ;!
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,(S9BA4)      ; Zeiger auf Rechenspeicher zwei
        POP     HL              ; Zeiger auf Argument holen
        PUSH    HL              ; und wieder merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        LD      B,A             ; als Anzahl Iterationsschritte merken
        LD      HL,B981E        ; Zeiger auf Konstanten f√ºr Iteration  SIN - Reihe
;
;
;   Iterationsroutine f√ºr  SIN - COS - ATN
;
A9774:  PUSH    BC              ; Anzahl Iterationsschritte retten
        PUSH    HL              ; Zeiger auf Konstantentabelle
        LD      HL,(S9BA4)      ; Zeiger auf Rechenspeicher zwei
        LD      DE,(S9BA6)      ; Zeiger auf Rechenspeicher eins
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     HL              ; Zeiger auf Konstantentabelle holen
        PUSH    HL              ; und wieder merken
        LD      DE,(S9BA2)      ; Zeiger auf Rechenspeicher drei
        PUSH    DE              ; merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Rechenspeicher drei
        LD      DE,(S9BA4)      ; Zeiger auf Rechenspeicher zwei
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        EX      DE,HL
        LD      HL,(S9BA0)      ; Zeiger auf Rechenspeicher vier
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        POP     HL              ; Zeiger auf Konstantentabelle
        LD      DE,5            ; L√§nge  Real - Zahlwert
        ADD     HL,DE           ; Zeiger auf n√§chste Konstante in Tabelle
        POP     BC              ; Restanzahl Iterationsschritte holen
        DJNZ    A9774           ; weitere Iterationsschritte ausf√ºhren
        POP     HL              ; Zeiger auf Ergebnis holen
        POP     BC
        LD      A,(S97E7)       ; Flag  'Vorzeichen Ergebnis Iteration'
        INC     HL              ; Zeiger auf Mantisse Ergebnis
        XOR     (HL)            ;! Vorzeichen Ergebnis richten
        CPL                     ;!
        LD      (HL),A          ; Vorzeichen Ergebnis merken
        DEC     HL              ; Zeiger wieder auf Exponenten
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        CP      8               ; Double - Precision - Wert  ?
        LD      A,(HL)          ; Exponenten Ergebnis holen
        JR      Z,A97B9         ; Double Precision
        CP      05CH
A97B5:  RET     NC              ; Ergebnis ist OK
        JP      A909E           ; Null im Real - Format nach (HL) eintragen
;
A97B9:  CP      04DH
        JR      A97B5           ; untersuchen, ob Ergebnis gro√ü genug ist
;
;
;   Werte f√ºr Iteration nach COS - Reihe vorgeben
;
A97BD:  LD      DE,B98CB        ; Zeiger auf Pi/2  (Real - Konstante)
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        CALL    A95BD           ; ABS - Wert der Zahl (HL) bilden
        POP     DE              ; Zeiger auf Rechenspeicher eins
        PUSH    HL              ; Zeiger auf Argument
        PUSH    DE              ; Zeiger auf Rechenspeicher eins
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Rechenspeicher eins
        LD      E,L             ;! nach DE
        LD      D,H             ;!
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,(S9BA4)      ; Zeiger auf Rechenspeicher zwei
        CALL    A79C2           ; +1 im Real - Format nach (DE) √ºbertragen
        POP     DE              ; Zeiger auf Argument holen
        PUSH    DE              ; und wieder merken
        CALL    A79C2           ; +1 im Real - Format nach (DE) √ºbertragen
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        LD      B,A             ; Anzahl Iterationsschritte merken
        LD      HL,B9846        ; Zeiger auf Konstante f√ºr  COS - Reihe
        JR      A9774           ; Einsprung in Iterationsschleife
;
S97E7:  DEFS    1               ; Flag  'Vorzeichen Ergebnis Iteration'
;
;
;   Basic - Funktion   TAN     (Zwischencode 255 132 / 0FFH 084H)
;
A97E8:  PUSH    BC              ; Register - Wert retten
        PUSH    HL              ; Zeiger auf Argument retten
        CALL    A94DD           ; einen Rechenspeicher reservieren
        EX      DE,HL           ; Zeiger auf Rechenspeicher nach HL
        LD      (S9BA8),HL      ; Zeiger auf Speicher f√ºr COS(Argument)
        CALL    A94DD           ; einen Rechenspeicher reservieren
        LD      (S9BAA),DE      ; Zeiger auf Speicher f√ºr SIN(Argument)
        POP     HL              ; Zeiger auf Argument holen
        PUSH    HL              ; und wieder merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        LD      HL,(S9BA8)      ; Zeiger auf Speicher f√ºr COS(Argument)
        EX      DE,HL           ; nach DE
        POP     HL              ; Zeiger auf Argument holen
        PUSH    HL              ; und wieder merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        LD      HL,(S9BAA)      ; Zeiger auf Speicher f√ºr SIN(Argument)
        CALL    A9709           ; SIN - Routine aufrufen   ( SIN( (HL) ) )
        POP     DE              ; Zeiger auf Stelle f√ºr Ergebnis holen
        PUSH    DE              ; und wieder merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        LD      HL,(S9BA8)      ; Zeiger auf Speicher f√ºr COS(Argument)
        CALL    A96F9           ; COS - Routine aufrufen   ( COS( (HL) ) )
        EX      DE,HL           ; Zeiger auf COS(Argument) nach DE
        POP     HL              ; Zeiger auf SIN(Argument) holen
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Zeiger auf Konstanten f√ºr Iteration nach SIN - Reihe
;
B981E:  DEFB    07EH                    ; Exponent  -0.16666667      (-1/3!)
        DEFB    0AAH,0AAH,0AAH,0ABH     ; Mantisse  -0.16666667      (-1/3!)
;
        DEFB    07AH                    ; Exponent   .83333333E-02   (1/5!)
        DEFB    008H,088H,088H,089H     ; Mantisse   .83333333E-02   (1/5!)
;
        DEFB    074H                    ; Exponent  -.1984127E-03    (-1/7!)
        DEFB    0D0H,00DH,000H,0D0H     ; Mantisse  -.1984127E-03    (-1/7!)
;
        DEFB    06EH                    ; Exponent   .27557319E-05   (1/9!)
        DEFB    038H,0EFH,01DH,02BH     ; Mantisse   .27557319E-05   (1/9!)
;
        DEFB    067H                    ; Exponent  -.25052108E-07   (-1/11!)
        DEFB    0D7H,032H,02BH,040H     ; Mantisse  -.25052108E-07   (-1/11!)
;
        DEFB    060H                    ; Exponent   .16059043E-09   (1/13!)
        DEFB    030H,092H,030H,09DH     ; Mantisse   .16059043E-09   (1/13!)
;
        DEFB    058H                    ; Exponent  -.76471635E-12   (-1/15!)
        DEFB    0D7H,03FH,09FH,03AH     ; Mantisse  -.76471635E-12   (-1/15!)
;
        DEFB    050H                    ; Exponent   .28114571E-14   (1/17!)
        DEFB    04AH,096H,03BH,082H     ; Mantisse   .28114571E-14   (1/17!)
;
;
;   Konstanten f√ºr Iteration nach COS - Reihe
;
B9846:  DEFB    080H                    ; Exponent  -0.5             (-1/2!)
        DEFB    080H,000H,000H,000H     ; Mantisse  -0.5             (-1/2!)
;
        DEFB    07CH                    ; Exponent   0.041666666     (1/4!)
        DEFB    02AH,0AAH,0AAH,0ABH     ; Mantisse   0.041666666     (1/4!)
;
        DEFB    077H                    ; Exponent  -.13888889E-02   (-1/6!)
        DEFB    0B6H,00BH,060H,0B6H     ; Mantisse  -.13888889E-02   (-1/6!)
;
        DEFB    071H                    ; Exponent   .24801587E-04   (1/8!)
        DEFB    050H,00DH,000H,0D0H     ; Mantisse   .24801587E-04   (1/8!)
;
        DEFB    06BH                    ; Exponent  -.27557319E-06   (-1/10!)
        DEFB    093H,0F2H,07DH,0BCH     ; Mantisse  -.27557319E-06   (-1/10!)
;
        DEFB    064H                    ; Exponent   .20876756E-10   (1/12!)
        DEFB    00FH,076H,0C7H,080H     ; Mantisse   .20876756E-10   (1/12!)
;
        DEFB    05CH                    ; Exponent  -.11470745E-10   (-1/14!)
        DEFB    0C9H,0CBH,0A5H,046H     ; Mantisse  -.11470745E-10   (-1/14!)
;
        DEFB    054H                    ; Exponent   .47794773E-13   (1/16!)
        DEFB    057H,03FH,09FH,03AH     ; Mantisse   .47794773E-13   (1/16!)
;
;
;   Konstanten f√ºr Iteration nach ATN - Reihe
;
B986E:  DEFB    07FH                    ; Exponent  -0.33333333      (-1/3)
        DEFB    0AAH,0AAH,0AAH,0ABH     ; Mantisse  -0.33333333      (-1/3)
;
        DEFB    07EH                    ; Exponent   0.2             (1/5)
        DEFB    04CH,0CCH,0CCH,0CDH     ; Mantisse   0.2             (1/5)
;
        DEFB    07EH                    ; Exponent  -0.14285714      (-1/7)
        DEFB    092H,049H,024H,092H     ; Mantisse  -0.14285714      (-1/7)
;
        DEFB    07DH                    ; Exponent   0.11111111      (1/9)
        DEFB    063H,08EH,038H,0E4H     ; Mantisse   0.11111111      (1/9)
;
        DEFB    07DH                    ; Exponent  -0.09090909      (-1/11)
        DEFB    0BAH,02EH,08BH,0A3H     ; Mantisse  -0.09090909      (-1/11)
;
        DEFB    07DH                    ; Exponent   0.076923076     (1/13)
        DEFB    01DH,089H,0D8H,09EH     ; Mantisse   0.076923076     (1/13)
;
        DEFB    07DH                    ; Exponent  -0.066666666     (-1/15)
        DEFB    088H,088H,088H,089H     ; Mantisse  -0.066666666     (-1/15)
;
        DEFB    07CH                    ; Exponent   0.058823529     (1/17)
        DEFB    070H,0F0H,0F0H,0F1H     ; Mantisse   0.058823529     (1/17)
;
        DEFB    07CH                    ; Exponent  -0.052631579     (-1/19)
        DEFB    0D7H,094H,035H,0E5H     ; Mantisse  -0.052631579     (-1/19)
;
        DEFB    07CH                    ; Exponent   0.047619047     (1/21)
        DEFB    043H,00CH,030H,0C3H     ; Mantisse   0.047619047     (1/21)
;
;
;   Basic - Funktion   SGN     (Zwischencode 255 139 / 0FFH 08BH)
;
A98A0:  LD      DE,0            ; Vorgabe  'Null'
        LD      A,(HL)          ; Exponent Argument holen
        OR      A               ; gleich Null  ?
        JR      Z,A98AF         ; ja -->  Ergebnis gleich Null
        CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        INC     DE              ; Wert auf +1
        JR      Z,A98AF         ; Zahl ist positiv
        DEC     DE              ;! Wert auf -1
        DEC     DE              ;!
A98AF:  CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        RET
;
;
;   Basic - Funktion   RAD     (Zwischencode 255 143 / 0FFH 08FH)
;
A98B3:  LD      DE,B98D5        ; Zeiger auf Pi/180
        JR      A98BB           ; Konstante mit Argument multiplizieren
;
;
;   Basic - Funktion   PAI     (Zwischencode 255 142 / 0FFH 08EH)
;
A98B8:  LD      DE,B98C6        ; Zeiger auf Pi im Real - Format
A98BB:  PUSH    BC              ; Register - Wert retten
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Tabelle mit PI - Konstanten
;
B98C1:  DEFB    083H                    ; Exponent  2 * Pi
        DEFB    049H,00FH,0DAH,0A2H     ; Mantisse  2 * Pi
;
B98C6:  DEFB    082H                    ; Exponent  Pi
        DEFB    049H,00FH,0DAH,0A2H     ; Mantisse  Pi
;
B98CB:  DEFB    081H                    ; Exponent  Pi/2
        DEFB    049H,00FH,0DAH,0A2H     ; Mantisse  Pi/2
;
B98D0:  DEFB    080H                    ; Exponent  Pi/4
        DEFB    049H,00FH,0DAH,0A2H     ; Mantisse  Pi/4
;
B98D5:  DEFB    07BH                    ; Exponent  Pi/180
        DEFB    00EH,0FAH,035H,013H     ; Mantisse  Pi/180
;
;
;   Basic - Funktion   PEEK     (Zwischencode 255 137 / 0FFH 089H)
;
A98DA:  PUSH    HL              ; Zeiger f√ºr Ergebnis retten
        CALL    A7BEA           ; Real - Wert (HL) umsetzen in Integer - Wert nach HL
        LD      E,(HL)          ; Wert aus Speicher holen       
        LD      D,0             ; High - Byte Wert auf Null
        POP     HL              ; Zeiger f√ºr Ergebnis holen
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        RET
;
;
;   Basic - Funktion   RND     (Zwischencode 255 136 / 0FFH 088H)
;
A98E6:  LD      A,(HL)          ; Exponent Argument holen
        OR      A               ; gleich Null  ?
        JR      Z,A98EF         ; ja -->  Argument gleich Null
        CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        JR      Z,A98FA         ; Wert positiv
A98EF:  PUSH    HL              ; Zeiger auf Argument retten
        LD      HL,04193H       ; Vorgabe f√ºr Anfangswert
        LD      (W9929),HL      ; als Zwischenwert RND merken
        POP     HL              ; Zeiger auf Argument holen
        XOR     A               ; Accu auf Null
        LD      R,A             ; ins Refresh - Register eintragen
A98FA:  PUSH    BC              ; Register - Wert  RND  holen
        LD      DE,(W9929)      ; Zwischenwert RND holen
        LD      A,R             ;! neuen Zwischenwert errechnen
        XOR     D               ;!
        RRC     A               ;!
        RRC     A               ;!
        RRC     A               ;!
        LD      D,A             ;!
        LD      A,R             ;!
        XOR     E               ;!
        RLC     A               ;!
        RLC     A               ;!
        LD      E,D             ;!
        LD      D,A             ;!
        LD      (W9929),DE      ; Zwischenwert RND merken
        PUSH    HL              ; Zeiger auf Argument retten
        INC     HL              ; Zeiger auf MSByte Mantisse
        RES     7,D             ; Vorzeichen auf plus
        LD      (HL),D          ;! Zwischenwert als Bytes der Mantisse eintragen
        INC     HL              ;!
        LD      (HL),E          ;!
        INC     HL
        LD      A,R             ; drittes Byte holen
        LD      (HL),A          ; und eintragen
        POP     HL              ; Zeiger auf Exponenten holen
        LD      (HL),081H       ; Exponent f√ºr Wert zwischen eins und zwei eintragen
        CALL    A95D5           ; eins vom Real - Wert (HL) abziehen
        POP     BC              ; geretteten Register - Wert holen
        RET
;
W9929:  DEFW    04193H          ; Zwischenwert RND
;
;       
;   Basic - Funktion   EXP     (Zwischencode 255 134 / 0FFH 086H)
;
A992B:  PUSH    BC              ; Register - Wert retten
        LD      A,(HL)          ; Exponent Argument holen
        OR      A               ; gleich Null  ?
        JP      Z,A9631         ; ja -->  Ergebnis gleich '+1'
        INC     HL              ; Zeiger auf MSByte Mantisse
        LD      A,(HL)          ; Vorzeichen Argument holen
        LD      (S9A41),A       ; und merken
        RES     7,(HL)          ; Vorzeichen auf plus
        DEC     HL              ; Zeiger wieder auf Exponent
        LD      DE,B9B96        ; Zeiger auf 1/LN(2)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        PUSH    HL              ; Zeiger auf Argument / LN(2)
        CALL    A94DD           ; einen Rechenspeicher reservieren
        PUSH    DE              ; Zeiger auf Rechenspeicher merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf Rechenspeicher holen
        CALL    A7B82           ; Nachkommastellen der Zahl (HL) vergessen
        PUSH    HL              ; Zeiger auf INT(Argument/LN(2))
        CALL    A7BEA           ; Real - Wert (HL) umsetzen in Integer - Wert nach HL
        XOR     A               ; Accu auf Null
        CP      H               ; High - Byte gleich Null  ?
        JP      NZ,A6367        ; nein -->  Fehler 2   Overflow error
        LD      A,L             ; Low - Byte holen
        LD      (S9A40),A       ; als Wert - Z√§hler EXP - Routine merken
        POP     DE              ; Zeiger auf INT(Argument/LN(2))
        POP     HL              ; Zeiger auf Argument/LN(2) holen
        PUSH    HL              ; und wieder merken
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        PUSH    DE              ; Zeiger auf INT(Argument/LN(2))
        PUSH    HL              ; Zeiger auf FRAC(Argument/LN(2))
        CALL    A79C2           ; +1 im Real - Format nach (DE) √ºbertragen
        POP     DE              ; Zeiger auf FRAC(Argument/LN(2))
        POP     HL              ; Zeiger auf +1
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        EX      DE,HL           ; Zeiger vertauschen
        XOR     A               ; Accu auf Null
        LD      B,8             ; acht Iterationsschritte
A996C:  PUSH    BC              ; Restanzahl Iterationsschritte merken
        PUSH    AF
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A997A         ; Zahl (DE) gr√∂√üer
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     AF
        SET     7,A
        PUSH    AF
A997A:  POP     AF
        RLC     A
        EX      DE,HL
        PUSH    AF
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        POP     AF
        EX      DE,HL
        POP     BC              ; Restanzahl Iterationsschritte holen
        DJNZ    A996C           ; Argument weiter angleichen
        LD      (S9A42),A
        PUSH    DE
        LD      DE,B9B8C        ; Zeiger auf LN(2)   (Real - Konstante)
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        BIT     3,A             ; Double - Precision  ?
        JR      NZ,A9998        ; ja
        LD      DE,B9B91        ; Zeiger auf LN(2)   (Real - Konstante)
A9998:  CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     DE
        PUSH    DE
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        BIT     3,A             ; Double - Precision  ?
        JP      Z,A9A30         ; nein -->  Real - Wert
        CALL    A94D0           ; Real - Zahl (HL) mal zwei
        LD      DE,B7C40        ; Zeiger auf +10   (Real - Format)
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        POP     DE
        PUSH    DE
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,B7C40        ; Zeiger auf +10   (Real - Format)
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        CALL    A94D0           ; Real - Zahl (HL) mal zwei
        POP     DE
        PUSH    DE
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,B9B87        ; Zeiger auf  1/120   (Real - Konstante)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        CALL    A94D0           ; Real - Zahl (HL) mal zwei
        CALL    A95DB           ; +1 zur Zahl (HL) addieren
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        POP     DE
        PUSH    DE
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        CALL    A95DB           ; +1 zur Zahl (HL) addieren
        POP     DE
        PUSH    DE
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
A99E7:  CALL    A95DB           ; +1 zur Zahl (HL) addieren
        EX      (SP),HL
        EX      DE,HL
        PUSH    DE
        CALL    A79C2           ; +1 im Real - Format nach (DE) √ºbertragen
        POP     HL
        LD      DE,B9B37        ; Zeiger auf Konstanten f√ºr EXP - Iteration
        LD      A,(S9A42)
        LD      B,8
A99F9:  RLC     A
        JR      NC,A9A04
        PUSH    AF
        PUSH    BC
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     BC
        POP     AF
A9A04:  INC     DE              ;! Zeiger auf n√§chstes Wert in Konstantentabelle
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        DJNZ    A99F9
        LD      A,(S9A40)       ; Wert - Z√§hler EXP - Routine holen
        ADD     A,(HL)
        JP      C,A6367         ; Fehler 2   Overflow error
        LD      (HL),A          ; Exponenten eintragen
        POP     DE      
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     BC
        LD      A,(S9A41)       ; Vorzeichen Argument EXP
        RLC     A               ; nach Carry schieben
        RET     NC              ; Argument war positiv
        PUSH    BC              ;! Register - Werte retten
        PUSH    DE              ;!
        PUSH    HL              ; Zeiger f√ºr Ergebnis retten
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     DE              ; Zeiger auf Stelle f√ºr Ergebnis holen
        PUSH    DE              ; und wieder merken
        CALL    A79C2           ; +1 im Real - Format nach (DE) √ºbertragen
        POP     HL              ; Zeiger auf +1
        POP     DE              ; Zeiger auf bisheriges Ergebnis
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        POP     BC              ; geretteten Register - Wert holen
        RET
;
A9A30:  POP     DE
        PUSH    DE
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      A,(HL)
        OR      A
        CALL    NZ,A94D5        ; Real - Zahl (HL) durch zwei
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        JP      A99E7           ; Wiedereinsprung in Routine
;
S9A40:  DEFS    1               ; Wert - Z√§hler  EXP - Routine
S9A41:  DEFS    1               ; Vorzeichen Argument EXP
S9A42:  DEFS    1  
;
;
;   Basic - Funktion   LOG     (Zwischencode 255 140 / 0FFH 08CH)
;
A9A43:  PUSH    BC              ; Register - Wert retten
        CALL    A9A4F           ; LN - Routine   ( LN(HL) )
        LD      DE,B9B28        ; Zeiger auf  LOG(e)   (Real - Konstante)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     BC              ; geretteten Register - Wert holen
        RET
;
;
;   Basic - Funktion   LN     (Zwischencode 255 133 / 0FFH 085H)
;
A9A4F:  PUSH    BC              ; Register - Wert retten
        CALL    A94CB           ; Vorzeichen der Zahl (HL) abfragen
        JP      NZ,A636A        ; negativ -->  Fehler 3  Illegal data error
        LD      A,(HL)          ; Exponent Argument holen
        OR      A               ; gleich Null  ?
        JP      Z,A636A         ; Argument = 0 -->  Fehler 3  Illegal data error
        SUB     081H            ; Exponentenz√§hler f√ºr Ergebnis errechnen
        LD      (S9B27),A       ; Exponentenz√§hler  LN - Routine
        LD      (HL),081H       ; neuen Exponenten vorgeben
        XOR     A               ; Accu auf Null
        LD      B,8             ; 8 Vergleichswerte
        LD      DE,B9B37        ; Zeiger auf Konstanten f√ºr LN - Routine
A9A68:  PUSH    BC              ; Z√§hler retten
        PUSH    AF              
        CALL    A9153           ; Real - Zahlwerte (HL) und (DE) vergleichen
        JR      C,A9A7E         ; Restwert kleiner Vergleichswert
        PUSH    HL              ; Zeiger auf Restwert retten
        LD      HL,8 * 5        ; Offset zur entsprechenden N.ten Wurzel aus 1/2
        ADD     HL,DE           ; Zeiger auf Tabelle errechnen
        EX      DE,HL           ; und nach DE
        EX      (SP),HL
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     DE
        POP     AF
        SET     7,A
        PUSH    AF
A9A7E:  POP     AF
        RLC     A
        INC     DE              ;! Zeiger auf Konstantentabelle auf n√§chsten
        INC     DE              ;! Wert in Tabelle
        INC     DE              ;!
        INC     DE              ;!
        INC     DE              ;!
        POP     BC              ; Z√§hler holen
        DJNZ    A9A68           ; weitere Durchl√§ufe
        LD      (S9BA0),HL      ; Zeiger auf Rechenspeicher vier
        CALL    A94DD           ; einen Rechenspeicher reservieren
        EX      DE,HL           ; Zeiger auf Rechenspeicher nach HL
        LD      E,A
        LD      D,0             ; High - Byte Wert auf Null
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        LD      A,(HL)          ; Exponenten holen
        OR      A               ; gleich Null  ?
        JR      Z,A9A9D         ; ja -->  Wert gleich Null
        SUB     8
        LD      (HL),A
A9A9D:  LD      A,(S9B27)       ; Exponentenz√§hler  LN - Routine
        CP      080H
        JR      C,A9AA6
        NEG
A9AA6:  PUSH    HL
        CALL    A94DD           ; einen Rechenspeicher reservieren
        EX      DE,HL           ; Zeiger auf Rechenspeicher nach DE
        LD      (S9BA2),HL      ; Zeiger auf Rechenspeicher drei
        LD      E,A
        LD      D,0
        CALL    A79CB           ; Integer-Wert in DE umsetzen in Real-Wert nach (HL)
        LD      A,(S9B27)       ; Exponentenz√§hler  LN - Routine
        AND     10000000B
        INC     HL
        OR      (HL)
        LD      (HL),A
        DEC     HL
        EX      DE,HL
        POP     HL
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        LD      A,(S9E9C)       ; Wertart des bereitgestellten Wertes holen
        LD      DE,B9B9B        ; Zeiger auf LN(2)  (Real - Konstante)
        CP      5               ; Real - Wert ?
        JR      Z,A9ACF         ; ja
        LD      DE,B9B8C        ; Zeiger auf LN(2)  (Real - Konstante)
A9ACF:  CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        PUSH    HL
        LD      DE,(S9BA2)      ; Zeiger auf Rechenspeicher drei
        LD      HL,(S9BA0)      ; Zeiger auf Rechenspeicher vier
        PUSH    HL              ; merken
        PUSH    DE              ; Zeiger auf Rechenspeicher drei merken
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL
        CALL    A95DB           ; +1 zur Zahl (HL) addieren
        EX      (SP),HL
        CALL    A90B3           ; -  - Routine   ( (HL) = (HL) - (DE) )
        POP     DE
        CALL    A93D5           ; /  - Routine  ( (HL) = (HL) / (DE) )
        PUSH    DE
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL
        PUSH    DE
        LD      E,L
        LD      D,H
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     DE
        PUSH    HL
        PUSH    DE
        CALL    A79C5           ; Real-Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL
        LD      DE,B9B32        ; Zeiger auf 5/3  (Real - Konstante)
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        EX      DE,HL
        POP     HL
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,B7C40        ; Zeiger auf  +10   (Real - Format)
        CALL    A94D0           ; Real - Zahl (HL) mal zwei
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        CALL    A94D5           ; Real - Zahl (HL) durch zwei
        EX      DE,HL
        LD      HL,(S9BA0)      ; Zeiger auf Rechenspeicher vier
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        LD      DE,B9B2D        ; Zeiger auf 2/5  (Real - Konstante)
        CALL    A92EA           ; *  - Routine   ( (HL) = (HL) * (DE) )
        POP     DE
        CALL    A90BC           ; +  - Routine   ( (HL) = (HL) + (DE) )
        POP     BC              ; geretteten Register - Wert holen
        RET
;
S9B27:  DEFS    1               ; Exponentenz√§hler  LN - Routine
;
;
;   diverse Konstanten f√ºr Rechenroutinen
;
B9B28:  DEFB    07FH                    ; Exponent   0.43429448    LOG(e)
        DEFB    05EH,05BH,0D8H,0A9H     ; Mantisse   0.43429448    LOG(e)
;
B9B2D:  DEFB    07FH                    ; Exponent   0.4           2/5
        DEFB    04CH,0CCH,0CCH,0CDH     ; Mantisse   0.4           2/5
;
B9B32:  DEFB    081H                    ; Exponent   1.6666667     5/3
        DEFB    055H,055H,055H,056H     ; Mantisse   1.6666667     5/3
;
;
;   Konstanten f√ºr EXP - Routine
;
B9B37:  DEFB    081H                    ; Exponent   1.4142136       2te Wurzel (2)
        DEFB    035H,004H,0F3H,034H     ; Mantisse   1.4142136       2te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.1892071       4te Wurzel (2)
        DEFB    018H,037H,0F0H,052H     ; Mantisse   1.1892071       4te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.0905077       6te Wurzel (2)
        DEFB    00BH,095H,0C1H,0E4H     ; Mantisse   1.0905077       6te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.0442738       8te Wurzel (2)
        DEFB    005H,0AAH,0C3H,068H     ; Mantisse   1.0442738       8te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.0218972      10te Wurzel (2)
        DEFB    002H,0CDH,086H,099H     ; Mantisse   1.0218972      10te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.0108893      12te Wurzel (2)
        DEFB    001H,064H,0D1H,0F4H     ; Mantisse   1.0108893      12te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.0054299      14te Wurzel (2)
        DEFB    000H,0B1H,0EDH,050H     ; Mantisse   1.0054299      14te Wurzel (2)
;
        DEFB    081H                    ; Exponent   1.0027113      16te Wurzel (2)
        DEFB    000H,058H,0D7H,0D3H     ; Mantisse   1.0027133      16te Wurzel (2)
;
        DEFB    080H                    ; Exponent   0.70710078      2te Wurzel (1/2)
        DEFB    035H,004H,0F3H,034H     ; Mantisse   0.70710078      2te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.84089641      4te Wurzel (1/2)
        DEFB    057H,044H,0FCH,0CBH     ; Mantisse   0.84089641      4te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.91700404      6te Wurzel (1/2)
        DEFB    06AH,0C0H,0C6H,0E8H     ; Mantisse   0.91700404      6te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.95760328      8te Wurzel (1/2)
        DEFB    075H,025H,07DH,016H     ; Mantisse   0.95760328      8te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.97857206     10te Wurzel (1/2)
        DEFB    07AH,083H,0B2H,0DCH     ; Mantisse   0.97857206     10te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.98922801     12te Wurzel (1/2)
        DEFB    07DH,03EH,00CH,00DH     ; Mantisse   0.98922801     12te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.99459942     14te Wurzel (1/2)
        DEFB    07EH,09EH,011H,05DH     ; Mantisse   0.99459942     14te Wurzel (1/2)
;
        DEFB    080H                    ; Exponent   0.99729605     16te Wurzel (1/2)
        DEFB    07FH,04EH,0CBH,05AH     ; Mantisse   0.99729605     16te Wurzel (1/2)
;
B9B87:  DEFB    07AH                    ; Exponent   .83333333E-02     1/120
        DEFB    008H,088H,088H,089H     ; Mantisse   .83333333E-02     1/120
;
B9B8C:  DEFB    080H                    ; Exponent   0.69314718        LN(2)
        DEFB    031H,072H,017H,0F8H     ; Mantisse   0.69314718        LN(2)  
;
B9B91:  DEFB    080H                    ; Exponent   0.69314718        LN(2)  
        DEFB    031H,072H,017H,0F8H     ; Mantisse   0.69314718        LN(2)  
;
B9B96:  DEFB    081H                    ; Exponent   1.442695          1/LN(2)
        DEFB    038H,0AAH,03BH,02AH     ; Mantisse   1,442695          1/LN(2)
;
B9B9B:  DEFB    080H                    ; Exponent   0.69314718        LN(2)  
        DEFB    031H,072H,017H,0F8H     ; Mantisse   0.69314718        LN(2)  
;
;
;   Speicher f√ºr Zeiger auf dynamische Zwischenspeicher f√ºr Rechenroutinen
;
S9BA0:  DEFS    2       ; Zeiger auf Rechenspeicher vier
S9BA2:  DEFS    2       ; Zeiger auf Rechenspeicher drei
S9BA4:  DEFS    2       ; Zeiger auf Rechenspeicher zwei
S9BA6:  DEFS    2       ; Zeiger auf Rechenspeicher eins
S9BA8:  DEFS    2       ; Zeiger auf Speicher f√ºr COS(Argument)
S9BAA:  DEFS    2       ; Zeiger auf Speicher f√ºr SIN(Argument)
;
; 
;   Basic - Befehl   SOUND     (Zwischencode 254 138 / 0FEH 08AH)
;
A9BAC:  CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFB    ____EQ          ; Zwischencode  =  ?
        JR      NZ,A9BBE        ; nicht SOUND =
        CALL    A79A3           ; auf Syntax 'Klammer auf' √ºberpr√ºfen
        CALL    A853D           ; 1-Byte - Wert nach E/Accu bereitstellen
        CP      15 + 1          ; gr√∂√üer als maximale Generatornummer  ?
        SET     7,A             ; Code for 'SOUND =' f√ºr Syntax√ºberpr√ºfung
        JR      A9BC3           ; √ºberpr√ºfen und Frequenz bereitstellen
;
A9BBE:  CALL    A853D           ; 1-Byte - Wert nach E/Accu bereitstellen
        CP      83 + 1          ; gr√∂√üer als maximale Notennummer  ?
A9BC3:  JP      NC,A636A        ; ja -->  Fehler 3  Illegal data error
        PUSH    AF              ; Generatornummer / Note retten
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A8551           ; Ausdruck (HL) auswerten und 2-Byte-Wert nach DE bereitst.
        POP     AF              ; Generatornummer / Note holen
        PUSH    AF              ; und wieder retten
        OR      A               ; SOUND =  ?
        CALL    M,A79AA         ; ja -->  auf Syntax 'Klammer zu' untersuchen
        POP     AF              ; Generatornummer / Note holen
        PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    34              ; Code 34  Ton nach Generatornr./Frequenz oder Note/L√§nge
        POP     HL              ; geretteten Programmzeiger holen
        RET
;
;
;   Basic - Befehl   TEMPO     (Zwischencode 254 163 / 0FE 0A3H)
;
A9BD9:  CALL    A853D           ; 1-Byte - Wert nach E/Accu bereitstellen
        DEC     A               ;! auf Tempo von 1 bis 7 untersuchen
        CP      7               ;! (hier fehlt aber irgendwie der Sprung
        INC     A               ;!  bei fehlerhaften Wert)
        JP      A0041           ; Tempo setzen
;
;
;   Basic - Befehl   NOISE     (Zwischencode 254 140 / 0FEH 08CH)
;
A9BE3:  LD      A,00001000B     ; Code for 'Tongenerator 4' 
        DEFB    LD_BC
;
;  
;   Basic - Befehl   MUSIC     (Zwischencode 254 163 / 0FEH 0A0H)
;
A9BE6:  LD      A,00000111B     ; Code for 'Tongenerator 1 - 3'
        LD      (S9CEB),A       ; Flag  'NOISE/MUSIC'
        CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
        LD      B,3             ; Code for 'MUSIC WAIT'
        CP      __WAIT          ; Zwischencode  WAIT  ?
        JR      Z,A9C07         ; ja -->  MUSIC WAIT
        DEC     B               ; Code auf  'MUSIC STOP'
        CP      __STOP          ; Zwischencode  STOP  ?
        JR      Z,A9C07         ; ja -->  MUSIC STOP
        CP      __INIT          ; Zwischencode INIT  ?
        JR      NZ,A9C0D        ; nein -->  normaler MUSIC - Befehl
        LD      DE,B9CDF        ; Zeiger auf Speicher f√ºr aktuelle Oktave
        LD      B,4             ; Vier Generatorwerte
        LD      A,2             ; Oktave vorgeben
        CALL    A013E           ; Speicherbereich (DE) mit Konstante im Accu f√ºllen
A9C07:  PUSH    HL              ; Programmzeiger retten
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    35              ; Code 35   MUSIC nach Status in B behandeln
        POP     HL              ; geretteten Programmzeiger holen
        INC     HL              ; Zwischencode √ºberspringen
        RET
;
;
;   Zeichenketten f√ºr MUSIC bereitstellen und auswerten
;
A9C0D:  CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        RET     Z               ; ja -->  fertig
        XOR     A               ; Accu auf Null
        LD      (S9CE7),A       ; Z√§hler 'bereitgestellte Zeichenkettenl√§nge' zur√ºcksetzen
        LD      (S9CE8),A       ; Z√§hler 'Stringnummer f√ºr parallele Ausgabe' zur√ºcksetzen
        LD      B,A             ; Null
        LD      A,CR            ; Textendezeichen
        LD      DE,S27D0        ; Zeiger auf Anfang Speicher f√ºr MUSIC - Text
        LD      (S9CE9),DE      ; Zeiger auf aktuelle Speicherstelle f√ºr MUSIC - Text
        LD      (DE),A          ; Textendezeichen eintragen
        CALL    A013E           ; Speicherbereich (DE) mit Konstante im Accu f√ºllen
        LD      A,(S9CEB)       ; Flag  'NOISE/MUSIC'
        LD      (S9CEC),A       ; als Flag 'welcher Tongenerator'  merken
A9C2C:  LD      DE,S9CEC        ; Zeiger auf Flag 'welcher Tongenerator'
        LD      A,(DE)          ; Flag 'welcher Tongenerator' holen
        RRC     A               ; ein Bit nach Carry schieben
        LD      (DE),A          ; Restbits merken
        PUSH    AF              ; Tongenerator-Status merken
        LD      B,0             ; Vorgabe f√ºr Zeichenkettenl√§nge
        JR      NC,A9C42        ; Bit nicht gesetzt -->  Tongegerator wird nicht angesprochen
        CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
        CP      ';'             ; Strichpunkt  ?
        JR      Z,A9C42         ; ja -->  keine Zeichenkette f√ºr Tongenerator angegeben
        CALL    A8561           ; Stringausdruck (HL) auswerten / Zeiger auf String nach DE
A9C42:  PUSH    HL              ; Programmzeiger retten
        LD      A,(S9CE8)       ; Z√§hler 'Stringnummer f√ºr parallele Ausgabe'
        CP      4               ; schon vierter paralleler String  ?
        JP      Z,A6364         ; ja -->  Fehler 1  Syntax error
        INC     A               ; Z√§hler plus eins
        LD      (S9CE8),A       ; Z√§hler 'Stringnummer f√ºr parallele Ausgabe' merken
        INC     B               ; Stringl√§nge plus eins   (f√ºr Textendezeichen)
        JP      Z,A6370         ; zu gro√ü -->  Fehler 5   String length error
        LD      A,(S9CE7)       ; Z√§hler 'bereitgestellte Zeichenkettenl√§nge'  holen
        ADD     A,B             ; plus neue L√§nge
        JP      C,A6370         ; zu gro√ü -->  Fehler 5   String lenght error
        LD      (S9CE7),A       ; Z√§hler 'bereitgestellte Zeichenkettenl√§nge' merken
        LD      HL,(S9CE9)      ; Zeiger auf aktuelle Speicherstelle f√ºr MUSIC - Text holen
        CALL    A014A           ; Speicherbereich von (DE) nach (HL) verschieben
        LD      (S9CE9),HL      ; Zeiger auf aktuelle Speicherstelle f√ºr MUSIC - Text
        DEC     HL              ; Zeiger auf Stelle f√ºr Textendezeichen
        LD      (HL),CR         ; Textende eintragen
        POP     HL              ; geretteten Programmzeiger holen
        POP     AF              ; geretteten Tongeneratorstatus holen
        JR      NC,A9C2C        ; Tongenerator nicht angesprochen -->  weiter untersuchen
        CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        JR      Z,A9C7E         ; ja -->  bereitgestellte Texte auswerten
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ","             ; Komma  ?
        JR      Z,A9C7E         ; wieder von vorne -->  bereitgestellte Texte auswerten
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    ";"             ; Strichpunkt als Trennzeichen √ºberspringen
        JR      A9C2C           ; weitere MUSIC - Teile auswerten
;
A9C7E:  PUSH    HL              ; Programmzeiger retten
        LD      HL,S27D0        ; Zeiger auf Speicher mit MUSIC - Texten
        PUSH    HL              ;! nach IX
        POP     IX              ;!
        LD      IY,B9CDF        ; Zeiger auf Speicher f√ºr aktuelle Oktave des Tongenerators
        LD      B,4             ; Texte f√ºr vier Tongeneratoren auswerten
A9C8B:  PUSH    BC              ; Z√§hler 'Restanzahl Texte' retten
        PUSH    HL              ; Zeiger auf MUSIC - Texte retten
        PUSH    IX              ;! Zeiger auf Stelle f√ºr Tongeneratorwerte
        POP     HL              ;! nach HL
        LD      DE,S27D0        ; Zeiger auf Anfang Speicher f√ºr Tongeneratorwerte
        XOR     A               ; Carry - Flag zur√ºcksetzen
        SBC     HL,DE           ; Offset auf Werte f√ºr Tongenerator errechnen
        LD      (IY+4),L        ; und merken
        POP     HL              ; Zeiger auf MUSIC - Texte merken
        LD      (A9CA1 + 1),SP  ; Stackpointer in Routine eintragen
        CALL    A9CED           ; MUSIC-Text (HL) auswerten und Werte f√ºr Tongenerator nach (IX)
A9CA1:  LD      SP,0            ; Stackpointer neu setzen
        POP     BC              ; Z√§hler 'Restanzahl Texte' holen
        INC     HL              ; Endezeichen MUSIC-Text √ºberspringen
        INC     IY              ; Endezeichen Tongeneratorwert √ºberspringen
        DJNZ    A9C8B           ; weitere Texte auswerten
        LD      B,3             ; Code 'MUSIC WAIT'  (Ende der letzten Melodie abwarten)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    35              ; Code 35   MUSIC nach Status in B behandeln
        LD      BC,256          ; maximal 256 Byte bereitgestellt
        LD      HL,S27D0        ; Zeiger auf bereitgestellte Werte f√ºr Tongenerator
        LD      DE,S2ED0        ; Zeiger auf Speicher f√ºr Generatorwerte
        LDIR                    ; Werte im Speicher retten
        LD      B,4             ; Werte f√ºr vier Tongeneratoren √ºbergeben
        LD      HL,S9CE3        ; Zeiger auf Speicher mit Offsets auf Werte
A9CBE:  LD      E,(HL)          ; einen Offset aus Speicher holen
        LD      D,0             ; High - Byte Offset auf Null
        INC     HL              ; Zeiger auf n√§chsten Offset
        PUSH    HL              ; Zeiger merken
        LD      HL,S2ED0        ; Zeiger auf Anfang Speicher mit Werten f√ºr Tongeneratoren
        ADD     HL,DE           ; Zeiger auf aktuellen Speicher errechnen
        LD      A,(HL)          ; ersten Wert aus Tabelle holen
        CP      -1              ; End of table  ?
        JR      Z,A9CD4         ; ja -->  keine Werte f√ºr diesen Tongenerator
        LD      A,4             ;! Tongeneratornummer aus Z√§hler errechnen
        SUB     B               ;!
        PUSH    BC              ; Tongeneratorz√§hler merken
        EX      DE,HL           ; Zeiger auf Tongeneratorwerte nach DE
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    33              ; Code 33  Werte (DE) nach Tongenerator im Accu
        POP     BC              ; Tongeneratorz√§hler holen
A9CD4:  POP     HL              ; Zeiger auf Offsets holen
        DJNZ    A9CBE           ; Werte f√ºr weitere Tongeneratoren auswerten
        LD      B,1
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    35              ; Code 35   MUSIC nach Status in B behandeln
        POP     HL              ; geretteten Programmzeiger holen
        JP      A9C0D           ; untersuchen, ob weitere MUSIC - Teile
;
;
;   Zeiger auf Speicher f√ºr aktuelle Oktave des Tongenerators
;
B9CDF:  DEFB    2               ; Tongenerator  1
        DEFB    2               ; Tongenerator  2
        DEFB    2               ; Tongenerator  3
        DEFB    2               ; Rauschgenerator
;
S9CE3:  DEFS    4               ; Speicher f√ºr Offset auf Tongeneratorwerte
S9CE7:  DEFS    1               ; Z√§hler 'bereitgestellte Zeichenkettenl√§nge'
S9CE8:  DEFS    1               ; Z√§hler 'Stringnummer f√ºr parallele Ausgabe'
S9CE9:  DEFS    2               ; Zeiger auf aktuelle Speicherstelle f√ºr MUSIC - Text
S9CEB:  DEFS    1               ; Flag  'NOISE/MUSIC'
S9CEC:  DEFS    1               ; Flag 'welcher Tongenerator'
;
;
;   Music - String (HL) auswerten und Werte f√ºr Tongenerator nach (IX) bereitstellen
;
A9CED:  CALL    A9E36           ; Speicher f√ºr Steuerparameter l√∂schen
A9CF0:  CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
        CALL    A9E0C           ; testen, ob Zeichen im Accu gleich Notenbuchstabe ist
        JR      C,A9CFF         ; kein Notenbuchstabe -->  auf Sonderzeichen untersuchen
        LD      C,0             ; Vorgabe f√ºr Offset auf Notennummer
        CALL    A9D60           ; Notenbuchstaben auswerten
        JR      A9D1F           ; untersuchen, ob Fehler aufgetreten ist
;
A9CFF:  CALL    A9E16           ; testen, ob Accu gleich Melodieendezeichen ist
        JP      Z,A9E1E         ; ja -->  Endezeichen eintragen
        LD      B,12            ; 12 Sonderzeichen in Tabelle
        EX      DE,HL           ; Zeiger auf Notentext nach DE
        LD      HL,M9D26        ; Zeiger auf Tabelle mit Sonderzeichen
A9D0B:  CP      (HL)            ; Accu mit Zeichen in Tabelle vergleichen
        INC     HL              ; Tabellenzeichen √ºberspringen
        JR      Z,A9D17         ; Zeichen gefunden -->  Routine aufrufen
        DEC     B               ; Restanzahl Zeichen minus eins
        JP      Z,A636A         ; Zeichen nicht gefunden -->  Fehler 3  Illegal data error
        INC     HL              ;! Anfangsadresse in Tabelle √ºberspringen
        INC     HL              ;!
        JR      A9D0B           ; n√§chstes Zeichen in Tabelle vergleichen
;
A9D17:  LD      C,(HL)          ;! Anfangsadresse der Routine aus
        INC     HL              ;! Tabelle holen
        LD      B,(HL)          ;!
        EX      DE,HL           ; Zeiger auf Music - Text nach HL
        INC     HL              ; ausgewertetes Zeichen √ºberspringen
        CALL    A9D24           ; Routine (BC) aufrufen
A9D1F:  JP      C,A636A         ; Fehler in Routine -->  Fehler 3  Illegal data error
        JR      A9CF0           ; Rest Notentext untersuchen
;
A9D24:  PUSH    BC              ; Anfangsadresse auf Stack ablegen
        RET                     ; Routine aufrufen
;
;
;   Tabelle mit Anfangsadresse der Sonderfunktionen im Music - Text
;
M9D26:  DEFM    "#"             ; erh√∂hte Note
        DEFW    A9D57           ; Anfangsadresse der Routine
        DEFM    "+"             ; obere Oktave
        DEFW    A9D4D           ; Anfangsadresse der Routine
        DEFB    0D7H            ; obere Oktave   (Balken oben)
        DEFW    A9D4D           ; Anfangsadresse der Routine
        DEFM    "-"             ; untere Oktave
        DEFW    A9D4A           ; Anfangsadresse der Routine
        DEFB    0CFH            ; untere Oktave  (Balken unten)
        DEFW    A9D4A           ; Anfangsadresse der Routine
        DEFM    "O"             ; Oktave setzen
        DEFW    A9D91           ; Anfangsadresse der Routine
        DEFM    "N"             ; Note angegeben
        DEFW    A9DA0           ; Anfangsadresse der Routine
        DEFM    "T"             ; Tempo angegeben
        DEFW    A9DAA           ; Anfangsadresse der Routine
        DEFM    "V"             ; Lautst√§rke angegeben
        DEFW    A9DBC           ; Anfangsadresse der Routine
        DEFM    "S"             ; Wellenform angegeben
        DEFW    A9DDE           ; Anfangsadresse der Routine
        DEFM    "M"             ; Wiederholungsfaktor angegeben
        DEFW    A9DEC           ; Anfangsadresse der Routine
        DEFM    "L"             ; Tonl√§nge angegeben
        DEFW    A9DCD           ; Anfangsadresse der Routine
;
;
;   Note in unterer Oktave auswerten
;
A9D4A:  LD      C,-12           ; Offset f√ºr Notennummer in unterer Oktave
        DEFB    LD_DE
;
;
;   Note in oberer Oktave auswerten
;
A9D4D:  LD      C,12            ; Offset f√ºr Notennummer in oberer Oktave
        CALL    A0164           ; Vergleich auf Byte hinter CALL
        DEFM    "#"             ; erh√∂hte Note  ?
        JR      NZ,B9D56        ; nein
        INC     C               ; Offset f√ºr Notennummer plus eins
B9D56:  DEFB    LD_DE
;
;
;   erh√∂hte Note auswerten
;
A9D57:  LD      C,1             ; Offset f√ºr erh√∂hte Note vorgeben
        CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
        CALL    A9E0C           ; testen, ob Zeichen im Accu gleich Notenbuchstabe ist
        RET     C               ; kein Notenbuchstabe -->  Abbruch
A9D60:  LD      B,A             ; Notenbuchstaben merken
        INC     HL              ; Notenbuchstaben im Text √ºberspringen
        CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        CCF                     ; Ergebnisflag umkehren
        CALL    C,A9DD4         ; Nummer angegeben -->  Tonl√§nge auswerten
        RET     C               ; Fehler aufgetreten -->  Abbruch
        LD      A,B             ; Notenbuchstaben holen
        CP      'R'             ; Pause  ?
        JR      Z,A9D85         ; ja -->  merken
        PUSH    HL              ; Zeiger auf Resttext retten
        LD      HL,B9E3E + -'A' ; Zeiger auf Notenoffset f√ºr Notennummer
        CALL    A0158           ; Wert im Accu zum HL-Register addieren
        LD      B,(IY+0)        ; aktuelle Oktave holen
        INC     B               ; f√ºr Schleife corrigieren
        LD      A,(HL)          ; Offset der Note aus Tabelle holen
        POP     HL              ; Zeiger auf Rest Notentext holen
        ADD     A,C             ; eventuellen Offset aus Oktave oder erh√∂hter Note addieren
        SUB     12              ; Wert f√ºr Schleife corrigieren
A9D7F:  ADD     A,12            ;! Notennummer der Note aus Notenoffset und aktueller
        DJNZ    A9D7F           ;! Oktave errechnen  (12 T√∂ne je Oktave)
        JR      A9DA4           ; Notennummer √ºberpr√ºfen und merken
;
A9D85:  XOR     A               ; Code for 'Pause'
A9D86:  PUSH    AF              ; neuen Wert retten
        CALL    A9E29           ; untersuchen, ob sich Steuerparameter ge√§ndert hat
        POP     AF              ; geretteten neuen Wert holen
A9D8B:  LD      (IX+0),A        ; neuen Wert merken
        INC     IX              ; Zeiger auf Speicher auf n√§chste Stelle
        RET
;
;
;   Oktave setzen
;
A9D91:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        JR      NC,A9D98        ; Zahlwert angegeben
        LD      A,2             ; Vorgabe f√ºr Oktave - Nummer
A9D98:  CP      6 + 1           ; Oktave 0 bis 6  ?
        CCF                     ; Ergebnis umkehren
        RET     C               ; Oktave zu gro√ü -->  Abbruch
        LD      (IY+0),A        ; aktuelle Oktave des Tongenerators merken
        RET
;
;
;   Notennummer auswerten
;
A9DA0:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        RET     C               ; keine Notennummer angegeben -->  Abbruch
A9DA4:  CP      83 + 1          ; Notennummer 0 - 83  ?
        CCF                     ; Ergebnis umkehren
        RET     C               ; Notennummer zu gro√ü -->  Abbruch
        JR      A9D86           ; Notennummer merken
;
;
;   Tempo auswerten
;
A9DAA:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        JR      NC,A9DB1        ; Tempo angegeben
        LD      A,4             ; Vorgabe f√ºr Tempo
A9DB1:  DEC     A               ;! Tempo zwischen 1 und 7  ?
        CP      7               ;!
        CCF                             ; Ergebnis umkehren
        RET     C               ; falsches Tempo -->  Abbruch
        ADD     A,06AH          ; plus Code for 'Tempo'
        LD      (S9E45),A       ; aktuelles Tempo merken
        RET
;
;
;   Lautst√§rke auswerten
;
A9DBC:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        JR      NC,A9DC3        ; Lautst√§rke angegeben
        LD      A,15            ; Vorgabe f√ºr Lautst√§rke
A9DC3:  CP      15 + 1          ; mit maximaler Lautst√§rke vergleichen
        CCF                     ; Ergebnis umkehren
        RET     C               ; Lautst√§rke zu gro√ü -->  Abbruch
        ADD     A,080H          ; plus Code for 'Lautst√§rke'
        LD      (S9E46),A       ; aktuelle Lautst√§rke merken
        RET
;
;
;   Tonl√§nge auswerten
;
A9DCD:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        JR      NC,A9DD4        ; Tonl√§nge angegeben
        LD      A,5             ; Vorgabe f√ºr Tonl√§nge
A9DD4:  CP      9 + 1           ; mit maximaler Tonl√§nge vergleichen
        CCF                     ; Ergebnis umkehren
        RET     C               ; Tonl√§nge zu gro√ü -->  Abbruch
        ADD     A,060H          ; plus Code for 'Tonl√§nge'
        LD      (S9E47),A       ; aktuelle Tonl√§nge merken
        RET
;
;
;   Wellenform auswerten
;
A9DDE:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        RET     C               ; keine Wellenform angegeben
        CP      8 + 1           ; mit maximaler Wellenform vergleichen
        CCF                     ; Ergebnis umkehren
        RET     C               ; Wellenform zu gro√ü -->  Abbruch
        ADD     A,090H          ; plus Code 'Wellenform'
        LD      (S9E48),A       ; aktuelle Wellenform merken
        RET
;
;
;   Wiederholungsfaktor auswerten
;
A9DEC:  CALL    A9DFC           ; testen, ob (HL) Zahlwert, wenn ja -->  bereitstellen
        RET     C               ; kein Wiederholungsfaktor angegeben -->  Abbruch
        OR      A               ; gleich Null  ?
        SCF                     ; Code for 'Fehler aufgetreten'  setzen
        RET     Z               ; gleich Null -->  Abbruch
        LD      B,A             ; Wiederholungsfaktor merke
        LD      C,0A0H          ; Code for 'Wiederholungsfaktor'
        LD      (S9E49),BC      ; Code und Wiederholungsfaktor merken
        OR      A
        RET
;
;
;   testen, ob (HL) Zahlwert, wenn ja -->  Zahlwert nach E/Accu bereitstellen
;
A9DFC:  CALL    A015E           ; Leerzeichen (Spaces)   (HL) √ºberspringen
        CALL    A9E16           ; testen, ob Accu gleich Melodieendezeichen ist
        SCF                     ; Code for 'kein Zahlwert'
        CALL    NZ,A79F6        ; nicht Ende -->  testen, ob Accu gleich Ziffer ist
        RET     C               ; kein Zahlwert angegeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    19              ; Code 19   ASCII - Wert (HL) umsetzen in Hex-Wert nach DE
        JP      A8540           ; untersuchen, ob Wert in DE zwischen 0 und 255 liegt
;
;
;   testen, ob Zeichen im Accu gleich Notenbuchstabe ist
;
A9E0C:  CP      'R'             ; Pause  ?
        RET     Z               ; ja
        CP      'A'             ; Notenbuchstabe  ?
        RET     C               ; nein
        CP      'G' + 1         ; Notenbuchstabe  ?
        CCF                     ; Ergebnisflag umkehren
        RET
;
;
;   testen, ob Accu gleich Melodieendezeichen ist
;
A9E16:  OR      A               ; Zeilenendezeichen  ?
        RET     Z               ; ja
        CP      CR              ; Textendezeichen  ?
        RET     Z               ; ja
        CP      0C8H            ; Melodieendezeichen  ?
        RET
;
;
;   Ende der Wertetabelle eintragen
;
A9E1E:  CALL    A9E29           ; untersuchen, ob sich Steuerparameter ge√§ndert hat
        LD      A,-1            ; 'End of table' code
        CALL    A9D8B           ; Wert im Accu merken
A9E26:
        JP      A9CA1           ; Text f√ºr n√§chsten Tongenerator auswerten
;
;
;   untersuchen, ob sich Steuerparameter ge√§ndert hat, wenn ja -->  merken
;
A9E29:  LD      DE,S9E45        ; Zeiger auf Speicher f√ºr Steuerparameter
        LD      B,6             ; sechs Speicher
A9E2E:  LD      A,(DE)          ; ein Wert aus Speicher holen
        OR      A               ; gleich Null  ?
        CALL    NZ,A9D8B        ; nein -->  merken
        INC     DE              ; Zeiger auf n√§chsten Speicher
        DJNZ    A9E2E           ; weitere Speicherzellen √ºberpr√ºfen
;
;
;   Speicher f√ºr Steuerparameter l√∂schen
;
A9E36:  LD      DE,S9E45        ; Zeiger auf Speicher f√ºr Steuerparameter
        LD      B,6             ; Anzahl Zeichen
        JP      A013D           ; Speicherbereich (DE) l√∂schen
;
;
;   Tabelle mit Offsets der Noten innerhalb der Oktave
;
B9E3E:  DEFB    9               ; A
        DEFB    11              ; B
        DEFB    0               ; C
        DEFB    2               ; D
        DEFB    4               ; E
        DEFB    5               ; F
        DEFB    7               ; G
;
;
;   Speicher f√ºr Steuerparameter   (MUSIC)
;
S9E45:  DEFS    1               ; Tempo
S9E46:  DEFS    1               ; Lautst√§rke 
S9E47:  DEFS    1               ; Tonl√§nge 
S9E48:  DEFS    1               ; Wellenform
S9E49:  DEFS    2               ; Wiederholungsfaktor
;
;
;   Statusdatensatz des aktuellen Programms  (wird bei SWAP gerettet)
;
S9E4B:  DEFS    2               ; Zeiger auf n√§chste Zeile
S9E4D:  DEFS    2               ; Editor - Zeilennummer
S9E4F:  DEFS    2               ; Offset f√ºr AUTO
S9E51:  DEFS    2               ; Zeilennummer der aktuellen Zeile
S9E53:  DEFS    1               ; Fehlernummer
S9E54:  DEFS    1               ; ON ERROR GOTO - Status
S9E55:  DEFS    2               ; Fehler - Zeilennummer
S9E57:  DEFS    2               ; Zeiger auf n√§chste Zeile bei Fehler
S9E59:  DEFS    2               ; Programmzeiger bei Fehler
S9E5B:  DEFS    2               ; Zeiger auf Fehlerbehandlungsroutine
S9E5D:  DEFS    1               ; DATA - Flag
S9E5E:  DEFS    2               ; DATA - Zeiger
;
W9E60:  DEFW    21              ; Rettl√§nge f√ºr SWAP
W9E62:  DEFW    -21             ; Rettl√§nge f√ºr SWAP  (Complement)
;
;
;
S9E64:  DEFS    2               ; Stackpointer bei Anfang Befehl
S9E66:  DEFS    2               ; Programmzeiger bei Anfang Befehl
S9E68:  DEFS    2  
;
S9E6A:  DEFS    7               ; Zeiger auf Zwischenspeicher  (bei USING - Format)
S9E71:  DEFS    1               ; Speicher zur Zahlaufbereitung in ASCII  (33 Byte)
S9E72:  DEFS    3               ; Anfang Speicher f√ºr ASCII - Zahl
S9E75:  DEFS    1               ; Speicher f√ºr ASCII - Zahl  (mindestens 5 Z.)
S9E76:  DEFS    4               ; Speicher f√ºr Aufbereitung Hex - Wert
S9E7A:  DEFS    1               ; Stelle f√ºr Dezimalpunkt
S9E7B:  DEFS    8               ; Speicher f√ºr Nachkommastellen
S9E83:  DEFS    25              ; maximales Ende Mantisse ohne Exponent
;
S9E9C:  DEFB    8               ; Wertart des bereitgestellten Wertes
;
S9E9D:  DEFS    8               ; Zwischenspeicher f√ºr Berechnung
S9EA5:  DEFS    8               ; Speicher f√ºr Real - Zahlwert
S9EAD:  DEFS    8               ; Speicher f√ºr Real - Zahl   (ASCII-Aufber.)
 
;   Text f√ºr Copyright  -  Meldung
;
;   Speicher wird nach Ausgabe f√ºr Zwischencodezeile genutzt
;
M9EB5:  DEFB    C_CLR,CR
        DEFB    0D7H,0D7H,0D7H,0D7H     ; Balken oben
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFB    0D7H,0D7H,0D7H,0D7H
        DEFM    " DISK BASIC I"         ; DISK BASIC interpreter MZ-2Z046 V1.0A
        DEFB    _SML
        DEFM    "NTERPRETER "
        DEFB    _CAP
        DEFM    "MZ-2Z046 V 1.0A "
        DEFB    CR
        DEFM    "   C"                  ; Copyright (C) by SHARP CORP.
        DEFB    _SML
        DEFM    "OPYRIGHT "
        DEFB    _CAP
        DEFM    "(C) 1984 "
        DEFB    _SML
        DEFM    " BY"
        DEFB    _CAP
        DEFM    " SHARP CORP.   "
        DEFB    0CFH,0CFH,0CFH,0CFH     ; Underlined
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
        DEFB    0CFH,0CFH,0CFH,0CFH
		DEFB    CR,_SML
        DEFM    "22338 BYTES FREE "     ; 22338 bytes free
        DEFB    CR,CR,NUL
;
        DEFS    92                      ; Rest Speicher f√ºr Zwischencodezeile
;
;
;   Die folgenden Routinen sind im wesentlichen f√ºr den MZ - 800 - Plotter
;
M9FD0:  DEFM    "N"             ; Textgr√∂√üenflag Drucker
;
;
;   Plotterroutinen l√∂schen   (NEW ON)
;
A9FD1:  LD      BC,T63CB        ; Fehler 59'   Can't execute error
        LD      DE,B9FF9        ; Zeiger auf Tabelle mit gel√∂schten Befehlen
A9FD7:  LD      A,(DE)          ; Zwischencode aus Tabelle holen
        INC     DE              ; Zeiger auf Tabelle auf n√§chsten Befehl
        ADD     A,A             ; Tabellenende  ?
        JR      Z,A9FE7         ; ja -->  noch Parallelausgabe abschalten
        LD      HL,W5C5B        ; Zeiger auf Tabelle mit Anfangsadressen
        CALL    A0158           ; Wert im Accu zum HL - Register addieren
        LD      (HL),C          ;! Fehleradresse als Anfangsadresse 
        INC     HL              ;! des Befehls eintragen
        LD      (HL),B          ;!
        JR      A9FD7           ; weitere Befehle abnippeln
;
A9FE7:  XOR     A               ; Accu auf Null
        LD      (S108F),A       ; Parallelausgabeflag Drucker zur√ºcksetzen
        LD      A,(S1097)       ; Drucker - Modus - Flag holen
        DEC     A               ; im Textmodus  ?
        CALL    NZ,AA04D        ; nein -->  umschalten auf Textmodus
        LD      HL,AA017        ; neuer Anfang freier Speicher vorgeben
        LD      (S1070),HL      ; Zeiger auf Basic - Programmanfang merken
        RET
;
;
;   Tabelle mit Zwischencodes der mit NEW ON gel√∂schten Befehle
;
B9FF9:  DEFB    0A2H            ; PMODE
        DEFB    0A3H            ; PSKIP
        DEFB    0A4H            ; PLOT
        DEFB    0A5H            ; PLINE
        DEFB    0A6H            ; RLINE
        DEFB    0A7H            ; PMOVE
        DEFB    0A8H            ; RMOVE
        DEFB    0AEH            ; PCOLOR
        DEFB    0AFH            ; PHOME
        DEFB    0B0H            ; HSET
        DEFB    0B1H            ; GPRINT
        DEFB    0B3H            ; AXIS
        DEFB    0BBH            ; PCIRCLE
        DEFB    0BCH            ; PTEST
        DEFB    0BDH            ; PAGE
        DEFB    0               ; End of table
;
;
;   Drucker auf Textmodus √ºberpr√ºfen
;
AA009:  LD      B,1             ; Code for 'Textmodus'
        JR      AA00F           ; Drucker - Modus √ºberpr√ºfen
;
;
;   Drucker auf Graphic - Modus √ºberpr√ºfen
;
AA00D:  LD      B,2             ; Code for 'Graphic - Modus'
AA00F:  LD      A,(S1097)       ; Drucker - Modus - Flag holen
        CP      B               ; mit Vorgabe vergleichen
        RET     Z               ; Drucker - Modus ist OK
        JP      A63B7           ; Fehler 68   Dev. mode error
;
;
;   Die folgenden Graphic - Plotter - Routinen werden mit NEW ON abgekoppelt.
;   Ab hier kann dann das BASIC - Anwender - Programm gespeichert werden.
;
;   
;   Basic - Befehl   MODE     (Zwischencode 162 / 0A2H)
;
AA017:  CALL    AA01F           ; Drucker - Modus auswerten und Drucker umstellen
        XOR     A               ; Accu auf Null
        LD      (S1095),A       ; als Spaltennummer Drucker merken
        RET
;
;
;   angegebenen Drucker - Modus auswerten und Drucker umstellen
;
AA01F:  LD      A,(S108F)       ; Parallelausgabeflag Drucker holen
        OR      A               ; Parallelausgabe gesetzt  ?
        JP      NZ,A63B7        ; ja -->  Fehler 68   Dev. mode error
        CALL    AA46A           ; Abfrage, ob angew√§hlter Drucker der MZ-800 - Plotter ist
        CALL    A0164           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    "G"             ; MODE  G   ?
        JP      Z,AA071         ; ja -->  auf Graphic - Modus umschalten
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "T"             ; MODE  T   ?
        CALL    A0164           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    "N"             ; MODE  TN   ?
        JR      Z,AA044         ; ja -->  Textgr√∂√üenflag merken und Drucker umschalten
        CALL    A0164           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    "L"             ; MODE  TL   ?
        JR      Z,AA044         ; ja -->  Textgr√∂√üenflag merken und Drucker umschalten
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "S"             ; MODE  TS   ?
AA044:  LD      (M9FD0),A       ; Textgr√∂√üenflag Drucker merken
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        CALL    AA069           ; Zeilenvorschub / Zeilenr√ºckzug  ausgeben
AA04D:  LD      A,1             ; Code for 'Umschalten auf Textmodus'
        LD      (S1097),A       ; als Drucker - Modus - Flag merken
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        LD      A,(M9FD0)       ; Textgr√∂√üenflag Drucker holen
        CP      'N'             ; MODE  TN  ?
        RET     Z               ; ja -->  fertig
        CP      'L'             ; MODE  TL  ?
        LD      A,00BH          ; Code for 'Umschalten auf 26 Zeichen/Zeile'
        JR      Z,AA066         ; Steuercode an Drucker ausgeben
;
;
;   Drucker / Plotter  umschalten auf 80 Zeichen / Zeile
;
AA060:  LD      A,009H          ; Code for 'Umschalten auf 80 Zeichen / Zeile'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
AA066:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        RET
;
;
;   Zeilenvorschub / Zeilenr√ºckzug ausgeben, im Papier zu spannen
;
AA069:  LD      A,LF            ; Code for 'Zeilenvorschub'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        LD      A,ETX           ; Code for 'Zeilenr√ºckzug'
        JR      AA066           ; Zeichen im Accu an Drucker ausgeben
;
;
;   Drucker auf Graphic - Modus umstellen
;
AA071:  INC     HL              ; ausgewertetes Zeichen √ºberspringen
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        LD      A,2             ; Code for 'Umschalten auf Graphic - Modus'
        LD      (S1097),A       ; als Drucker - Modus - Flag merken
        JR      AA066           ; Zeichen im Accu an Drucker ausgeben 
;
;
;   Basic - Befehl   SKIP     (Zwischencode 163 / 0A3H)
;
AA07C:  CALL    AA46A           ; Abfrage, ob angew√§hlter Drucker der MZ-800 - Plotter ist
        CALL    AA009           ; Drucker auf Text - Modus √ºberpr√ºfen
        CALL    A8551           ; Ausdruck (HL) auswerten und 2-Byte-Wert nach DE bereitstellen
        LD      A,E             ; Low - Byte Wert holen
        OR      A               ; gleich Null  ?
        RET     Z               ; ja -->  fertig
        CP      -20             ; mit maximal erlaubter Anzahl R√ºckschritte vergleichen
        JR      NC,AA091        ; Wert ist OK
        CP      20 + 1          ; mit maximal erlaubter Anzahl Vorsch√ºbe vergleichen
        JP      NC,A636A        ; zu gro√ü -->  Fehler 3   Illegal data error
AA091:  CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        BIT     7,E             ; Wert negativ  ?
        JR      NZ,AA0A0        ; ja -->  Zeilenr√ºcksch√ºbe ausgeben
AA098:  LD      A,LF            ; Code for 'Zeilenvorschub'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        DEC     E               ; Z√§hler  'Restanzahl Zeilen'  minus eins
        JR      NZ,AA098        ; weitere Zeilenvorsch√ºbe ausgeben
        RET
;
AA0A0:  LD      A,ETX           ; Code for 'Zeilenr√ºckzug'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        INC     E               ; Z√§hler  'Restanzahl Zeilen'  plus eins
        JR      NZ,AA0A0        ; weitere Zeilenr√ºcksch√ºbe ausgeben
        RET
;
;
;   Wert in DE auf Y - Koordinate Graphic - Modus √ºberpr√ºfen
;
AA0A8:  PUSH    HL              ; Register - Wert retten
        LD      HL,999          ; maximale Y - Koordinate vorgeben
        JR      AA0B2           ; Koordinate in DE √ºberpr√ºfen
;
;
;   Wert in DE auf X - Koordinate Graphic - Modus √ºberpr√ºfen
;
AA0AE:  PUSH    HL              ; Register - Wert retten
        LD      HL,480          ; maximale X - Koordinate vorgeben
AA0B2:  PUSH    HL              ; maximale Koordinate retten
        ADD     HL,DE           ; Koordinate in DE auf minus Maximum √ºberpr√ºfen
        POP     HL              ; maximale Koordinate holen
        JR      C,AA0BC         ; Koordinate ist OK -->  geretteten Register - Wert holen
        SBC     HL,DE           ; auf maximale Koordinate √ºberpr√ºfen
        JP      C,A636A         ; zu gro√ü -->  Fehler 3   Illegal data error
AA0BC:  POP     HL              ; gerettete Register - Wert holen
        RET
;
;
;   Basic - Befehl   PLINE     (Zwischencode  165 / 0A5H)
;
AA0BE:  LD      C,'D'           ; D   (Draw)     (absolute Linie)
        DEFB    LD_DE
;
;
;   Basic - Befehl   RLINE     (Zwischencode  166 / 0A6H)
;
AA0C1:  LD      C,'J'           ; J              (relative Linie)
        DEFB    LD_DE
;
;
;   Basic - Befehl   PMOVE     (Zwischencode  167 / 0A7H)
;
AA0C4:  LD      C,'M'           ; M   (Move)     (absolute Kopfbewegung)
        DEFB    LD_DE
;
;
;   Basic - Befehl   RMOVE     (Zwischencode  168 / 0A8H)
;
AA0C7:  LD      C,'R'           ; R   (relativ)  (relative Kopfbewegung)
        CALL    AA46A           ; Abfrage, ob angew√§hlter Drucker der MZ-800 - Plotter ist
        CALL    AA00D           ; Drucker auf Graphic - Modus √ºberpr√ºfen
        LD      A,C             ; Steuercode f√ºr Drucker holen
        LD      (DA112 + 1),A   ; und in Routine eintragen
        CP      'M'             ; Kopfbewegung  ?
        JR      NC,AA0F9        ; ja -->  nicht auf Linientyp untersuchen
        CALL    A0164           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    "%"             ; Code for 'Linientyp'  ?
        JR      NZ,AA0F9        ; kein Linientyp angegeben
        CALL    A853D           ; 1-Byte - Wert nach E/Accu bereitstellen
        LD      A,E             ; Linientypwert holen
        DEC     A               ; intern von 0 - 15
        CP      15 + 1          ; mit maximalem Wert vergleichen
        JP      NC,A636A        ; zu gro√ü -->  Fehler 3   Illegal data error
        DEC     DE              ; Z√§hler corrigieren
        LD      A,'L'           ; L  (Line)    (Code  Linientyp)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        CALL    AA158           ; Zeilenvorschub an Drucker ausgeben
        CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        RET     Z               ; nur Linie spezifiziert -->  fertig
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
AA0F9:  CALL    A8551           ; Ausdruck (HL) auswerten und 2-Byte-Wert nach DE bereitstellen
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
        CALL    AA0AE           ; Wert in DE auf X-Koordinate Graphic-Modus √ºberpr√ºfen
        PUSH    DE              ; X - Koordinate Graphic merken
        CALL    A8551           ; Ausdruck (HL) auswerten und 2-Byte-Wert nach DE bereitstellen
        CP      ','             ; n√§chstes Zeichen gleich Komma  ?
        JR      Z,AA10D         ; ja -->  weitere Koordinaten angegeben
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
AA10D:  CALL    AA0A8           ; Wert in DE auf Y-Koordinate Graphic-Modus √ºberpr√ºfen
        POP     BC              ; X - Koordinate Graphic holen
        PUSH    DE              ; Y - Koordinate Graphic holen
DA112:  LD      A,0             ; Befehlsbuchstaben f√ºr Bewegung   (wird eingetragen)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        LD      E,C             ;! X - Koordinate nach DE kopieren
        LD      D,B             ;!
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        CALL    AA15C           ; Komma an Drucker ausgeben
        POP     DE              ; Y - Koordinate Graphic holen
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        CALL    AA158           ; Zeilenvorschub an Drucker ausgeben
        CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        RET     Z               ; fertig
        INC     HL              ; Trennzeichen √ºberspringen
        JR      AA0F9           ; n√§chstes Koordinatenpaar bereitstellen und ausgeben
;
;
;   Basic - Befehl   PCOLOR     (Zwischencode  174 / 0EAH)
;
AA12C:  CALL    AA46A           ; Abfrage, ob angew√§hlter Drucker der MZ-800 - Plotter ist
        CALL    A853D           ; 1-Byte - Wert nach E/Accu bereitstellen
        LD      A,E             ; bereitgestellte Zeichenfarbe holen
        CP      3 + 1           ; Farbe gleich 0 - 3  ?
        JP      NC,A636A        ; nein -->  Fehler 3   Illegal data error
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        LD      A,(S1097)       ; Drucker - Modus - Flag holen
        CP      2               ; im Graphic - Modus  ?
        JR      Z,AA14F         ; ja -->  Farbwert ausgeben
        CALL    AA069           ; Zeilenvorschub/Zeilenr√ºckzug ausgeben
        LD      A,2             ; im Graphic - Modus  ?
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        CALL    AA14F           ; Stiftfarbe an Drucker ausgeben
        JP      AA45C           ; n√§chstes Koordinatenpaar bereitstellen und ausgeben
;
;
;   Stiftfarbe in E an Drucker ausgeben
;
AA14F:  LD      A,'C'           ; Code for 'Stiftfarbe wechseln'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        LD      A,E             ; Stiftfarbnummer holen
        OR      '0'             ; umsetzen in ASCII
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
AA158:
        LD      A,CR            ; Code for 'Zeilenvorschub'
        JR      AA15E           ; Zeichen im Accu an Drucker ausgeben
;
;
;   Komma an Drucker ausgeben
;
AA15C:  LD      A,','           ; Komma
AA15E:  RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        RET
;
;
;   Basic - Befehl   PHOME     (Zwischencode  175 / 0AFH)
;
AA161:  LD      C,'H'           ; Code   'HOME'
        DEFB    LD_DE
;
;
;   Basic - Befehl   HSET     (Zwischencode  176 / 0B0H)
;
AA164:  LD      C,'I'           ; Code   'Initialize'
        CALL    AA00D           ; Drucker auf Graphic - Modus √ºberpr√ºfen
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        LD      A,C             ; Steuerzeichen f√ºr Drucker holen
        JR      AA15E           ; Zeichen im Accu an Drucker ausgeben
;
;
;   Basic - Befehl   GPRINT     (Zwischencode  177 / 0B1H)
;
AA16F:  CALL    AA46A           ; Abfrage, ob angew√§hlter Drucker der MZ-800 - Plotter ist
        CALL    AA00D           ; Drucker auf Graphic - Modus √ºberpr√ºfen
        CALL    A0164           ; Vergleich auf Byte hinter CALL - Aufruf
        DEFM    "["             ; Eckige Klammer auf  ?
        JR      NZ,AA1B3        ; nein -->  keine Zeichengr√∂√üe/-lage angegeben
        CALL    A853D           ; 1-Byte - Wert nach E/Accu bereitstellen
        CP      63 + 1          ; mit maximaler Zeichengr√∂√üe vergleichen
        JP      NC,A636A        ; zu gro√ü -->  Fehler 3   Illegal data error
        PUSH    DE              ; Zeichengr√∂√üe retten
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A853D           ; 1-Byte - Wert nach E/Accu bereitstellen
        CP      3 + 1           ; Schriftrichtung  0  -  3  ?
        JP      NC,A636A        ; zu gro√ü -->  Fehler 3   Illegal data error
        PUSH    DE              ; Schriftrichtung merken
        CALL    A016E           ; Syntaxuntersuchung auf Byte hinter CALL - Aufruf
        DEFM    "]"             ; Eckige Klammer zu  ?
        POP     BC              ; Schriftrichtung holen
        POP     DE              ; Zeichengr√∂√üe holen
        PUSH    BC              ; Schriftrichtung wieder merken
        LD      A,'S'           ; Code for 'Zeichengr√∂√üe'   (Scale)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        CALL    AA15C           ; Komma an Drucker ausgeben
        POP     DE              ; Schriftrichtung holen
        LD      A,'Q'           ; Code for 'Schriftrichtung'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        CALL    AA158           ; Zeilenvorschub an Drucker ausgeben
        CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        RET     Z               ; kein Text angegeben
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
AA1B3:  CALL    A8561           ; Stringausdruck (HL) auswerten/Zeiger auf String nach DE
        CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        JR      Z,AA1BF         ; ja -->  keine weitere Texte
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
        DEC     HL              ; Programmzeiger corrigieren
AA1BF:  LD      A,B             ; Textl√§nge holen
        OR      A               ; gleich Null  ?
        JR      Z,AA1D0         ; ja -->  kein Text zur ausgabe bereitgestellt
        LD      A,'P'           ; Code for 'Text zeichnen'   (PRINT)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
AA1C7:  LD      A,(DE)          ; ein Zeichn Text holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        INC     DE              ; Zeiger auf Text auf n√§chstes Zeichen
        DJNZ    AA1C7           ; weitere Zeichen Text ausgeben
        CALL    AA158           ; Zeilenvorschub an Drucker ausgeben
AA1D0:  CALL    A5963           ; Zeichen im Accu auf Befehlsendezeichen untersuchen
        RET     Z               ; Befehlsende -->  fertig
        INC     HL              ; Trennzeichen √ºberspringen
        JR      AA1B3           ; n√§chste Zeichenkette bereitstellen und ausgeben
;
;
;   Basic - Befehl   AXIS     (Zwischencode  179 / 0B3H)
;
AA1D7:  CALL    AA00D           ; Drucker auf Graphic - Modus √ºberpr√ºfen
        CALL    A853D           ; 1-Byte - Wert nach E/Accu bereitstellen
        CP      1 + 1           ; Achse null oder eins  ?
        JP      NC,A636A        ; zu gro√ü -->  Fehler 3   Illegal data error
        PUSH    AF              ; Achsennummer merken
        CALL    A79B1           ; auf Syntax  'Komma'  untersuchen
        CALL    A8551           ; Ausdruck (HL) auswerten und 2-Byte-Wert nach DE bereitstellen
        PUSH    DE              ; Skalenfaktor holen
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
        CALL    A853D           ; 1-Byte - Wert nach E/Accu bereitstellen
        OR      A               ; gleich Null  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        LD      A,'X'           ; Code for 'Achse zeichnen'    (aXis)
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        POP     BC              ; Skalenfaktor holen
        POP     AF              ; Achsennummer holen
        PUSH    DE              ; Anzahl Markierungen merken
        PUSH    BC              ; Skalenfaktor merken
        OR      '0'             ; Achsennummer in ASCII umsetzen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        CALL    AA15C           ; Komma an Drucker ausgeben
        POP     DE              ; Skalenfaktor holen
        CALL    AA0A8           ; Wert in DE auf Y-Koordinate Graphic-Modus √ºberpr√ºfen
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        CALL    AA15C           ; Komma an Drucker ausgeben
        POP     DE              ; Anzahl Markierungen holen
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        JP      AA158           ; Zeilenvorschub an Drucker ausgeben
;
;
;   Basic - Befehl   PCIRCLE     (Zwischencode  187 / 0BBH)
;
AA217:  CALL    AA00D           ; Drucker auf Graphic - Modus √ºberpr√ºfen
        PUSH    HL              ; Programmzeiger retten
        LD      DE,0            ; Vorgabe f√ºr  Anfangswinkel  0  Grad
        LD      HL,SA3B1        ; Zeiger auf Speicher f√ºr Anfangswinkel
        CALL    A79CB           ; Integer - Wert in DE umsetzen in Real-Wert nach (HL)
        LD      DE,360          ; Vorgabe f√ºr  Endwinkel  360  Grad
        LD      HL,SA3B6        ; Zeiger auf Speicher f√ºr Endwinkel
        CALL    A79CB           ; Integer - Wert in DE umsetzen in Real-Wert nach (HL)
        LD      HL,B7C40        ; Zeiger auf +10   (Real - Format)
        LD      DE,SA3BB        ; Zeiger auf Speicher f√ºr Schrittwinkel
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; geretteten Programmzeiger holen
;
;
;   X - Koordinate des Mittelpunktes f√ºr PCIRCLE bereitstellen
;
        CALL    A857C           ; Ausdruck (HL) auswerten/Zeiger auf Ergebnis bereitstellen
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
        PUSH    HL              ; Programmzeiger retten
        LD      HL,SA3A2        ; Zeiger auf Speicher f√ºr X-Koordinate Mittelpunkt
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; geretteten Programmzeiger holen
;
;
;   Y - Koordinate des Mittelpunktes f√ºr PCIRCLE bereitstellen
;
        CALL    A857C           ; Ausdruck (HL) auswerten/Zeiger auf Ergebnis bereitstellen
        CALL    A79B4           ; auf  'Syntax Komma'  untersuchen
        PUSH    HL              ; Programmzeiger retten
        LD      HL,SA3A7        ; Zeiger auf Speicher f√ºr Y - Koordinate Mittelpunkt
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        POP     HL              ; geretteten Programmzeiger holen
;
;
;   Radius f√ºr PCIRCLE bereitstellen
;
        CALL    A857C           ; Ausdruck (HL) auswerten/Zeiger auf Ergebnis bereitstellen
        PUSH    HL              ; Programmzeiger retten
        PUSH    AF              ; n√§chstes Programmbyte retten
        LD      HL,SA3AC        ; Zeiger auf Speicher f√ºr Radius
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        LD      A,(SA3AC + 1)   ; MSByte Mantisse Radius holen
        RLCA                    ; Vorzeichenbit nach Carry schieben
        JP      C,A636A         ; Radius negativ -->  Fehler 3   Illegal data error
        POP     AF              ; n√§chstes Programmbyte holen
        CP      ','             ; Komma  ?
        JR      NZ,AA2A7        ; nein -->  keine weiteren Parameter angegeben
        POP     HL              ; geretteten Programmzeiger holen
        INC     HL              ; komma √ºberspringen
;
;
;   Anfangswinkel f√ºr PCIRCLE bereitstellen
;
        CALL    A857C           ; Ausdruck (HL) auswerten/Zeiger auf Ergebnis bereitstellen
        PUSH    HL              ; Programmzeiger retten
        PUSH    AF              ; n√§chstes Programmbyte retten
        LD      HL,SA3B1        ; Zeiger auf Speicher f√ºr Anfangswinkel
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        POP     AF              ; n√§chstes Programmbyte holen
        CP      ','             ; Komma  ?
        JR      NZ,AA2A7        ; nein -->  keine weiteren Parameter angegeben
        POP     HL              ; geretteten Programmzeiger holen
        INC     HL              ; komma √ºberspringen
;
;
;   Endwinkel f√ºr PCIRCLE bereitstellen
;
        CALL    A857C           ; Ausdruck (HL) auswerten/Zeiger auf Ergebnis bereitstellen
        PUSH    HL              ; Programmzeiger retten
        PUSH    AF              ; n√§chstes Programmbyte retten
        LD      HL,SA3B6        ; Zeiger auf Speicher f√ºr Endwinkel
        EX      DE,HL           ; Zeiger auf Ergebnis nach HL
        CALL    A79C5           ; Real - Zahlwert von (HL) nach (DE) √ºbertragen
        POP     AF              ; n√§chstes Programmbyte holen
        CP      ','             ; Komma  ?
        JR      NZ,AA2A7        ; nein -->  keine weiteren Parameter angegeben
        POP     HL              ; geretteten Programmzeiger holen
        INC     HL              ; Komma √ºberspringen
;
;
;   Provide step angle for PCIRCLE
;
        CALL    A857C           ; Evaluate expression (HL)/provide pointer to result
        PUSH    HL              ; Save program pointer
        LD      HL,SA3BB        ; Pointer to step angle memory
        EX      DE,HL           ; Pointer to result after HL
        CALL    A79C5           ; Real - number value transferred from (HL) to (DE).
        LD      A,(SA3BB+1)      ; Get MSByte mantissa increment
        RLCA                    ; Shift sign bit after carry
        JP      C,A636A         ; Increment negative --> Error 3 Illegal data error
AA2A7:  POP     HL              ; get saved program pointer
        CALL    A797A           ; examine for 'syntax end of command'
        PUSH    HL              ; Save program pointer 
;
;
;   Draw circle according to provided parameters
;
        LD      HL,SA3B6        ; Pointer to storage for end angles
        LD      DE,SA3B1        ; Pointer to storage for initial angles
        LD      A,(SA3BB)       ; Get step angle exponent
        OR      A               ; equals zero  ?
        CALL    NZ,A9153        ; no --> compare real numerical values ??(HL) and (DE).
        JP      C,A636A         ; End angle smaller start angle --> Error 3 Illegal data error
        CALL    AA358           ; Calculate X/Y coordinates from center/radius/angle
        LD      HL,SA3C0        ; Pointer to current X coordinate
        LD      (DA32F + 1),HL  ; enter into routine
        LD      HL,SA3C5        ; Pointer to current Y coordinate
        LD      (DA33A + 1),HL  ; enter into routine
        CALL    AA32C           ; Set character head to current coordinate
        LD      A,(SA3BB)       ; Get step angle exponent
        OR      A               ; equals zero  ?
        JR      Z,AA306         ; yes --> line from start to middle to end point
AA2D4:  LD      HL,SA3B1        ; Pointer to storage for initial angles
        LD      DE,SA3BB        ; Pointer to step angle memory
        CALL    A90BC           ; + - Routine ( (HL) = (HL) + (DE) )
        LD      DE,SA3B6        ; Pointer to storage for end angles
        CALL    A9153           ; Real - compare numerical values ??(HL) and (DE).
        JR      NC,AA2F1        ; End angle < current angle --> line after end point
        CALL    AA358           ; Calculate X/Y coordinates from center/radius/angle
        CALL    AA329           ; Draw a line to the calculated point
        RST     _DOCMD          ; Software - Execute command
        DEFB    14              ; Code 14 Query whether (Shift) - BREAK is pressed
        JR      NZ,AA2D4        ; no --> draw more polygon pieces
        POP     HL              ; get saved program pointer
        RET
;
AA2F1:  CALL    AA2F9           ; Calculate X/Y coordinates of the end point
        CALL    AA329           ; Draw a line to the calculated point
        POP     HL              ; get saved program pointer
        RET
;
;
;   Calculate the absolute coordinates of the end point
;
AA2F9:  LD      HL,SA3B6        ; Pointer to storage for end angles
        LD      DE,SA3B1        ; Pointer to storage for initial angles
        LD      BC,5            ; Length of a number in internal format
        LDIR                    ; Specify the end angle as the current angle
        JR      AA358           ; Calculate X/Y coordinates from center/radius/angle 
;
;
;   Draw a line from the starting point through the midpoint to the ending point
;
AA306:  LD      HL,SA3A2        ; Pointer to memory for X coordinate center point
        LD      (DA32F + 1),HL  ; enter into routine
        LD      HL,SA3A7        ; Pointer to memory for Y - coordinate center
        LD      (DA33A + 1),HL  ; enter into routine
        CALL    AA329           ; Draw a line to the calculated point
        CALL    AA2F9           ; Calculate the absolute coordinates of the end point
        LD      HL,SA3C0        ; Pointer to current X coordinate
        LD      (DA32F + 1),HL  ; enter into routine
        LD      HL,SA3C5        ; Pointer to current Y coordinate
        LD      (DA33A + 1),HL  ; enter into routine
        CALL    AA329           ; Draw a line to the calculated point
        POP     HL              ; get saved program pointer 
        RET
;
;
;   Draw a line to the calculated point
;
AA329:  LD      A,'D'           ; Code 'Draw line' (Draw)
        DEFB    LD_HL
;
;
;   Set character head to current coordinate
;
AA32C:  LD      A,'M'           ; Code 'position head' (Move)
        PUSH    AF              ; Remember command letters for printers
DA32F:  LD      HL,SA3A2        ; Pointer to memory for X coordinate center point
        CALL    A7BEA           ; Real - convert value (HL) into integer - value after HL
        PUSH    HL              ; Note X coordinate
        EX      DE,HL           ; X - coordinate to DE
        CALL    AA0A8           ; Check value in DE on Y coordinate graphic mode
DA33A:  LD      HL,SA3A7        ; Pointer to memory for Y - coordinate center
        CALL    A7BEA           ; Real - convert value (HL) into integer - value after HL
        PUSH    HL              ; Y - remember coordinate
        EX      DE,HL           ; Y - coordinate to DE
        CALL    AA0A8           ; Check value in DE on Y coordinate graphic mode
        POP     HL              ; Y - get coordinate
        POP     DE              ; Y - get coordinate
        POP     AF              ; Printer - get command letters
        RST     _DOCMD          ; Software - Execute command
        DEFB    6               ; Output code 6 characters in Accu to printer
        PUSH    HL              ; Y - save coordinate
        CALL    AA3CF           ; Prepare value in DE in ASCII / output to printer
        CALL    AA15C           ; Output comma to printer
        POP     DE              ; retrieve saved Y coordinate
        CALL    AA3CF           ; Prepare value in DE in ASCII / output to printer
        JP      AA158           ; Output newline to printer 
;
;
;   Calculate X/Y coordinates from center/radius/angle
;
AA358:  LD      DE,(S107C)      ; Get pointer to start of arithmetic memory
        LD      HL,SA3B1        ; Pointer to storage for initial angles
        CALL    A79C5           ; Real - number value transferred from (HL) to (DE).
        LD      HL,(S107C)      ; Get pointer to start of arithmetic memory
        CALL    A98B3           ; RAD - call function (angle in radians)
        CALL    A96F9           ; Call COS routine ( COS( (HL) ) )
        LD      DE,SA3AC        ; Pointer to memory for radius
        CALL    A92EA           ; * - Routine ( (HL) = (HL) * (DE) )
        LD      DE,SA3A2        ; Pointer to memory for X coordinate center point
        CALL    A90BC           ; + - Routine ( (HL) = (HL) + (DE) )
        LD      DE,SA3C0        ; Pointer to current X coordinate
        CALL    A79C5           ; Real - number value transferred from (HL) to (DE).
        LD      DE,(S107C)      ; Get pointer to start of arithmetic memory
        LD      HL,SA3B1        ; Pointer to storage for initial angles
        CALL    A79C5           ; Real - number value transferred from (HL) to (DE).
        LD      HL,(S107C)      ; Get pointer to start of arithmetic memory
        CALL    A98B3           ; RAD - call function (angle in radians)
        CALL    A9709           ; Call SIN routine ( SIN( (HL) ) )
        LD      DE,SA3AC        ; Pointer to memory for radius
        CALL    A92EA           ; * - Routine ( (HL) = (HL) * (DE) )
        LD      DE,SA3A7        ; Pointer to memory for Y - coordinate center
        CALL    A90BC           ; + - Routine ( (HL) = (HL) + (DE) )
        LD      DE,SA3C5        ; Pointer to current Y coordinate
        JP      A79C5           ; Real - number value transferred from (HL) to (DE).
;
;
;   Memory area for PCIRCLE command
;
SA3A2:  DEFS    5               ; Memory for X coordinate center
SA3A7:  DEFS    5               ; Memory for Y - coordinate center point
SA3AC:  DEFS    5               ; Memory for Radius
SA3B1:  DEFS    5               ; Storage for initial angles
SA3B6:  DEFS    5               ; Storage for end angles
SA3BB:  DEFS    5               ; Memory for step angle
SA3C0:  DEFS    5               ; current X coordinate
SA3C5:  DEFS    5               ; current Y coordinate 
;
        DEFS    5  
;
;
;   Prepare value in DE in decimal - ASCII and output to printer
;
AA3CF:  PUSH    AF              ;!Register - save values
        PUSH    HL              ;!
        LD      HL,(S107C)      ; Get pointer to start of arithmetic memory
        CALL    A79CB           ; Integer - convert value in DE into real value according to (HL)
        CALL    A7B5B           ; Convert real value (HL) to ASCII to buffer
        RST     _DOCMD          ; Software - Execute command
        DEFB    23              ; Code 23 Count length of text (DE).
AA3DC:  LD      A,(DE)          ; get a character text
        RST     _DOCMD          ; Software - Execute command
        DEFB    6               ; Output code 6 characters in Accu to printer
        INC     DE              ; Pointer to text on next character
        DJNZ    AA3DC           ; output additional characters of text
        POP     HL              ;!  saved registers - get values 
        POP     AF              ;!
        RET
;
;
;   Basic - Befehl   PTEST     (Zwischencode  188 / 0BCH)
;
AA3E5:  CALL    AA46A           ; Abfrage, ob angew√§hlter Drucker der MZ-800 - Plotter ist
        CALL    AA009           ; Drucker auf Text - Modus √ºberpr√ºfen
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        LD      A,___TST        ; Code for 'Testmuster zeichnen'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        RET
;
;
;   Basic - Befehl   PAGE     (Zwischencode  189 / 0BDH)
;
AA3F3:  CALL    AA009           ; Drucker auf Text - Modus √ºberpr√ºfen
        CALL    A8551           ; Ausdruck (HL) auswerten und 2-Byte-Wert nach DE bereitstellen
        LD      A,E             ; Anzahl Zeilen je Seite holen
        OR      A               ; gleich Null  ?
        JP      Z,A636A         ; ja -->  Fehler 3   Illegal data error
        CP      72 + 1          ; gr√∂√üer 72  ?
        JP      NC,A636A        ; ja -->  Fehler 3   Illegal data error
        CALL    A797A           ; auf  'Syntax Befehlsende'  untersuchen
        LD      A,009H          ; Einleitungscode
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        LD      A,(S1092)       ; Drucker - Typ - Nummer holen
        BIT     0,A             ; MZ - 800 - Plotter  ?
        JR      Z,AA419         ; nein
        CALL    AA3CF           ; Wert in DE aufbereiten in ASCII / an Drucker ausgeben
        JP      AA158           ; Zeilenvorschub an Drucker ausgeben
;
AA419:  LD      A,E             ; Anzahl Zeile je Seite holen
        LD      DE,S11A4        ; Zeiger auf Zwischenspeicher vorgeben
        CALL    A851A           ; Byte im Accu umsetzen on 2 ASCII-Hex-Zeichen nach (DE)
        DEC     DE              ;! Zeiger auf erstes aufbereitetes Zeichen
        DEC     DE              ;!
        LD      A,(DE)          ; ein Zeichen Text holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        INC     DE              ; ausgegebenes Zeichen √ºberspringen
        LD      A,(DE)          ; ein Zeichen Text holen
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        RET
;
;
;   Basic - Befehl   PLOT   (Zwischencode  164 / 0A4H)
;
AA42A:  LD      A,(HL)          ; n√§chstes Programmbyte holen
        CP      ____ON          ; Zwischencode  ON  ?
        JR      Z,AA43A         ; ja -->  Parallelausgabe auf Drucker einschalten
        CP      ___OFF          ; Zwischencode  OFF  ?
        JP      NZ,A6364        ; nein -->  Fehler 1  Syntax error
        XOR     A               ; Code for 'keine Parallelausgabe'
AA435:  LD      (S108F),A       ; Parallelausgabeflag Drucker merken
        INC     HL              ; Code for 'ON/OFF'  √ºberspringen
        RET
;
;
;   Parallelausgabe auf Drucker einschalten
;
AA43A:  CALL    AA009           ; Drucker auf Text - Modus √ºberpr√ºfen
        CALL    AA46A           ; Abfrage, ob angew√§hlter Drucker der MZ-800 - Plotter ist
        LD      A,(M9FD0)       ; Textgr√∂√üenflag Drucker holen
        CP      'L'             ; L   (Large)  ?
        JP      Z,A63B7         ; ja -->  Fehler 68   Dev. mode error
        CALL    AA45C           ; Drucker auf Textmodus und richtige Anzahl Zeichen/Zeile
        LD      A,(S108F)       ; Parallelausgabeflag Drucker holen
        OR      A               ; gesetzt  ?
        JR      NZ,AA435        ; ja -->  Programmzeiger corrigieren
        CALL    A6A8D           ; Standardwerte f√ºr CONSOLE vorgeben
        LD      A,C_CLR         ; Code for 'Bildschirm l√∂schen'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    3               ; Code 3  Accu auf Bildschirm ausgeben  (Ausf√ºhrung Steuerzeichen)
        OR      00000001B       ; Accu auf Wert ungleich Null
        JR      AA435           ; Parallelausgabeflag Drucker setzen
;
;
;   Drucker auf Textmodus und richtiger Anzahl Zeichen / Zeile setzen
;
AA45C:  LD      A,1             ; Code for 'Umschalten auf Textmodus'
        RST     _DOCMD          ; Software - Kommando ausf√ºhren
        DEFB    6               ; Code 6   Zeichen im Accu auf Drucker ausgeben
        LD      A,(S137A)       ; Bildschirm - Modus - Nummer holen
        CP      2 + 1           ; Bildschirm auf 40  Zeichen je Zeile  ?
        RET     C               ; ja
        CALL    AA060           ; Drucker umschalten auf 80 Zeichen / Zeile
        RET
;
;   Abfrage, ob angew√§hlter Drucker der MZ-800 - Plotter ist
;
AA46A:  LD      A,(S1092)       ; Drucker - Typ - Nummer  holen
        BIT     0,A             ; MZ - 800 - Plotter  (Drucker 1)  ?
        JP      Z,A63B7         ; nein -->  Fehler 68   Dev. mode error
        RET
;

SA473:                          ; from here free memory for basic - program


; ..the original tape dump here contains useless program code and data, including an old disclaimer:
; =====================================
; DISK BASIC INTERPRETER MZ-2Z046 V0.2G
; =====================================
; COPYRIGHT (C) 1984 BY SHARP CORP.
; 22929 BYTES FREE


; Data block filler
defs $b000-SA473

